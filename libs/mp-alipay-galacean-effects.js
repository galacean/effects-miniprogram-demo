'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var alipay = {};

var core = {};

var eventIniter = {};

var touchEvent = {};

var document = {};

var platform$1 = {};

Object.defineProperty(platform$1, "__esModule", { value: true });
platform$1.platform = void 0;
platform$1.platform = {
    getSystemInfoSync: function () {
        return {
            pixelRatio: 1,
            system: '',
            platform: '',
            language: '',
            screenWidth: 1,
            screenHeight: 1,
            windowWidth: 1,
            windowHeight: 1,
        };
    },
    createCanvas: function () {
        return {
            addEventListener: function (type, listener, options) {
            },
            removeEventListener: function (type, listener) { },
            dispatchEvent: function (event) { },
            width: 0,
            height: 0,
        };
    },
    createOffscreenCanvas: function (options) {
        return {
            addEventListener: function (type, listener, options) {
            },
            removeEventListener: function (type, listener) { },
            dispatchEvent: function (event) { },
            width: 0,
            height: 0,
        };
    },
    createImage: function () { },
    createSelectorQuery: function () { },
    request: function (object) { },
    downloadFile: function (options) { },
    createVideoContext: function (id) { },
    startDeviceMotionListening: function (object) { },
    stopDeviceMotionListening: function () { },
    onDeviceMotionChange: function (listener) { },
    offDeviceMotionChange: function (listener) { },
};

var body = {};

var htmlElement = {};

var mixin = {};

var screen = {};

Object.defineProperty(screen, "__esModule", { value: true });
screen.screen = void 0;
var platform_1$7 = platform$1;
var _a$a = platform_1$7.platform.getSystemInfoSync(), screenWidth = _a$a.screenWidth, screenHeight = _a$a.screenHeight, windowWidth = _a$a.windowWidth, windowHeight = _a$a.windowHeight;
screen.screen = {
    width: screenWidth,
    height: screenHeight,
    availWidth: windowWidth,
    availHeight: windowHeight,
    availLeft: 0,
    availTop: 0,
};

var noop$2 = {};

Object.defineProperty(noop$2, "__esModule", { value: true });
noop$2.noop = void 0;
function noop$1() { }
noop$2.noop = noop$1;

var __assign$2 = (undefined && undefined.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
Object.defineProperty(mixin, "__esModule", { value: true });
mixin.classList = mixin.scrollRegion = mixin.offsetRegion = mixin.clientRegion = mixin.style = mixin.parentNode = void 0;
var screen_1 = screen;
var document_1$6 = document;
var noop_1$1 = noop$2;
var innerWidth = screen_1.screen.availWidth, innerHeight = screen_1.screen.availHeight;
function parentNode(obj, level) {
    if (!('parentNode' in obj)) {
        var parent_1;
        if (level === 0) {
            parent_1 = function () {
                return null;
            };
        }
        else if (level === 1) {
            parent_1 = function () {
                return document_1$6.document.documentElement;
            };
        }
        else {
            parent_1 = function () {
                return document_1$6.document.body;
            };
        }
        Object.defineProperty(obj, 'parentNode', {
            enumerable: true,
            get: parent_1,
        });
    }
    if (!('parentElement' in obj)) {
        var parent_2;
        if (level === 0) {
            parent_2 = function () {
                return null;
            };
        }
        else if (level === 1) {
            parent_2 = function () {
                return document_1$6.document.documentElement;
            };
        }
        else {
            parent_2 = function () {
                return document_1$6.document.body;
            };
        }
        Object.defineProperty(obj, 'parentElement', {
            enumerable: true,
            get: parent_2,
        });
    }
}
mixin.parentNode = parentNode;
function style(obj) {
    var _a;
    obj.style = __assign$2(__assign$2({}, ((_a = obj.style) !== null && _a !== void 0 ? _a : {})), { top: '0px', left: '0px', width: innerWidth + 'px', height: innerHeight + 'px', margin: '0px', padding: '0px' });
}
mixin.style = style;
function clientRegion(obj) {
    if (!('clientLeft' in obj)) {
        obj.clientLeft = 0;
        obj.clientTop = 0;
    }
    if (!('clientWidth' in obj)) {
        obj.clientWidth = innerWidth;
        obj.clientHeight = innerHeight;
    }
    if (!('getBoundingClientRect' in obj)) {
        obj.getBoundingClientRect = function () {
            return {
                x: 0,
                y: 0,
                top: obj.top || 0,
                left: obj.left || 0,
                width: this.clientWidth,
                height: this.clientHeight,
                right: this.clientWidth,
                bottom: this.clientHeight,
            };
        };
    }
}
mixin.clientRegion = clientRegion;
function offsetRegion(obj) {
    if (!('offsetLeft' in obj)) {
        obj.offsetLeft = 0;
        obj.offsetTop = 0;
    }
    if (!('offsetWidth' in obj)) {
        obj.offsetWidth = innerWidth;
        obj.offsetHeight = innerHeight;
    }
}
mixin.offsetRegion = offsetRegion;
function scrollRegion(obj) {
    if (!('scrollLeft' in obj)) {
        obj.scrollLeft = 0;
        obj.scrollTop = 0;
    }
    if (!('scrollWidth' in obj)) {
        obj.scrollWidth = innerWidth;
        obj.scrollHeight = innerHeight;
    }
}
mixin.scrollRegion = scrollRegion;
function classList(obj) {
    obj.classList = [];
    obj.classList.add = noop_1$1.noop;
    obj.classList.remove = noop_1$1.noop;
    obj.classList.contains = noop_1$1.noop;
    obj.classList.toggle = noop_1$1.noop;
}
mixin.classList = classList;

var element = {};

var node = {};

var eventTarget = {};

Object.defineProperty(eventTarget, "__esModule", { value: true });
eventTarget.EventTarget = void 0;
var eventMap = new WeakMap();
var EventTarget = /** @class */ (function () {
    function EventTarget() {
        eventMap.set(this, {});
    }
    EventTarget.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        var events = eventMap.get(this);
        if (!events) {
            events = {};
        }
        if (!events[type]) {
            events[type] = [];
        }
        events[type].push(listener);
        eventMap.set(this, events);
        if (options.capture) ;
        if (options.once) ;
        if (options.passive) ;
    };
    EventTarget.prototype.removeEventListener = function (type, listener, options) {
        var events = eventMap.get(this);
        if (events) {
            var listeners = events[type];
            if (listeners && listeners.length > 0) {
                for (var i = listeners.length; i--; i > 0) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        }
    };
    EventTarget.prototype.dispatchEvent = function (event) {
        var listeners = eventMap.get(this)[event.type];
        if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
                listeners[i](event);
            }
        }
    };
    return EventTarget;
}());
eventTarget.EventTarget = EventTarget;

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(node, "__esModule", { value: true });
node.Node = void 0;
var event_target_1$1 = eventTarget;
var Node$1 = /** @class */ (function (_super) {
    __extends$b(Node, _super);
    function Node() {
        var _this = _super.call(this) || this;
        _this.childNodes = [];
        return _this;
    }
    Node.prototype.appendChild = function (node) {
        this.childNodes.push(node);
        // if (node instanceof Node) {
        //   this.childNodes.push(node)
        // } else {
        //   throw new TypeError('Failed to executed \'appendChild\' on \'Node\': parameter 1 is not of type \'Node\'.')
        // }
    };
    Node.prototype.cloneNode = function () {
        var copyNode = Object.create(this);
        Object.assign(copyNode, this);
        return copyNode;
    };
    Node.prototype.removeChild = function (node) {
        var index = this.childNodes.findIndex(function (child) { return child === node; });
        if (index > -1) {
            return this.childNodes.splice(index, 1);
        }
        return null;
    };
    return Node;
}(event_target_1$1.EventTarget));
node.Node = Node$1;

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(element, "__esModule", { value: true });
element.Element = void 0;
var node_1 = node;
var Element = /** @class */ (function (_super) {
    __extends$a(Element, _super);
    function Element() {
        var _this = _super.call(this) || this;
        _this.className = '';
        _this.children = [];
        return _this;
    }
    Element.prototype.setAttribute = function (name, value) {
        this[name] = value;
    };
    Element.prototype.getAttribute = function (name) {
        return this[name];
    };
    Element.prototype.setAttributeNS = function (name, value) {
        this[name] = value;
    };
    Element.prototype.getAttributeNS = function (name) {
        return this[name];
    };
    return Element;
}(node_1.Node));
element.Element = Element;

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding$1 = (undefined && undefined.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (undefined && undefined.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(htmlElement, "__esModule", { value: true });
htmlElement.HTMLElement = void 0;
var Mixin$1 = __importStar$1(mixin);
var noop_1 = noop$2;
var element_1 = element;
var HTMLElement = /** @class */ (function (_super) {
    __extends$9(HTMLElement, _super);
    function HTMLElement(tagName, level) {
        if (tagName === void 0) { tagName = ''; }
        var _this = _super.call(this) || this;
        _this.className = '';
        _this.children = [];
        _this.focus = noop_1.noop;
        _this.blur = noop_1.noop;
        _this.insertBefore = noop_1.noop;
        _this.appendChild = noop_1.noop;
        _this.removeChild = noop_1.noop;
        _this.remove = noop_1.noop;
        _this.innerHTML = '';
        _this.tagName = tagName.toUpperCase();
        Mixin$1.parentNode(_this, level);
        Mixin$1.style(_this);
        Mixin$1.classList(_this);
        Mixin$1.clientRegion(_this);
        Mixin$1.offsetRegion(_this);
        Mixin$1.scrollRegion(_this);
        return _this;
    }
    return HTMLElement;
}(element_1.Element));
htmlElement.HTMLElement = HTMLElement;
// eslint-disable-next-line compat/compat
Object.defineProperty(HTMLElement, Symbol.hasInstance, {
    value: function (instance) {
        return (instance === null || instance === void 0 ? void 0 : instance.tagName) === 'BODY';
    },
});

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(body, "__esModule", { value: true });
body.Body = void 0;
var html_element_1$2 = htmlElement;
var document_1$5 = document;
var Body = /** @class */ (function (_super) {
    __extends$8(Body, _super);
    function Body() {
        // 为了性能, 此处不按照标准的 DOM 层级关系设计
        // 将 body 设置为 0 级, parent 元素为 null
        return _super.call(this, 'body', 0) || this;
    }
    Body.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        document_1$5.document.addEventListener(type, listener, options);
    };
    Body.prototype.removeEventListener = function (type, listener) {
        document_1$5.document.removeEventListener(type, listener);
    };
    Body.prototype.dispatchEvent = function (event) {
        document_1$5.document.dispatchEvent(event);
    };
    return Body;
}(html_element_1$2.HTMLElement));
body.Body = Body;

var htmlVideoElement = {};

var htmlMediaElement = {};

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(htmlMediaElement, "__esModule", { value: true });
htmlMediaElement.HTMLMediaElement = void 0;
var html_element_1$1 = htmlElement;
var HTMLMediaElement = /** @class */ (function (_super) {
    __extends$7(HTMLMediaElement, _super);
    function HTMLMediaElement(tagName) {
        return _super.call(this, tagName) || this;
    }
    HTMLMediaElement.prototype.addTextTrack = function () { };
    HTMLMediaElement.prototype.captureStream = function () { };
    HTMLMediaElement.prototype.fastSeek = function () { };
    HTMLMediaElement.prototype.load = function () { };
    HTMLMediaElement.prototype.pause = function () { };
    HTMLMediaElement.prototype.play = function () { };
    return HTMLMediaElement;
}(html_element_1$1.HTMLElement));
htmlMediaElement.HTMLMediaElement = HTMLMediaElement;

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(htmlVideoElement, "__esModule", { value: true });
htmlVideoElement.HTMLVideoElement = void 0;
var html_media_element_1$1 = htmlMediaElement;
var HTMLVideoElement = /** @class */ (function (_super) {
    __extends$6(HTMLVideoElement, _super);
    // srcObject: any;
    // videoContext: any;
    //
    function HTMLVideoElement() {
        return _super.call(this, 'video') || this;
        // this.videoContext = platform.createVideoContext('GEVideo');
    }
    return HTMLVideoElement;
}(html_media_element_1$1.HTMLMediaElement));
htmlVideoElement.HTMLVideoElement = HTMLVideoElement;

var image = {};

var register$1 = {};

var __createBinding = (undefined && undefined.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (undefined && undefined.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(register$1, "__esModule", { value: true });
register$1.isMiniGame = register$1.getCanvas = register$1.registerOffscreenCanvas = register$1.registerCanvas = void 0;
var platform_1$6 = platform$1;
var document_1$4 = document;
var Mixin = __importStar(mixin);
// 同步和异步都需要的数据
var canvas = {};
var _isMiniGame = false;
/**
 * 异步注册 canvas
 * @param options
 * @returns
 */
function registerCanvas() {
    return __awaiter$1(this, arguments, void 0, function (options) {
        var _a, id, _b, isMiniGame, _c, elementLevel;
        if (options === void 0) { options = {}; }
        return __generator$1(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = options.id, id = _a === void 0 ? 'J-canvas' : _a, _b = options.isMiniGame, isMiniGame = _b === void 0 ? false : _b, _c = options.elementLevel, elementLevel = _c === void 0 ? 0 : _c;
                    if (!(typeof id === 'string')) return [3 /*break*/, 4];
                    if (!isMiniGame) return [3 /*break*/, 1];
                    canvas = platform_1$6.platform.createCanvas();
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, getCanvasById(id)];
                case 2:
                    canvas = _d.sent();
                    _d.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    canvas = id;
                    canvas.id = id;
                    _d.label = 5;
                case 5:
                    registerOffscreenCanvas(canvas, elementLevel);
                    _isMiniGame = isMiniGame;
                    return [2 /*return*/, canvas];
            }
        });
    });
}
register$1.registerCanvas = registerCanvas;
/**
 * 异步注册 canvas
 * @param options
 * @returns
 */
function registerOffscreenCanvas(canvas, elementLevel) {
    if (!('tagName' in canvas)) {
        canvas.tagName = 'CANVAS';
    }
    canvas.type = 'canvas';
    canvas.width = canvas.width * 2;
    canvas.height = canvas.height * 2;
    Mixin.parentNode(canvas, elementLevel !== null && elementLevel !== void 0 ? elementLevel : 0);
    Mixin.style(canvas);
    Mixin.classList(canvas);
    Mixin.offsetRegion(canvas);
    canvas.focus = function () { };
    canvas.blur = function () { };
    canvas.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        document_1$4.document.addEventListener(type, listener, options);
    };
    canvas.removeEventListener = function (type, listener) {
        document_1$4.document.removeEventListener(type, listener);
    };
    canvas.dispatchEvent = function (event) {
        document_1$4.document.dispatchEvent(event);
    };
    return canvas;
}
register$1.registerOffscreenCanvas = registerOffscreenCanvas;
function getCanvasById(id) {
    return __awaiter$1(this, void 0, void 0, function () {
        return __generator$1(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    platform_1$6.platform.createSelectorQuery()
                        // @ts-expect-error
                        .select(id).node()
                        .select(id).boundingClientRect()
                        // @ts-expect-error
                        .exec(function (res) {
                        try {
                            var canvas_1 = res[0].node;
                            var rect_1 = res[1];
                            if (canvas_1) {
                                canvas_1.getBoundingClientRect = function () { return rect_1; };
                                resolve(canvas_1);
                            }
                            else {
                                reject("create canvas fail, canvas is ".concat(canvas_1));
                            }
                        }
                        catch (e) {
                            reject("Cannot find canvas by id: ".concat(id, ", ").concat(e));
                        }
                    });
                })];
        });
    });
}
/**
 * 获取 canvas
 * @returns
 */
function getCanvas() {
    return canvas;
}
register$1.getCanvas = getCanvas;
function isMiniGame() {
    return _isMiniGame;
}
register$1.isMiniGame = isMiniGame;

Object.defineProperty(image, "__esModule", { value: true });
image.Image = void 0;
var platform_1$5 = platform$1;
var register_1$4 = register$1;
var Image = /** @class */ (function () {
    function Image() {
        var _a, _b;
        var image;
        if ((0, register_1$4.isMiniGame)()) {
            image = platform_1$5.platform.createImage();
        }
        else {
            var canvas = (0, register_1$4.getCanvas)();
            image = (_b = (_a = canvas.createImage) === null || _a === void 0 ? void 0 : _a.call(canvas)) !== null && _b !== void 0 ? _b : {};
        }
        return image;
    }
    return Image;
}());
image.Image = Image;

(function (exports) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.document = void 0;
var platform_1 = platform$1;
var body_1 = body;
var html_element_1 = htmlElement;
var html_video_element_1 = htmlVideoElement;
var image_1 = image;
var register_1 = register$1;
var DocumentElement = /** @class */ (function (_super) {
    __extends(DocumentElement, _super);
    function DocumentElement() {
        return _super.call(this, 'html', 0) || this;
    }
    DocumentElement.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        exports.document.addEventListener(type, listener, options);
    };
    DocumentElement.prototype.removeEventListener = function (type, listener) {
        exports.document.removeEventListener(type, listener);
    };
    DocumentElement.prototype.dispatchEvent = function (event) {
        exports.document.dispatchEvent(event);
    };
    return DocumentElement;
}(html_element_1.HTMLElement));
var events = {};
exports.document = {
    readyState: 'complete',
    visibilityState: 'visible', // 'visible' , 'hidden'
    hidden: false,
    fullscreen: true,
    scripts: [],
    style: {},
    ontouchstart: null,
    ontouchmove: null,
    ontouchend: null,
    onvisibilitychange: null,
    parentNode: null,
    parentElement: null,
    head: null,
    body: null,
    documentElement: null,
    createElement: function (tagName) {
        tagName = tagName.toLowerCase();
        if (tagName === 'canvas') {
            if ((0, register_1.isMiniGame)()) {
                var canvas = platform_1.platform.createCanvas();
                // 小游戏适配
                canvas.addEventListener = function (type, listener, options) {
                    if (options === void 0) { options = {}; }
                    exports.document.addEventListener(type, listener, options);
                };
                canvas.removeEventListener = function (type, listener) {
                    exports.document.removeEventListener(type, listener);
                };
                canvas.dispatchEvent = function (event) {
                    exports.document.dispatchEvent(event);
                };
                return canvas;
            }
            else {
                var canvas = platform_1.platform.createOffscreenCanvas({ type: '2d' });
                (0, register_1.registerOffscreenCanvas)(canvas);
                return canvas;
            }
        }
        else if (tagName === 'img') {
            return new image_1.Image();
        }
        else if (tagName === 'video') {
            return new html_video_element_1.HTMLVideoElement();
        }
        return new html_element_1.HTMLElement(tagName);
    },
    createElementNS: function (nameSpace, tagName) {
        return this.createElement(tagName);
    },
    createTextNode: function (text) {
        // TODO: Do we need the TextNode Class ???
        return text;
    },
    getElementById: function (id) {
        var canvas = (0, register_1.getCanvas)();
        if (id === canvas.id) {
            return canvas;
        }
        else {
            return null;
        }
    },
    getElementsByTagName: function (tagName) {
        tagName = tagName.toLowerCase();
        if (tagName === 'head') {
            return [exports.document.head];
        }
        else if (tagName === 'body') {
            return [exports.document.body];
        }
        else if (tagName === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    getElementsByTagNameNS: function (nameSpace, tagName) {
        return this.getElementsByTagName(tagName);
    },
    getElementsByName: function (tagName) {
        if (tagName === 'head') {
            return [exports.document.head];
        }
        else if (tagName === 'body') {
            return [exports.document.body];
        }
        else if (tagName === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    querySelector: function (query) {
        var canvas = (0, register_1.getCanvas)();
        if (query === 'head') {
            return exports.document.head;
        }
        else if (query === 'body') {
            return exports.document.body;
        }
        else if (query === 'canvas') {
            return canvas;
        }
        else if (query === "#".concat(canvas.id)) {
            return canvas;
        }
        return null;
    },
    querySelectorAll: function (query) {
        if (query === 'head') {
            return [exports.document.head];
        }
        else if (query === 'body') {
            return [exports.document.body];
        }
        else if (query === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    addEventListener: function (type, listener, options) {
        if (!events[type]) {
            events[type] = [];
        }
        events[type].push(listener);
    },
    removeEventListener: function (type, listener) {
        var listeners = events[type];
        if (listeners && listeners.length > 0) {
            for (var i = listeners.length; i--; i > 0) {
                if (listeners[i] === listener) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    },
    dispatchEvent: function (event) {
        var type = event.type;
        var listeners = events[type];
        if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
                listeners[i](event);
            }
        }
        if (event.target && typeof event.target['on' + type] === 'function') {
            event.target['on' + type](event);
        }
    },
};
exports.document.documentElement = new DocumentElement();
exports.document.head = new html_element_1.HTMLElement('head');
exports.document.body = new body_1.Body();
}(document));

var event = {};

Object.defineProperty(event, "__esModule", { value: true });
event.Event = void 0;
var Event = /** @class */ (function () {
    function Event(type) {
        this.cancelBubble = false;
        this.cancelable = false;
        this.target = null;
        this.currentTarget = null;
        this.preventDefault = function () { };
        this.stopPropagation = function () { };
        this.type = type;
        this.timeStamp = Date.now();
    }
    return Event;
}());
event.Event = Event;

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(touchEvent, "__esModule", { value: true });
touchEvent.dispatchTouchCancel = touchEvent.dispatchTouchEnd = touchEvent.dispatchTouchMove = touchEvent.dispatchTouchStart = void 0;
var document_1$3 = document;
var event_1$1 = event;
var register_1$3 = register$1;
var TouchEvent = /** @class */ (function (_super) {
    __extends$5(TouchEvent, _super);
    function TouchEvent(type) {
        var _this = _super.call(this, type) || this;
        _this.touches = [];
        _this.targetTouches = [];
        _this.changedTouches = [];
        _this.target = (0, register_1$3.getCanvas)();
        _this.currentTarget = (0, register_1$3.getCanvas)();
        return _this;
    }
    return TouchEvent;
}(event_1$1.Event));
function mapEvent(event) {
    var _a = event || {}, _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c, _d = _a.clientX, clientX = _d === void 0 ? 0 : _d, _e = _a.clientY, clientY = _e === void 0 ? 0 : _e;
    // 小程序不支持Object.hasOwnProperty
    // (抹平不同的view事件)[https://docs.alipay.com/mini/framework/event-object]
    if (Object.keys(event).includes('x')) {
        event.pageX = event.clientX = x;
        event.pageY = event.clientY = y;
    }
    else {
        event.x = clientX;
        event.y = clientY;
    }
    if (!event.target) {
        event.target = (0, register_1$3.getCanvas)();
    }
}
function eventHandlerFactory$2(type) {
    return function (rawEvent) {
        var event = new TouchEvent(type);
        event.changedTouches = rawEvent.changedTouches || rawEvent.touches;
        event.touches = rawEvent.touches;
        event.targetTouches = Array.prototype.slice.call(rawEvent.touches);
        event.timeStamp = rawEvent.timeStamp;
        event.changedTouches.forEach(function (e) { return mapEvent(e); });
        event.touches.forEach(function (e) { return mapEvent(e); });
        event.targetTouches.forEach(function (e) { return mapEvent(e); });
        document_1$3.document.dispatchEvent(event);
    };
}
var dispatchTouchStart = eventHandlerFactory$2('touchstart');
touchEvent.dispatchTouchStart = dispatchTouchStart;
var dispatchTouchMove = eventHandlerFactory$2('touchmove');
touchEvent.dispatchTouchMove = dispatchTouchMove;
var dispatchTouchEnd = eventHandlerFactory$2('touchend');
touchEvent.dispatchTouchEnd = dispatchTouchEnd;
var dispatchTouchCancel = eventHandlerFactory$2('touchcancel');
touchEvent.dispatchTouchCancel = dispatchTouchCancel;

var pointerEvent = {};

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(pointerEvent, "__esModule", { value: true });
pointerEvent.dispatchPointerCancel = pointerEvent.dispatchPointerLeave = pointerEvent.dispatchPointerUp = pointerEvent.dispatchPointerMove = pointerEvent.dispatchPointerDown = void 0;
var event_1 = event;
var register_1$2 = register$1;
var document_1$2 = document;
var PointerEvent = /** @class */ (function (_super) {
    __extends$4(PointerEvent, _super);
    function PointerEvent(type) {
        var _this = _super.call(this, type) || this;
        _this.target = (0, register_1$2.getCanvas)();
        _this.currentTarget = (0, register_1$2.getCanvas)();
        return _this;
    }
    return PointerEvent;
}(event_1.Event));
var CLONE_PROPS = [
    // MouseEvent
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    // PointerEvent
    'pointerId',
    'width',
    'height',
    'pressure',
    'tiltX',
    'tiltY',
    'pointerType',
    'hwTimestamp',
    'isPrimary',
    // event instance
    'pageX',
    'pageY',
    'timeStamp',
];
var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    // DOM Level 3
    0,
    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    '',
    0,
    false,
    // event instance
    0,
    0,
    0,
];
var POINTER_TYPE = 'touch';
function touchToPointer(type, touch) {
    var e = new PointerEvent(type);
    for (var i = 0; i < CLONE_PROPS.length; i++) {
        var p = CLONE_PROPS[i];
        e[p] = touch[p] || CLONE_DEFAULTS[i];
    }
    e.type = type;
    e.target = (0, register_1$2.getCanvas)();
    e.currentTarget = (0, register_1$2.getCanvas)();
    e.buttons = typeToButtons(type);
    e.which = e.buttons;
    e.pointerId = (touch.identifier || 0) + 2;
    e.bubbles = true;
    e.cancelable = true; // e.detail = this.clickCount;
    e.button = 0;
    e.width = (touch.radiusX || 0.5) * 2;
    e.height = (touch.radiusY || 0.5) * 2;
    e.pressure = touch.force || 0.5;
    e.isPrimary = isPrimaryPointer(touch);
    e.pointerType = POINTER_TYPE; // forward modifier keys
    // @ts-expect-error
    e.offsetX = touch.pageX || touch.x;
    // @ts-expect-error
    e.offsetY = touch.pageY || touch.y;
    return e;
}
function typeToButtons(type) {
    var ret = 0;
    if (type === 'touchstart' || type === 'touchmove' || type === 'pointerdown' || type === 'pointermove') {
        ret = 1;
    }
    return ret;
}
var firstPointer = null;
function isPrimaryPointer(touch) {
    return firstPointer === touch.identifier;
}
function setPrimaryPointer(touch) {
    if (firstPointer === null) {
        firstPointer = touch.identifier;
    }
}
function removePrimaryPointer(touch) {
    if (firstPointer === touch.identifier) {
        firstPointer = null;
    }
}
function eventHandlerFactory$1(type) {
    return function (rawEvent) {
        var changedTouches = rawEvent.changedTouches || rawEvent.touches;
        for (var i = 0; i < changedTouches.length; i++) {
            var touch = changedTouches[i];
            switch (type) {
                case 'pointerdown':
                    i === 0 && setPrimaryPointer(touch);
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointermove':
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointerup':
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointerleave':
                case 'pointercancel':
                    removePrimaryPointer(touch);
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
            }
        }
    };
}
var dispatchPointerDown = eventHandlerFactory$1('pointerdown');
pointerEvent.dispatchPointerDown = dispatchPointerDown;
var dispatchPointerMove = eventHandlerFactory$1('pointermove');
pointerEvent.dispatchPointerMove = dispatchPointerMove;
var dispatchPointerUp = eventHandlerFactory$1('pointerup');
pointerEvent.dispatchPointerUp = dispatchPointerUp;
var dispatchPointerLeave = eventHandlerFactory$1('pointerleave');
pointerEvent.dispatchPointerLeave = dispatchPointerLeave;
var dispatchPointerCancel = eventHandlerFactory$1('pointercancel');
pointerEvent.dispatchPointerCancel = dispatchPointerCancel;

var mouseEvent = {};

Object.defineProperty(mouseEvent, "__esModule", { value: true });
mouseEvent.dispatchMouseUp = mouseEvent.dispatchMouseMove = mouseEvent.dispatchMouseDown = void 0;
var document_1$1 = document;
// class MouseEvent extends Event {
//   constructor (type: string) {
//     super(type);
//   }
// }
function eventHandlerFactory(type) {
    return function (rawEvent) {
        rawEvent.type = type;
        document_1$1.document.dispatchEvent(rawEvent);
    };
}
var dispatchMouseDown = eventHandlerFactory('mousedown');
mouseEvent.dispatchMouseDown = dispatchMouseDown;
var dispatchMouseMove = eventHandlerFactory('mousemove');
mouseEvent.dispatchMouseMove = dispatchMouseMove;
var dispatchMouseUp = eventHandlerFactory('mouseup');
mouseEvent.dispatchMouseUp = dispatchMouseUp;

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(touchEvent, exports);
__exportStar(pointerEvent, exports);
__exportStar(mouseEvent, exports);
}(eventIniter));

var accelerometer = {};

Object.defineProperty(accelerometer, "__esModule", { value: true });
accelerometer.Accelerometer = void 0;
var platform_1$4 = platform$1;
var document_1 = document;
var Accelerometer = /** @class */ (function () {
    function Accelerometer() {
    }
    Accelerometer.prototype.handleDeviceMotionChange = function (event) {
        document_1.document.dispatchEvent({
            alpha: event.alpha,
            gamma: event.gamma,
            beta: -event.beta,
            type: 'deviceorientation',
        });
    };
    Accelerometer.prototype.startWatch = function (interval) {
        var _this = this;
        if (interval === void 0) { interval = 'ui'; }
        platform_1$4.platform.startDeviceMotionListening({
            interval: interval,
            success: function () {
                platform_1$4.platform.onDeviceMotionChange(_this.handleDeviceMotionChange);
            },
        });
    };
    Accelerometer.prototype.stopWatch = function () {
        platform_1$4.platform.offDeviceMotionChange(this.handleDeviceMotionChange);
    };
    return Accelerometer;
}());
accelerometer.Accelerometer = Accelerometer;

var atob$1 = {};

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(atob$1, "__esModule", { value: true });
atob$1.btoa = atob$1.atob = void 0;
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var InvalidCharacterError = /** @class */ (function (_super) {
    __extends$3(InvalidCharacterError, _super);
    function InvalidCharacterError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = 'InvalidCharacterError';
        return _this;
    }
    return InvalidCharacterError;
}(Error));
function atob(input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 === 1) {
        throw new InvalidCharacterError('\'atob\' failed: The string to be decoded is not correctly encoded.');
    }
    var output = '';
    for (
    // initialize result and counters
    var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
    // get next character
    (buffer = str.charAt(idx++)); 
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer &&
        (
        // @ts-expect-error
        (bs = bc % 4 ? bs * 64 + buffer : buffer),
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4)
        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
        : 0) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
    }
    return output;
}
atob$1.atob = atob;
function btoa(string) {
    string = String(string);
    var bitmap;
    var a;
    var b;
    var c;
    var result = '';
    var i = 0;
    var rest = string.length % 3; // To determine the final padding
    for (; i < string.length;) {
        if ((a = string.charCodeAt(i++)) > 255 || (b = string.charCodeAt(i++)) > 255 || (c = string.charCodeAt(i++)) > 255) {
            throw new TypeError('Failed to execute \'btoa\' on \'Window\': The string to be encoded contains characters outside of the Latin1 range.');
        }
        bitmap = (a << 16) | (b << 8) | c;
        result +=
            chars.charAt((bitmap >> 18) & 63) +
                chars.charAt((bitmap >> 12) & 63) +
                chars.charAt((bitmap >> 6) & 63) +
                chars.charAt(bitmap & 63);
    }
    // If there's need of padding, replace the last 'A's with equal signs
    return rest ? result.slice(0, rest - 3) + '==='.substring(rest) : result;
}
atob$1.btoa = btoa;

var blob = {};

Object.defineProperty(blob, "__esModule", { value: true });
blob.Blob = void 0;
var Blob = /** @class */ (function () {
    /**
     *
     * @param buffers only support zero index
     * @param type mimetype image/png image/webp...
     */
    function Blob(buffers, type) {
        this.buffers = buffers;
        this.type = type;
    }
    Blob.prototype.arraybuffer = function () {
        return Promise.resolve(this.buffers[0]);
    };
    Blob.prototype.stream = function () {
        throw 'not implemented';
    };
    Blob.prototype.text = function () {
        throw 'not implemented';
    };
    Blob.prototype.slice = function (start, end, contentType) {
        throw 'not implemented';
    };
    return Blob;
}());
blob.Blob = Blob;

var constructor = {};

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(constructor, "__esModule", { value: true });
constructor.HTMLAudioElement = constructor.HTMLCanvasElement = constructor.HTMLImageElement = void 0;
var html_element_1 = htmlElement;
var html_media_element_1 = htmlMediaElement;
var HTMLImageElement = /** @class */ (function (_super) {
    __extends$2(HTMLImageElement, _super);
    function HTMLImageElement() {
        return _super.call(this, 'img') || this;
    }
    return HTMLImageElement;
}(html_element_1.HTMLElement));
constructor.HTMLImageElement = HTMLImageElement;
// eslint-disable-next-line compat/compat
Object.defineProperty(HTMLImageElement, Symbol.hasInstance, {
    value: function (instance) {
        return (instance === null || instance === void 0 ? void 0 : instance.tagName) === 'IMG' || (instance === null || instance === void 0 ? void 0 : instance.crossOrigin);
    },
});
var HTMLCanvasElement = /** @class */ (function (_super) {
    __extends$2(HTMLCanvasElement, _super);
    function HTMLCanvasElement() {
        return _super.call(this, 'canvas') || this;
    }
    return HTMLCanvasElement;
}(html_element_1.HTMLElement));
constructor.HTMLCanvasElement = HTMLCanvasElement;
var HTMLAudioElement = /** @class */ (function (_super) {
    __extends$2(HTMLAudioElement, _super);
    function HTMLAudioElement() {
        return _super.call(this, 'audio') || this;
    }
    return HTMLAudioElement;
}(html_media_element_1.HTMLMediaElement));
constructor.HTMLAudioElement = HTMLAudioElement;

var devicePixelRatio = {};

Object.defineProperty(devicePixelRatio, "__esModule", { value: true });
devicePixelRatio.devicePixelRatio = void 0;
var platform_1$3 = platform$1;
devicePixelRatio.devicePixelRatio = platform_1$3.platform.getSystemInfoSync().pixelRatio;

var imageData = {};

Object.defineProperty(imageData, "__esModule", { value: true });
imageData.ImageData = void 0;
var ImageData = /** @class */ (function () {
    function ImageData() {
        var len = arguments.length;
        if (len == 2) {
            if (typeof arguments[0] == 'number' && typeof arguments[1] == 'number') {
                this.w = arguments[0];
                this.h = arguments[1];
                this.d = new Uint8ClampedArray(this.w * this.h * 4);
                return;
            }
        }
        else if (len == 3) {
            if (typeof arguments[0] == 'object' && typeof arguments[1] == 'number' && typeof arguments[2] == 'number') {
                this.d = arguments[0];
                this.w = arguments[1];
                this.h = arguments[2];
            }
        }
        throw new Error('ImageData: params error');
    }
    Object.defineProperty(ImageData.prototype, "width", {
        get: function () {
            return this.w;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageData.prototype, "height", {
        get: function () {
            return this.h;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageData.prototype, "data", {
        get: function () {
            return this.d;
        },
        enumerable: false,
        configurable: true
    });
    return ImageData;
}());
imageData.ImageData = ImageData;

var location = {};

Object.defineProperty(location, "__esModule", { value: true });
location.location = void 0;
location.location = {
    href: '',
};

var navigator = {};

Object.defineProperty(navigator, "__esModule", { value: true });
navigator.navigator = void 0;
var platform_1$2 = platform$1;
var info$1 = platform_1$2.platform.getSystemInfoSync();
var platform = info$1.platform, language = info$1.language;
var android = platform.toLowerCase().includes('android');
var uaDesc = android ? 'Android; CPU Android 6.0' : 'iPhone; CPU iPhone OS 10_3_1 like Mac OS X';
var ua = "Mozilla/5.0 (".concat(uaDesc, ") AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/").concat(language);
navigator.navigator = {
    platform: platform,
    language: language,
    appVersion: "5.0 (".concat(uaDesc, ") AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1"),
    userAgent: ua,
};

var offscreenCanvas = {};

Object.defineProperty(offscreenCanvas, "__esModule", { value: true });
offscreenCanvas._OffscreenCanvas = void 0;
var platform_1$1 = platform$1;
var register_1$1 = register$1;
// 会导致蒙版失效，暂时不进行 Adapter 操作
var _OffscreenCanvas = /** @class */ (function () {
    function _OffscreenCanvas(width, height) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        var canvas;
        if ((0, register_1$1.isMiniGame)()) {
            canvas = platform_1$1.platform.createCanvas();
            canvas.width = width;
            canvas.height = height;
        }
        else {
            canvas = platform_1$1.platform.createOffscreenCanvas({ width: width, height: height });
        }
        return canvas;
    }
    return _OffscreenCanvas;
}());
offscreenCanvas._OffscreenCanvas = _OffscreenCanvas;

var performance$1 = {};

Object.defineProperty(performance$1, "__esModule", { value: true });
performance$1.performance = void 0;
var performance = /** @class */ (function () {
    function performance() {
    }
    performance.now = function () {
        return Date.now();
    };
    performance.clearMarks = function () { };
    performance.clearMeasures = function () { };
    performance.clearResourceTimings = function () { };
    performance.getEntries = function () { };
    performance.getEntriesByName = function () { };
    performance.getEntriesByType = function () { };
    performance.mark = function () { };
    performance.measure = function () { };
    performance.setResourceTimingBufferSize = function () { };
    performance.toJSON = function () { };
    performance.eventCounts = 0;
    performance.timeOrigin = 0;
    return performance;
}());
performance$1.performance = performance;

var requestAnimationFrame$1 = {};

Object.defineProperty(requestAnimationFrame$1, "__esModule", { value: true });
requestAnimationFrame$1.cancelAnimationFrame = requestAnimationFrame$1.requestAnimationFrame = void 0;
var register_1 = register$1;
var lastTime = 0;
var id = 0;
function hack(cb) {
    var now = Date.now();
    var nextTime = Math.max(lastTime + 23, now);
    id = setTimeout(function () {
        cb((lastTime = nextTime));
    }, nextTime - now);
    return id;
}
function requestAnimationFrame(cb) {
    var canvas = (0, register_1.getCanvas)();
    if (canvas.requestAnimationFrame) {
        return canvas.requestAnimationFrame(cb);
    }
    else {
        return hack(cb);
    }
}
requestAnimationFrame$1.requestAnimationFrame = requestAnimationFrame;
function cancelAnimationFrame(id) {
    var canvas = (0, register_1.getCanvas)();
    if (canvas.cancelAnimationFrame) {
        return canvas.cancelAnimationFrame(id);
    }
    else {
        return clearTimeout(id);
    }
}
requestAnimationFrame$1.cancelAnimationFrame = cancelAnimationFrame;

var url = {};

Object.defineProperty(url, "__esModule", { value: true });
url.URL = void 0;
var atob_1 = atob$1;
var URL = /** @class */ (function () {
    // todo: 完善URL对象
    function URL(url, host) {
        if (host === void 0) { host = ''; }
        // 如果 URL 是绝对的，则直接使用它
        if (url.indexOf('http://') == 0 || url.indexOf('https://') == 0) {
            this.href = url;
            return;
        }
        // 如果是相对地址
        // 移除基础 URL 的文件名部分（如果有）
        host = host.substring(0, host.lastIndexOf('/') + 1);
        // 移除相对 URL 的 "./" 部分（如果有）
        url = url.startsWith('./') ? url.substring(2) : url;
        // 拼接两个部分以构建绝对 URL
        this.href = host + url;
    }
    /**
     * fake createObject, use base64 instead
     * @param blob
     */
    URL.createObjectURL = function (blob) {
        var buffer = blob.buffers[0];
        var type = typeof blob.type === 'object' ? blob.type.type : blob.type;
        var base64 = _arrayBufferToBase64(buffer);
        var prefix = "data:".concat(type, ";base64,");
        return prefix + base64;
    };
    URL.revokeObjectURL = function () {
    };
    return URL;
}());
url.URL = URL;
function _arrayBufferToBase64(buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return (0, atob_1.btoa)(binary);
}

var xmlHttpRequest = {};

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(xmlHttpRequest, "__esModule", { value: true });
xmlHttpRequest.XMLHttpRequest = void 0;
// @ts-nocheck
var platform_1 = platform$1;
var event_target_1 = eventTarget;
var _requestHeader = new WeakMap();
var _responseHeader = new WeakMap();
var _requestTask = new WeakMap();
var contentTypes = {
    json: 'application/json',
    text: 'application/text',
    arraybuffer: 'application/octet-stream',
};
function _triggerEvent(type, event) {
    if (event === void 0) { event = {}; }
    event.target = event.target || this;
    if (typeof this["on".concat(type)] === 'function') {
        this["on".concat(type)].call(this, event);
    }
}
function _changeReadyState(readyState, event) {
    if (event === void 0) { event = {}; }
    this.readyState = readyState;
    event.readyState = readyState;
    _triggerEvent.call(this, 'readystatechange', event);
}
function _isRelativePath(url) {
    return !/^(http|https|ftp|wxfile):\/\/.*/i.test(url);
}
var XMLHttpRequest = /** @class */ (function (_super) {
    __extends$1(XMLHttpRequest, _super);
    function XMLHttpRequest() {
        var _this = _super.call(this) || this;
        _this.runtime = platform_1.platform.getSystemInfoSync().platform;
        /*
         * TODO 这一批事件应该是在 XMLHttpRequestEventTarget.prototype 上面的
         */
        _this.onabort = null;
        _this.onerror = null;
        _this.onload = null;
        _this.onloadstart = null;
        _this.onprogress = null;
        _this.ontimeout = null;
        _this.onloadend = null;
        _this.onreadystatechange = null;
        _this.readyState = 0;
        _this.response = null;
        _this.responseText = null;
        _this.responseType = 'text';
        _this.dataType = 'string';
        _this.responseXML = null;
        _this.status = 0;
        _this.statusText = '';
        _this.upload = {};
        _this.withCredentials = false;
        _requestHeader.set(_this, {
            'content-type': 'application/x-www-form-urlencoded',
        });
        _responseHeader.set(_this, {});
        return _this;
    }
    XMLHttpRequest.prototype.abort = function () {
        var myRequestTask = _requestTask.get(this);
        if (myRequestTask) {
            myRequestTask.abort();
        }
    };
    XMLHttpRequest.prototype.getAllResponseHeaders = function () {
        var responseHeader = _responseHeader.get(this);
        return Object.keys(responseHeader)
            .map(function (header) {
            return "".concat(header, ": ").concat(responseHeader[header]);
        })
            .join('\n');
    };
    XMLHttpRequest.prototype.getResponseHeader = function (header) {
        return _responseHeader.get(this)[header];
    };
    /* async, user, password 这几个参数在小程序内不支持 */
    XMLHttpRequest.prototype.open = function (method, url) {
        this._method = method;
        this._url = url;
        _changeReadyState.call(this, XMLHttpRequest.OPENED);
    };
    XMLHttpRequest.prototype.overrideMimeType = function () { };
    XMLHttpRequest.prototype.send = function (data) {
        var _this = this;
        if (data === void 0) { data = ''; }
        if (this.readyState !== XMLHttpRequest.OPENED) {
            throw new Error('Failed to execute \'send\' on \'XMLHttpRequest\': The object\'s state must be OPENED.');
        }
        else {
            var url_1 = this._url;
            var header_1 = _requestHeader.get(this);
            var responseType_1 = this.responseType;
            var dataType_1 = this.dataType;
            if (contentTypes[responseType_1] && !header_1['content-type']) {
                header_1['content-type'] = contentTypes[responseType_1];
            }
            var relative_1 = _isRelativePath(url_1);
            var encoding = void 0;
            if (responseType_1 === 'arraybuffer') {
                // 避免被默认转换为JSON
                dataType_1 = 'arrayBuffer';
            }
            else {
                encoding = 'utf8';
            }
            if (responseType_1 === 'json') {
                dataType_1 = 'json';
                responseType_1 = 'text';
            }
            delete this.response;
            this.response = null;
            var resolved_1 = false;
            var onSuccess_1 = function (_a) {
                var data = _a.data, statusCode = _a.statusCode, header = _a.header;
                // console.log('onSuccess', url);
                if (resolved_1) {
                    return;
                }
                resolved_1 = true;
                statusCode = statusCode === undefined ? 200 : statusCode;
                if (typeof data !== 'string' && !(data instanceof ArrayBuffer) && dataType_1 !== 'json') {
                    try {
                        data = JSON.stringify(data);
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    }
                    catch (e) { /* empty */ }
                }
                _this.status = statusCode;
                if (header) {
                    _responseHeader.set(_this, header);
                }
                _triggerEvent.call(_this, 'loadstart');
                _changeReadyState.call(_this, XMLHttpRequest.HEADERS_RECEIVED);
                _changeReadyState.call(_this, XMLHttpRequest.LOADING);
                _this.response = data;
                if (data instanceof ArrayBuffer) {
                    Object.defineProperty(_this, 'responseText', {
                        enumerable: true,
                        configurable: true,
                        get: function () {
                            throw 'InvalidStateError : responseType is ' + this.responseType;
                        },
                    });
                }
                else {
                    _this.responseText = data;
                }
                _changeReadyState.call(_this, XMLHttpRequest.DONE);
                _triggerEvent.call(_this, 'load');
                _triggerEvent.call(_this, 'loadend');
            };
            var onFail_1 = function (e) {
                var errMsg = e.message || e.errorMessage;
                // TODO 规范错误
                if (resolved_1) {
                    return;
                }
                resolved_1 = true;
                if (errMsg.indexOf('abort') !== -1) {
                    _triggerEvent.call(_this, 'abort');
                }
                else {
                    _triggerEvent.call(_this, 'error', {
                        message: errMsg,
                    });
                }
                _triggerEvent.call(_this, 'loadend');
                if (relative_1) {
                    // 用户即使没监听error事件, 也给出相应的警告
                    console.warn(errMsg);
                }
            };
            if (relative_1) {
                var fs = platform_1.platform.getFileSystemManager();
                var options = {
                    filePath: url_1,
                    success: onSuccess_1,
                    fail: onFail_1,
                };
                if (encoding) {
                    options['encoding'] = encoding;
                }
                fs.readFile(options);
                return;
            }
            // IOS在某些情况下不会触发onSuccess...
            var usePatch = responseType_1 === 'arraybuffer' && this.runtime === 'ios' && XMLHttpRequest.useFetchPatch;
            platform_1.platform.request({
                data: data,
                url: url_1,
                method: this._method.toUpperCase(),
                header: header_1,
                dataType: dataType_1,
                responseType: responseType_1,
                enableCache: false,
                success: onSuccess_1,
                // success: usePatch ? undefined : onSuccess,
                fail: onFail_1,
            });
            if (usePatch) {
                setTimeout(function () {
                    platform_1.platform.request({
                        data: data,
                        url: url_1,
                        method: this._method,
                        header: header_1,
                        dataType: dataType_1,
                        responseType: responseType_1,
                        enableCache: true,
                        success: onSuccess_1,
                        fail: onFail_1,
                    });
                }, XMLHttpRequest.fetchPatchDelay);
            }
        }
    };
    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        var myHeader = _requestHeader.get(this);
        myHeader[header] = value;
        _requestHeader.set(this, myHeader);
    };
    XMLHttpRequest.prototype.addEventListener = function (type, listener) {
        var _this = this;
        if (typeof listener !== 'function') {
            return;
        }
        this['on' + type] = function (event) {
            if (event === void 0) { event = {}; }
            event.target = event.target || _this;
            listener.call(_this, event);
        };
    };
    XMLHttpRequest.prototype.removeEventListener = function (type, listener) {
        if (this['on' + type] === listener) {
            this['on' + type] = null;
        }
    };
    return XMLHttpRequest;
}(event_target_1.EventTarget));
xmlHttpRequest.XMLHttpRequest = XMLHttpRequest;
// TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态
XMLHttpRequest.UNSEND = 0;
XMLHttpRequest.OPENED = 1;
XMLHttpRequest.HEADERS_RECEIVED = 2;
XMLHttpRequest.LOADING = 3;
XMLHttpRequest.DONE = 4;
// 某些情况下IOS会不success不触发。。。
XMLHttpRequest.useFetchPatch = false;
XMLHttpRequest.fetchPatchDelay = 200;

var webgl = {};

Object.defineProperty(webgl, "__esModule", { value: true });
webgl.WebGLRenderingContext = void 0;
webgl.WebGLRenderingContext = {
    GCCSO_SHADER_BINARY_FJ: 0x9260,
    _3DC_XY_AMD: 0x87fa,
    _3DC_X_AMD: 0x87f9,
    ACTIVE_ATTRIBUTES: 0x8b89,
    ACTIVE_ATTRIBUTE_MAX_LENGTH: 0x8b8a,
    ACTIVE_PROGRAM_EXT: 0x8259,
    ACTIVE_TEXTURE: 0x84e0,
    ACTIVE_UNIFORMS: 0x8b86,
    ACTIVE_UNIFORM_MAX_LENGTH: 0x8b87,
    ALIASED_LINE_WIDTH_RANGE: 0x846e,
    ALIASED_POINT_SIZE_RANGE: 0x846d,
    ALL_COMPLETED_NV: 0x84f2,
    ALL_SHADER_BITS_EXT: 0xffffffff,
    ALPHA: 0x1906,
    ALPHA16F_EXT: 0x881c,
    ALPHA32F_EXT: 0x8816,
    ALPHA8_EXT: 0x803c,
    ALPHA8_OES: 0x803c,
    ALPHA_BITS: 0xd55,
    ALPHA_TEST_FUNC_QCOM: 0xbc1,
    ALPHA_TEST_QCOM: 0xbc0,
    ALPHA_TEST_REF_QCOM: 0xbc2,
    ALREADY_SIGNALED_APPLE: 0x911a,
    ALWAYS: 0x207,
    AMD_compressed_3DC_texture: 0x1,
    AMD_compressed_ATC_texture: 0x1,
    AMD_performance_monitor: 0x1,
    AMD_program_binary_Z400: 0x1,
    ANGLE_depth_texture: 0x1,
    ANGLE_framebuffer_blit: 0x1,
    ANGLE_framebuffer_multisample: 0x1,
    ANGLE_instanced_arrays: 0x1,
    ANGLE_pack_reverse_row_order: 0x1,
    ANGLE_program_binary: 0x1,
    ANGLE_texture_compression_dxt3: 0x1,
    ANGLE_texture_compression_dxt5: 0x1,
    ANGLE_texture_usage: 0x1,
    ANGLE_translated_shader_source: 0x1,
    ANY_SAMPLES_PASSED_CONSERVATIVE_EXT: 0x8d6a,
    ANY_SAMPLES_PASSED_EXT: 0x8c2f,
    APPLE_copy_texture_levels: 0x1,
    APPLE_framebuffer_multisample: 0x1,
    APPLE_rgb_422: 0x1,
    APPLE_sync: 0x1,
    APPLE_texture_format_BGRA8888: 0x1,
    APPLE_texture_max_level: 0x1,
    ARM_mali_program_binary: 0x1,
    ARM_mali_shader_binary: 0x1,
    ARM_rgba8: 0x1,
    ARRAY_BUFFER: 0x8892,
    ARRAY_BUFFER_BINDING: 0x8894,
    ATC_RGBA_EXPLICIT_ALPHA_AMD: 0x8c93,
    ATC_RGBA_INTERPOLATED_ALPHA_AMD: 0x87ee,
    ATC_RGB_AMD: 0x8c92,
    ATTACHED_SHADERS: 0x8b85,
    BACK: 0x405,
    BGRA8_EXT: 0x93a1,
    BGRA_EXT: 0x80e1,
    BGRA_IMG: 0x80e1,
    BINNING_CONTROL_HINT_QCOM: 0x8fb0,
    BLEND: 0xbe2,
    BLEND_COLOR: 0x8005,
    BLEND_DST_ALPHA: 0x80ca,
    BLEND_DST_RGB: 0x80c8,
    BLEND_EQUATION: 0x8009,
    BLEND_EQUATION_ALPHA: 0x883d,
    BLEND_EQUATION_RGB: 0x8009,
    BLEND_SRC_ALPHA: 0x80cb,
    BLEND_SRC_RGB: 0x80c9,
    BLUE_BITS: 0xd54,
    BOOL: 0x8b56,
    BOOL_VEC2: 0x8b57,
    BOOL_VEC3: 0x8b58,
    BOOL_VEC4: 0x8b59,
    BUFFER: 0x82e0,
    BUFFER_ACCESS_OES: 0x88bb,
    BUFFER_MAPPED_OES: 0x88bc,
    BUFFER_MAP_POINTER_OES: 0x88bd,
    BUFFER_OBJECT_EXT: 0x9151,
    BUFFER_SIZE: 0x8764,
    BUFFER_USAGE: 0x8765,
    BYTE: 0x1400,
    CCW: 0x901,
    CLAMP_TO_BORDER_NV: 0x812d,
    CLAMP_TO_EDGE: 0x812f,
    COLOR_ATTACHMENT0: 0x8ce0,
    COLOR_ATTACHMENT0_NV: 0x8ce0,
    COLOR_ATTACHMENT10_NV: 0x8cea,
    COLOR_ATTACHMENT11_NV: 0x8ceb,
    COLOR_ATTACHMENT12_NV: 0x8cec,
    COLOR_ATTACHMENT13_NV: 0x8ced,
    COLOR_ATTACHMENT14_NV: 0x8cee,
    COLOR_ATTACHMENT15_NV: 0x8cef,
    COLOR_ATTACHMENT1_NV: 0x8ce1,
    COLOR_ATTACHMENT2_NV: 0x8ce2,
    COLOR_ATTACHMENT3_NV: 0x8ce3,
    COLOR_ATTACHMENT4_NV: 0x8ce4,
    COLOR_ATTACHMENT5_NV: 0x8ce5,
    COLOR_ATTACHMENT6_NV: 0x8ce6,
    COLOR_ATTACHMENT7_NV: 0x8ce7,
    COLOR_ATTACHMENT8_NV: 0x8ce8,
    COLOR_ATTACHMENT9_NV: 0x8ce9,
    COLOR_ATTACHMENT_EXT: 0x90f0,
    COLOR_BUFFER_BIT: 0x4000,
    COLOR_BUFFER_BIT0_QCOM: 0x1,
    COLOR_BUFFER_BIT1_QCOM: 0x2,
    COLOR_BUFFER_BIT2_QCOM: 0x4,
    COLOR_BUFFER_BIT3_QCOM: 0x8,
    COLOR_BUFFER_BIT4_QCOM: 0x10,
    COLOR_BUFFER_BIT5_QCOM: 0x20,
    COLOR_BUFFER_BIT6_QCOM: 0x40,
    COLOR_BUFFER_BIT7_QCOM: 0x80,
    COLOR_CLEAR_VALUE: 0xc22,
    COLOR_EXT: 0x1800,
    COLOR_WRITEMASK: 0xc23,
    COMPARE_REF_TO_TEXTURE_EXT: 0x884e,
    COMPILE_STATUS: 0x8b81,
    COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93bb,
    COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93b8,
    COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93b9,
    COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93ba,
    COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93bc,
    COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93bd,
    COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93b0,
    COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93b1,
    COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93b2,
    COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93b3,
    COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93b4,
    COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93b5,
    COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93b6,
    COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93b7,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,
    COMPRESSED_RGBA_PVRTC_2BPPV2_IMG: 0x9137,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
    COMPRESSED_RGBA_PVRTC_4BPPV2_IMG: 0x9138,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
    COMPRESSED_RGBA_S3TC_DXT3_ANGLE: 0x83f2,
    COMPRESSED_RGBA_S3TC_DXT5_ANGLE: 0x83f3,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93db,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93d8,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93d9,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93da,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93dc,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93dd,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93d0,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93d1,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93d2,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93d3,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93d4,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93d5,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93d6,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93d7,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV: 0x8c4d,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV: 0x8c4e,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV: 0x8c4f,
    COMPRESSED_SRGB_S3TC_DXT1_NV: 0x8c4c,
    COMPRESSED_TEXTURE_FORMATS: 0x86a3,
    CONDITION_SATISFIED_APPLE: 0x911c,
    CONSTANT_ALPHA: 0x8003,
    CONSTANT_COLOR: 0x8001,
    CONTEXT_FLAG_DEBUG_BIT: 0x2,
    CONTEXT_ROBUST_ACCESS_EXT: 0x90f3,
    COUNTER_RANGE_AMD: 0x8bc1,
    COUNTER_TYPE_AMD: 0x8bc0,
    COVERAGE_ALL_FRAGMENTS_NV: 0x8ed5,
    COVERAGE_ATTACHMENT_NV: 0x8ed2,
    COVERAGE_AUTOMATIC_NV: 0x8ed7,
    COVERAGE_BUFFERS_NV: 0x8ed3,
    COVERAGE_BUFFER_BIT_NV: 0x8000,
    COVERAGE_COMPONENT4_NV: 0x8ed1,
    COVERAGE_COMPONENT_NV: 0x8ed0,
    COVERAGE_EDGE_FRAGMENTS_NV: 0x8ed6,
    COVERAGE_SAMPLES_NV: 0x8ed4,
    CPU_OPTIMIZED_QCOM: 0x8fb1,
    CULL_FACE: 0xb44,
    CULL_FACE_MODE: 0xb45,
    CURRENT_PROGRAM: 0x8b8d,
    CURRENT_QUERY_EXT: 0x8865,
    CURRENT_VERTEX_ATTRIB: 0x8626,
    CW: 0x900,
    DEBUG_CALLBACK_FUNCTION: 0x8244,
    DEBUG_CALLBACK_USER_PARAM: 0x8245,
    DEBUG_GROUP_STACK_DEPTH: 0x826d,
    DEBUG_LOGGED_MESSAGES: 0x9145,
    DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: 0x8243,
    DEBUG_OUTPUT: 0x92e0,
    DEBUG_OUTPUT_SYNCHRONOUS: 0x8242,
    DEBUG_SEVERITY_HIGH: 0x9146,
    DEBUG_SEVERITY_LOW: 0x9148,
    DEBUG_SEVERITY_MEDIUM: 0x9147,
    DEBUG_SEVERITY_NOTIFICATION: 0x826b,
    DEBUG_SOURCE_API: 0x8246,
    DEBUG_SOURCE_APPLICATION: 0x824a,
    DEBUG_SOURCE_OTHER: 0x824b,
    DEBUG_SOURCE_SHADER_COMPILER: 0x8248,
    DEBUG_SOURCE_THIRD_PARTY: 0x8249,
    DEBUG_SOURCE_WINDOW_SYSTEM: 0x8247,
    DEBUG_TYPE_DEPRECATED_BEHAVIOR: 0x824d,
    DEBUG_TYPE_ERROR: 0x824c,
    DEBUG_TYPE_MARKER: 0x8268,
    DEBUG_TYPE_OTHER: 0x8251,
    DEBUG_TYPE_PERFORMANCE: 0x8250,
    DEBUG_TYPE_POP_GROUP: 0x826a,
    DEBUG_TYPE_PORTABILITY: 0x824f,
    DEBUG_TYPE_PUSH_GROUP: 0x8269,
    DEBUG_TYPE_UNDEFINED_BEHAVIOR: 0x824e,
    DECR: 0x1e03,
    DECR_WRAP: 0x8508,
    DELETE_STATUS: 0x8b80,
    DEPTH24_STENCIL8_OES: 0x88f0,
    DEPTH_ATTACHMENT: 0x8d00,
    DEPTH_STENCIL_ATTACHMENT: 0x821a,
    DEPTH_BITS: 0xd56,
    DEPTH_BUFFER_BIT: 0x100,
    DEPTH_BUFFER_BIT0_QCOM: 0x100,
    DEPTH_BUFFER_BIT1_QCOM: 0x200,
    DEPTH_BUFFER_BIT2_QCOM: 0x400,
    DEPTH_BUFFER_BIT3_QCOM: 0x800,
    DEPTH_BUFFER_BIT4_QCOM: 0x1000,
    DEPTH_BUFFER_BIT5_QCOM: 0x2000,
    DEPTH_BUFFER_BIT6_QCOM: 0x4000,
    DEPTH_BUFFER_BIT7_QCOM: 0x8000,
    DEPTH_CLEAR_VALUE: 0xb73,
    DEPTH_COMPONENT: 0x1902,
    DEPTH_COMPONENT16: 0x81a5,
    DEPTH_COMPONENT16_NONLINEAR_NV: 0x8e2c,
    DEPTH_COMPONENT16_OES: 0x81a5,
    DEPTH_COMPONENT24_OES: 0x81a6,
    DEPTH_COMPONENT32_OES: 0x81a7,
    DEPTH_EXT: 0x1801,
    DEPTH_FUNC: 0xb74,
    DEPTH_RANGE: 0xb70,
    DEPTH_STENCIL: 0x84f9,
    DEPTH_STENCIL_OES: 0x84f9,
    DEPTH_TEST: 0xb71,
    DEPTH_WRITEMASK: 0xb72,
    DITHER: 0xbd0,
    DMP_shader_binary: 0x1,
    DONT_CARE: 0x1100,
    DRAW_BUFFER0_NV: 0x8825,
    DRAW_BUFFER10_NV: 0x882f,
    DRAW_BUFFER11_NV: 0x8830,
    DRAW_BUFFER12_NV: 0x8831,
    DRAW_BUFFER13_NV: 0x8832,
    DRAW_BUFFER14_NV: 0x8833,
    DRAW_BUFFER15_NV: 0x8834,
    DRAW_BUFFER1_NV: 0x8826,
    DRAW_BUFFER2_NV: 0x8827,
    DRAW_BUFFER3_NV: 0x8828,
    DRAW_BUFFER4_NV: 0x8829,
    DRAW_BUFFER5_NV: 0x882a,
    DRAW_BUFFER6_NV: 0x882b,
    DRAW_BUFFER7_NV: 0x882c,
    DRAW_BUFFER8_NV: 0x882d,
    DRAW_BUFFER9_NV: 0x882e,
    DRAW_BUFFER_EXT: 0xc01,
    DRAW_FRAMEBUFFER_ANGLE: 0x8ca9,
    DRAW_FRAMEBUFFER_APPLE: 0x8ca9,
    DRAW_FRAMEBUFFER_BINDING_ANGLE: 0x8ca6,
    DRAW_FRAMEBUFFER_BINDING_APPLE: 0x8ca6,
    DRAW_FRAMEBUFFER_BINDING_NV: 0x8ca6,
    DRAW_FRAMEBUFFER_NV: 0x8ca9,
    DST_ALPHA: 0x304,
    DST_COLOR: 0x306,
    DYNAMIC_DRAW: 0x88e8,
    ELEMENT_ARRAY_BUFFER: 0x8893,
    ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
    EQUAL: 0x202,
    ES_VERSION_2_0: 0x1,
    ETC1_RGB8_OES: 0x8d64,
    ETC1_SRGB8_NV: 0x88ee,
    EXTENSIONS: 0x1f03,
    EXT_blend_minmax: 0x1,
    EXT_color_buffer_half_float: 0x1,
    EXT_debug_label: 0x1,
    EXT_debug_marker: 0x1,
    EXT_discard_framebuffer: 0x1,
    EXT_map_buffer_range: 0x1,
    EXT_multi_draw_arrays: 0x1,
    EXT_multisampled_render_to_texture: 0x1,
    EXT_multiview_draw_buffers: 0x1,
    EXT_occlusion_query_boolean: 0x1,
    EXT_read_format_bgra: 0x1,
    EXT_robustness: 0x1,
    EXT_sRGB: 0x1,
    EXT_separate_shader_objects: 0x1,
    EXT_shader_framebuffer_fetch: 0x1,
    EXT_shader_texture_lod: 0x1,
    EXT_shadow_samplers: 0x1,
    EXT_texture_compression_dxt1: 0x1,
    EXT_texture_filter_anisotropic: 0x1,
    EXT_texture_format_BGRA8888: 0x1,
    EXT_texture_rg: 0x1,
    EXT_texture_storage: 0x1,
    EXT_texture_type_2_10_10_10_REV: 0x1,
    EXT_unpack_subimage: 0x1,
    FALSE: 0x0,
    FASTEST: 0x1101,
    FENCE_CONDITION_NV: 0x84f4,
    FENCE_STATUS_NV: 0x84f3,
    FIXED: 0x140c,
    FJ_shader_binary_GCCSO: 0x1,
    FLOAT: 0x1406,
    FLOAT_MAT2: 0x8b5a,
    FLOAT_MAT3: 0x8b5b,
    FLOAT_MAT4: 0x8b5c,
    FLOAT_VEC2: 0x8b50,
    FLOAT_VEC3: 0x8b51,
    FLOAT_VEC4: 0x8b52,
    FRAGMENT_SHADER: 0x8b30,
    FRAGMENT_SHADER_BIT_EXT: 0x2,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8b8b,
    FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT: 0x8a52,
    FRAMEBUFFER: 0x8d40,
    FRAMEBUFFER_ATTACHMENT_ANGLE: 0x93a3,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES: 0x8cd4,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT: 0x8d6c,
    FRAMEBUFFER_BINDING: 0x8ca6,
    FRAMEBUFFER_COMPLETE: 0x8cd5,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG: 0x9134,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV: 0x8d56,
    FRAMEBUFFER_UNDEFINED_OES: 0x8219,
    FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
    FRONT: 0x404,
    FRONT_AND_BACK: 0x408,
    FRONT_FACE: 0xb46,
    FUNC_ADD: 0x8006,
    FUNC_REVERSE_SUBTRACT: 0x800b,
    FUNC_SUBTRACT: 0x800a,
    GENERATE_MIPMAP_HINT: 0x8192,
    GEQUAL: 0x206,
    GPU_OPTIMIZED_QCOM: 0x8fb2,
    GREATER: 0x204,
    GREEN_BITS: 0xd53,
    GUILTY_CONTEXT_RESET_EXT: 0x8253,
    HALF_FLOAT_OES: 0x8d61,
    HIGH_FLOAT: 0x8df2,
    HIGH_INT: 0x8df5,
    IMG_multisampled_render_to_texture: 0x1,
    IMG_program_binary: 0x1,
    IMG_read_format: 0x1,
    IMG_shader_binary: 0x1,
    IMG_texture_compression_pvrtc: 0x1,
    IMG_texture_compression_pvrtc2: 0x1,
    IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
    IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
    INCR: 0x1e02,
    INCR_WRAP: 0x8507,
    INFO_LOG_LENGTH: 0x8b84,
    INNOCENT_CONTEXT_RESET_EXT: 0x8254,
    INT: 0x1404,
    INT_10_10_10_2_OES: 0x8df7,
    INT_VEC2: 0x8b53,
    INT_VEC3: 0x8b54,
    INT_VEC4: 0x8b55,
    INVALID_ENUM: 0x500,
    INVALID_FRAMEBUFFER_OPERATION: 0x506,
    INVALID_OPERATION: 0x502,
    INVALID_VALUE: 0x501,
    INVERT: 0x150a,
    KEEP: 0x1e00,
    KHR_debug: 0x1,
    KHR_texture_compression_astc_ldr: 0x1,
    LEFT: 0x0406,
    LEQUAL: 0x203,
    LESS: 0x201,
    LINEAR: 0x2601,
    LINEAR_MIPMAP_LINEAR: 0x2703,
    LINEAR_MIPMAP_NEAREST: 0x2701,
    LINES: 0x1,
    LINE_LOOP: 0x2,
    LINE_STRIP: 0x3,
    LINE_WIDTH: 0xb21,
    LINK_STATUS: 0x8b82,
    LOSE_CONTEXT_ON_RESET_EXT: 0x8252,
    LOW_FLOAT: 0x8df0,
    LOW_INT: 0x8df3,
    LUMINANCE: 0x1909,
    LUMINANCE16F_EXT: 0x881e,
    LUMINANCE32F_EXT: 0x8818,
    LUMINANCE4_ALPHA4_OES: 0x8043,
    LUMINANCE8_ALPHA8_EXT: 0x8045,
    LUMINANCE8_ALPHA8_OES: 0x8045,
    LUMINANCE8_EXT: 0x8040,
    LUMINANCE8_OES: 0x8040,
    LUMINANCE_ALPHA: 0x190a,
    LUMINANCE_ALPHA16F_EXT: 0x881f,
    LUMINANCE_ALPHA32F_EXT: 0x8819,
    MALI_PROGRAM_BINARY_ARM: 0x8f61,
    MALI_SHADER_BINARY_ARM: 0x8f60,
    MAP_FLUSH_EXPLICIT_BIT_EXT: 0x10,
    MAP_INVALIDATE_BUFFER_BIT_EXT: 0x8,
    MAP_INVALIDATE_RANGE_BIT_EXT: 0x4,
    MAP_READ_BIT_EXT: 0x1,
    MAP_UNSYNCHRONIZED_BIT_EXT: 0x20,
    MAP_WRITE_BIT_EXT: 0x2,
    MAX_3D_TEXTURE_SIZE_OES: 0x8073,
    MAX_COLOR_ATTACHMENTS_NV: 0x8cdf,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
    MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
    MAX_DEBUG_GROUP_STACK_DEPTH: 0x826c,
    MAX_DEBUG_LOGGED_MESSAGES: 0x9144,
    MAX_DEBUG_MESSAGE_LENGTH: 0x9143,
    MAX_DRAW_BUFFERS_NV: 0x8824,
    MAX_EXT: 0x8008,
    MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
    MAX_LABEL_LENGTH: 0x82e8,
    MAX_MULTIVIEW_BUFFERS_EXT: 0x90f2,
    MAX_RENDERBUFFER_SIZE: 0x84e8,
    MAX_SAMPLES_ANGLE: 0x8d57,
    MAX_SAMPLES_APPLE: 0x8d57,
    MAX_SAMPLES_EXT: 0x8d57,
    MAX_SAMPLES_IMG: 0x9135,
    MAX_SAMPLES_NV: 0x8d57,
    MAX_SERVER_WAIT_TIMEOUT_APPLE: 0x9111,
    MAX_TEXTURE_IMAGE_UNITS: 0x8872,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
    MAX_TEXTURE_SIZE: 0xd33,
    MAX_VARYING_VECTORS: 0x8dfc,
    MAX_VERTEX_ATTRIBS: 0x8869,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
    MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
    MAX_VIEWPORT_DIMS: 0xd3a,
    MEDIUM_FLOAT: 0x8df1,
    MEDIUM_INT: 0x8df4,
    MIN_EXT: 0x8007,
    MIRRORED_REPEAT: 0x8370,
    MULTISAMPLE_BUFFER_BIT0_QCOM: 0x1000000,
    MULTISAMPLE_BUFFER_BIT1_QCOM: 0x2000000,
    MULTISAMPLE_BUFFER_BIT2_QCOM: 0x4000000,
    MULTISAMPLE_BUFFER_BIT3_QCOM: 0x8000000,
    MULTISAMPLE_BUFFER_BIT4_QCOM: 0x10000000,
    MULTISAMPLE_BUFFER_BIT5_QCOM: 0x20000000,
    MULTISAMPLE_BUFFER_BIT6_QCOM: 0x40000000,
    MULTISAMPLE_BUFFER_BIT7_QCOM: 0x80000000,
    MULTIVIEW_EXT: 0x90f1,
    NEAREST: 0x2600,
    NEAREST_MIPMAP_LINEAR: 0x2702,
    NEAREST_MIPMAP_NEAREST: 0x2700,
    NEVER: 0x200,
    NICEST: 0x1102,
    NONE: 0x0,
    NOTEQUAL: 0x205,
    NO_ERROR: 0x0,
    NO_RESET_NOTIFICATION_EXT: 0x8261,
    NUM_COMPRESSED_TEXTURE_FORMATS: 0x86a2,
    NUM_PROGRAM_BINARY_FORMATS_OES: 0x87fe,
    NUM_SHADER_BINARY_FORMATS: 0x8df9,
    NV_coverage_sample: 0x1,
    NV_depth_nonlinear: 0x1,
    NV_draw_buffers: 0x1,
    NV_draw_instanced: 0x1,
    NV_fbo_color_attachments: 0x1,
    NV_fence: 0x1,
    NV_framebuffer_blit: 0x1,
    NV_framebuffer_multisample: 0x1,
    NV_generate_mipmap_sRGB: 0x1,
    NV_instanced_arrays: 0x1,
    NV_read_buffer: 0x1,
    NV_read_buffer_front: 0x1,
    NV_read_depth: 0x1,
    NV_read_depth_stencil: 0x1,
    NV_read_stencil: 0x1,
    NV_sRGB_formats: 0x1,
    NV_shadow_samplers_array: 0x1,
    NV_shadow_samplers_cube: 0x1,
    NV_texture_border_clamp: 0x1,
    NV_texture_compression_s3tc_update: 0x1,
    NV_texture_npot_2D_mipmap: 0x1,
    OBJECT_TYPE_APPLE: 0x9112,
    OES_EGL_image: 0x1,
    OES_EGL_image_external: 0x1,
    OES_compressed_ETC1_RGB8_texture: 0x1,
    OES_compressed_paletted_texture: 0x1,
    OES_depth24: 0x1,
    OES_depth32: 0x1,
    OES_depth_texture: 0x1,
    OES_element_index_uint: 0x1,
    OES_fbo_render_mipmap: 0x1,
    OES_fragment_precision_high: 0x1,
    OES_get_program_binary: 0x1,
    OES_mapbuffer: 0x1,
    OES_packed_depth_stencil: 0x1,
    OES_required_internalformat: 0x1,
    OES_rgb8_rgba8: 0x1,
    OES_standard_derivatives: 0x1,
    OES_stencil1: 0x1,
    OES_stencil4: 0x1,
    OES_surfaceless_context: 0x1,
    OES_texture_3D: 0x1,
    OES_texture_float: 0x1,
    OES_texture_float_linear: 0x1,
    OES_texture_half_float: 0x1,
    OES_texture_half_float_linear: 0x1,
    OES_texture_npot: 0x1,
    OES_vertex_array_object: 0x1,
    OES_vertex_half_float: 0x1,
    OES_vertex_type_10_10_10_2: 0x1,
    ONE: 0x1,
    ONE_MINUS_CONSTANT_ALPHA: 0x8004,
    ONE_MINUS_CONSTANT_COLOR: 0x8002,
    ONE_MINUS_DST_ALPHA: 0x305,
    ONE_MINUS_DST_COLOR: 0x307,
    ONE_MINUS_SRC_ALPHA: 0x303,
    ONE_MINUS_SRC_COLOR: 0x301,
    OUT_OF_MEMORY: 0x505,
    PACK_ALIGNMENT: 0xd05,
    PACK_REVERSE_ROW_ORDER_ANGLE: 0x93a4,
    PALETTE4_R5_G6_B5_OES: 0x8b92,
    PALETTE4_RGB5_A1_OES: 0x8b94,
    PALETTE4_RGB8_OES: 0x8b90,
    PALETTE4_RGBA4_OES: 0x8b93,
    PALETTE4_RGBA8_OES: 0x8b91,
    PALETTE8_R5_G6_B5_OES: 0x8b97,
    PALETTE8_RGB5_A1_OES: 0x8b99,
    PALETTE8_RGB8_OES: 0x8b95,
    PALETTE8_RGBA4_OES: 0x8b98,
    PALETTE8_RGBA8_OES: 0x8b96,
    PERCENTAGE_AMD: 0x8bc3,
    PERFMON_GLOBAL_MODE_QCOM: 0x8fa0,
    PERFMON_RESULT_AMD: 0x8bc6,
    PERFMON_RESULT_AVAILABLE_AMD: 0x8bc4,
    PERFMON_RESULT_SIZE_AMD: 0x8bc5,
    POINTS: 0x0,
    POLYGON_OFFSET_FACTOR: 0x8038,
    POLYGON_OFFSET_FILL: 0x8037,
    POLYGON_OFFSET_UNITS: 0x2a00,
    PROGRAM: 0x82e2,
    PROGRAM_BINARY_ANGLE: 0x93a6,
    PROGRAM_BINARY_FORMATS_OES: 0x87ff,
    PROGRAM_BINARY_LENGTH_OES: 0x8741,
    PROGRAM_OBJECT_EXT: 0x8b40,
    PROGRAM_PIPELINE_BINDING_EXT: 0x825a,
    PROGRAM_PIPELINE_OBJECT_EXT: 0x8a4f,
    PROGRAM_SEPARABLE_EXT: 0x8258,
    QCOM_alpha_test: 0x1,
    QCOM_binning_control: 0x1,
    QCOM_driver_control: 0x1,
    QCOM_extended_get: 0x1,
    QCOM_extended_get2: 0x1,
    QCOM_perfmon_global_mode: 0x1,
    QCOM_tiled_rendering: 0x1,
    QCOM_writeonly_rendering: 0x1,
    QUERY: 0x82e3,
    QUERY_OBJECT_EXT: 0x9153,
    QUERY_RESULT_AVAILABLE_EXT: 0x8867,
    QUERY_RESULT_EXT: 0x8866,
    R16F_EXT: 0x822d,
    R32F_EXT: 0x822e,
    R8_EXT: 0x8229,
    READ_BUFFER_EXT: 0xc02,
    READ_BUFFER_NV: 0xc02,
    READ_FRAMEBUFFER_ANGLE: 0x8ca8,
    READ_FRAMEBUFFER_APPLE: 0x8ca8,
    READ_FRAMEBUFFER_BINDING_ANGLE: 0x8caa,
    READ_FRAMEBUFFER_BINDING_APPLE: 0x8caa,
    READ_FRAMEBUFFER_BINDING_NV: 0x8caa,
    READ_FRAMEBUFFER_NV: 0x8ca8,
    RED_BITS: 0xd52,
    RED_EXT: 0x1903,
    RENDERBUFFER: 0x8d41,
    RENDERBUFFER_ALPHA_SIZE: 0x8d53,
    RENDERBUFFER_BINDING: 0x8ca7,
    RENDERBUFFER_BLUE_SIZE: 0x8d52,
    RENDERBUFFER_DEPTH_SIZE: 0x8d54,
    RENDERBUFFER_GREEN_SIZE: 0x8d51,
    RENDERBUFFER_HEIGHT: 0x8d43,
    RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
    RENDERBUFFER_RED_SIZE: 0x8d50,
    RENDERBUFFER_SAMPLES_ANGLE: 0x8cab,
    RENDERBUFFER_SAMPLES_APPLE: 0x8cab,
    RENDERBUFFER_SAMPLES_EXT: 0x8cab,
    RENDERBUFFER_SAMPLES_IMG: 0x9133,
    RENDERBUFFER_SAMPLES_NV: 0x8cab,
    RENDERBUFFER_STENCIL_SIZE: 0x8d55,
    RENDERBUFFER_WIDTH: 0x8d42,
    RENDERER: 0x1f01,
    RENDER_DIRECT_TO_FRAMEBUFFER_QCOM: 0x8fb3,
    REPEAT: 0x2901,
    REPLACE: 0x1e01,
    REQUIRED_TEXTURE_IMAGE_UNITS_OES: 0x8d68,
    RESET_NOTIFICATION_STRATEGY_EXT: 0x8256,
    RG16F_EXT: 0x822f,
    RG32F_EXT: 0x8230,
    RG8_EXT: 0x822b,
    RGB: 0x1907,
    RGB10_A2_EXT: 0x8059,
    RGB10_EXT: 0x8052,
    RGB16F_EXT: 0x881b,
    RGB32F_EXT: 0x8815,
    RGB565: 0x8d62,
    RGB565_OES: 0x8d62,
    RGB5_A1: 0x8057,
    RGB5_A1_OES: 0x8057,
    RGB8_OES: 0x8051,
    RGBA: 0x1908,
    RGBA16F_EXT: 0x881a,
    RGBA32F_EXT: 0x8814,
    RGBA4: 0x8056,
    RGBA4_OES: 0x8056,
    RGBA8_OES: 0x8058,
    RGB_422_APPLE: 0x8a1f,
    RG_EXT: 0x8227,
    RIGHT: 0x0407,
    SAMPLER: 0x82e6,
    SAMPLER_2D: 0x8b5e,
    SAMPLER_2D_ARRAY_SHADOW_NV: 0x8dc4,
    SAMPLER_2D_SHADOW_EXT: 0x8b62,
    SAMPLER_3D_OES: 0x8b5f,
    SAMPLER_CUBE: 0x8b60,
    SAMPLER_CUBE_SHADOW_NV: 0x8dc5,
    SAMPLER_EXTERNAL_OES: 0x8d66,
    SAMPLES: 0x80a9,
    SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
    SAMPLE_BUFFERS: 0x80a8,
    SAMPLE_COVERAGE: 0x80a0,
    SAMPLE_COVERAGE_INVERT: 0x80ab,
    SAMPLE_COVERAGE_VALUE: 0x80aa,
    SCISSOR_BOX: 0xc10,
    SCISSOR_TEST: 0xc11,
    SGX_BINARY_IMG: 0x8c0a,
    SGX_PROGRAM_BINARY_IMG: 0x9130,
    SHADER: 0x82e1,
    SHADER_BINARY_DMP: 0x9250,
    SHADER_BINARY_FORMATS: 0x8df8,
    SHADER_BINARY_VIV: 0x8fc4,
    SHADER_COMPILER: 0x8dfa,
    SHADER_OBJECT_EXT: 0x8b48,
    SHADER_SOURCE_LENGTH: 0x8b88,
    SHADER_TYPE: 0x8b4f,
    SHADING_LANGUAGE_VERSION: 0x8b8c,
    SHORT: 0x1402,
    SIGNALED_APPLE: 0x9119,
    SLUMINANCE8_ALPHA8_NV: 0x8c45,
    SLUMINANCE8_NV: 0x8c47,
    SLUMINANCE_ALPHA_NV: 0x8c44,
    SLUMINANCE_NV: 0x8c46,
    SRC_ALPHA: 0x302,
    SRC_ALPHA_SATURATE: 0x308,
    SRC_COLOR: 0x300,
    SRGB8_ALPHA8_EXT: 0x8c43,
    SRGB8_NV: 0x8c41,
    SRGB_ALPHA_EXT: 0x8c42,
    SRGB_EXT: 0x8c40,
    STACK_OVERFLOW: 0x503,
    STACK_UNDERFLOW: 0x504,
    STATE_RESTORE: 0x8bdc,
    STATIC_DRAW: 0x88e4,
    STENCIL_ATTACHMENT: 0x8d20,
    STENCIL_BACK_FAIL: 0x8801,
    STENCIL_BACK_FUNC: 0x8800,
    STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
    STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
    STENCIL_BACK_REF: 0x8ca3,
    STENCIL_BACK_VALUE_MASK: 0x8ca4,
    STENCIL_BACK_WRITEMASK: 0x8ca5,
    STENCIL_BITS: 0xd57,
    STENCIL_BUFFER_BIT: 0x400,
    STENCIL_BUFFER_BIT0_QCOM: 0x10000,
    STENCIL_BUFFER_BIT1_QCOM: 0x20000,
    STENCIL_BUFFER_BIT2_QCOM: 0x40000,
    STENCIL_BUFFER_BIT3_QCOM: 0x80000,
    STENCIL_BUFFER_BIT4_QCOM: 0x100000,
    STENCIL_BUFFER_BIT5_QCOM: 0x200000,
    STENCIL_BUFFER_BIT6_QCOM: 0x400000,
    STENCIL_BUFFER_BIT7_QCOM: 0x800000,
    STENCIL_CLEAR_VALUE: 0xb91,
    STENCIL_EXT: 0x1802,
    STENCIL_FAIL: 0xb94,
    STENCIL_FUNC: 0xb92,
    STENCIL_INDEX1_OES: 0x8d46,
    STENCIL_INDEX4_OES: 0x8d47,
    STENCIL_INDEX: 0x1901,
    STENCIL_INDEX8: 0x8d48,
    STENCIL_PASS_DEPTH_FAIL: 0xb95,
    STENCIL_PASS_DEPTH_PASS: 0xb96,
    STENCIL_REF: 0xb97,
    STENCIL_TEST: 0xb90,
    STENCIL_VALUE_MASK: 0xb93,
    STENCIL_WRITEMASK: 0xb98,
    STREAM_DRAW: 0x88e0,
    SUBPIXEL_BITS: 0xd50,
    SYNC_CONDITION_APPLE: 0x9113,
    SYNC_FENCE_APPLE: 0x9116,
    SYNC_FLAGS_APPLE: 0x9115,
    SYNC_FLUSH_COMMANDS_BIT_APPLE: 0x1,
    SYNC_GPU_COMMANDS_COMPLETE_APPLE: 0x9117,
    SYNC_OBJECT_APPLE: 0x8a53,
    SYNC_STATUS_APPLE: 0x9114,
    TEXTURE: 0x1702,
    TEXTURE0: 0x84c0,
    TEXTURE1: 0x84c1,
    TEXTURE10: 0x84ca,
    TEXTURE11: 0x84cb,
    TEXTURE12: 0x84cc,
    TEXTURE13: 0x84cd,
    TEXTURE14: 0x84ce,
    TEXTURE15: 0x84cf,
    TEXTURE16: 0x84d0,
    TEXTURE17: 0x84d1,
    TEXTURE18: 0x84d2,
    TEXTURE19: 0x84d3,
    TEXTURE2: 0x84c2,
    TEXTURE20: 0x84d4,
    TEXTURE21: 0x84d5,
    TEXTURE22: 0x84d6,
    TEXTURE23: 0x84d7,
    TEXTURE24: 0x84d8,
    TEXTURE25: 0x84d9,
    TEXTURE26: 0x84da,
    TEXTURE27: 0x84db,
    TEXTURE28: 0x84dc,
    TEXTURE29: 0x84dd,
    TEXTURE3: 0x84c3,
    TEXTURE30: 0x84de,
    TEXTURE31: 0x84df,
    TEXTURE4: 0x84c4,
    TEXTURE5: 0x84c5,
    TEXTURE6: 0x84c6,
    TEXTURE7: 0x84c7,
    TEXTURE8: 0x84c8,
    TEXTURE9: 0x84c9,
    TEXTURE_2D: 0xde1,
    TEXTURE_3D_OES: 0x806f,
    TEXTURE_BINDING_2D: 0x8069,
    TEXTURE_BINDING_3D_OES: 0x806a,
    TEXTURE_BINDING_CUBE_MAP: 0x8514,
    TEXTURE_BINDING_EXTERNAL_OES: 0x8d67,
    TEXTURE_BORDER_COLOR_NV: 0x1004,
    TEXTURE_COMPARE_FUNC_EXT: 0x884d,
    TEXTURE_COMPARE_MODE_EXT: 0x884c,
    TEXTURE_CUBE_MAP: 0x8513,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
    TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
    TEXTURE_DEPTH_QCOM: 0x8bd4,
    TEXTURE_EXTERNAL_OES: 0x8d65,
    TEXTURE_FORMAT_QCOM: 0x8bd6,
    TEXTURE_HEIGHT_QCOM: 0x8bd3,
    TEXTURE_IMAGE_VALID_QCOM: 0x8bd8,
    TEXTURE_IMMUTABLE_FORMAT_EXT: 0x912f,
    TEXTURE_INTERNAL_FORMAT_QCOM: 0x8bd5,
    TEXTURE_MAG_FILTER: 0x2800,
    TEXTURE_MAX_ANISOTROPY_EXT: 0x84fe,
    TEXTURE_MAX_LEVEL_APPLE: 0x813d,
    TEXTURE_MIN_FILTER: 0x2801,
    TEXTURE_NUM_LEVELS_QCOM: 0x8bd9,
    TEXTURE_OBJECT_VALID_QCOM: 0x8bdb,
    TEXTURE_SAMPLES_IMG: 0x9136,
    TEXTURE_TARGET_QCOM: 0x8bda,
    TEXTURE_TYPE_QCOM: 0x8bd7,
    TEXTURE_USAGE_ANGLE: 0x93a2,
    TEXTURE_WIDTH_QCOM: 0x8bd2,
    TEXTURE_WRAP_R_OES: 0x8072,
    TEXTURE_WRAP_S: 0x2802,
    TEXTURE_WRAP_T: 0x2803,
    TIMEOUT_EXPIRED_APPLE: 0x911b,
    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
    TIMEOUT_IGNORED_APPLE: 0xffffffffffffffff,
    TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE: 0x93a0,
    TRIANGLES: 0x4,
    TRIANGLE_FAN: 0x6,
    TRIANGLE_STRIP: 0x5,
    TRUE: 0x1,
    UNKNOWN_CONTEXT_RESET_EXT: 0x8255,
    UNPACK_ALIGNMENT: 0xcf5,
    UNPACK_ROW_LENGTH: 0xcf2,
    UNPACK_SKIP_PIXELS: 0xcf4,
    UNPACK_SKIP_ROWS: 0xcf3,
    UNSIGNALED_APPLE: 0x9118,
    UNSIGNED_BYTE: 0x1401,
    UNSIGNED_INT: 0x1405,
    UNSIGNED_INT64_AMD: 0x8bc2,
    UNSIGNED_INT_10_10_10_2_OES: 0x8df6,
    UNSIGNED_INT_24_8_OES: 0x84fa,
    UNSIGNED_INT_2_10_10_10_REV_EXT: 0x8368,
    UNSIGNED_NORMALIZED_EXT: 0x8c17,
    UNSIGNED_SHORT: 0x1403,
    UNSIGNED_SHORT_1_5_5_5_REV_EXT: 0x8366,
    UNSIGNED_SHORT_4_4_4_4: 0x8033,
    UNSIGNED_SHORT_4_4_4_4_REV_EXT: 0x8365,
    UNSIGNED_SHORT_4_4_4_4_REV_IMG: 0x8365,
    UNSIGNED_SHORT_5_5_5_1: 0x8034,
    UNSIGNED_SHORT_5_6_5: 0x8363,
    UNSIGNED_SHORT_8_8_APPLE: 0x85ba,
    UNSIGNED_SHORT_8_8_REV_APPLE: 0x85bb,
    VALIDATE_STATUS: 0x8b83,
    VENDOR: 0x1f00,
    VERSION: 0x1f02,
    VERTEX_ARRAY_BINDING_OES: 0x85b5,
    VERTEX_ARRAY_OBJECT_EXT: 0x9154,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,
    VERTEX_ATTRIB_ARRAY_DIVISOR_NV: 0x88fe,
    VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
    VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
    VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
    VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
    VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
    VERTEX_SHADER: 0x8b31,
    VERTEX_SHADER_BIT_EXT: 0x1,
    VIEWPORT: 0xba2,
    VIV_shader_binary: 0x1,
    WAIT_FAILED_APPLE: 0x911d,
    WRITEONLY_RENDERING_QCOM: 0x8823,
    WRITE_ONLY_OES: 0x88b9,
    Z400_BINARY_AMD: 0x8740,
    ZERO: 0x0,
    RASTERIZER_DISCARD: 0x8c89,
    UNPACK_FLIP_Y_WEBGL: 0x9240,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
    CONTEXT_LOST_WEBGL: 0x9242,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
    BROWSER_DEFAULT_WEBGL: 0x9244,
};

var webgl2 = {};

Object.defineProperty(webgl2, "__esModule", { value: true });
webgl2.WebGL2RenderingContext = void 0;
webgl2.WebGL2RenderingContext = {};

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(eventIniter, exports);
__exportStar(platform$1, exports);
__exportStar(accelerometer, exports);
__exportStar(atob$1, exports);
__exportStar(blob, exports);
__exportStar(body, exports);
__exportStar(constructor, exports);
__exportStar(devicePixelRatio, exports);
__exportStar(document, exports);
__exportStar(element, exports);
__exportStar(event, exports);
__exportStar(eventTarget, exports);
__exportStar(htmlElement, exports);
__exportStar(htmlMediaElement, exports);
__exportStar(htmlVideoElement, exports);
__exportStar(image, exports);
__exportStar(imageData, exports);
__exportStar(location, exports);
__exportStar(navigator, exports);
__exportStar(offscreenCanvas, exports);
__exportStar(performance$1, exports);
__exportStar(register$1, exports);
__exportStar(node, exports);
__exportStar(requestAnimationFrame$1, exports);
__exportStar(screen, exports);
__exportStar(url, exports);
__exportStar(xmlHttpRequest, exports);
__exportStar(webgl, exports);
__exportStar(webgl2, exports);
}(core));

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.window = void 0;
__exportStar(core, exports);
var core_1 = core;
exports.window = {
    innerWidth: core_1.screen.availWidth,
    innerHeight: core_1.screen.availHeight,
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
    atob: core_1.atob,
    btoa: core_1.btoa,
    devicePixelRatio: core_1.devicePixelRatio,
    document: core_1.document,
    navigator: core_1.navigator,
    location: core_1.location,
    screen: core_1.screen,
    Blob: core_1.Blob,
    Event: core_1.Event,
    EventTarget: core_1.EventTarget,
    Node: core_1.Node,
    Element: core_1.Element,
    HTMLElement: core_1.HTMLElement,
    HTMLCanvasElement: core_1.HTMLCanvasElement,
    HTMLImageElement: core_1.HTMLImageElement,
    HTMLMediaElement: core_1.HTMLMediaElement,
    HTMLAudioElement: core_1.HTMLAudioElement,
    HTMLVideoElement: core_1.HTMLVideoElement,
    Image: core_1.Image,
    ImageData: core_1.ImageData,
    requestAnimationFrame: core_1.requestAnimationFrame,
    cancelAnimationFrame: core_1.cancelAnimationFrame,
    XMLHttpRequest: core_1.XMLHttpRequest,
    performance: core_1.performance,
    URL: core_1.URL,
    WebGLRenderingContext: core_1.WebGLRenderingContext,
    WebGL2RenderingContext: core_1.WebGL2RenderingContext,
    addEventListener: function (type, listener, options) {
        if (options === void 0) { options = {}; }
        core_1.document.addEventListener(type, listener, options);
    },
    removeEventListener: function (type, listener) {
        core_1.document.removeEventListener(type, listener);
    },
    dispatchEvent: function (event) {
        core_1.document.dispatchEvent(event);
    },
};
core_1.platform.createCanvas = my.createCanvas;
core_1.platform.createImage = my.createImage;
core_1.platform.createOffscreenCanvas = my.createOffscreenCanvas;
core_1.platform.createSelectorQuery = my.createSelectorQuery;
core_1.platform.getSystemInfoSync = my.getSystemInfoSync;
core_1.platform.request = my.request;
core_1.platform.startDeviceMotionListening = my.startDeviceMotionListening;
core_1.platform.stopDeviceMotionListening = my.stopDeviceMotionListening;
core_1.platform.onDeviceMotionChange = my.onDeviceMotionChange;
core_1.platform.offDeviceMotionChange = my.offDeviceMotionChange;
}(alipay));

var index$2 = /*@__PURE__*/getDefaultExportFromCjs(alipay);

var index$3 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	'default': index$2
}, [alipay]);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values$1(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read$3(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray$2(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var SPRITE_VERTEX_STRIDE = 6;
var SEMANTIC_PRE_COLOR_ATTACHMENT_0 = 'PRE_COLOR_0';
var SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = 'PRE_COLOR_SIZE_0';
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = 'PRE_MAIN_COLOR_0';
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = 'PRE_MAIN_COLOR_SIZE_0';
var PLAYER_OPTIONS_ENV_EDITOR = 'editor';
var FILTER_NAME_NONE = 'none';
var HELP_LINK$1 = {
    'Filter not imported': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'Item duration can\'t be less than 0': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
};

/**
 * Helper class to create a WebGL Context
 *
 * @param canvas
 * @param glType
 * @param options
 * @returns
 */
function createGLContext(canvas, glType, options) {
    if (glType === void 0) { glType = 'webgl'; }
    var context;
    if (glType === 'webgl2') {
        context = canvas.getContext('webgl2', options);
        if (!context) {
            console.debug('WebGL2 context retrieval failed, falling back to WebGL context.');
        }
    }
    if (!context || glType === 'webgl') {
        context = canvas.getContext('webgl', options);
    }
    if (!context) {
        throw new Error('This browser does not support WebGL or the WebGL version is incorrect. Please check your WebGL version.');
    }
    return context;
}

function gpuTimer(gl) {
    var _this = this;
    var ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');
    if (ext) {
        var query_1 = gl.createQuery();
        var getTime_1 = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (query_1) {
                            var available = gl.getQueryParameter(query_1, gl.QUERY_RESULT_AVAILABLE);
                            var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
                            if (available && !disjoint) {
                                // See how much time the rendering of the object took in nanoseconds.
                                var timeElapsed = gl.getQueryParameter(query_1, gl.QUERY_RESULT); // Do something useful with the time.  Note that care should be
                                // taken to use all significant bits of the result, not just the
                                // least significant 32 bits.
                                resolve(timeElapsed / 1000 / 1000);
                            }
                            if (available || disjoint) {
                                // Clean up the query object.
                                gl.deleteQuery(query_1); // Don't re-enter this polling loop.
                                query_1 = null;
                            }
                            available !== null && query_1 && alipay.window.setTimeout(function () {
                                getTime_1().then(resolve).catch;
                            }, 1);
                        }
                    })];
            });
        }); };
        if (!query_1) {
            return;
        }
        return {
            begin: function () {
                query_1 && gl.beginQuery(ext.TIME_ELAPSED_EXT, query_1);
            },
            end: function () {
                gl.endQuery(ext.TIME_ELAPSED_EXT);
            },
            getTime: getTime_1,
        };
    }
}

var initErrors = [];
// @ts-expect-error
var glContext = {};
if (!initErrors.length) {
    initGLContext();
}
function initGLContext() {
    // 重要：iOS 9/10 低版本需要拷贝 gl context 的 prototype，要不然会有属性值的缺失
    if (typeof alipay.WebGL2RenderingContext === 'function') {
        copy(alipay.WebGL2RenderingContext);
    }
    else if (typeof alipay.WebGLRenderingContext !== 'undefined') {
        copy(alipay.WebGLRenderingContext);
        copy(alipay.WebGLRenderingContext.prototype);
    }
    else {
        initErrors.push(
        // iOS 16 lockdown mode
        'iOS16 lockdown mode, WebGL Constants not in global');
    }
    if (!initErrors.length && !('HALF_FLOAT' in glContext)) {
        // @ts-expect-error set default value
        glContext['HALF_FLOAT'] = 5131;
    }
}
function isWebGL2(gl) {
    return typeof alipay.WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';
}
function copy(target) {
    for (var name_1 in target) {
        if (/^[A-Z_]/.test(name_1)) {
            // @ts-expect-error safe to assign
            glContext[name_1] = target[name_1];
        }
    }
}

var filterFuncMap = {};
var filterShaderFuncMap = {};
/**
 * 注册滤镜
 * @param name - 滤镜名
 * @param func - 函数，用于在创建 Mesh 前执行
 * @param shaderFunc - 函数，用于获取创建 shader 文本的参数
 */
function registerFilter(name, func, shaderFunc) {
    if (name in filterFuncMap) {
        console.error("Filter ".concat(name, " registered twice."));
    }
    filterFuncMap[name] = func;
    filterShaderFuncMap[name] = shaderFunc;
}
/**
 * 批量注册插件
 * @param filters
 */
function registerFilters(filters) {
    Object.keys(filters).forEach(function (name) {
        var _a = __read$3(filters[name], 2), register = _a[0], createShaderDefine = _a[1];
        registerFilter(name, register, createShaderDefine);
    });
}
/**
 * 执行注册的 shader 回调，创建滤镜的 shader
 * @param filter - `filterShaderFunc` 回调函数的参数
 */
function createFilterShaders(filter) {
    var func = filterShaderFuncMap[filter.name];
    if (!func) {
        throw Error("Filter ".concat(filter.name, " not imported, see ").concat(HELP_LINK$1['Filter not imported']));
    }
    return func(filter);
}
/**
 * 获取滤镜需要在 Mesh 中传递的参数和在 renderPass 中的回调
 * @param filter - `filterFunc` 回调的参数
 * @param composition - 合成对象
 */
function createFilter(filter, composition) {
    var func = filterFuncMap[filter.name];
    if (!func) {
        throw Error("Filter ".concat(filter.name, " not imported, see ").concat(HELP_LINK$1['Filter not imported']));
    }
    var ret = func(filter, composition);
    if (!ret.passSplitOptions) {
        ret.passSplitOptions = {
            attachments: [{ texture: { format: glContext.RGBA } }],
        };
    }
    return ret;
}

function addItem(arr, value) {
    if (!arr.includes(value)) {
        arr.push(value);
    }
    return arr;
}
/**
 * 性能测试：https://blog.mutoe.com/2019/compare-filter-vs-splice-in-javascript/
 * @param arr
 * @param value
 * @returns
 */
function removeItem(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    return arr;
}
/**
 * 原 arrAddWithOrder 根据property的大小在arr中插入item
 * @param arr
 * @param item
 * @param property
 * @param descending
 * @returns
 */
function addItemWithOrder(arr, item, property, descending) {
    if (descending === void 0) { descending = false; }
    if (arr.includes(item)) {
        return;
    }
    arr.push(item);
    if (arr.length === 1) {
        return;
    }
    //单次插入排序
    var index = arr.length - 1;
    if (index) {
        var currentItem = arr[index];
        if (descending) {
            while (arr[index - 1][property] < currentItem[property]) {
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        }
        else {
            while (arr[index - 1][property] > currentItem[property]) {
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        }
        arr[index] = currentItem;
    }
}
function enlargeBuffer(typeArray, length, increase, maxSize) {
    if (increase === void 0) { increase = 1; }
    var buffer = typeArray.buffer;
    if (buffer.byteLength < typeArray.BYTES_PER_ELEMENT * length) {
        var size = Math.ceil(length * increase);
        if (!isNaN(maxSize)) {
            size = Math.min(size, maxSize);
        }
        var nbuffer = new ArrayBuffer(typeArray.BYTES_PER_ELEMENT * size);
        var nArr = new typeArray.constructor(nbuffer);
        nArr.set(typeArray);
        return nArr;
    }
    return typeArray;
}

function colorToArr$1(hex, normalized) {
    var ret = [0, 0, 0, 0];
    if (isString(hex)) {
        hex = hex.replace(/[\s\t\r\n]/g, '');
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [+m[1], +m[2], +m[3], isNaN(a) ? 255 : a * 255];
        }
        else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), parseInt(hex[3] + hex[3], 16), 255];
            // eslint-disable-next-line no-cond-assign
        }
        else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 255] || [0, 0, 0, 255];
        }
    }
    else if (hex instanceof Array) {
        ret = [hex[0], hex[1], hex[2], isNaN(hex[3]) ? 255 : hex[3]];
    }
    if (normalized) {
        for (var i = 0; i < 4; i++) {
            ret[i] /= 255;
        }
    }
    return ret;
}
function getColorFromGradientStops(stops, key, normalize) {
    if (stops.length) {
        var color = void 0;
        for (var j = 1; j <= stops.length - 1; j++) {
            var s0 = stops[j - 1];
            var s1 = stops[j];
            if (s0.stop <= key && key <= s1.stop) {
                color = interpolateColor(s0.color, s1.color, (key - s0.stop) / (s1.stop - s0.stop));
                break;
            }
        }
        if (!color) {
            color = stops[stops.length - 1].color;
        }
        return normalize ? color.map(function (n) { return n / 255; }) : color;
    }
    return [0, 0, 0, 0];
}
function colorStopsFromGradient(gradient) {
    var stops = [];
    if (gradient instanceof Array) {
        gradient.forEach(function (val) {
            var _a = __read$3(val, 5), s = _a[0], r = _a[1], g = _a[2], b = _a[3], a = _a[4];
            stops.push({
                // TODO
                // @ts-expect-error
                stop: parsePercent$1(s),
                color: [r, g, b, a],
            });
        });
    }
    else {
        Object.keys(gradient).forEach(function (stop) {
            var colorRGB = gradient[stop];
            var color = colorToArr$1(colorRGB);
            stops.push({
                stop: parsePercent$1(stop),
                color: color,
            });
        });
    }
    stops = stops.sort(function (a, b) { return a.stop - b.stop; });
    if (stops.length) {
        if (stops[0].stop !== 0) {
            stops.unshift({ stop: 0, color: stops[0].color.slice() });
        }
        var lastStop = stops[stops.length - 1];
        if (lastStop.stop !== 1) {
            stops.push({ stop: 1, color: lastStop.color.slice() });
        }
    }
    return stops;
}
function interpolateColor(a, b, s, origin) {
    var ret = [];
    var ms = 1 - s;
    if (origin) {
        for (var i = 0; i < 4; i++) {
            ret[i] = a[i] * ms + b[i] * s;
        }
    }
    else {
        for (var i = 0; i < 3; i++) {
            ret[i] = Math.round(Math.sqrt(a[i] * a[i] * ms + b[i] * b[i] * s));
        }
        ret[3] = Math.round(a[3] * ms + b[3] * s);
    }
    return ret;
}
function parsePercent$1(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}

function getPixelRatio() {
    if (typeof alipay.screen === 'object' && typeof alipay.document === 'object') {
        var viewportWidth = Math.max(alipay.document.documentElement.clientWidth, alipay.window.innerWidth || 0);
        var screenWidth = alipay.screen.width;
        var viewportScale = screenWidth / viewportWidth;
        return Math.min(2 * viewportScale, 2);
    }
    return 1;
}
function isIOS() {
    // real ios device not in simulator
    return !!alipay.navigator.platform && /iPad|iPhone|iPod/.test(alipay.navigator.platform);
}
function isAndroid() {
    return /\b[Aa]ndroid\b/.test(alipay.navigator.userAgent);
}
function isSimulatorCellPhone() {
    return isAndroid() || /\b(iPad|iPhone|iPod)\b/.test(alipay.navigator.userAgent);
}
function isAlipayMiniApp() {
    //@ts-expect-error
    return typeof my !== 'undefined' && (my === null || my === void 0 ? void 0 : my.renderTarget) === 'web';
}

function imageDataFromColor(value) {
    if (isString(value)) {
        value = colorToArr$1(value);
    }
    var color = value;
    var image = {
        width: 1,
        height: 1,
        data: new Uint8Array(1 * 1 * 4),
    };
    var data = image.data;
    for (var i = 0; i < 4; i++) {
        data[i] = color[i];
    }
    return image;
}
function imageDataFromGradient(gradient) {
    var width = 128;
    var image = {
        width: width,
        height: 1,
        data: new Uint8Array(width * 1 * 4),
    };
    var data = image.data;
    var stops = colorStopsFromGradient(gradient);
    if (stops.length) {
        data.set(stops[0].color, 0);
        for (var i = 1, cursor = 0; i < width - 1; i++) {
            var index = i / width;
            var s0 = void 0;
            var s1 = void 0;
            for (var j = cursor; j < stops.length; j++) {
                s0 = stops[j];
                s1 = stops[j + 1];
                if (s0.stop <= index && s1.stop > index) {
                    break;
                }
            }
            var color = interpolateColor(s0.color, s1.color, (index - s0.stop) / (s1.stop - s0.stop));
            data.set(color, i * 4);
        }
        data.set(stops[stops.length - 1].color, (width - 1) * 4);
    }
    return image;
}

exports.OrderType = void 0;
(function (OrderType) {
    OrderType[OrderType["none"] = 1] = "none";
    OrderType[OrderType["ascending"] = 2] = "ascending";
    OrderType[OrderType["descending"] = 3] = "descending";
})(exports.OrderType || (exports.OrderType = {}));
/**
 * 按照指定排序方式对数组排序
 * @param arr - 要排序的数组
 * @param order - 排序方式
 * @returns
 */
function sortByOrder(arr, order) {
    if (order === void 0) { order = exports.OrderType.ascending; }
    var length = arr.length;
    if (length <= 1 || order === exports.OrderType.none) {
        return arr;
    }
    if (length <= 30) {
        for (var i = 1; i < length; i++) {
            insertionSort(arr, i, order);
        }
        return arr;
    }
    else {
        return fastSort(arr, order);
    }
}
/**
 * 按照指定排序方式往Sortable数组中添加成员
 * @param arr - 被添加的数组
 * @param item - 要添加的成员
 * @param order - 排序方式
 * @returns
 */
function addByOrder(arr, item, order) {
    if (order === void 0) { order = exports.OrderType.ascending; }
    if (arr.includes(item)) {
        return arr;
    }
    arr.push(item);
    if (arr.length === 1) {
        return arr;
    }
    if (order !== exports.OrderType.none) {
        insertionSort(arr, arr.length - 1, order);
    }
    return arr;
}
function insertionSort(array, index, order) {
    var currentItem = array[index];
    if (order !== exports.OrderType.ascending) {
        while (index >= 1 && array[index - 1].priority < currentItem.priority) {
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    }
    else {
        while (index >= 1 && array[index - 1].priority > currentItem.priority) {
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    }
    array[index] = currentItem;
}
function fastSort(arr, order, start, end) {
    var _a, _b;
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = arr.length - 1; }
    // 终止条件
    if (start >= end) {
        return arr;
    }
    var base = arr[start];
    var left = start;
    var right = end;
    while (left < right) {
        if (order === exports.OrderType.ascending) {
            // 从右向左，寻找第一个小于base的值
            while (arr[right].priority > base.priority && right >= left) {
                right--;
            }
            // 从左向右，寻找第一个大于base的值
            while (arr[left].priority <= base.priority && left < right) {
                left++;
            }
        }
        else {
            // 从右向左，寻找第一个大于base的值
            while (arr[right].priority < base.priority && right >= left) {
                right--;
            }
            // 从左向右，寻找第一个小于base的值
            while (arr[left].priority >= base.priority && left < right) {
                left++;
            }
        }
        // 将两个值交换位置
        _a = __read$3([arr[right], arr[left]], 2), arr[left] = _a[0], arr[right] = _a[1];
    }
    // 将最后两个游标相遇的位置的值与base值交换
    _b = __read$3([arr[left], arr[start]], 2), arr[start] = _b[0], arr[left] = _b[1];
    fastSort(arr, order, start, left - 1);
    fastSort(arr, order, right + 1, end);
    return arr;
}

function assertExist(item, msg) {
    if (msg === void 0) { msg = 'item doesn\'t exist'; }
    if (item === undefined || item === null) {
        throw new Error(msg);
    }
}
function asserts(condition, msg) {
    if (msg === void 0) { msg = 'asserts failed'; }
    if (!condition) {
        throw new Error(msg);
    }
}

/**
 * 判断是否为可解析的字体
 * - 首字母不能为数字或 `.`
 * - 不能包含特殊字符，`_-` 是被允许的
 * @param fontFamily - 字体名称
 * @returns
 */
function isValidFontFamily(fontFamily) {
    // iOS 11/12 不支持自定义字体开头为数字的名称，特殊字符也有风险
    return /^[^\d.][\w-]*$/.test(fontFamily);
}

/*!
 * Name: @galacean/effects-specification
 * Description: Galacean Effects JSON Specification
 * Author: Ant Group CO., Ltd.
 * Version: v1.3.0
 */

/*********************************************/
/*               元素属性参数类型               */
/*********************************************/
/**
 * 渲染等级
 */
var RenderLevel$1;
(function (RenderLevel) {
    RenderLevel["S"] = "S";
    RenderLevel["APlus"] = "A+";
    RenderLevel["A"] = "A";
    RenderLevel["BPlus"] = "B+";
    RenderLevel["B"] = "B";
})(RenderLevel$1 || (RenderLevel$1 = {}));
/**
 * 混合模式
 */
var BlendingMode$1;
(function (BlendingMode) {
    /**
     * 普通混合模式
     */
    BlendingMode[BlendingMode["ALPHA"] = 0] = "ALPHA";
    /**
     * 叠加混合模式
     */
    BlendingMode[BlendingMode["ADD"] = 1] = "ADD";
    /**
     * 相乘混合模式
     */
    BlendingMode[BlendingMode["MULTIPLY"] = 2] = "MULTIPLY";
    /**
     * 亮度混合模式
     */
    BlendingMode[BlendingMode["BRIGHTNESS"] = 3] = "BRIGHTNESS";
    /**
     * 减色混合模式
     */
    BlendingMode[BlendingMode["SUBTRACTION"] = 4] = "SUBTRACTION";
    /**
     * 强光混合模式
     */
    BlendingMode[BlendingMode["STRONG_LIGHT"] = 5] = "STRONG_LIGHT";
    /**
     * 弱光混合模式
     */
    BlendingMode[BlendingMode["WEAK_LIGHT"] = 6] = "WEAK_LIGHT";
    /**
     * 亮度叠加混合模式
     */
    BlendingMode[BlendingMode["SUPERPOSITION"] = 7] = "SUPERPOSITION";
})(BlendingMode$1 || (BlendingMode$1 = {}));
/**
 * 单双面模式
 */
var SideMode$1;
(function (SideMode) {
    /**
     * 双面模式
     */
    SideMode[SideMode["DOUBLE"] = 1032] = "DOUBLE";
    /**
     * 正面模式
     */
    SideMode[SideMode["FRONT"] = 1028] = "FRONT";
    /**
     * 背面模式
     */
    SideMode[SideMode["BACK"] = 1029] = "BACK";
})(SideMode$1 || (SideMode$1 = {}));
/**
 * 蒙版模式
 */
var MaskMode$1;
(function (MaskMode) {
    /**
     * 无蒙版
     */
    MaskMode[MaskMode["NONE"] = 0] = "NONE";
    /**
     * 蒙版
     */
    MaskMode[MaskMode["MASK"] = 1] = "MASK";
    /**
     * 被遮挡
     */
    MaskMode[MaskMode["OBSCURED"] = 2] = "OBSCURED";
    /**
     * 被反向遮挡
     */
    MaskMode[MaskMode["REVERSE_OBSCURED"] = 3] = "REVERSE_OBSCURED";
})(MaskMode$1 || (MaskMode$1 = {}));
/**
 * 发射器形状
 */
var ShapeType$1;
(function (ShapeType) {
    /**
     * 没有类型
     */
    ShapeType[ShapeType["NONE"] = 0] = "NONE";
    /**
     * 圆球
     */
    ShapeType[ShapeType["SPHERE"] = 1] = "SPHERE";
    /**
     * 圆锥
     */
    ShapeType[ShapeType["CONE"] = 2] = "CONE";
    /**
     * 半球
     */
    ShapeType[ShapeType["HEMISPHERE"] = 3] = "HEMISPHERE";
    /**
     * 圆
     */
    ShapeType[ShapeType["CIRCLE"] = 4] = "CIRCLE";
    /**
     * 圆环
     */
    ShapeType[ShapeType["DONUT"] = 5] = "DONUT";
    /**
     * 矩形
     */
    ShapeType[ShapeType["RECTANGLE"] = 6] = "RECTANGLE";
    /**
     * 矩形框
     */
    ShapeType[ShapeType["RECTANGLE_EDGE"] = 7] = "RECTANGLE_EDGE";
    /**
     * 直线
     */
    ShapeType[ShapeType["EDGE"] = 8] = "EDGE";
    /**
     * 贴图
     */
    ShapeType[ShapeType["TEXTURE"] = 9] = "TEXTURE";
})(ShapeType$1 || (ShapeType$1 = {}));
/**
 * 插件类型
 */
var PluginType$1;
(function (PluginType) {
    /**
     * 陀螺仪
     */
    PluginType[PluginType["GYROSCOPE"] = 0] = "GYROSCOPE";
    /**
     * Spine
     */
    PluginType[PluginType["SPINE"] = 1] = "SPINE";
})(PluginType$1 || (PluginType$1 = {}));
/**
 * 交互类型
 */
var InteractType$1;
(function (InteractType) {
    /**
     * 点击
     */
    InteractType[InteractType["CLICK"] = 0] = "CLICK";
    /**
     * 消息
     * 前端收到 onMessageItem 回调
     */
    InteractType[InteractType["MESSAGE"] = 1] = "MESSAGE";
    /**
     * 拖拽
     */
    InteractType[InteractType["DRAG"] = 2] = "DRAG";
})(InteractType$1 || (InteractType$1 = {}));
/**
 * 交互行为
 */
var InteractBehavior$2;
(function (InteractBehavior) {
    /**
     * 无
     */
    InteractBehavior[InteractBehavior["NONE"] = 0] = "NONE";
    /**
     * 通知
     */
    InteractBehavior[InteractBehavior["NOTIFY"] = 1] = "NOTIFY";
    /**
     * 重置播放器
     */
    InteractBehavior[InteractBehavior["RESUME_PLAYER"] = 2] = "RESUME_PLAYER";
    /**
     * 清除元素
     */
    InteractBehavior[InteractBehavior["REMOVE"] = 3] = "REMOVE";
    /**
     * 暂停播放器
     */
    InteractBehavior[InteractBehavior["PAUSE"] = 4] = "PAUSE";
})(InteractBehavior$2 || (InteractBehavior$2 = {}));
/**
 * 元素类型
 */
var ItemType$1;
(function (ItemType) {
    /**
     * 错误元素
     */
    ItemType["base"] = "0";
    /**
     * 图层元素
     */
    ItemType["sprite"] = "1";
    /**
     * 粒子元素
     */
    ItemType["particle"] = "2";
    /**
     * 空节点元素
     */
    ItemType["null"] = "3";
    /**
     * 交互元素
     */
    ItemType["interact"] = "4";
    /**
     * 插件元素
     */
    ItemType["plugin"] = "5";
    /**
     * 相机元素
     */
    ItemType["camera"] = "6";
    /**
     * 预合成元素
     */
    ItemType["composition"] = "7";
    /**
     * 滤镜图层
     */
    ItemType["filter"] = "8";
    /**
     * Spine 元素
     */
    ItemType["spine"] = "spine";
    /**
     * Mesh 元素
     */
    ItemType["mesh"] = "mesh";
    /**
     * 节点树元素
     */
    ItemType["tree"] = "tree";
    /**
     * 文本元素
     */
    ItemType["text"] = "text";
    /**
     * 灯光元素
     */
    ItemType["light"] = "light";
    /**
     * 天空盒元素
     */
    ItemType["skybox"] = "skybox";
})(ItemType$1 || (ItemType$1 = {}));
/**
 * 渲染模式
 */
var RenderMode$1;
(function (RenderMode) {
    /**
     * 广告牌模式
     */
    RenderMode[RenderMode["BILLBOARD"] = 0] = "BILLBOARD";
    /**
     * 网格模式
     */
    RenderMode[RenderMode["MESH"] = 1] = "MESH";
    /**
     * 垂直广告牌模式
     */
    RenderMode[RenderMode["VERTICAL_BILLBOARD"] = 2] = "VERTICAL_BILLBOARD";
    /**
     * 水平广告牌模式
     */
    RenderMode[RenderMode["HORIZONTAL_BILLBOARD"] = 3] = "HORIZONTAL_BILLBOARD";
})(RenderMode$1 || (RenderMode$1 = {}));
/**
 * 变换中心
 */
var ParticleOrigin$1;
(function (ParticleOrigin) {
    /**
     * 水平和垂直中点
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER"] = 0] = "PARTICLE_ORIGIN_CENTER";
    /**
     * 水平左侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_TOP"] = 1] = "PARTICLE_ORIGIN_LEFT_TOP";
    /**
     * 水平左侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_CENTER"] = 2] = "PARTICLE_ORIGIN_LEFT_CENTER";
    /**
     * 水平左侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_BOTTOM"] = 3] = "PARTICLE_ORIGIN_LEFT_BOTTOM";
    /**
     * 水平中间 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_TOP"] = 4] = "PARTICLE_ORIGIN_CENTER_TOP";
    /**
     * 水平中间 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_BOTTOM"] = 5] = "PARTICLE_ORIGIN_CENTER_BOTTOM";
    /**
     * 水平右侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_TOP"] = 6] = "PARTICLE_ORIGIN_RIGHT_TOP";
    /**
     * 水平右侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_CENTER"] = 7] = "PARTICLE_ORIGIN_RIGHT_CENTER";
    /**
     * 水平右侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_BOTTOM"] = 8] = "PARTICLE_ORIGIN_RIGHT_BOTTOM";
})(ParticleOrigin$1 || (ParticleOrigin$1 = {}));

var END_BEHAVIOR_DESTROY$1 = 0;
var END_BEHAVIOR_PAUSE$1 = 1;
var END_BEHAVIOR_FORWARD$1 = 2;
var END_BEHAVIOR_PAUSE_AND_DESTROY$1 = 3;
var END_BEHAVIOR_FREEZE$1 = 4;
var END_BEHAVIOR_RESTART$1 = 5;
var END_BEHAVIOR_DESTROY_CHILDREN$1 = 6;
var CAMERA_CLIP_MODE_VERTICAL$1 = 1;
var CAMERA_CLIP_MODE_NORMAL$1 = 0;
var MESSAGE_ITEM_PHRASE_BEGIN = 2;
var MESSAGE_ITEM_PHRASE_END = 1;

var CameraClipMode$1;
(function (CameraClipMode) {
    /**
     * 剪裁上下
     */
    CameraClipMode[CameraClipMode["portrait"] = CAMERA_CLIP_MODE_VERTICAL$1] = "portrait";
    /**
     * 剪裁左右
     */
    CameraClipMode[CameraClipMode["landscape"] = CAMERA_CLIP_MODE_NORMAL$1] = "landscape";
})(CameraClipMode$1 || (CameraClipMode$1 = {}));
/**
 * 结束行为
 */
var CompositionEndBehavior$1;
(function (CompositionEndBehavior) {
    /**
     * 销毁
     */
    CompositionEndBehavior[CompositionEndBehavior["destroy"] = END_BEHAVIOR_DESTROY$1] = "destroy";
    /**
     * 暂停
     */
    CompositionEndBehavior[CompositionEndBehavior["pause"] = END_BEHAVIOR_PAUSE$1] = "pause";
    /**
     * 重播
     */
    CompositionEndBehavior[CompositionEndBehavior["restart"] = END_BEHAVIOR_RESTART$1] = "restart";
    /**
     * 无限播放
     */
    CompositionEndBehavior[CompositionEndBehavior["forward"] = END_BEHAVIOR_FORWARD$1] = "forward";
    /**
     * 销毁并保留最后一帧
     */
    CompositionEndBehavior[CompositionEndBehavior["pause_destroy"] = END_BEHAVIOR_PAUSE_AND_DESTROY$1] = "pause_destroy";
})(CompositionEndBehavior$1 || (CompositionEndBehavior$1 = {}));

/**
 * 动态换图类型
 * @since 1.3.0
 */
var BackgroundType$1;
(function (BackgroundType) {
    BackgroundType["video"] = "video";
    BackgroundType["image"] = "image";
})(BackgroundType$1 || (BackgroundType$1 = {}));

/*********************************************/
/*               基本数值属性参数              */
/*********************************************/
var ValueType$1;
(function (ValueType) {
    /**
     * 常数
     */
    ValueType[ValueType["CONSTANT"] = 0] = "CONSTANT";
    /**
     * 二维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC2"] = 1] = "CONSTANT_VEC2";
    /**
     * 三维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC3"] = 2] = "CONSTANT_VEC3";
    /**
     * 四维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC4"] = 3] = "CONSTANT_VEC4";
    /**
     * 随机数
     */
    ValueType[ValueType["RANDOM"] = 4] = "RANDOM";
    /**
     * 直线
     */
    ValueType[ValueType["LINE"] = 5] = "LINE";
    /**
     * 曲线
     */
    ValueType[ValueType["CURVE"] = 6] = "CURVE";
    /**
     * 贝塞尔路径
     */
    ValueType[ValueType["BEZIER_PATH"] = 7] = "BEZIER_PATH";
    /**
     * 颜色
     */
    ValueType[ValueType["RGBA_COLOR"] = 8] = "RGBA_COLOR";
    /**
     * 渐变色
     */
    ValueType[ValueType["GRADIENT_COLOR"] = 9] = "GRADIENT_COLOR";
    /**
     * 蒙版形状点集
     */
    ValueType[ValueType["SHAPE_POINTS"] = 10] = "SHAPE_POINTS";
    /**
     * 蒙版形状切分
     */
    ValueType[ValueType["SHAPE_SPLITS"] = 11] = "SHAPE_SPLITS";
    /**
     *直线路径
     */
    ValueType[ValueType["LINEAR_PATH"] = 12] = "LINEAR_PATH";
    /**
     * 多色
     */
    ValueType[ValueType["COLORS"] = 13] = "COLORS";
    /**
     * 二进制指针
     */
    ValueType[ValueType["BINARY"] = 20] = "BINARY";
    /**
     * 贝塞尔曲线
     */
    ValueType[ValueType["BEZIER_CURVE"] = 21] = "BEZIER_CURVE";
    /**
     * 贝塞尔曲线路径
     */
    ValueType[ValueType["BEZIER_CURVE_PATH"] = 22] = "BEZIER_CURVE_PATH";
})(ValueType$1 || (ValueType$1 = {}));
/**
 * 关键帧类型
 */
var BezierKeyframeType$1;
(function (BezierKeyframeType) {
    BezierKeyframeType[BezierKeyframeType["AUTO"] = 0] = "AUTO";
    BezierKeyframeType[BezierKeyframeType["EASE"] = 1] = "EASE";
    BezierKeyframeType[BezierKeyframeType["EASE_IN"] = 2] = "EASE_IN";
    BezierKeyframeType[BezierKeyframeType["EASE_OUT"] = 3] = "EASE_OUT";
    BezierKeyframeType[BezierKeyframeType["LINE"] = 4] = "LINE";
    BezierKeyframeType[BezierKeyframeType["HOLD"] = 5] = "HOLD";
    BezierKeyframeType[BezierKeyframeType["LINE_OUT"] = 6] = "LINE_OUT";
})(BezierKeyframeType$1 || (BezierKeyframeType$1 = {}));

var ItemEndBehavior$1;
(function (ItemEndBehavior) {
    ItemEndBehavior[ItemEndBehavior["destroy"] = END_BEHAVIOR_DESTROY$1] = "destroy";
    ItemEndBehavior[ItemEndBehavior["loop"] = END_BEHAVIOR_RESTART$1] = "loop";
    ItemEndBehavior[ItemEndBehavior["freeze"] = END_BEHAVIOR_FREEZE$1] = "freeze";
})(ItemEndBehavior$1 || (ItemEndBehavior$1 = {}));
var ParentItemEndBehavior$1;
(function (ParentItemEndBehavior) {
    ParentItemEndBehavior[ParentItemEndBehavior["destroyChildren"] = END_BEHAVIOR_DESTROY_CHILDREN$1] = "destroyChildren";
})(ParentItemEndBehavior$1 || (ParentItemEndBehavior$1 = {}));

/**
 * 粒子交互行为
 */
var ParticleInteractionBehavior$1;
(function (ParticleInteractionBehavior) {
    /**
     * 无
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["none"] = 0] = "none";
    /**
     * 移出粒子
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["removeParticle"] = 1] = "removeParticle";
})(ParticleInteractionBehavior$1 || (ParticleInteractionBehavior$1 = {}));

var ShapeArcMode$1;
(function (ShapeArcMode) {
    /**
     * 随机
     */
    ShapeArcMode[ShapeArcMode["RANDOM"] = 0] = "RANDOM";
    /**
     * 单向循环
     */
    ShapeArcMode[ShapeArcMode["UNIDIRECTIONAL_CYCLE"] = 1] = "UNIDIRECTIONAL_CYCLE";
    /**
     * 双向循环
     */
    ShapeArcMode[ShapeArcMode["BIDIRECTIONAL_CYCLE"] = 2] = "BIDIRECTIONAL_CYCLE";
    /**
     * 均匀爆发
     */
    ShapeArcMode[ShapeArcMode["UNIFORM_BURST"] = 3] = "UNIFORM_BURST";
})(ShapeArcMode$1 || (ShapeArcMode$1 = {}));

var BloomFilterThresholdAvgColor = 0;

var ModelBoundingType$1;
(function (ModelBoundingType) {
    ModelBoundingType[ModelBoundingType["box"] = 2] = "box";
    ModelBoundingType[ModelBoundingType["sphere"] = 3] = "sphere";
})(ModelBoundingType$1 || (ModelBoundingType$1 = {}));

// 材质类型
var MaterialType$1;
(function (MaterialType) {
    MaterialType["unlit"] = "unlit";
    MaterialType["pbr"] = "pbr";
    // 头发材质，在 pbr 材质基础上扩展
    MaterialType["hair"] = "hair";
})(MaterialType$1 || (MaterialType$1 = {}));
// 混合模式
var MaterialBlending$1;
(function (MaterialBlending) {
    MaterialBlending[MaterialBlending["opaque"] = 100] = "opaque";
    MaterialBlending[MaterialBlending["masked"] = 101] = "masked";
    MaterialBlending[MaterialBlending["translucent"] = 102] = "translucent";
    MaterialBlending[MaterialBlending["additive"] = 103] = "additive";
})(MaterialBlending$1 || (MaterialBlending$1 = {}));

/**
 * 3D渲染模式：将渲染过程中的中间结果输出，主要用于排查渲染效果问题，支持 pbr 和 unlit 材质
 */
var RenderMode3D$1;
(function (RenderMode3D) {
    /**
     * 正常渲染
     */
    RenderMode3D["none"] = "none";
    /**
     * 纹理坐标
     */
    RenderMode3D["uv"] = "uv";
    /**
     * 世界坐标法线
     */
    RenderMode3D["normal"] = "normal";
    /**
     * 基础颜色
     */
    RenderMode3D["basecolor"] = "basecolor";
    /**
     * 基础颜色 Alpha
     */
    RenderMode3D["alpha"] = "alpha";
    /**
     * 金属度
     */
    RenderMode3D["metallic"] = "metallic";
    /**
     * 粗超度
     */
    RenderMode3D["roughness"] = "roughness";
    /**
     * 环境遮蔽
     */
    RenderMode3D["ao"] = "ao";
    /**
     * 自发光
     */
    RenderMode3D["emissive"] = "emissive";
})(RenderMode3D$1 || (RenderMode3D$1 = {}));

var TextOverflow$1;
(function (TextOverflow) {
    /**
     * display 模式下，会显示所有文本，存在文本超过边界框的情况。
     */
    TextOverflow[TextOverflow["display"] = 0] = "display";
    /**
     * clip 模式下，当文本内容超出边界框时，多余的会被截断。
     */
    TextOverflow[TextOverflow["clip"] = 1] = "clip";
    /**
     * ellipsis 模式下，会使用（...）来代替超出边界框的内容。
     */
    TextOverflow[TextOverflow["ellipsis"] = 2] = "ellipsis";
})(TextOverflow$1 || (TextOverflow$1 = {}));
var TextBaseline$1;
(function (TextBaseline) {
    /**
     * 文本顶对齐。
     */
    TextBaseline[TextBaseline["top"] = 0] = "top";
    /**
     * 文本垂直居中对齐。
     */
    TextBaseline[TextBaseline["middle"] = 1] = "middle";
    /**
     * 文本底对齐。
     */
    TextBaseline[TextBaseline["bottom"] = 2] = "bottom";
})(TextBaseline$1 || (TextBaseline$1 = {}));
var TextAlignment$1;
(function (TextAlignment) {
    /**
     * text alignment starts from（x,y) to right direction
     * 从(x,y)开始第一个字符，向右边延伸
     */
    TextAlignment[TextAlignment["left"] = 0] = "left";
    /**
     * (x,y) is middle position of text, where (left + right)/2 =(x,y)
     * (x,y) 为文字中间位置，（最左位置 + 最右位置)/2 = (x,y)
     */
    TextAlignment[TextAlignment["middle"] = 1] = "middle";
    /**
     * text alignment ends with（x,y) from left direction
     * 从(x,y)结束最后一个字符，向左边延伸
     */
    TextAlignment[TextAlignment["right"] = 2] = "right";
})(TextAlignment$1 || (TextAlignment$1 = {}));
/**
 * 文本字重
 */
var TextWeight$1;
(function (TextWeight) {
    /**
     * 正常
     */
    TextWeight["normal"] = "normal";
    /**
     * 粗体
     */
    TextWeight["bold"] = "bold";
    /**
     * 瘦体
     */
    TextWeight["lighter"] = "lighter";
})(TextWeight$1 || (TextWeight$1 = {}));
/**
 * 文本样式
 */
var FontStyle$1;
(function (FontStyle) {
    /**
     * 正常
     */
    FontStyle["normal"] = "normal";
    /**
     * 斜体
     */
    FontStyle["italic"] = "italic";
    /**
     * 倾斜体
     */
    FontStyle["oblique"] = "oblique";
})(FontStyle$1 || (FontStyle$1 = {}));

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get BackgroundType () { return BackgroundType$1; },
    get BezierKeyframeType () { return BezierKeyframeType$1; },
    get BlendingMode () { return BlendingMode$1; },
    BloomFilterThresholdAvgColor: BloomFilterThresholdAvgColor,
    CAMERA_CLIP_MODE_NORMAL: CAMERA_CLIP_MODE_NORMAL$1,
    CAMERA_CLIP_MODE_VERTICAL: CAMERA_CLIP_MODE_VERTICAL$1,
    get CameraClipMode () { return CameraClipMode$1; },
    get CompositionEndBehavior () { return CompositionEndBehavior$1; },
    END_BEHAVIOR_DESTROY: END_BEHAVIOR_DESTROY$1,
    END_BEHAVIOR_DESTROY_CHILDREN: END_BEHAVIOR_DESTROY_CHILDREN$1,
    END_BEHAVIOR_FORWARD: END_BEHAVIOR_FORWARD$1,
    END_BEHAVIOR_FREEZE: END_BEHAVIOR_FREEZE$1,
    END_BEHAVIOR_PAUSE: END_BEHAVIOR_PAUSE$1,
    END_BEHAVIOR_PAUSE_AND_DESTROY: END_BEHAVIOR_PAUSE_AND_DESTROY$1,
    END_BEHAVIOR_RESTART: END_BEHAVIOR_RESTART$1,
    get FontStyle () { return FontStyle$1; },
    get InteractBehavior () { return InteractBehavior$2; },
    get InteractType () { return InteractType$1; },
    get ItemEndBehavior () { return ItemEndBehavior$1; },
    get ItemType () { return ItemType$1; },
    MESSAGE_ITEM_PHRASE_BEGIN: MESSAGE_ITEM_PHRASE_BEGIN,
    MESSAGE_ITEM_PHRASE_END: MESSAGE_ITEM_PHRASE_END,
    get MaskMode () { return MaskMode$1; },
    get MaterialBlending () { return MaterialBlending$1; },
    get MaterialType () { return MaterialType$1; },
    get ModelBoundingType () { return ModelBoundingType$1; },
    get ParentItemEndBehavior () { return ParentItemEndBehavior$1; },
    get ParticleInteractionBehavior () { return ParticleInteractionBehavior$1; },
    get ParticleOrigin () { return ParticleOrigin$1; },
    get PluginType () { return PluginType$1; },
    get RenderLevel () { return RenderLevel$1; },
    get RenderMode () { return RenderMode$1; },
    get RenderMode3D () { return RenderMode3D$1; },
    get ShapeArcMode () { return ShapeArcMode$1; },
    get ShapeType () { return ShapeType$1; },
    get SideMode () { return SideMode$1; },
    get TextAlignment () { return TextAlignment$1; },
    get TextBaseline () { return TextBaseline$1; },
    get TextOverflow () { return TextOverflow$1; },
    get TextWeight () { return TextWeight$1; },
    get ValueType () { return ValueType$1; }
});

var PI2 = Math.PI * 2;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
var NumberEpsilon = 1e-6;
function isZero(v) {
    return isNaN(v) || Math.abs(v) < NumberEpsilon;
}
function isEqual(a, b) {
    return Math.abs(a - b) < NumberEpsilon || (a === Infinity && b === Infinity) || (a === -Infinity && b === -Infinity);
}
// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
var damp = function (x, y, lambda, dt) { return lerp(x, y, 1 - Math.exp(-lambda * dt)); };
// https://en.wikipedia.org/wiki/Linear_interpolation
var lerp = function (x, y, t) { return (1 - t) * x + t * y; };
var degToRad = function (degrees) { return degrees * DEG2RAD; };
var radToDeg = function (radians) { return radians * RAD2DEG; };
function clamp$1(value, min, max) {
    var fixedMin = isNaN(min) ? -Infinity : min;
    var fixedMax = isNaN(max) ? Infinity : max;
    var lower = Math.min(fixedMin, fixedMax);
    var upper = Math.max(fixedMin, fixedMax);
    return Math.min(Math.max(value, lower), upper);
}

/**
 * 二维向量
 */
var Vector2 = /** @class */ (function () {
    /**
     * 构造函数，默认为零向量
     * @param [x=0] - x 分量
     * @param [y=0] - y 分量
     */
    function Vector2(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @returns
     */
    Vector2.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */
    Vector2.prototype.setZero = function () {
        this.x = 0;
        this.y = 0;
        return this;
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */
    Vector2.prototype.setFromNumber = function (num) {
        this.x = num;
        this.y = num;
        return this;
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector2.prototype.setFromArray = function (array, offset) {
        var _a, _b;
        if (offset === void 0) { offset = 0; }
        this.x = (_a = array[offset]) !== null && _a !== void 0 ? _a : 0;
        this.y = (_b = array[offset + 1]) !== null && _b !== void 0 ? _b : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param src - 要拷贝的对象
     * @returns 向量
     */
    Vector2.prototype.copyFrom = function (src) {
        this.x = src.x;
        this.y = src.y;
        return this;
    };
    /**
     * 克隆向量
     * @returns 克隆结果
     */
    Vector2.prototype.clone = function () {
        return new Vector2(this.x, this.y);
    };
    /**
     * 根据下标设置元素值
     * @param index - 下标值
     * @param value - 数字
     * @returns 向量
     */
    Vector2.prototype.setElement = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default: console.error('index is out of range: ' + index);
        }
        return this;
    };
    /**
     * 根据下标获取值
     * @param index - 下标
     * @returns 值
     */
    Vector2.prototype.getElement = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            default: console.error('index is out of range: ' + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 向量 | 数字
     * @returns 向量
     */
    Vector2.prototype.add = function (right) {
        if (typeof right === 'number') {
            this.x += right;
            this.y += right;
        }
        else if (right instanceof Array) {
            this.x += right[0];
            this.y += right[1];
        }
        else {
            this.x += right.x;
            this.y += right.y;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 相加结果
     */
    Vector2.prototype.addVectors = function (left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        return this;
    };
    /**
     * 向量相减
     * @param right - 向量 |  数字
     * @returns 相减结果
     */
    Vector2.prototype.subtract = function (right) {
        if (typeof right === 'number') {
            this.x -= right;
            this.y -= right;
        }
        else if (right instanceof Array) {
            this.x -= right[0];
            this.y -= right[1];
        }
        else {
            this.x -= right.x;
            this.y -= right.y;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 相减结果
     */
    Vector2.prototype.subtractVectors = function (left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 向量 | 数字
     * @returns 相乘结果
     */
    Vector2.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            this.x *= right;
            this.y *= right;
        }
        else if (right instanceof Array) {
            this.x *= right[0];
            this.y *= right[1];
        }
        else {
            this.x *= right.x;
            this.y *= right.y;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 相乘结果
     */
    Vector2.prototype.multiplyVectors = function (left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        return this;
    };
    /**
     * 向量相除
     * @param right - 向量 | 数字
     * @returns 相除结果
     */
    Vector2.prototype.divide = function (right) {
        if (typeof right === 'number') {
            this.x /= right;
            this.y /= right;
        }
        else if (right instanceof Array) {
            this.x /= right[0];
            this.y /= right[1];
        }
        else {
            this.x /= right.x;
            this.y /= right.y;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */
    Vector2.prototype.scale = function (v) {
        this.x *= v;
        this.y *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */
    Vector2.prototype.sum = function () {
        return this.x + this.y;
    };
    /**
     * 向量求最小值
     * @param v - 向量
     * @returns 最小值
     */
    Vector2.prototype.min = function (v) {
        if (typeof v === 'number') {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
        }
        else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量
     * @returns 最大值
     */
    Vector2.prototype.max = function (v) {
        if (typeof v === 'number') {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
        }
        else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 极小值
     * @param max - 极大值
     * @returns 向量
     */
    Vector2.prototype.clamp = function (min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */
    Vector2.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */
    Vector2.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    };
    /**
     * 向量取四舍五入
     * @returns 四舍五入结果
     */
    Vector2.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */
    Vector2.prototype.abs = function () {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        return this;
    };
    /**
     * 向量取反
     * @returns 取反结果
     */
    Vector2.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    };
    /**
     * 向量长度
     * @returns 求值结果
     */
    Vector2.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    /**
     * 向量长度平方
     * @returns 求值结果
     */
    Vector2.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y;
    };
    /**
     * 向量归一化
     * @returns 归一化结果
     */
    Vector2.prototype.normalize = function () {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */
    Vector2.prototype.setLength = function (length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量线性插值
     * @param other - 向量
     * @param alpha - 插值比
     * @returns 计算结果
     */
    Vector2.prototype.lerp = function (other, alpha) {
        this.x += (other.x - this.x) * alpha;
        this.y += (other.y - this.y) * alpha;
        return this;
    };
    /**
     * 向量线性插值
     * @param v1 - 向量
     * @param v2 - 向量
     * @param alpha - 插值比
     * @returns 计算结果
     */
    Vector2.prototype.lerpVectors = function (v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    };
    /**
     * 向量点乘
     * @param v - 向量
     * @returns 点乘结果
     */
    Vector2.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y;
    };
    /**
     * 向量叉乘
     * @param v - 向量
     * @returns 叉乘结果
     */
    Vector2.prototype.cross = function (v) {
        return this.x * v.y - this.y * v.x;
    };
    /**
     * 点距离
     * @param v - 点
     * @returns 距离
     */
    Vector2.prototype.distance = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * 点距离平方
     * @param v - 点
     * @returns 距离平方
     */
    Vector2.prototype.distanceSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */
    Vector2.prototype.equals = function (v) {
        return this.x === v.x && this.y === v.y;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */
    Vector2.prototype.isZero = function () {
        var _a;
        var eps = NumberEpsilon;
        var x = (_a = this, _a.x), y = _a.y;
        return Math.abs(x) <= eps && Math.abs(y) <= eps;
    };
    /**
     * 向量转数组
     * @returns 数组
     */
    Vector2.prototype.toArray = function () {
        return [this.x, this.y];
    };
    Vector2.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
    };
    /**
     * 随机生成向量
     * @returns 向量
     */
    Vector2.prototype.random = function () {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    };
    /**
     * 通过标量创建向量
     * @param num - 数值
     * @returns 向量
     */
    Vector2.fromNumber = function (num) {
        return new Vector2().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector2.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Vector2().setFromArray(array, offset);
    };
    /**
     * 二维向量的常量
     */
    Vector2.ONE = new Vector2(1.0, 1.0);
    Vector2.ZERO = new Vector2(0.0, 0.0);
    return Vector2;
}());

/**
 * 三维向量
 */
var Vector3 = /** @class */ (function () {
    /**
     * 构造函数，默认值为零向量
     * @param [x=0]
     * @param [y=0]
     * @param [z=0]
     */
    function Vector3(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
    }
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @param z - z 轴分量
     * @returns 向量
     */
    Vector3.prototype.set = function (x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */
    Vector3.prototype.setZero = function () {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        return this;
    };
    /**
     * 通过标量数值设置向量
     * @param num - 数值
     * @returns 向量
     */
    Vector3.prototype.setFromNumber = function (num) {
        this.x = num;
        this.y = num;
        this.z = num;
        return this;
    };
    /**
     * 通过数组设置向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector3.prototype.setFromArray = function (array, offset) {
        var _a, _b, _c;
        if (offset === void 0) { offset = 0; }
        this.x = (_a = array[offset]) !== null && _a !== void 0 ? _a : 0;
        this.y = (_b = array[offset + 1]) !== null && _b !== void 0 ? _b : 0;
        this.z = (_c = array[offset + 2]) !== null && _c !== void 0 ? _c : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param v - 要拷贝的对象
     * @returns 向量
     */
    Vector3.prototype.copyFrom = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    /**
     * 克隆向量
     * @returns 向量
     */
    Vector3.prototype.clone = function () {
        return new Vector3(this.x, this.y, this.z);
    };
    /**
     * 根据下标设置向量分量
     * @param index - 下标值
     * @param value - 数字
     * @returns 向量
     */
    Vector3.prototype.setElement = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default: console.error('index is out of range: ' + index);
        }
        return this;
    };
    /**
     * 根据下标获取向量分量
     * @param index - 下标
     * @returns
     */
    Vector3.prototype.getElement = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            default: console.error('index is out of range: ' + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 向量 | 数字
     * @returns 相加结果
     */
    Vector3.prototype.add = function (right) {
        if (typeof right === 'number') {
            this.x += right;
            this.y += right;
            this.z += right;
        }
        else if (right instanceof Array) {
            this.x += right[0];
            this.y += right[1];
            this.z += right[2];
        }
        else {
            this.x += right.x;
            this.y += right.y;
            this.z += right.z;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 相加结果
     */
    Vector3.prototype.addVectors = function (left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        return this;
    };
    /**
     * 向量乘比例后相加
     * @param right - 向量
     * @param s - 比例
     * @returns 相加结果
     */
    Vector3.prototype.addScaledVector = function (right, s) {
        this.x += right.x * s;
        this.y += right.y * s;
        this.z += right.z * s;
        return this;
    };
    /**
     * 向量相减
     * @param right - 向量 | 数字
     * @returns 相减
     */
    Vector3.prototype.subtract = function (right) {
        if (typeof right === 'number') {
            this.x -= right;
            this.y -= right;
            this.z -= right;
        }
        else if (right instanceof Array) {
            this.x -= right[0];
            this.y -= right[1];
            this.z -= right[2];
        }
        else {
            this.x -= right.x;
            this.y -= right.y;
            this.z -= right.z;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 相减结果
     */
    Vector3.prototype.subtractVectors = function (left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        this.z = left.z - right.z;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 向量 | 数字
     * @returns 相乘结果
     */
    Vector3.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            this.x *= right;
            this.y *= right;
            this.z *= right;
        }
        else if (right instanceof Array) {
            this.x *= right[0];
            this.y *= right[1];
            this.z *= right[2];
        }
        else {
            this.x *= right.x;
            this.y *= right.y;
            this.z *= right.z;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 相乘结果
     */
    Vector3.prototype.multiplyVectors = function (left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        this.z = left.z * right.z;
        return this;
    };
    /**
     * 向量相除
     * @param right - 向量 | 数字
     * @returns 相除结果
     */
    Vector3.prototype.divide = function (right) {
        if (typeof right === 'number') {
            this.x /= right;
            this.y /= right;
            this.z /= right;
        }
        else if (right instanceof Array) {
            this.x /= right[0];
            this.y /= right[1];
            this.z /= right[2];
        }
        else {
            this.x /= right.x;
            this.y /= right.y;
            this.z /= right.z;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */
    Vector3.prototype.scale = function (v) {
        this.x *= v;
        this.y *= v;
        this.z *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */
    Vector3.prototype.sum = function () {
        return this.x + this.y + this.z;
    };
    /**
     * 向量求最小值
     * @param v - 向量或数值
     * @returns 求值结果
     */
    Vector3.prototype.min = function (v) {
        if (typeof v === 'number') {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
            this.z = Math.min(this.z, v);
        }
        else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量或数值
     * @returns 求值结果
     */
    Vector3.prototype.max = function (v) {
        if (typeof v === 'number') {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
            this.z = Math.max(this.z, v);
        }
        else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 向量
     * @param max - 向量
     * @returns 求值结果
     */
    Vector3.prototype.clamp = function (min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */
    Vector3.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */
    Vector3.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    };
    /**
     * 向量四舍五入
     * @returns 计算结果
     */
    Vector3.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */
    Vector3.prototype.abs = function () {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        this.z = Math.abs(this.z);
        return this;
    };
    /**
     * 向量取反
     * @returns 向量
     */
    Vector3.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 向量长度
     * @returns 长度
     */
    Vector3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    /**
     * 向量长度平方
     * @returns 长度平方
     */
    Vector3.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    /**
     * 向量归一化
     * @returns 向量
     */
    Vector3.prototype.normalize = function () {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */
    Vector3.prototype.setLength = function (length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量间求线性插值
     * @param other - 向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */
    Vector3.prototype.lerp = function (other, alpha) {
        this.x += (other.x - this.x) * alpha;
        this.y += (other.y - this.y) * alpha;
        this.z += (other.z - this.z) * alpha;
        return this;
    };
    /**
     * 向量间求线性插值
     * @param v1 - 第一个向量
     * @param v2 - 第二个向量
     * @param alpha - 插值比例
     * @returns 求值结果
     */
    Vector3.prototype.lerpVectors = function (v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    };
    /**
     * 向量求点积，点积为零表示两向量垂直
     * @param v - 向量
     * @returns 点积结果
     */
    Vector3.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    };
    /**
     * 向量求叉积
     * @param right - 向量
     * @returns 叉积结果
     */
    Vector3.prototype.cross = function (right) {
        return this.crossVectors(this, right);
    };
    /**
     * 向量（a 与 b）求叉积
     * @param left - 向量
     * @param right - 向量
     * @returns 叉积结果
     */
    Vector3.prototype.crossVectors = function (left, right) {
        var ax = left.x, ay = left.y, az = left.z;
        var bx = right.x, by = right.y, bz = right.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    };
    /**
     * 向量反射
     * @param normal - 法线
     * @returns 反射结果
     */
    Vector3.prototype.reflect = function (normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.subtract(normal.clone().multiply(2 * this.dot(normal)));
    };
    /**
     * 计算向量距离
     * @param v - 向量
     * @returns 距离
     */
    Vector3.prototype.distance = function (v) {
        return Math.sqrt(this.distanceSquared(v));
    };
    /**
     * 计算向量距离平方
     * @param v - 向量
     * @returns 距离平方
     */
    Vector3.prototype.distanceSquared = function (v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */
    Vector3.prototype.equals = function (v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */
    Vector3.prototype.isZero = function () {
        var _a;
        var eps = NumberEpsilon;
        var x = (_a = this, _a.x), y = _a.y, z = _a.z;
        return Math.abs(x) <= eps && Math.abs(y) <= eps && Math.abs(z) <= eps;
    };
    /**
     * 向量转数组
     * @param array - 目标保存对象
     * @returns 数组
     */
    Vector3.prototype.toArray = function () {
        return [this.x, this.y, this.z];
    };
    Vector3.prototype.toVector2 = function () {
        return new Vector2(this.x, this.y);
    };
    Vector3.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
    };
    /**
     * 获取随机向量
     * @returns
     */
    Vector3.prototype.random = function () {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    };
    /**
     * 用欧拉角旋转向量
     * @param euler - 欧拉角
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 旋转结果
     */
    Vector3.prototype.applyEuler = function (euler, out) {
        return euler.rotateVector3(this, out);
    };
    /**
     * 用四元数旋转向量
     * @param q - 四元数
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 旋转结果
     */
    Vector3.prototype.applyQuaternion = function (q, out) {
        return q.rotateVector3(this, out);
    };
    /**
     * 用矩阵变换点
     * @param m - 变换矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 结果点
     */
    Vector3.prototype.applyMatrix = function (m, out) {
        return m.transformPoint(this, out);
    };
    /**
     * 用法向量矩阵变换法向量
     * @param m - 法向量矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 向量
     */
    Vector3.prototype.applyNormalMatrix = function (m, out) {
        return m.transformNormal(this, out);
    };
    /**
     * 用投影矩阵变换点
     * @param m - 投影矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 结果点
     */
    Vector3.prototype.applyProjectionMatrix = function (m, out) {
        return m.projectPoint(this, out);
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */
    Vector3.fromNumber = function (num) {
        return new Vector3().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector3.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Vector3().setFromArray(array, offset);
    };
    /**
     * 三维向量的常量
     */
    Vector3.X = new Vector3(1.0, 0.0, 0.0);
    Vector3.Y = new Vector3(0.0, 1.0, 0.0);
    Vector3.Z = new Vector3(0.0, 0.0, 1.0);
    Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
    Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
    return Vector3;
}());

/**
 * 四元数
 */
var Quaternion = /** @class */ (function () {
    /**
     * 构造函数
     * @param [x=0] - x 分量
     * @param [y=0] - y 分量
     * @param [z=0] - z 分量
     * @param [w=1] - w 分量
     */
    function Quaternion(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    /**
     * 四元数设置
     * @param x - x 分量
     * @param y - y 分量
     * @param z - z 分量
     * @param w - w 分量
     * @returns 四元数
     */
    Quaternion.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    /**
     * 通过欧拉角设置四元数
     * @param euler - 欧拉角
     * @returns
     */
    Quaternion.prototype.setFromEuler = function (euler) {
        euler.toQuaternion(this);
        return this;
    };
    /**
     * 通过旋转轴和旋转角度设置四元数
     * @param axis - 旋转轴
     * @param angle - 旋转角度（弧度）
     * @returns
     */
    Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
        var halfAngle = angle / 2;
        var s = Math.sin(halfAngle);
        var v = Quaternion.tempVec0;
        v.copyFrom(axis).normalize();
        this.x = v.x * s;
        this.y = v.y * s;
        this.z = v.z * s;
        this.w = Math.cos(halfAngle);
        return this;
    };
    /**
     * 通过数组设置四元数
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */
    Quaternion.prototype.setFromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    };
    /**
     * 通过矩阵设置四元数
     * @param m - 矩阵
     * @returns
     */
    Quaternion.prototype.setFromRotationMatrix = function (m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;
        var m11 = te[0];
        var m12 = te[4];
        var m13 = te[8];
        var m21 = te[1];
        var m22 = te[5];
        var m23 = te[9];
        var m31 = te[2];
        var m32 = te[6];
        var m33 = te[10];
        var trace = m11 + m22 + m33;
        if (trace > 0) {
            var s = 0.5 / Math.sqrt(trace + 1.0);
            this.w = 0.25 / s;
            this.x = (m32 - m23) * s;
            this.y = (m13 - m31) * s;
            this.z = (m21 - m12) * s;
        }
        else if (m11 > m22 && m11 > m33) {
            var s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this.w = (m32 - m23) / s;
            this.x = 0.25 * s;
            this.y = (m12 + m21) / s;
            this.z = (m13 + m31) / s;
            this.negate();
        }
        else if (m22 > m33) {
            var s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this.w = (m13 - m31) / s;
            this.x = (m12 + m21) / s;
            this.y = 0.25 * s;
            this.z = (m23 + m32) / s;
            this.negate();
        }
        else {
            var s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this.w = (m21 - m12) / s;
            this.x = (m13 + m31) / s;
            this.y = (m23 + m32) / s;
            this.z = 0.25 * s;
            this.negate();
        }
        // 兼容原先数学库
        return this;
    };
    /**
     * 通过开始和结束向量设置四元数
     * @param from - 开始向量
     * @param to - 结束向量
     * @returns
     */
    Quaternion.prototype.setFromUnitVectors = function (from, to) {
        // assumes direction vectors vFrom and vTo are normalized
        var r = from.dot(to) + 1;
        if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(from.x) > Math.abs(from.z)) {
                this.x = -from.y;
                this.y = from.x;
                this.z = 0;
                this.w = r;
            }
            else {
                this.x = 0;
                this.y = -from.z;
                this.z = from.y;
                this.w = r;
            }
        }
        else {
            this.x = from.y * to.z - from.z * to.y;
            this.y = from.z * to.x - from.x * to.z;
            this.z = from.x * to.y - from.y * to.x;
            this.w = r;
        }
        return this.normalize();
    };
    /**
     * 四元数拷贝
     * @param quat - 拷贝目标四元数
     * @returns 拷贝四元数
     */
    Quaternion.prototype.copyFrom = function (quat) {
        this.x = quat.x;
        this.y = quat.y;
        this.z = quat.z;
        this.w = quat.w;
        return this;
    };
    /**
     * 四元数克隆
     * @returns 克隆结果
     */
    Quaternion.prototype.clone = function () {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };
    /**
     * 四元数间的夹角计算
     * @param other - 其他四元数
     * @returns 夹角
     */
    Quaternion.prototype.angleTo = function (other) {
        return 2 * Math.acos(Math.abs(clamp$1(this.dot(other), -1, 1)));
    };
    /**
     * 四元数向目标旋转
     * @param q - 四元数
     * @param step - 旋转弧度
     * @returns 目标四元数
     */
    Quaternion.prototype.rotateTowards = function (q, step) {
        var angle = this.angleTo(q);
        if (angle === 0) {
            return this;
        }
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    };
    /**
     * 四元数单位化
     * @returns 单位四元数
     */
    Quaternion.prototype.identity = function () {
        return this.set(0, 0, 0, 1);
    };
    /**
     * 四元数求逆
     * @returns 四元数的逆
     */
    Quaternion.prototype.invert = function () {
        return this.conjugate();
    };
    /**
     * 四元数取负
     * @returns 负四元数
     */
    Quaternion.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    };
    /**
     * 四元数求共轭值
     * @returns 四元数的共轭值
     */
    Quaternion.prototype.conjugate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 四元数点乘结果
     * @param v
     * @return
     */
    Quaternion.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    /**
     * 四元数的模平方
     * @return
     */
    Quaternion.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    /**
     * 四元数的欧式长度
     * @returns 长度
     */
    Quaternion.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    /**
     * 四元数归一化
     * @returns 归一化值
     */
    Quaternion.prototype.normalize = function () {
        var l = this.length();
        if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        else {
            l = 1 / l;
            this.x = this.x * l;
            this.y = this.y * l;
            this.z = this.z * l;
            this.w = this.w * l;
        }
        return this;
    };
    /**
     * 四元数右乘
     * @param right - 右乘的四元数
     * @returns
     */
    Quaternion.prototype.multiply = function (right) {
        return this.multiplyQuaternions(this, right);
    };
    /**
     * 四元数左乘
     * @param left - 左乘的四元数
     * @returns
     */
    Quaternion.prototype.premultiply = function (left) {
        return this.multiplyQuaternions(left, this);
    };
    /**
     * 四元数乘法
     * @param left - 四元数
     * @param right - 四元数
     * @returns 四元数
     */
    Quaternion.prototype.multiplyQuaternions = function (left, right) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = left.x;
        var qay = left.y;
        var qaz = left.z;
        var qaw = left.w;
        var qbx = right.x;
        var qby = right.y;
        var qbz = right.z;
        var qbw = right.w;
        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        return this;
    };
    /**
     * 四元数线性插值
     * @see http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
     * @param other - 四元数
     * @param t - 插值比
     * @returns 插值结果
     */
    Quaternion.prototype.slerp = function (other, t) {
        var _a;
        if (t === 0) {
            return this;
        }
        if (t === 1) {
            return this.copyFrom(other);
        }
        var x = (_a = this, _a.x), y = _a.y, z = _a.z, w = _a.w;
        var cosHalfTheta = w * other.w + x * other.x + y * other.y + z * other.z;
        if (cosHalfTheta < 0) {
            this.w = -other.w;
            this.x = -other.x;
            this.y = -other.y;
            this.z = -other.z;
            cosHalfTheta = -cosHalfTheta;
        }
        else {
            this.copyFrom(other);
        }
        if (cosHalfTheta >= 1.0) {
            this.w = w;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            var s = 1 - t;
            this.w = s * w + t * this.w;
            this.x = s * x + t * this.x;
            this.y = s * y + t * this.y;
            this.z = s * z + t * this.z;
            this.normalize();
            return this;
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
        var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this.w = (w * ratioA + this.w * ratioB);
        this.x = (x * ratioA + this.x * ratioB);
        this.y = (y * ratioA + this.y * ratioB);
        this.z = (z * ratioA + this.z * ratioB);
        return this;
    };
    /**
     * 两个四元数的线性插值
     * @param qa - 四元数
     * @param qb - 四元数
     * @param t - 插值比
     */
    Quaternion.prototype.slerpQuaternions = function (qa, qb, t) {
        this.copyFrom(qa).slerp(qb, t);
    };
    /**
     * 通过四元数旋转向量
     * @param v - 待旋转向量
     * @param [out] - 旋转结果，如果没有传入直接覆盖输入值
     * @returns
     */
    Quaternion.prototype.rotateVector3 = function (v, out) {
        var _a;
        var qx = (_a = this, _a.x), qy = _a.y, qz = _a.z, qw = _a.w;
        var vx = v.x, vy = v.y, vz = v.z;
        var ix = qw * vx + qy * vz - qz * vy;
        var iy = qw * vy + qz * vx - qx * vz;
        var iz = qw * vz + qx * vy - qy * vx;
        var iw = -qx * vx - qy * vy - qz * vz;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return res;
    };
    /**
     * 四元数判等
     * @param quaternion - 四元数
     * @returns 判等结果
     */
    Quaternion.prototype.equals = function (quaternion) {
        return quaternion.x === this.x
            && quaternion.y === this.y
            && quaternion.z === this.z
            && quaternion.w === this.w;
    };
    /**
     * 四元数保存为数组
     * @returns
     */
    Quaternion.prototype.toArray = function () {
        return [this.x, this.y, this.z, this.w];
    };
    /**
     * 四元数转四维向量数组
     * @param vec - 目标保存对象
     * @returns 保存结果
     */
    Quaternion.prototype.toVector4 = function (vec) {
        return vec.set(this.x, this.y, this.z, this.w);
    };
    /**
     * 四元数转欧拉角
     * @param euler - 目标欧拉角
     * @returns 欧拉角
     */
    Quaternion.prototype.toEuler = function (euler) {
        return euler.setFromQuaternion(this);
    };
    /**
     * 四元数转矩阵
     * @param mat - 目标矩阵
     * @returns
     */
    Quaternion.prototype.toMatrix4 = function (mat) {
        return mat.compose(Vector3.ZERO, this, Vector3.ONE);
    };
    /**
     * 通过欧拉角创建四元数
     * @param euler - 欧拉角
     * @returns 四元数
     */
    Quaternion.fromEuler = function (euler) {
        return new Quaternion().setFromEuler(euler);
    };
    /**
     * 通过旋转轴和旋转角度创建四元数
     * @param axis - 旋转轴
     * @param angle - 旋转角（弧度值）
     * @returns 四元数
     */
    Quaternion.fromAxisAngle = function (axis, angle) {
        return new Quaternion().setFromAxisAngle(axis, angle);
    };
    /**
     * 通过数组获取四元数
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 四元数
     */
    Quaternion.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Quaternion().setFromArray(array, offset);
    };
    /**
     * 通过旋转矩阵创建四元数
     * @param m - 旋转矩阵
     * @returns 四元数
     */
    Quaternion.fromRotationMatrix = function (m) {
        return new Quaternion().setFromRotationMatrix(m);
    };
    /**
     * 通过开始和结束向量创建四元数
     * @param from - 开始向量
     * @param to - 结束向量
     * @returns
     */
    Quaternion.fromUnitVectors = function (from, to) {
        return new Quaternion().setFromUnitVectors(from, to);
    };
    Quaternion.tempVec0 = new Vector3();
    return Quaternion;
}());

var __read$2 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$1 = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * 四阶矩阵（列优先矩阵）
 */
var Matrix4$1 = /** @class */ (function () {
    /**
     * 构造函数，初始值为单位矩阵
     * @param [m11=1] - 第 1 行，第 1 列
     * @param [m21=0] - 第 2 行，第 1 列
     * @param [m31=0] - 第 3 行，第 1 列
     * @param [m41=0] - 第 4 行，第 1 列
     * @param [m12=0] - 第 1 行，第 2 列
     * @param [m22=1] - 第 2 行，第 2 列
     * @param [m32=0] - 第 3 行，第 2 列
     * @param [m42=0] - 第 4 行，第 2 列
     * @param [m13=0] - 第 1 行，第 3 列
     * @param [m23=0] - 第 2 行，第 3 列
     * @param [m33=1] - 第 3 行，第 3 列
     * @param [m43=0] - 第 4 行，第 3 列
     * @param [m14=0] - 第 1 行，第 4 列
     * @param [m24=0] - 第 2 行，第 4 列
     * @param [m34=0] - 第 3 行，第 4 列
     * @param [m44=1] - 第 4 行，第 4 列
     */
    function Matrix4(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44) {
        if (m11 === void 0) { m11 = 1; }
        if (m21 === void 0) { m21 = 0; }
        if (m31 === void 0) { m31 = 0; }
        if (m41 === void 0) { m41 = 0; }
        if (m12 === void 0) { m12 = 0; }
        if (m22 === void 0) { m22 = 1; }
        if (m32 === void 0) { m32 = 0; }
        if (m42 === void 0) { m42 = 0; }
        if (m13 === void 0) { m13 = 0; }
        if (m23 === void 0) { m23 = 0; }
        if (m33 === void 0) { m33 = 1; }
        if (m43 === void 0) { m43 = 0; }
        if (m14 === void 0) { m14 = 0; }
        if (m24 === void 0) { m24 = 0; }
        if (m34 === void 0) { m34 = 0; }
        if (m44 === void 0) { m44 = 1; }
        this.elements = [
            m11, m21, m31, m41,
            m12, m22, m32, m42,
            m13, m23, m33, m43,
            m14, m24, m34, m44,
        ];
    }
    /**
     * 设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m21 - 第 2 行，第 1 列
     * @param m31 - 第 3 行，第 1 列
     * @param m41 - 第 4 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m22 - 第 2 行，第 2 列
     * @param m32 - 第 3 行，第 2 列
     * @param m42 - 第 4 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m23 - 第 2 行，第 3 列
     * @param m33 - 第 3 行，第 3 列
     * @param m43 - 第 4 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m24 - 第 2 行，第 4 列
     * @param m34 - 第 3 行，第 4 列
     * @param m44 - 第 4 行，第 4 列
     * @returns 矩阵
     */
    Matrix4.prototype.set = function (m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m21;
        e[2] = m31;
        e[3] = m41;
        e[4] = m12;
        e[5] = m22;
        e[6] = m32;
        e[7] = m42;
        e[8] = m13;
        e[9] = m23;
        e[10] = m33;
        e[11] = m43;
        e[12] = m14;
        e[13] = m24;
        e[14] = m34;
        e[15] = m44;
        return this;
    };
    /**
     * 通过行优先数据设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m24 - 第 2 行，第 4 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @param m34 - 第 3 行，第 4 列
     * @param m41 - 第 4 行，第 1 列
     * @param m42 - 第 4 行，第 2 列
     * @param m43 - 第 4 行，第 3 列
     * @param m44 - 第 4 行，第 4 列
     * @returns 矩阵
     */
    Matrix4.prototype.setFromRowMajorData = function (m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[4] = m12;
        e[8] = m13;
        e[12] = m14;
        e[1] = m21;
        e[5] = m22;
        e[9] = m23;
        e[13] = m24;
        e[2] = m31;
        e[6] = m32;
        e[10] = m33;
        e[14] = m34;
        e[3] = m41;
        e[7] = m42;
        e[11] = m43;
        e[15] = m44;
        return this;
    };
    /**
     * 通过四个列向量设置矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @param c4 - 第四列
     * @returns 矩阵
     */
    Matrix4.prototype.setFromColumnVectors = function (c1, c2, c3, c4) {
        return this.set(c1.x, c1.y, c1.z, c1.w, c2.x, c2.y, c2.z, c2.w, c3.x, c3.y, c3.z, c3.w, c4.x, c4.y, c4.z, c4.w);
    };
    /**
     * 通过三维矩阵设置矩阵
     * @param m - 三维矩阵
     * @returns 设置结果
     */
    Matrix4.prototype.setFromMatrix3 = function (m) {
        var me = m.elements;
        this.set(me[0], me[1], me[2], 0, me[3], me[4], me[5], 0, me[6], me[7], me[8], 0, 0, 0, 0, 1);
        return this;
    };
    /**
     * 通过数组设置矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */
    Matrix4.prototype.setFromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        for (var i = 0; i < 16; i++) {
            this.elements[i] = array[offset + i];
        }
        return this;
    };
    /**
     * 通过缩放设置矩阵
     * @param x - x 方向缩放
     * @param y - y 方向缩放
     * @param z - z 方向缩放
     * @returns 缩放矩阵
     */
    Matrix4.prototype.setFromScale = function (x, y, z) {
        return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    };
    /**
     * 通过平移设置矩阵
     * @param x - x 方向平移
     * @param y - y 方向平移
     * @param z - z 方向平移
     * @returns 平移矩阵
     */
    Matrix4.prototype.setFromTranslation = function (x, y, z) {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1);
    };
    /**
     * 通过 x 轴旋转角度设置矩阵
     * @param theta - x 轴旋转弧度
     * @returns 矩阵
     */
    Matrix4.prototype.setFromRotationX = function (theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过 y 轴旋转角度设置矩阵
     * @param theta - y 轴旋转弧度
     * @returns 矩阵
     */
    Matrix4.prototype.setFromRotationY = function (theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过 z 轴旋转角度设置矩阵
     * @param theta - z 轴旋转弧度
     * @returns 矩阵
     */
    Matrix4.prototype.setFromRotationZ = function (theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 根据三维旋转轴与弧度设置矩阵
     * @param axis - 三维旋转轴
     * @param angle - 旋转弧度
     * @returns 矩阵
     */
    Matrix4.prototype.setFromRotationAxis = function (axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        var v = Matrix4.tempVec0;
        v.copyFrom(axis).normalize();
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = v.x, y = v.y, z = v.z;
        var tx = t * x;
        var ty = t * y;
        return this.set(tx * x + c, tx * y + s * z, tx * z - s * y, 0, tx * y - s * z, ty * y + c, ty * z + s * x, 0, tx * z + s * y, ty * z - s * x, t * z * z + c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过欧拉角设置矩阵
     * @param euler - 欧拉角
     * @returns 矩阵
     */
    Matrix4.prototype.setFromEuler = function (euler) {
        euler.toMatrix4(this);
        return this;
    };
    /**
     * 通过四元数设置矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */
    Matrix4.prototype.setFromQuaternion = function (quat) {
        return this.compose(Vector3.ZERO, quat, Vector3.ONE);
    };
    /**
     * 通过倾斜参数设置矩阵
     * @param x - x 方向倾斜分量
     * @param y - y 方向倾斜分量
     * @param z - z 方向倾斜分量
     * @returns 倾斜矩阵
     */
    Matrix4.prototype.setFromShear = function (x, y, z) {
        return this.set(1, x, x, 0, y, 1, y, 0, z, z, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 通过基轴设置矩阵
     * @param xAxis - x 轴
     * @param yAxis - y 轴
     * @param zAxis - z 轴
     * @returns 倾斜矩阵
     */
    Matrix4.prototype.setFromBasis = function (xAxis, yAxis, zAxis) {
        return this.set(xAxis.x, xAxis.y, xAxis.z, 0, yAxis.x, yAxis.y, yAxis.z, 0, zAxis.x, zAxis.y, zAxis.z, 0, 0, 0, 0, 1);
    };
    /**
     * 矩阵清零
     * @returns 零矩阵
     */
    Matrix4.prototype.setZero = function () {
        for (var i = 0; i < 16; i++) {
            this.elements[i] = 0;
        }
        return this;
    };
    /**
     * 矩阵单位化
     * @returns 单位矩阵
     */
    Matrix4.prototype.identity = function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 单位阵判断
     * @returns 判断结果
     */
    Matrix4.prototype.isIdentity = function () {
        var e = this.elements;
        return e[0] === 1 && e[4] === 0 && e[8] === 0 && e[12] === 0
            && e[1] === 0 && e[5] === 1 && e[9] === 0 && e[13] === 0
            && e[2] === 0 && e[6] === 0 && e[10] === 1 && e[14] === 0
            && e[3] === 0 && e[7] === 0 && e[11] === 0 && e[15] === 1;
    };
    /**
     * 矩阵克隆
     * @returns 克隆结果
     */
    Matrix4.prototype.clone = function () {
        var e = this.elements;
        return new Matrix4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    };
    /**
     * 矩阵复制
     * @param m - 复制对象
     * @returns 复制结果
     */
    Matrix4.prototype.copyFrom = function (m) {
        this.elements = __spreadArray$1([], __read$2(m.elements), false);
        return this;
    };
    /**
     * 得到列向量
     * @param i - 列向量索引，从 0 开始
     * @param v
     * @returns 矩阵
     */
    Matrix4.prototype.getColumnVector = function (i, v) {
        return v.set(this.elements[i * 4], this.elements[i * 4 + 1], this.elements[i * 4 + 2], this.elements[i * 4 + 3]);
    };
    /**
     * 设置相机矩阵
     * @param eye - 相机位置
     * @param target - 目标位置
     * @param up - 相机方向
     * @returns 矩阵
     */
    Matrix4.prototype.lookAt = function (eye, target, up) {
        var vX = Matrix4.tempVec0;
        var vY = Matrix4.tempVec1;
        var vZ = Matrix4.tempVec2;
        vZ.subtractVectors(eye, target);
        vZ.normalize();
        vX.crossVectors(up, vZ);
        vX.normalize();
        vY.crossVectors(vZ, vX);
        var te = this.elements;
        te[0] = vX.x;
        te[1] = vY.x;
        te[2] = vZ.x;
        te[3] = 0;
        te[4] = vX.y;
        te[5] = vY.y;
        te[6] = vZ.y;
        te[7] = 0;
        te[8] = vX.z;
        te[9] = vY.z;
        te[10] = vZ.z;
        te[11] = 0;
        te[12] = -vX.dot(eye);
        te[13] = -vY.dot(eye);
        te[14] = -vZ.dot(eye);
        te[15] = 1;
        return this;
    };
    /**
     * 矩阵乘比例后相加
     * @param right - 矩阵
     * @param s - 比例
     * @returns 相加结果
     */
    Matrix4.prototype.addScaledMatrix = function (right, s) {
        var te = this.elements;
        var re = right.elements;
        for (var i = 0; i < 16; i++) {
            te[i] += re[i] * s;
        }
        return this;
    };
    /**
     * 矩阵右乘
     * @param right - 右侧矩阵或数值
     * @returns 右乘结果
     */
    Matrix4.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            for (var i = 0; i < 16; i++) {
                this.elements[i] *= right;
            }
            return this;
        }
        else {
            return this.multiplyMatrices(this, right);
        }
    };
    /**
     * 矩阵左乘
     * @param left - 左侧矩阵
     * @returns 左乘结果
     */
    Matrix4.prototype.premultiply = function (left) {
        return this.multiplyMatrices(left, this);
    };
    /**
     * 矩阵相乘
     * @param left - 矩阵
     * @param right - 矩阵
     * @returns 相乘结果
     */
    Matrix4.prototype.multiplyMatrices = function (left, right) {
        var ae = left.elements;
        var be = right.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    };
    /**
     * 矩阵缩放
     * @param s - 缩放比例
     * @returns 缩放结果
     */
    Matrix4.prototype.multiplyScalar = function (s) {
        var e = this.elements;
        e[0] *= s;
        e[4] *= s;
        e[8] *= s;
        e[12] *= s;
        e[1] *= s;
        e[5] *= s;
        e[9] *= s;
        e[13] *= s;
        e[2] *= s;
        e[6] *= s;
        e[10] *= s;
        e[14] *= s;
        e[3] *= s;
        e[7] *= s;
        e[11] *= s;
        e[15] *= s;
        return this;
    };
    /**
     * 矩阵求行列式值
     * @returns 行列式值
     */
    Matrix4.prototype.determinant = function () {
        var e = this.elements;
        var m11 = e[0], m12 = e[4], m13 = e[8], m14 = e[12];
        var m21 = e[1], m22 = e[5], m23 = e[9], m24 = e[13];
        var m31 = e[2], m32 = e[6], m33 = e[10], m34 = e[14];
        var m41 = e[3], m42 = e[7], m43 = e[11], m44 = e[15];
        return (m41 * (+m14 * m23 * m32
            - m13 * m24 * m32
            - m14 * m22 * m33
            + m12 * m24 * m33
            + m13 * m22 * m34
            - m12 * m23 * m34) +
            m42 * (+m11 * m23 * m34
                - m11 * m24 * m33
                + m14 * m21 * m33
                - m13 * m21 * m34
                + m13 * m24 * m31
                - m14 * m23 * m31) +
            m43 * (+m11 * m24 * m32
                - m11 * m22 * m34
                - m14 * m21 * m32
                + m12 * m21 * m34
                + m14 * m22 * m31
                - m12 * m24 * m31) +
            m44 * (-m13 * m22 * m31
                - m11 * m23 * m32
                + m11 * m22 * m33
                + m13 * m21 * m32
                - m12 * m21 * m33
                + m12 * m23 * m31));
    };
    /**
     * 矩阵转置
     * @returns 转置结果
     */
    Matrix4.prototype.transpose = function () {
        var e = this.elements;
        var t;
        t = e[1];
        e[1] = e[4];
        e[4] = t;
        t = e[2];
        e[2] = e[8];
        e[8] = t;
        t = e[3];
        e[3] = e[12];
        e[12] = t;
        //
        t = e[6];
        e[6] = e[9];
        e[9] = t;
        t = e[7];
        e[7] = e[13];
        e[13] = t;
        t = e[11];
        e[11] = e[14];
        e[14] = t;
        return this;
    };
    /**
     * 矩阵求逆
     * @returns 逆矩阵
     */
    Matrix4.prototype.invert = function () {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var e = this.elements;
        var m11 = e[0], m21 = e[1], m31 = e[2], m41 = e[3];
        var m12 = e[4], m22 = e[5], m32 = e[6], m42 = e[7];
        var m13 = e[8], m23 = e[9], m33 = e[10], m43 = e[11];
        var m14 = e[12], m24 = e[13], m34 = e[14], m44 = e[15];
        var t11 = m23 * m34 * m42 - m24 * m33 * m42 + m24 * m32 * m43 - m22 * m34 * m43 - m23 * m32 * m44 + m22 * m33 * m44;
        var t12 = m14 * m33 * m42 - m13 * m34 * m42 - m14 * m32 * m43 + m12 * m34 * m43 + m13 * m32 * m44 - m12 * m33 * m44;
        var t13 = m13 * m24 * m42 - m14 * m23 * m42 + m14 * m22 * m43 - m12 * m24 * m43 - m13 * m22 * m44 + m12 * m23 * m44;
        var t14 = m14 * m23 * m32 - m13 * m24 * m32 - m14 * m22 * m33 + m12 * m24 * m33 + m13 * m22 * m34 - m12 * m23 * m34;
        var det = m11 * t11 + m21 * t12 + m31 * t13 + m41 * t14;
        if (det === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        var detInv = 1 / det;
        e[0] = t11 * detInv;
        e[1] = (m24 * m33 * m41 - m23 * m34 * m41 - m24 * m31 * m43 + m21 * m34 * m43 + m23 * m31 * m44 - m21 * m33 * m44) * detInv;
        e[2] = (m22 * m34 * m41 - m24 * m32 * m41 + m24 * m31 * m42 - m21 * m34 * m42 - m22 * m31 * m44 + m21 * m32 * m44) * detInv;
        e[3] = (m23 * m32 * m41 - m22 * m33 * m41 - m23 * m31 * m42 + m21 * m33 * m42 + m22 * m31 * m43 - m21 * m32 * m43) * detInv;
        e[4] = t12 * detInv;
        e[5] = (m13 * m34 * m41 - m14 * m33 * m41 + m14 * m31 * m43 - m11 * m34 * m43 - m13 * m31 * m44 + m11 * m33 * m44) * detInv;
        e[6] = (m14 * m32 * m41 - m12 * m34 * m41 - m14 * m31 * m42 + m11 * m34 * m42 + m12 * m31 * m44 - m11 * m32 * m44) * detInv;
        e[7] = (m12 * m33 * m41 - m13 * m32 * m41 + m13 * m31 * m42 - m11 * m33 * m42 - m12 * m31 * m43 + m11 * m32 * m43) * detInv;
        e[8] = t13 * detInv;
        e[9] = (m14 * m23 * m41 - m13 * m24 * m41 - m14 * m21 * m43 + m11 * m24 * m43 + m13 * m21 * m44 - m11 * m23 * m44) * detInv;
        e[10] = (m12 * m24 * m41 - m14 * m22 * m41 + m14 * m21 * m42 - m11 * m24 * m42 - m12 * m21 * m44 + m11 * m22 * m44) * detInv;
        e[11] = (m13 * m22 * m41 - m12 * m23 * m41 - m13 * m21 * m42 + m11 * m23 * m42 + m12 * m21 * m43 - m11 * m22 * m43) * detInv;
        e[12] = t14 * detInv;
        e[13] = (m13 * m24 * m31 - m14 * m23 * m31 + m14 * m21 * m33 - m11 * m24 * m33 - m13 * m21 * m34 + m11 * m23 * m34) * detInv;
        e[14] = (m14 * m22 * m31 - m12 * m24 * m31 - m14 * m21 * m32 + m11 * m24 * m32 + m12 * m21 * m34 - m11 * m22 * m34) * detInv;
        e[15] = (m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) * detInv;
        return this;
    };
    /**
     * 提取基轴
     * @param xAxis - 提取的 x 轴
     * @param yAxis - 提取的 y 轴
     * @param zAxis - 提取的 z 轴
     * @returns
     */
    Matrix4.prototype.extractBasis = function (xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
    };
    /**
     * 根据基础信息组装矩阵
     * @param translation - 位置信息
     * @param rotation - 旋转信息
     * @param scale - 缩放信息
     * @param [anchor] - 锚点信息
     * @returns 矩阵
     */
    Matrix4.prototype.compose = function (translation, rotation, scale, anchor) {
        if (anchor === void 0) { anchor = Vector3.ZERO; }
        var te = this.elements;
        var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
        var l = -anchor.x;
        var m = -anchor.y;
        var n = -anchor.z;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = l * te[0] + m * te[4] + n * te[8] - l + translation.x;
        te[13] = l * te[1] + m * te[5] + n * te[9] - m + translation.y;
        te[14] = l * te[2] + m * te[6] + n * te[10] - n + translation.z;
        return this;
    };
    /**
     * 矩阵拆分为基础信息
     * @param translation - 位置信息
     * @param rotation - 旋转信息
     * @param scale - 缩放信息
     * @returns 矩阵
     */
    Matrix4.prototype.decompose = function (translation, rotation, scale) {
        var v = Matrix4.tempVec0;
        var te = this.elements;
        var sx = v.set(te[0], te[1], te[2]).length();
        var sy = v.set(te[4], te[5], te[6]).length();
        var sz = v.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if (det < 0) {
            sx = -sx;
        }
        translation.x = te[12];
        translation.y = te[13];
        translation.z = te[14];
        // scale the rotation part
        var m = Matrix4.tempMat0;
        m.copyFrom(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        m.elements[0] *= invSX;
        m.elements[1] *= invSX;
        m.elements[2] *= invSX;
        m.elements[4] *= invSY;
        m.elements[5] *= invSY;
        m.elements[6] *= invSY;
        m.elements[8] *= invSZ;
        m.elements[9] *= invSZ;
        m.elements[10] *= invSZ;
        rotation.setFromRotationMatrix(m);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    };
    Matrix4.prototype.getTranslation = function (translation) {
        var te = this.elements;
        return translation.set(te[12], te[13], te[14]);
    };
    Matrix4.prototype.getScale = function (scale) {
        var te = this.elements;
        return scale.set(Math.hypot(te[0], te[1], te[2]), Math.hypot(te[4], te[5], te[6]), Math.hypot(te[8], te[9], te[10]));
    };
    /**
     * 获得矩阵分解的结果
     * @returns 分解的结果
     */
    Matrix4.prototype.getTransform = function () {
        var translation = new Vector3();
        var rotation = new Quaternion();
        var scale = new Vector3();
        this.decompose(translation, rotation, scale);
        return { translation: translation, rotation: rotation, scale: scale };
    };
    /**
     * 根据视窗信息设置正交相机投影矩阵
     * @param left - 视窗左平面位置
     * @param right - 视窗右平面位置
     * @param top - 视窗上平面位置
     * @param bottom - 视窗下平面位置
     * @param near - 视窗近平面位置
     * @param far - 视窗远平面位置
     * @returns 矩阵
     */
    Matrix4.prototype.orthographic = function (left, right, top, bottom, near, far) {
        var a = 1.0 / (right - left);
        var b = 1.0 / (top - bottom);
        var c = 1.0 / (far - near);
        var tx = -(right + left) * a;
        var ty = -(top + bottom) * b;
        var tz = -(far + near) * c;
        a *= 2.0;
        b *= 2.0;
        c *= -2.0;
        var te = this.elements;
        te[0] = a;
        te[1] = 0.0;
        te[2] = 0.0;
        te[3] = 0.0;
        //
        te[4] = 0.0;
        te[5] = b;
        te[6] = 0.0;
        te[7] = 0.0;
        //
        te[8] = 0.0;
        te[9] = 0.0;
        te[10] = c;
        te[11] = 0.0;
        //
        te[12] = tx;
        te[13] = ty;
        te[14] = tz;
        te[15] = 1.0;
        return this;
    };
    /**
     * 通过透视相机基础参数设置投影矩阵
     * @param fov - 视角(弧度)
     * @param aspect - 视窗比例
     * @param near - 近平面
     * @param far - 远平面
     * @param [reverse] - 视锥体长宽反转(3D这里反了？)
     * @returns 投影矩阵
     */
    Matrix4.prototype.perspective = function (fov, aspect, near, far, reverse) {
        var f = 1.0 / Math.tan(fov * 0.5);
        var nf = 1 / (near - far);
        var te = this.elements;
        te[0] = reverse ? f : f / aspect;
        te[1] = 0;
        te[2] = 0;
        te[3] = 0;
        //
        te[4] = 0;
        te[5] = reverse ? f * aspect : f;
        te[6] = 0;
        te[7] = 0;
        //
        te[8] = 0;
        te[9] = 0;
        te[10] = (far + near) * nf;
        te[11] = -1;
        //
        te[12] = 0;
        te[13] = 0;
        te[14] = 2 * far * near * nf;
        te[15] = 0;
        if (far === null || far === Infinity) {
            te[10] = -1;
            te[14] = -2 * near;
        }
        return this;
    };
    /**
     * 对点进行投影变换
     * @param v - 输入点
     * @param [out] - 输出点，如果没有就覆盖输入的数据
     * @returns 投影后的点
     */
    Matrix4.prototype.projectPoint = function (v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        var w = e[3] * x + e[7] * y + e[11] * z + e[15];
        return res.multiply(1 / w);
    };
    /**
     * 对点进行矩阵变换
     * @param v - 输入点
     * @param [out] - 输出点，如果没有就覆盖输入的数据
     * @returns 变换后的点
     */
    Matrix4.prototype.transformPoint = function (v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return res;
    };
    /**
     * 对法向量进行矩阵变换
     * @param v - 输入法向量
     * @param [out] - 输出法向量，如果没有就覆盖输入的数据
     * @returns 变换后的法向量
     */
    Matrix4.prototype.transformNormal = function (v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z;
        res.y = e[1] * x + e[5] * y + e[9] * z;
        res.z = e[2] * x + e[6] * y + e[10] * z;
        return res.normalize();
    };
    /**
     * 对四维向量进行矩阵变换
     * @param v - 输入向量
     * @param [out] - 输出向量，如果没有就覆盖输入的数据
     * @returns 变换后向量
     */
    Matrix4.prototype.transformVector4 = function (v, out) {
        var x = v.x, y = v.y, z = v.z, w = v.w;
        var e = this.elements;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        res.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return res;
    };
    /**
     * 矩阵判等
     * @param matrix - 矩阵
     * @returns 判等结果
     */
    Matrix4.prototype.equals = function (matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
            if (!isEqual(te[i], me[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * 矩阵转数组
     * @returns
     */
    Matrix4.prototype.toArray = function () {
        return __spreadArray$1([], __read$2(this.elements), false);
    };
    Matrix4.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
    };
    /**
     * 创建单位阵
     * @returns 单位矩阵
     */
    Matrix4.fromIdentity = function () {
        return new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 创建相机矩阵
     * @param eye - 相机位置
     * @param target - 目标位置
     * @param up - 相机方向
     * @returns 矩阵
     */
    Matrix4.fromLookAt = function (eye, target, up) {
        return new Matrix4().lookAt(eye, target, up);
    };
    /**
     * 创建投影矩阵
     * @param fov - 视角
     * @param aspect - 视窗比例
     * @param near - 近平面
     * @param far - 远平面
     * @param [reverse] - 视锥体长宽反转
     * @returns 投影矩阵
     */
    Matrix4.fromPerspective = function (fov, aspect, near, far, reverse) {
        return new Matrix4().perspective(fov, aspect, near, far, reverse);
    };
    /**
     * 通过四个列向量创建矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @param c4 - 第四列
     * @returns
     */
    Matrix4.fromColumnVectors = function (c1, c2, c3, c4) {
        return new Matrix4().setFromColumnVectors(c1, c2, c3, c4);
    };
    /**
     * 通过三阶矩阵创建矩阵
     * @param m - 三阶矩阵
     * @returns 创建的矩阵
     */
    Matrix4.fromMatrix3 = function (m) {
        return new Matrix4().setFromMatrix3(m);
    };
    /**
     * 通过数组创建矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */
    Matrix4.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Matrix4().setFromArray(array, offset);
    };
    /**
     * 通过缩放创建矩阵
     * @param x - x 缩放
     * @param y - y 缩放
     * @param z - z 缩放
     * @returns 缩放结果
     */
    Matrix4.fromScale = function (x, y, z) {
        return new Matrix4().setFromScale(x, y, z);
    };
    /**
     * 通过平移创建矩阵
     * @param x - x 平移
     * @param y - y 平移
     * @param z - z 平移
     * @returns 平移结果
     */
    Matrix4.fromTranslation = function (x, y, z) {
        return new Matrix4().setFromTranslation(x, y, z);
    };
    /**
     * 通过 x 轴旋转创建矩阵
     * @param theta - x 轴旋转弧度
     * @returns 矩阵
     */
    Matrix4.fromRotationX = function (theta) {
        return new Matrix4().setFromRotationX(theta);
    };
    /**
     * 通过 y 轴旋转创建矩阵
     * @param theta - y 轴旋转弧度
     * @returns 矩阵
     */
    Matrix4.fromRotationY = function (theta) {
        return new Matrix4().setFromRotationY(theta);
    };
    /**
     * 通过 z 轴旋转创建矩阵
     * @param theta - z 轴旋转弧度
     * @returns
     */
    Matrix4.fromRotationZ = function (theta) {
        return new Matrix4().setFromRotationZ(theta);
    };
    /**
     * 通过旋转轴与旋转弧度创建矩阵
     * @param axis - 旋转轴
     * @param angle - 旋转弧度
     * @returns
     */
    Matrix4.fromRotationAxis = function (axis, angle) {
        return new Matrix4().setFromRotationAxis(axis, angle);
    };
    /**
     * 通过欧拉角创建矩阵
     * @param euler - 欧拉角
     * @returns
     */
    Matrix4.fromEuler = function (euler) {
        return new Matrix4().setFromEuler(euler);
    };
    /**
     * 通过四元数创建矩阵
     * @param quat - 四元数
     * @returns
     */
    Matrix4.fromQuaternion = function (quat) {
        return new Matrix4().setFromQuaternion(quat);
    };
    /**
     * 通过倾斜创建矩阵
     * @param x - x 方向倾斜分量
     * @param y - y 方向倾斜分量
     * @param z - z 方向倾斜分量
     * @returns 倾斜矩阵
     */
    Matrix4.fromShear = function (x, y, z) {
        return new Matrix4().setFromShear(x, y, z);
    };
    /**
     * 通过基轴创建矩阵
     * @param xAxis - x 轴
     * @param yAxis - y 轴
     * @param zAxis - z 轴
     * @returns
     */
    Matrix4.fromBasis = function (xAxis, yAxis, zAxis) {
        return new Matrix4().setFromBasis(xAxis, yAxis, zAxis);
    };
    /**
     * 通过行优先数据设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m24 - 第 2 行，第 4 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @param m34 - 第 3 行，第 4 列
     * @param m41 - 第 4 行，第 1 列
     * @param m42 - 第 4 行，第 2 列
     * @param m43 - 第 4 行，第 3 列
     * @param m44 - 第 4 行，第 4 列
     * @returns
     */
    Matrix4.fromRowMajorData = function (m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        return new Matrix4(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44);
    };
    Matrix4.IDENTITY = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    Matrix4.ZERO = new Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    Matrix4.tempVec0 = new Vector3();
    Matrix4.tempVec1 = new Vector3();
    Matrix4.tempVec2 = new Vector3();
    Matrix4.tempMat0 = new Matrix4();
    return Matrix4;
}());

/**
 * 欧拉角顺序
 */
var EulerOrder;
(function (EulerOrder) {
    EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
    EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
    EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
    EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
    EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
    EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
})(EulerOrder || (EulerOrder = {}));
/**
 * 欧拉角
 */
var Euler = /** @class */ (function () {
    /**
     * 构造函数，传入值为 x, y, z 方向分量以及欧拉角顺序
     * @param [x=0] - x 方向分量
     * @param [y=0] - y 方向分量
     * @param [z=0] - z 方向分量
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     */
    function Euler(x, y, z, order) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (order === void 0) { order = Euler.DEFAULT_ORDER; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.order = order;
    }
    /**
     * 设置欧拉角
     * @param x - x 方向分量
     * @param y - y 方向分量
     * @param z - z 方向分量
     * @param [order] - 欧拉角顺序
     * @returns
     */
    Euler.prototype.set = function (x, y, z, order) {
        if (order === void 0) { order = this.order; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.order = order;
        return this;
    };
    Euler.prototype.setZero = function (order) {
        if (order === void 0) { order = this.order; }
        return this.set(0, 0, 0, order);
    };
    /**
     * 通过矩阵设置欧拉角
     * @param m - 矩阵
     * @param [order] - 欧拉角顺序
     * @returns
     */
    Euler.prototype.setFromRotationMatrix4 = function (m, order) {
        if (order === void 0) { order = this.order; }
        var te = m.elements;
        var m11 = te[0];
        var m12 = te[4];
        var m13 = te[8];
        var m21 = te[1];
        var m22 = te[5];
        var m23 = te[9];
        var m31 = te[2];
        var m32 = te[6];
        var m33 = te[10];
        switch (order) {
            case EulerOrder.XYZ:
                this.y = Math.asin(clamp$1(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this.x = Math.atan2(-m23, m33);
                    this.z = Math.atan2(-m12, m11);
                }
                else {
                    this.x = Math.atan2(m32, m22);
                    this.z = 0;
                }
                break;
            case EulerOrder.YXZ:
                this.x = Math.asin(-clamp$1(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this.y = Math.atan2(m13, m33);
                    this.z = Math.atan2(m21, m22);
                }
                else {
                    this.y = Math.atan2(-m31, m11);
                    this.z = 0;
                }
                break;
            case EulerOrder.ZXY:
                this.x = Math.asin(clamp$1(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this.y = Math.atan2(-m31, m33);
                    this.z = Math.atan2(-m12, m22);
                }
                else {
                    this.y = 0;
                    this.z = Math.atan2(m21, m11);
                }
                break;
            case EulerOrder.ZYX:
                this.y = Math.asin(-clamp$1(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this.x = Math.atan2(m32, m33);
                    this.z = Math.atan2(m21, m11);
                }
                else {
                    this.x = 0;
                    this.z = Math.atan2(-m12, m22);
                }
                break;
            case EulerOrder.YZX:
                this.z = Math.asin(clamp$1(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this.x = Math.atan2(-m23, m22);
                    this.y = Math.atan2(-m31, m11);
                }
                else {
                    this.x = 0;
                    this.y = Math.atan2(m13, m33);
                }
                break;
            case EulerOrder.XZY:
                this.z = Math.asin(-clamp$1(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this.x = Math.atan2(m32, m22);
                    this.y = Math.atan2(m13, m11);
                }
                else {
                    this.x = Math.atan2(-m23, m33);
                    this.y = 0;
                }
                break;
            default:
                console.error('setFromRotationMatrix: unknown order: ' + order);
        }
        this.x *= RAD2DEG;
        this.y *= RAD2DEG;
        this.z *= RAD2DEG;
        this.order = order;
        return this;
    };
    /**
     * 通过四元数设置欧拉角
     * @param quat - 四元数
     * @param [order] - 欧拉角顺序
     * @returns
     */
    Euler.prototype.setFromQuaternion = function (quat, order) {
        if (order === void 0) { order = this.order; }
        var matrix = Euler.tempMat0;
        matrix.setFromQuaternion(quat);
        return this.setFromRotationMatrix4(matrix, order);
    };
    /**
     * 通过三维向量设置欧拉角
     * @param v - 三维向量
     * @param [order] - 欧拉角顺序
     * @returns
     */
    Euler.prototype.setFromVector3 = function (v, order) {
        if (order === void 0) { order = this.order; }
        return this.set(v.x, v.y, v.z, order);
    };
    /**
     * 通过数组设置欧拉角
     * @param array - 数组
     * @param [offset=0] - 偏移
     * @param [order] - 欧拉角顺序
     * @returns
     */
    Euler.prototype.setFromArray = function (array, offset, order) {
        var _a, _b, _c, _d;
        if (offset === void 0) { offset = 0; }
        if (order === void 0) { order = this.order; }
        this.x = (_a = array[offset]) !== null && _a !== void 0 ? _a : 0;
        this.y = (_b = array[offset + 1]) !== null && _b !== void 0 ? _b : 0;
        this.z = (_c = array[offset + 2]) !== null && _c !== void 0 ? _c : 0;
        this.order = (_d = array[offset + 3]) !== null && _d !== void 0 ? _d : order;
        return this;
    };
    /**
     * 克隆欧拉角
     * @returns 克隆结果
     */
    Euler.prototype.clone = function () {
        return new Euler(this.x, this.y, this.z, this.order);
    };
    /**
     * 复制欧拉角
     * @param euler - 复制对象
     * @returns 复制结果
     */
    Euler.prototype.copyFrom = function (euler) {
        this.x = euler.x;
        this.y = euler.y;
        this.z = euler.z;
        this.order = euler.order;
        return this;
    };
    Euler.prototype.add = function (euler) {
        if (this.order != euler.order) {
            console.error('add euler with different order');
            return this;
        }
        this.x += euler.x;
        this.y += euler.y;
        this.z += euler.z;
        return this;
    };
    Euler.prototype.addEulers = function (left, right) {
        if (left.order != right.order) {
            console.error('add euler with different order');
            return this;
        }
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        this.order = left.order;
        return this;
    };
    Euler.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 修改欧拉角顺序
     * @param newOrder - 欧拉角顺序
     * @returns 修改结果
     */
    Euler.prototype.reorder = function (newOrder) {
        var quaternion = new Quaternion();
        quaternion.setFromEuler(this);
        return this.setFromQuaternion(quaternion, newOrder);
    };
    /**
     * 通过四元数旋转向量
     * @param v - 待旋转向量
     * @param out - 旋转结果，如果没有传入直接覆盖输入值
     * @returns
     */
    Euler.prototype.rotateVector3 = function (v, out) {
        var q = Euler.tempQuat0;
        return q.setFromEuler(this).rotateVector3(v, out);
    };
    /**
     * 欧拉角相等判断
     * @param euler - 欧拉角
     * @returns 判断结果
     */
    Euler.prototype.equals = function (euler) {
        return euler.x === this.x
            && euler.y === this.y
            && euler.z === this.z
            && euler.order === this.order;
    };
    /**
     * 欧拉角保存于三维向量
     * @param vec - 目标保存对象
     * @returns 保存结果
     */
    Euler.prototype.toVector3 = function (vec) {
        return vec.set(this.x, this.y, this.z);
    };
    /**
     * 欧拉角转数组
     * @returns 保存结果
     */
    Euler.prototype.toArray = function () {
        return [this.x, this.y, this.z];
    };
    /**
     * 欧拉角转四元数
     * @param quat - 目标四元数
     * @returns 目标四元数
     */
    Euler.prototype.toQuaternion = function (quat) {
        var _a;
        var x = (_a = this, _a.x), y = _a.y, z = _a.z, order = _a.order;
        var c1 = Math.cos(x * DEG2RAD * 0.5);
        var c2 = Math.cos(y * DEG2RAD * 0.5);
        var c3 = Math.cos(z * DEG2RAD * 0.5);
        var s1 = Math.sin(x * DEG2RAD * 0.5);
        var s2 = Math.sin(y * DEG2RAD * 0.5);
        var s3 = Math.sin(z * DEG2RAD * 0.5);
        switch (order) {
            case EulerOrder.XYZ:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.YXZ:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            case EulerOrder.ZXY:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.ZYX:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            case EulerOrder.YZX:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.XZY:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            default:
                console.error('unknown euler order: ' + order);
        }
        return quat;
    };
    /**
     * 欧拉角转矩阵
     * @param mat - 目标矩阵
     * @returns 返回目标矩阵
     */
    Euler.prototype.toMatrix4 = function (mat) {
        var _a;
        var me = mat.elements;
        var x = (_a = this, _a.x), y = _a.y, z = _a.z, order = _a.order;
        var cosX = Math.cos(x * DEG2RAD), sinX = Math.sin(x * DEG2RAD);
        var cosY = Math.cos(y * DEG2RAD), sinY = Math.sin(y * DEG2RAD);
        var cosZ = Math.cos(z * DEG2RAD), sinZ = Math.sin(z * DEG2RAD);
        if (order === EulerOrder.XYZ) {
            var cosXcosZ = cosX * cosZ;
            var cosXsinZ = cosX * sinZ;
            var sinXcosZ = sinX * cosZ;
            var sinXsinZ = sinX * sinZ;
            me[0] = cosY * cosZ;
            me[4] = -cosY * sinZ;
            me[8] = sinY;
            me[1] = cosXsinZ + sinXcosZ * sinY;
            me[5] = cosXcosZ - sinXsinZ * sinY;
            me[9] = -sinX * cosY;
            me[2] = sinXsinZ - cosXcosZ * sinY;
            me[6] = sinXcosZ + cosXsinZ * sinY;
            me[10] = cosX * cosY;
        }
        else if (order === EulerOrder.YXZ) {
            var cosYcosZ = cosY * cosZ;
            var cosYsinZ = cosY * sinZ;
            var sinYcosZ = sinY * cosZ;
            var sinYsinZ = sinY * sinZ;
            me[0] = cosYcosZ + sinYsinZ * sinX;
            me[4] = sinYcosZ * sinX - cosYsinZ;
            me[8] = cosX * sinY;
            me[1] = cosX * sinZ;
            me[5] = cosX * cosZ;
            me[9] = -sinX;
            me[2] = cosYsinZ * sinX - sinYcosZ;
            me[6] = sinYsinZ + cosYcosZ * sinX;
            me[10] = cosX * cosY;
        }
        else if (order === EulerOrder.ZXY) {
            var cosYcosZ = cosY * cosZ;
            var cosYsinZ = cosY * sinZ;
            var sinYcosZ = sinY * cosZ;
            var sinYsinZ = sinY * sinZ;
            me[0] = cosYcosZ - sinYsinZ * sinX;
            me[4] = -cosX * sinZ;
            me[8] = sinYcosZ + cosYsinZ * sinX;
            me[1] = cosYsinZ + sinYcosZ * sinX;
            me[5] = cosX * cosZ;
            me[9] = sinYsinZ - cosYcosZ * sinX;
            me[2] = -cosX * sinY;
            me[6] = sinX;
            me[10] = cosX * cosY;
        }
        else if (order === EulerOrder.ZYX) {
            var cosXcosZ = cosX * cosZ;
            var cosXsinZ = cosX * sinZ;
            var sinXcosZ = sinX * cosZ;
            var sinXsinZ = sinX * sinZ;
            me[0] = cosY * cosZ;
            me[4] = sinXcosZ * sinY - cosXsinZ;
            me[8] = cosXcosZ * sinY + sinXsinZ;
            me[1] = cosY * sinZ;
            me[5] = sinXsinZ * sinY + cosXcosZ;
            me[9] = cosXsinZ * sinY - sinXcosZ;
            me[2] = -sinY;
            me[6] = sinX * cosY;
            me[10] = cosX * cosY;
        }
        else if (order === EulerOrder.YZX) {
            var cosXcosY = cosX * cosY;
            var cosXsinY = cosX * sinY;
            var sinXcosY = sinX * cosY;
            var sinXsinY = sinX * sinY;
            me[0] = cosY * cosZ;
            me[4] = sinXsinY - cosXcosY * sinZ;
            me[8] = sinXcosY * sinZ + cosXsinY;
            me[1] = sinZ;
            me[5] = cosX * cosZ;
            me[9] = -sinX * cosZ;
            me[2] = -sinY * cosZ;
            me[6] = cosXsinY * sinZ + sinXcosY;
            me[10] = cosXcosY - sinXsinY * sinZ;
        }
        else if (order === EulerOrder.XZY) {
            var cosXcosY = cosX * cosY;
            var cosXsinY = cosX * sinY;
            var sinXcosY = sinX * cosY;
            var sinXsinY = sinX * sinY;
            me[0] = cosY * cosZ;
            me[4] = -sinZ;
            me[8] = sinY * cosZ;
            me[1] = cosXcosY * sinZ + sinXsinY;
            me[5] = cosX * cosZ;
            me[9] = cosXsinY * sinZ - sinXcosY;
            me[2] = sinXcosY * sinZ - cosXsinY;
            me[6] = sinX * cosZ;
            me[10] = sinXsinY * sinZ + cosXcosY;
        }
        else {
            console.error('toMatrix4: Invalid order ' + order);
        }
        // bottom row
        me[3] = 0;
        me[7] = 0;
        me[11] = 0;
        // last column
        me[12] = 0;
        me[13] = 0;
        me[14] = 0;
        me[15] = 1;
        return mat;
    };
    /**
     * 通过矩阵创建欧拉角
     * @param m - 矩阵
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */
    Euler.fromRotationMatrix4 = function (m, order) {
        if (order === void 0) { order = Euler.DEFAULT_ORDER; }
        return new Euler().setFromRotationMatrix4(m, order);
    };
    /**
     * 通过四元数创建欧拉角
     * @param quat - 四元数
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */
    Euler.fromQuaternion = function (quat, order) {
        if (order === void 0) { order = Euler.DEFAULT_ORDER; }
        return new Euler().setFromQuaternion(quat, order);
    };
    /**
     * 通过三维向量创建欧拉角
     * @param v - 三维向量
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */
    Euler.fromVector3 = function (v, order) {
        if (order === void 0) { order = Euler.DEFAULT_ORDER; }
        return new Euler().setFromVector3(v, order);
    };
    /**
     * 通过数组创建欧拉角
     * @param array - 数组
     * @param [offset=0] - 偏移
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */
    Euler.fromArray = function (array, offset, order) {
        if (offset === void 0) { offset = 0; }
        if (order === void 0) { order = Euler.DEFAULT_ORDER; }
        return new Euler().setFromArray(array, offset, order);
    };
    Euler.DEFAULT_ORDER = EulerOrder.ZYX;
    Euler.tempQuat0 = new Quaternion();
    Euler.tempMat0 = new Matrix4$1();
    return Euler;
}());

/**
 * 四维向量
 */
var Vector4$1 = /** @class */ (function () {
    /**
     * 构造函数
     * @param [x=0] - x 轴分量
     * @param [y=0] - y 轴分量
     * @param [z=0] - z 轴分量
     * @param [w=1] - w 轴分量
     */
    function Vector4(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @param z - z 轴分量
     * @param w - w 轴分量
     * @returns
     */
    Vector4.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */
    Vector4.prototype.setZero = function () {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
    };
    /**
     * 通过标量数值设置向量
     * @param num - 数值
     * @returns 向量
     */
    Vector4.prototype.setFromNumber = function (num) {
        this.x = num;
        this.y = num;
        this.z = num;
        this.w = num;
        return this;
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector4.prototype.setFromArray = function (array, offset) {
        var _a, _b, _c, _d;
        if (offset === void 0) { offset = 0; }
        this.x = (_a = array[offset]) !== null && _a !== void 0 ? _a : 0;
        this.y = (_b = array[offset + 1]) !== null && _b !== void 0 ? _b : 0;
        this.z = (_c = array[offset + 2]) !== null && _c !== void 0 ? _c : 0;
        this.w = (_d = array[offset + 3]) !== null && _d !== void 0 ? _d : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param v - 复制对象
     * @returns 拷贝结果
     */
    Vector4.prototype.copyFrom = function (v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    };
    /**
     * 克隆向量
     * @returns 克隆结果
     */
    Vector4.prototype.clone = function () {
        return new Vector4(this.x, this.y, this.z, this.w);
    };
    /**
     * 根据下标设置向量分量
     * @param index - 下标值
     * @param value - 分量值
     * @returns 向量
     */
    Vector4.prototype.setElement = function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default: console.error('index is out of range: ' + index);
        }
        return this;
    };
    /**
     * 根据下标获取向量分量
     * @param index - 下标
     * @returns 分量值
     */
    Vector4.prototype.getElement = function (index) {
        switch (index) {
            case 0: return this.x;
            case 1: return this.y;
            case 2: return this.z;
            case 3: return this.w;
            default: console.error('index is out of range: ' + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 相加对象，向量 | 数字
     * @returns 相加结果
     */
    Vector4.prototype.add = function (right) {
        if (typeof right === 'number') {
            this.x += right;
            this.y += right;
            this.z += right;
            this.w += right;
        }
        else if (right instanceof Array) {
            this.x += right[0];
            this.y += right[1];
            this.z += right[2];
            this.w += right[3];
        }
        else {
            this.x += right.x;
            this.y += right.y;
            this.z += right.z;
            this.w += right.w;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 求和结果
     */
    Vector4.prototype.addVectors = function (left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        this.w = left.w + right.w;
        return this;
    };
    /**
     * 向量比例缩放后相加
     * @param right - 向量
     * @param s - 比例
     * @returns 求和结果
     */
    Vector4.prototype.addScaledVector = function (right, s) {
        this.x += right.x * s;
        this.y += right.y * s;
        this.z += right.z * s;
        this.w += right.w * s;
        return this;
    };
    /**
     * 向量相减
     * @param right - 相减对象，向量 | 数字
     * @returns 相减结果
     */
    Vector4.prototype.subtract = function (right) {
        if (typeof right === 'number') {
            this.x -= right;
            this.y -= right;
            this.z -= right;
            this.w -= right;
        }
        else if (right instanceof Array) {
            this.x -= right[0];
            this.y -= right[1];
            this.z -= right[2];
            this.w -= right[3];
        }
        else {
            this.x -= right.x;
            this.y -= right.y;
            this.z -= right.z;
            this.w -= right.w;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 向量
     */
    Vector4.prototype.subtractVectors = function (left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        this.z = left.z - right.z;
        this.w = left.w - right.w;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 相乘对象，对象 | 数字
     * @returns 向量
     */
    Vector4.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            this.x *= right;
            this.y *= right;
            this.z *= right;
            this.w *= right;
        }
        else if (right instanceof Array) {
            this.x *= right[0];
            this.y *= right[1];
            this.z *= right[2];
            this.w *= right[3];
        }
        else {
            this.x *= right.x;
            this.y *= right.y;
            this.z *= right.z;
            this.w *= right.w;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 向量
     */
    Vector4.prototype.multiplyVectors = function (left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        this.z = left.z * right.z;
        this.w = left.w * right.w;
        return this;
    };
    /**
     * 向量相除
     * @param right - 相除对象，对象 | 数字
     * @returns 向量
     */
    Vector4.prototype.divide = function (right) {
        if (typeof right === 'number') {
            this.x /= right;
            this.y /= right;
            this.z /= right;
            this.w /= right;
        }
        else if (right instanceof Array) {
            this.x /= right[0];
            this.y /= right[1];
            this.z /= right[2];
            this.w /= right[3];
        }
        else {
            this.x /= right.x;
            this.y /= right.y;
            this.z /= right.z;
            this.w /= right.w;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */
    Vector4.prototype.scale = function (v) {
        this.x *= v;
        this.y *= v;
        this.z *= v;
        this.w *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */
    Vector4.prototype.sum = function () {
        return this.x + this.y + this.z + this.w;
    };
    /**
     * 向量求最小值
     * @param v - 向量或数值
     * @returns 最小值
     */
    Vector4.prototype.min = function (v) {
        if (typeof v === 'number') {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
            this.z = Math.min(this.z, v);
            this.w = Math.min(this.w, v);
        }
        else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量或数值
     * @returns 最大值
     */
    Vector4.prototype.max = function (v) {
        if (typeof v === 'number') {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
            this.z = Math.max(this.z, v);
            this.w = Math.max(this.w, v);
        }
        else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 最小值
     * @param max - 最大值
     * @returns 向量
     */
    Vector4.prototype.clamp = function (min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */
    Vector4.prototype.floor = function () {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */
    Vector4.prototype.ceil = function () {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    };
    /**
     * 向量四舍五入
     * @returns 求值结果
     */
    Vector4.prototype.round = function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */
    Vector4.prototype.abs = function () {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        this.z = Math.abs(this.z);
        this.w = Math.abs(this.w);
        return this;
    };
    /**
     * 向量取反
     * @returns 取反结果
     */
    Vector4.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    };
    /**
     * 向量长度平方
     * @returns 长度平方
     */
    Vector4.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    /**
     * 向量长度
     * @returns 长度
     */
    Vector4.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    /**
     * 向量归一化
     * @returns 归一化结果
     */
    Vector4.prototype.normalize = function () {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */
    Vector4.prototype.setLength = function (length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量求线性插值
     * @param v - 向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */
    Vector4.prototype.lerp = function (v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    };
    /**
     * 两向量求线性插值
     * @param v1 - 第一个向量
     * @param v2 - 第二个向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */
    Vector4.prototype.lerpVectors = function (v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    };
    /**
     * 向量求点积
     * @param v - 向量
     * @returns 点积结果
     */
    Vector4.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */
    Vector4.prototype.equals = function (v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */
    Vector4.prototype.isZero = function () {
        var _a;
        var eps = NumberEpsilon;
        var x = (_a = this, _a.x), y = _a.y, z = _a.z, w = _a.w;
        return Math.abs(x) <= eps && Math.abs(y) <= eps && Math.abs(z) <= eps && Math.abs(w) <= eps;
    };
    /**
     * 向量转数组
     * @returns 数组
     */
    Vector4.prototype.toArray = function () {
        return [this.x, this.y, this.z, this.w];
    };
    Vector4.prototype.toVector3 = function () {
        return new Vector3(this.x, this.y, this.z);
    };
    Vector4.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
    };
    /**
     * 生成随机向量
     * @returns 向量
     */
    Vector4.prototype.random = function () {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    };
    /**
     * 变换矩阵作用于向量
     * @param m - 变换矩阵
     * @param [out] - 输出结果，如果没有设置就直接覆盖当前值
     * @returns 向量
     */
    Vector4.prototype.applyMatrix = function (m, out) {
        return m.transformVector4(this, out);
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */
    Vector4.fromNumber = function (num) {
        return new Vector4().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */
    Vector4.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Vector4().setFromArray(array, offset);
    };
    /**
     * 四维向量的常量
     */
    Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
    Vector4.ZERO = new Vector4(0.0, 0.0, 0.0, 0.0);
    return Vector4;
}());

var __read$1 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * 三维矩阵（列优先矩阵）
 */
var Matrix3 = /** @class */ (function () {
    /**
     * 构造函数，初始值为零矩阵
     * @param [m11=1] - 第 1 行，第 1 列
     * @param [m21=0] - 第 2 行，第 1 列
     * @param [m31=0] - 第 3 行，第 1 列
     * @param [m12=0] - 第 1 行，第 2 列
     * @param [m22=1] - 第 2 行，第 2 列
     * @param [m32=0] - 第 3 行，第 2 列
     * @param [m13=0] - 第 1 行，第 3 列
     * @param [m23=0] - 第 2 行，第 3 列
     * @param [m33=1] - 第 3 行，第 3 列
     */
    function Matrix3(m11, m21, m31, m12, m22, m32, m13, m23, m33) {
        if (m11 === void 0) { m11 = 1; }
        if (m21 === void 0) { m21 = 0; }
        if (m31 === void 0) { m31 = 0; }
        if (m12 === void 0) { m12 = 0; }
        if (m22 === void 0) { m22 = 1; }
        if (m32 === void 0) { m32 = 0; }
        if (m13 === void 0) { m13 = 0; }
        if (m23 === void 0) { m23 = 0; }
        if (m33 === void 0) { m33 = 1; }
        this.elements = [
            m11, m21, m31,
            m12, m22, m32,
            m13, m23, m33,
        ];
    }
    /**
     * 设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m21 - 第 2 行，第 1 列
     * @param m31 - 第 3 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m22 - 第 2 行，第 2 列
     * @param m32 - 第 3 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m23 - 第 2 行，第 3 列
     * @param m33 - 第 3 行，第 3 列
     * @returns
     */
    Matrix3.prototype.set = function (m11, m21, m31, m12, m22, m32, m13, m23, m33) {
        var e = this.elements;
        e[0] = m11;
        e[3] = m12;
        e[6] = m13;
        e[1] = m21;
        e[4] = m22;
        e[7] = m23;
        e[2] = m31;
        e[5] = m32;
        e[8] = m33;
        return this;
    };
    /**
     * 设置矩阵通过行优先数据
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @returns 矩阵
     */
    Matrix3.prototype.setFromRowMajorData = function (m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[3] = m12;
        e[6] = m13;
        e[1] = m21;
        e[4] = m22;
        e[7] = m23;
        e[2] = m31;
        e[5] = m32;
        e[8] = m33;
        return this;
    };
    /**
     * 通过列向量设置矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @returns 矩阵
     */
    Matrix3.prototype.setFromColumnVectors = function (c1, c2, c3) {
        return this.set(c1.x, c1.y, c1.z, c2.x, c2.y, c2.z, c3.x, c3.y, c3.z);
    };
    /**
     * 通过四阶矩阵设置三阶矩阵
     * @param m - 四阶矩阵
     * @returns 矩阵
     */
    Matrix3.prototype.setFromMatrix4 = function (m) {
        var me = m.elements;
        return this.set(me[0], me[1], me[2], me[4], me[5], me[6], me[8], me[9], me[10]);
    };
    /**
     * 通过数组设置矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */
    Matrix3.prototype.setFromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        for (var i = 0; i < 9; i++) {
            this.elements[i] = array[offset + i];
        }
        return this;
    };
    /**
     * 通过四元数设置矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */
    Matrix3.prototype.setFromQuaternion = function (quat) {
        var x = quat.x, y = quat.y, z = quat.z, w = quat.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var te = this.elements;
        te[0] = 1 - (yy + zz);
        te[1] = xy + wz;
        te[2] = xz - wy;
        te[3] = xy - wz;
        te[4] = 1 - (xx + zz);
        te[5] = yz + wx;
        te[6] = xz + wy;
        te[7] = yz - wx;
        te[8] = 1 - (xx + yy);
        return this;
    };
    /**
     * 矩阵清零
     * @returns 零矩阵
     */
    Matrix3.prototype.setZero = function () {
        for (var i = 0; i < 9; i++) {
            this.elements[i] = 0;
        }
        return this;
    };
    /**
     * 矩阵单位化
     * @returns 单位矩阵
     */
    Matrix3.prototype.identity = function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    };
    /**
     * 矩阵克隆
     * @returns 克隆结果
     */
    Matrix3.prototype.clone = function () {
        var e = this.elements;
        return new Matrix3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    };
    /**
     * 矩阵复制
     * @param m - 复制对象
     * @returns 复制结果
     */
    Matrix3.prototype.copyFrom = function (m) {
        this.elements = __spreadArray([], __read$1(m.elements), false);
        return this;
    };
    /**
     * 得到列向量
     * @param i - 列向量索引，从 0 开始
     * @returns 列向量
     */
    Matrix3.prototype.getColumnVector = function (i, v) {
        return v.set(this.elements[i * 3], this.elements[i * 3 + 1], this.elements[i * 3 + 2]);
    };
    /**
     * 矩阵缩放
     * @param sx - x 轴缩放分量
     * @param sy - y 轴缩放分量
     * @returns 缩放结果
     */
    Matrix3.prototype.scale = function (sx, sy) {
        var e = this.elements;
        e[0] *= sx;
        e[3] *= sx;
        e[6] *= sx;
        e[1] *= sy;
        e[4] *= sy;
        e[7] *= sy;
        return this;
    };
    /**
     * 矩阵旋转
     * @param theta - 旋转角度（弧度）
     * @returns 旋转结果
     */
    Matrix3.prototype.rotate = function (theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var e = this.elements;
        var m11 = e[0], m12 = e[3], m13 = e[6];
        var m21 = e[1], m22 = e[4], m23 = e[7];
        e[0] = c * m11 + s * m21;
        e[3] = c * m12 + s * m22;
        e[6] = c * m13 + s * m23;
        e[1] = -s * m11 + c * m21;
        e[4] = -s * m12 + c * m22;
        e[7] = -s * m13 + c * m23;
        return this;
    };
    /**
     * 矩阵平移
     * @param x - x 轴平移分量
     * @param y - y 轴平移分量
     * @returns 平移结果
     */
    Matrix3.prototype.translate = function (x, y) {
        var e = this.elements;
        e[0] += x * e[2];
        e[3] += x * e[5];
        e[6] += x * e[8];
        e[1] += y * e[2];
        e[4] += y * e[5];
        e[7] += y * e[8];
        return this;
    };
    /**
     * 矩阵右乘
     * @param right - 相乘矩阵
     * @returns 右乘结果
     */
    Matrix3.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            for (var i = 0; i < 9; i++) {
                this.elements[i] *= right;
            }
            return this;
        }
        else {
            return this.multiplyMatrices(this, right);
        }
    };
    /**
     * 矩阵左乘
     * @param left - 相乘矩阵
     * @returns 左乘结果
     */
    Matrix3.prototype.premultiply = function (left) {
        return this.multiplyMatrices(left, this);
    };
    /**
     * 矩阵乘法
     * @param left - 矩阵
     * @param right - 矩阵
     * @returns 相乘结果
     */
    Matrix3.prototype.multiplyMatrices = function (left, right) {
        var ae = left.elements;
        var be = right.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[3], a13 = ae[6];
        var a21 = ae[1], a22 = ae[4], a23 = ae[7];
        var a31 = ae[2], a32 = ae[5], a33 = ae[8];
        var b11 = be[0], b12 = be[3], b13 = be[6];
        var b21 = be[1], b22 = be[4], b23 = be[7];
        var b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    };
    /**
     * 矩阵求行列式值
     * @returns 行列式结果
     */
    Matrix3.prototype.determinant = function () {
        var e = this.elements;
        var m11 = e[0], m21 = e[3], m31 = e[6];
        var m12 = e[1], m22 = e[4], m32 = e[7];
        var m13 = e[2], m23 = e[5], m33 = e[8];
        return (m11 * (m22 * m33 - m23 * m32) +
            m12 * (m23 * m31 - m21 * m33) +
            m13 * (m21 * m32 - m22 * m31));
    };
    /**
     * 矩阵求逆
     * @returns 逆矩阵
     */
    Matrix3.prototype.invert = function () {
        var e = this.elements;
        var m11 = e[0], m12 = e[3], m13 = e[6];
        var m21 = e[1], m22 = e[4], m23 = e[7];
        var m31 = e[2], m32 = e[5], m33 = e[8];
        var t11 = m33 * m22 - m32 * m23;
        var t12 = m32 * m13 - m33 * m12;
        var t13 = m23 * m12 - m22 * m13;
        var det = m11 * t11 + m21 * t12 + m31 * t13;
        if (det === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        var detInv = 1 / det;
        e[0] = t11 * detInv;
        e[1] = (m31 * m23 - m33 * m21) * detInv;
        e[2] = (m32 * m21 - m31 * m22) * detInv;
        e[3] = t12 * detInv;
        e[4] = (m33 * m11 - m31 * m13) * detInv;
        e[5] = (m31 * m12 - m32 * m11) * detInv;
        e[6] = t13 * detInv;
        e[7] = (m21 * m13 - m23 * m11) * detInv;
        e[8] = (m22 * m11 - m21 * m12) * detInv;
        return this;
    };
    /**
     * 矩阵转置
     * @returns 转置结果
     */
    Matrix3.prototype.transpose = function () {
        var t;
        var m = this.elements;
        t = m[1];
        m[1] = m[3];
        m[3] = t;
        t = m[2];
        m[2] = m[6];
        m[6] = t;
        t = m[5];
        m[5] = m[7];
        m[7] = t;
        return this;
    };
    /**
     * 对点进行矩阵变换
     * @param v - 输入点
     * @param out - 输出点，如果没有会覆盖输入的数据
     * @returns 变换后的结果
     */
    Matrix3.prototype.transformPoint = function (v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out !== null && out !== void 0 ? out : v;
        res.x = e[0] * x + e[3] * y + e[6] * z;
        res.y = e[1] * x + e[4] * y + e[7] * z;
        res.z = e[2] * x + e[5] * y + e[8] * z;
        return res;
    };
    /**
     * 对法向量进行矩阵变换
     * @param v - 输入向量
     * @param out - 输出向量，如果没有会覆盖输入的数据
     * @returns 变换后的结果
     */
    Matrix3.prototype.transformNormal = function (v, out) {
        return this.transformPoint(v, out).normalize();
    };
    /**
     * 矩阵判等
     * @param matrix - 矩阵
     * @returns 判等结果
     */
    Matrix3.prototype.equals = function (matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 9; i++) {
            if (!isEqual(te[i], me[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * 矩阵转为数组
     * @returns
     */
    Matrix3.prototype.toArray = function () {
        return __spreadArray([], __read$1(this.elements), false);
    };
    Matrix3.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        var e = this.elements;
        array[offset] = e[0];
        array[offset + 1] = e[1];
        array[offset + 2] = e[2];
        array[offset + 3] = e[3];
        array[offset + 4] = e[4];
        array[offset + 5] = e[5];
        array[offset + 6] = e[6];
        array[offset + 7] = e[7];
        array[offset + 8] = e[8];
    };
    /**
     * 创建单位阵
     * @returns 单位矩阵
     */
    Matrix3.fromIdentity = function () {
        return new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    };
    /**
     * 通过列向量创建矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @returns 矩阵
     */
    Matrix3.fromColumnVectors = function (c1, c2, c3) {
        return new Matrix3().setFromColumnVectors(c1, c2, c3);
    };
    /**
     * 通过四阶矩阵创建矩阵（获取空间变换矩阵旋转缩放部分）
     * @param m - 四阶矩阵
     * @returns 矩阵
     */
    Matrix3.fromMatrix4 = function (m) {
        return new Matrix3().setFromMatrix4(m);
    };
    /**
     * 通过数组创建矩阵
     * @param array - 数组（列优先）
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */
    Matrix3.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Matrix3().setFromArray(array, offset);
    };
    /**
     * 通过四元数创建矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */
    Matrix3.fromQuaternion = function (quat) {
        return new Matrix3().setFromQuaternion(quat);
    };
    /**
     * 设置矩阵通过行优先数据
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @returns 矩阵
     */
    Matrix3.fromRowMajorData = function (m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        return new Matrix3(m11, m21, m31, m12, m22, m32, m13, m23, m33);
    };
    return Matrix3;
}());

/**
 * 光线类
 */
var Ray = /** @class */ (function () {
    /**
     * 构造函数
     * @param [origin] - 原点，默认是 (0, 0, 0)
     * @param [direction] - 方向，默认是 (1, 0, 0)
     */
    function Ray(origin, direction) {
        if (origin === void 0) { origin = Vector3.ZERO; }
        if (direction === void 0) { direction = Vector3.X; }
        /**
         * 光线的原点
         */
        this.origin = new Vector3();
        /**
         * 光线的方向
         */
        this.direction = new Vector3();
        // 注意这里必须拷贝
        this.origin.copyFrom(origin);
        this.direction.copyFrom(direction).normalize();
    }
    /**
     * 光线设置
     * @param origin - 原点
     * @param direction - 方向
     * @returns
     */
    Ray.prototype.set = function (origin, direction) {
        this.origin.copyFrom(origin);
        this.direction.copyFrom(direction).normalize();
        return this;
    };
    /**
     * 光线克隆
     * @returns 克隆结果
     */
    Ray.prototype.clone = function () {
        return new Ray(this.origin, this.direction);
    };
    /**
     * 光线拷贝
     * @param ray - 要拷贝对象
     * @returns 拷贝结果
     */
    Ray.prototype.copyFrom = function (ray) {
        return this.set(ray.origin, ray.direction);
    };
    /**
     * 根据t计算新的光线原点
     * @param t - 光线的系数 t
     * @returns
     */
    Ray.prototype.recast = function (t) {
        this.origin.copyFrom(this.at(t, Ray.tempVec0));
        return this;
    };
    /**
     * 根据t值计算光线上的点
     * @param t - 光线的系数 t
     * @param [out] - 计算的点
     * @returns
     */
    Ray.prototype.at = function (t, out) {
        var ret = out ? out : new Vector3();
        ret.copyFrom(this.origin);
        return ret.addScaledVector(this.direction, t);
    };
    /**
     * 光线相等判断
     * @param other - 其他对象
     * @returns
     */
    Ray.prototype.equals = function (other) {
        return this.origin.equals(other.origin) && this.direction.equals(other.direction);
    };
    /**
     * 根据矩阵对光线进行变换
     * @param m - 变换矩阵
     * @returns
     */
    Ray.prototype.applyMatrix = function (m) {
        this.origin.applyProjectionMatrix(m);
        this.direction.applyNormalMatrix(m);
        return this;
    };
    /**
     * 光线和包围盒求交
     * @param box - 类包围盒对象
     * @param [out] - 交点
     * @returns
     */
    Ray.prototype.intersectBox = function (box, out) {
        var _a, _b, _c, _d;
        var ox = (_a = this.origin, _a.x), oy = _a.y, oz = _a.z;
        var dx = (_b = this.direction, _b.x), dy = _b.y, dz = _b.z;
        var bxmin = (_c = box.min, _c.x), bymin = _c.y, bzmin = _c.z;
        var bxmax = (_d = box.max, _d.x), bymax = _d.y, bzmax = _d.z;
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / dx;
        var invdiry = 1 / dy;
        var invdirz = 1 / dz;
        if (invdirx >= 0) {
            tmin = (bxmin - ox) * invdirx;
            tmax = (bxmax - ox) * invdirx;
        }
        else {
            tmin = (bxmax - ox) * invdirx;
            tmax = (bxmin - ox) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (bymin - oy) * invdiry;
            tymax = (bymax - oy) * invdiry;
        }
        else {
            tymin = (bymax - oy) * invdiry;
            tymax = (bymin - oy) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax)) {
            return;
        }
        if (tymin > tmin || tmin !== tmin) {
            tmin = tymin;
        }
        if (tymax < tmax || tmax !== tmax) {
            tmax = tymax;
        }
        if (tymin > tmin || tmin !== tmin) {
            tmin = tymin;
        }
        if (tymax < tmax || tmax !== tmax) {
            tmax = tymax;
        }
        if (invdirz >= 0) {
            tzmin = (bzmin - oz) * invdirz;
            tzmax = (bzmax - oz) * invdirz;
        }
        else {
            tzmin = (bzmax - oz) * invdirz;
            tzmax = (bzmin - oz) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax)) {
            return;
        }
        if (tzmin > tmin || tmin !== tmin) {
            tmin = tzmin;
        }
        if (tzmax < tmax || tmax !== tmax) {
            tmax = tzmax;
        }
        if (tmax < 0) {
            return;
        }
        return tmin >= 0 ? this.at(tmin, out) : this.at(tmax, out);
    };
    /**
     * 光线和平面求交
     * @param plane - 类平面对象
     * @param [out] - 交点
     * @returns
     */
    Ray.prototype.intersectPlane = function (plane, out) {
        var normal = plane.normal;
        var distance = plane.distance;
        var denominator = normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            var t_1 = normal.dot(this.origin) + distance;
            if (t_1 === 0) {
                var ret = out ? out : new Vector3();
                return ret.copyFrom(this.origin);
            }
            // Null is preferable to undefined since undefined means.... it is undefined
            return;
        }
        var t = -(this.origin.dot(normal) + distance) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? this.at(t, out) : undefined;
    };
    /**
     * 光线和圆求交
     * @param sphere - 类球对象
     * @param [out] - 交点
     * @returns
     */
    Ray.prototype.intersectSphere = function (sphere, out) {
        var center = sphere.center;
        var vector = Ray.tempVec0.subtractVectors(center, this.origin);
        var tca = vector.dot(this.direction);
        var d2 = vector.dot(vector) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) {
            return;
        }
        var thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        var t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        var t1 = tca + thc;
        // test to see if t1 is behind the ray - if so, return null
        if (t1 < 0) {
            return;
        }
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return t0 >= 0 ? this.at(t0, out) : this.at(t1, out);
    };
    /**
     * 光线和三角形求交
     * @param triangle - 类三角形对象
     * @param [out] - 交点
     * @param [backfaceCulling] - 是否背面剔除
     * @returns
     */
    Ray.prototype.intersectTriangle = function (triangle, out, backfaceCulling) {
        // FIXME: 交换out和backfaceCulling
        // Compute the offset origin, edges, and normal.
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        var a = triangle.p0;
        var b = triangle.p1;
        var c = triangle.p2;
        var edge1 = Ray.tempVec0.subtractVectors(b, a);
        var edge2 = Ray.tempVec1.subtractVectors(c, a);
        var diff = Ray.tempVec2.subtractVectors(this.origin, a);
        var normal = Ray.tempVec3.crossVectors(edge1, edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        var DdN = this.direction.dot(normal);
        var sign;
        if (DdN > 0) {
            if (backfaceCulling) {
                return;
            }
            sign = 1;
        }
        else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        }
        else {
            return;
        }
        edge2.crossVectors(diff, edge2);
        var DdQxE2 = sign * this.direction.dot(edge2);
        // b1 < 0, no intersection
        if (DdQxE2 < 0) {
            return;
        }
        edge1.cross(diff);
        var DdE1xQ = sign * this.direction.dot(edge1);
        // b2 < 0, no intersection
        if (DdE1xQ < 0) {
            return;
        }
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) {
            return;
        }
        // Line intersects triangle, check if ray does.
        var QdN = -sign * diff.dot(normal);
        // t < 0, no intersection
        if (QdN < 0) {
            return;
        }
        // Ray intersects triangle.
        return this.at(QdN / DdN, out);
    };
    Ray.tempVec0 = new Vector3();
    Ray.tempVec1 = new Vector3();
    Ray.tempVec2 = new Vector3();
    Ray.tempVec3 = new Vector3();
    return Ray;
}());

var Color = /** @class */ (function () {
    /**
     * 构造函数，默认值为黑色
     * @param [r=0]
     * @param [g=0]
     * @param [b=0]
     * @param [a=0]
     */
    function Color(r, g, b, a) {
        if (r === void 0) { r = 0; }
        if (g === void 0) { g = 0; }
        if (b === void 0) { b = 0; }
        if (a === void 0) { a = 0; }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * 设置颜色
     * @param r - r 分量
     * @param g - g 分量
     * @param b - b 分量
     * @param a - a 分量
     * @returns
     */
    Color.prototype.set = function (r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
    };
    /**
     * 设置零颜色
     * @returns
     */
    Color.prototype.setZero = function () {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        return this;
    };
    /**
     * 通过标量数值设置颜色
     * @param num - 数值
     * @returns
     */
    Color.prototype.setFromNumber = function (num) {
        this.r = num;
        this.g = num;
        this.b = num;
        this.a = num;
        return this;
    };
    /**
     * 通过Vector4创建颜色
     * @param v - Vector4
     * @returns
     */
    Color.prototype.setFromVector4 = function (v) {
        this.r = v.x;
        this.g = v.y;
        this.b = v.z;
        this.a = v.w;
        return this;
    };
    /**
     * 通过数组创建颜色
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */
    Color.prototype.setFromArray = function (array, offset) {
        var _a, _b, _c, _d;
        if (offset === void 0) { offset = 0; }
        this.r = (_a = array[offset]) !== null && _a !== void 0 ? _a : 0;
        this.g = (_b = array[offset + 1]) !== null && _b !== void 0 ? _b : 0;
        this.b = (_c = array[offset + 2]) !== null && _c !== void 0 ? _c : 0;
        this.a = (_d = array[offset + 3]) !== null && _d !== void 0 ? _d : 0;
        return this;
    };
    Color.prototype.setFromHSV = function (hue, saturation, value, alpha) {
        if (alpha === void 0) { alpha = 1; }
        var chroma = value * saturation;
        var h = hue / 60;
        var x = chroma * (1 - Math.abs((h % 2) - 1));
        var r = 0;
        var g = 0;
        var b = 0;
        if (h >= 0 && h <= 1) {
            r = chroma;
            g = x;
        }
        else if (h >= 1 && h <= 2) {
            r = x;
            g = chroma;
        }
        else if (h >= 2 && h <= 3) {
            g = chroma;
            b = x;
        }
        else if (h >= 3 && h <= 4) {
            g = x;
            b = chroma;
        }
        else if (h >= 4 && h <= 5) {
            r = x;
            b = chroma;
        }
        else if (h >= 5 && h <= 6) {
            r = chroma;
            b = x;
        }
        var m = value - chroma;
        return this.set(r + m, g + m, b + m, alpha);
    };
    Color.prototype.setFromHexString = function (hex) {
        if (hex.substring(0, 1) !== '#' || (hex.length !== 9 && hex.length !== 7)) {
            return this;
        }
        var r = parseInt(hex.substring(1, 3), 16) / 255.0;
        var g = parseInt(hex.substring(3, 5), 16) / 255.0;
        var b = parseInt(hex.substring(5, 7), 16) / 255.0;
        var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) / 255.0 : 1.0;
        return this.set(r, g, b, a);
    };
    /**
     * 拷贝颜色
     * @param v - 复制对象
     * @returns 拷贝结果
     */
    Color.prototype.copyFrom = function (v) {
        this.r = v.r;
        this.g = v.g;
        this.b = v.b;
        this.a = v.a;
        return this;
    };
    /**
     * 克隆颜色
     * @returns 克隆结果
     */
    Color.prototype.clone = function () {
        return new Color(this.r, this.g, this.b, this.a);
    };
    /**
     * 根据下标设置颜色分量
     * @param index - 下标值
     * @param value - 分量值
     * @returns
     */
    Color.prototype.setElement = function (index, value) {
        switch (index) {
            case 0:
                this.r = value;
                break;
            case 1:
                this.g = value;
                break;
            case 2:
                this.b = value;
                break;
            case 3:
                this.a = value;
                break;
            default: console.error('index is out of range: ' + index);
        }
        return this;
    };
    /**
     * 根据下标获取颜色分量
     * @param index - 下标
     * @returns 分量值
     */
    Color.prototype.getElement = function (index) {
        switch (index) {
            case 0: return this.r;
            case 1: return this.g;
            case 2: return this.b;
            case 3: return this.a;
            default: console.error('index is out of range: ' + index);
        }
        return 0;
    };
    /**
     * 颜色相加
     * @param right - 相加对象，颜色 | 数字
     * @returns 相加结果
     */
    Color.prototype.add = function (right) {
        if (typeof right === 'number') {
            this.r += right;
            this.g += right;
            this.b += right;
            this.a += right;
        }
        else if (right instanceof Array) {
            this.r += right[0];
            this.g += right[1];
            this.b += right[2];
            this.a += right[3];
        }
        else {
            this.r += right.r;
            this.g += right.g;
            this.b += right.b;
            this.a += right.a;
        }
        return this;
    };
    /**
     * 颜色相减
     * @param right - 相减对象，颜色 | 数字
     * @returns 相减结果
     */
    Color.prototype.subtract = function (right) {
        if (typeof right === 'number') {
            this.r -= right;
            this.g -= right;
            this.b -= right;
            this.a -= right;
        }
        else if (right instanceof Array) {
            this.r -= right[0];
            this.g -= right[1];
            this.b -= right[2];
            this.a -= right[3];
        }
        else {
            this.r -= right.r;
            this.g -= right.g;
            this.b -= right.b;
            this.a -= right.a;
        }
        return this;
    };
    /**
     * 颜色相乘
     * @param right - 相乘对象，对象 | 数字
     * @returns 颜色
     */
    Color.prototype.multiply = function (right) {
        if (typeof right === 'number') {
            this.r *= right;
            this.g *= right;
            this.b *= right;
            this.a *= right;
        }
        else if (right instanceof Array) {
            this.r *= right[0];
            this.g *= right[1];
            this.b *= right[2];
            this.a *= right[3];
        }
        else {
            this.r *= right.r;
            this.g *= right.g;
            this.b *= right.b;
            this.a *= right.a;
        }
        return this;
    };
    /**
     * 颜色相除
     * @param right - 相除对象，对象 | 数字
     * @returns 颜色
     */
    Color.prototype.divide = function (right) {
        if (typeof right === 'number') {
            this.r /= right;
            this.g /= right;
            this.b /= right;
            this.a /= right;
        }
        else if (right instanceof Array) {
            this.r /= right[0];
            this.g /= right[1];
            this.b /= right[2];
            this.a /= right[3];
        }
        else {
            this.r /= right.r;
            this.g /= right.g;
            this.b /= right.b;
            this.a /= right.a;
        }
        return this;
    };
    /**
     * 颜色缩放
     * @param v - 数字
     * @returns 缩放结果
     */
    Color.prototype.scale = function (v) {
        this.r *= v;
        this.g *= v;
        this.b *= v;
        this.a *= v;
        return this;
    };
    /**
     * 颜色求最小值
     * @param v - 颜色或数值
     * @returns 最小值
     */
    Color.prototype.min = function (v) {
        if (typeof v === 'number') {
            this.r = Math.min(this.r, v);
            this.g = Math.min(this.g, v);
            this.b = Math.min(this.b, v);
            this.a = Math.min(this.a, v);
        }
        else {
            this.r = Math.min(this.r, v.r);
            this.g = Math.min(this.g, v.g);
            this.b = Math.min(this.b, v.b);
            this.a = Math.min(this.a, v.a);
        }
        return this;
    };
    /**
     * 颜色求最大值
     * @param v - 颜色或数值
     * @returns 最大值
     */
    Color.prototype.max = function (v) {
        if (typeof v === 'number') {
            this.r = Math.max(this.r, v);
            this.g = Math.max(this.g, v);
            this.b = Math.max(this.b, v);
            this.a = Math.max(this.a, v);
        }
        else {
            this.r = Math.max(this.r, v.r);
            this.g = Math.max(this.g, v.g);
            this.b = Math.max(this.b, v.b);
            this.a = Math.max(this.a, v.a);
        }
        return this;
    };
    /**
     * 颜色阈值约束
     * @param min - 最小值
     * @param max - 最大值
     * @returns 颜色
     */
    Color.prototype.clamp = function (min, max) {
        return this.max(min).min(max);
    };
    /**
     * 颜色求线性插值
     * @param v - 颜色
     * @param alpha - 插值比例
     * @returns 插值结果
     */
    Color.prototype.lerp = function (v, alpha) {
        this.r += (v.r - this.r) * alpha;
        this.g += (v.g - this.g) * alpha;
        this.b += (v.b - this.b) * alpha;
        this.a += (v.a - this.a) * alpha;
        return this;
    };
    /**
     * 计算颜色亮度值
     * @returns 亮度值
     */
    Color.prototype.luminance = function () {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
    };
    /**
     * 颜色判等
     * @param v - 颜色
     * @returns 判等结果
     */
    Color.prototype.equals = function (v) {
        return v.r === this.r && v.g === this.g && v.b === this.b && v.a === this.a;
    };
    Color.prototype.toLinear = function () {
        this.r = Color.gammaToLinear(this.r);
        this.g = Color.gammaToLinear(this.g);
        this.b = Color.gammaToLinear(this.b);
        return this;
    };
    Color.prototype.toGamma = function () {
        this.r = Color.linearToGamma(this.r);
        this.g = Color.linearToGamma(this.g);
        this.b = Color.linearToGamma(this.b);
        return this;
    };
    /**
     * 颜色转数组
     * @returns 数组
     */
    Color.prototype.toArray = function () {
        return [this.r, this.g, this.b, this.a];
    };
    Color.prototype.toVector4 = function () {
        return new Vector4$1(this.r, this.g, this.b, this.a);
    };
    /**
     * RGB 颜色空间转 HSV
     * @param result HSV 值
     */
    Color.prototype.toHSV = function () {
        var _a;
        var r = (_a = this, _a.r), g = _a.g, b = _a.b, a = _a.a;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var v = max;
        var dm = max - min;
        var h = 0;
        var s = 0;
        if (max !== 0) {
            s = dm / max;
        }
        if (max != min) {
            if (max == r) {
                h = (g - b) / dm;
                if (g < b) {
                    h += 6;
                }
            }
            else if (max == g) {
                h = (b - r) / dm + 2;
            }
            else if (max == b) {
                h = (r - g) / dm + 4;
            }
            h *= 60;
        }
        return new Color(h, s, v, a);
    };
    Color.prototype.toHexString = function (includeAlpha) {
        if (includeAlpha === void 0) { includeAlpha = true; }
        var R = Color.ToHex(Math.round(this.r * 255));
        var G = Color.ToHex(Math.round(this.g * 255));
        var B = Color.ToHex(Math.round(this.b * 255));
        var A = Color.ToHex(Math.round(this.a * 255));
        if (includeAlpha) {
            return '#' + R + G + B + A;
        }
        else {
            return '#' + R + G + B;
        }
    };
    Color.prototype.fill = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        array[offset + 3] = this.a;
    };
    /**
     * 通过标量数值创建颜色
     * @param num - 数值
     * @returns
     */
    Color.fromNumber = function (num) {
        return new Color().setFromNumber(num);
    };
    /**
     * 通过数组创建颜色
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */
    Color.fromArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        return new Color().setFromArray(array, offset);
    };
    /**
     * 通过 hex 字符串创建颜色
     * @param hex - hex 字符串
     * @returns
     */
    Color.fromHexString = function (hex) {
        return new Color().setFromHexString(hex);
    };
    Color.fromHSV = function (hue, saturation, value, alpha) {
        if (alpha === void 0) { alpha = 1; }
        return new Color().setFromHSV(hue, saturation, value, alpha);
    };
    /**
     * 颜色值从 Gamma 空间转到线性空间
     * @param v - Gamma 空间颜色值
     * @returns 线性空间颜色值
     */
    Color.gammaToLinear = function (v) {
        if (v <= 0.0) {
            return 0.0;
        }
        else if (v <= 0.04045) {
            return v / 12.92;
        }
        else if (v < 1.0) {
            return Math.pow((v + 0.055) / 1.055, 2.4);
        }
        else {
            return Math.pow(v, 2.4);
        }
    };
    /**
     * 颜色值从线性空间转到 Gamma 空间
     * @param value - 线性空间颜色值
     * @returns Gamma 空间颜色值
     */
    Color.linearToGamma = function (value) {
        if (value <= 0.0) {
            return 0.0;
        }
        else if (value < 0.0031308) {
            return 12.92 * value;
        }
        else if (value < 1.0) {
            return 1.055 * Math.pow(value, 0.41666) - 0.055;
        }
        else {
            return Math.pow(value, 0.41666);
        }
    };
    Color.ToHex = function (i) {
        var str = i.toString(16);
        if (i <= 15) {
            return ('0' + str).toUpperCase();
        }
        return str.toUpperCase();
    };
    /**
     * 颜色的常量
     */
    Color.BLACK = new Color(0, 0, 0, 1); // 纯黑色
    Color.BLUE = new Color(0, 0, 1, 1); // 纯蓝色
    Color.CLEAR = new Color(0, 0, 0, 0); // 完全透明
    Color.CYAN = new Color(0, 1, 1, 1); // 青色
    Color.GRAY = new Color(0.5, 0.5, 0.5, 1); // 灰色
    Color.GREEN = new Color(0, 1, 0, 1); // 纯绿色
    Color.MAGENTA = new Color(1, 0, 1, 1); // 洋红色
    Color.RED = new Color(1, 0, 0, 1); // 纯红色
    Color.WHITE = new Color(1, 1, 1, 1); // 纯白色
    Color.YELLOW = new Color(1, 0.92, 0.016, 1); // 黄色
    return Color;
}());

/**
 * 三维包围盒
 */
var Box3 = /** @class */ (function () {
    /**
     * 构造函数，传入值为空时表示空包围盒
     * @param [min=new Vector3(Infinity)] - 最小角点
     * @param [max=new Vector3(-Infinity)] - 最大角点
     */
    function Box3(min, max) {
        if (min === void 0) { min = new Vector3(Infinity, Infinity, Infinity); }
        if (max === void 0) { max = new Vector3(-Infinity, -Infinity, -Infinity); }
        this.min = min.clone();
        this.max = max.clone();
    }
    /**
     * 设置三维包围盒的值
     * @param min - 三维包围盒最小点
     * @param max - 三维包围盒最大点
     * @returns
     */
    Box3.prototype.set = function (min, max) {
        this.min.copyFrom(min);
        this.max.copyFrom(max);
        return this;
    };
    /**
     * 通过数组构建三维包围盒
     * @param array - 数组集合（每三个数视为一个三维空间点）
     * @returns 三维包围盒
     */
    Box3.prototype.setFromArray = function (array) {
        var minX = Number(Infinity);
        var minY = Number(Infinity);
        var minZ = Number(Infinity);
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for (var i = 0, l = array.length; i < l; i += 3) {
            var x = array[i];
            var y = array[i + 1];
            var z = array[i + 2];
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (z < minZ) {
                minZ = z;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
            if (z > maxZ) {
                maxZ = z;
            }
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    };
    /**
     * 通过三维空间点构建三维包围盒
     * @param points - 三维空间点集合
     * @returns 三维包围盒
     */
    Box3.prototype.setFromPoints = function (points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
            this.expandByPoint(points[i]);
        }
        return this;
    };
    /**
     * 通过三维空间点（包围盒中心）和大小确定包围盒
     * @param center - 三维包围盒中心点
     * @param size - 三维包围盒大小值
     * @returns 三维包围盒
     */
    Box3.prototype.setFromCenterAndSize = function (center, size) {
        var halfSize = size.clone().multiply(0.5);
        this.min.copyFrom(center).subtract(halfSize);
        this.max.copyFrom(center).add(halfSize);
        return this;
    };
    // TODO
    /**
     * 通过实体构建包围盒
     * @param object - 构件实体
     * @returns 三维包围盒
     */
    Box3.prototype.setFromObject = function (object) {
        this.makeEmpty();
        return this.expandByObject(object);
    };
    /**
     * 克隆三维包围盒
     * @returns 克隆结果
     */
    Box3.prototype.clone = function () {
        return new Box3().copyFrom(this);
    };
    /**
     * 复制三维包围盒
     * @param box - 复制对象
     * @returns 复制结果
     */
    Box3.prototype.copyFrom = function (box) {
        this.min.copyFrom(box.min);
        this.max.copyFrom(box.max);
        return this;
    };
    /**
     * 三维包围盒置空
     * @returns 置空结果
     */
    Box3.prototype.makeEmpty = function () {
        this.min.x = this.min.y = this.min.z = Number(Infinity);
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    };
    /**
     * 三维包围盒判空
     * @returns 判空结果
     */
    Box3.prototype.isEmpty = function () {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x
            || this.max.y < this.min.y
            || this.max.z < this.min.z;
    };
    /**
     * 获取三维包围盒中心
     * @param [target=new Vector3()]
     * @returns
     */
    Box3.prototype.getCenter = function (target) {
        if (target === void 0) { target = new Vector3(); }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiply(0.5);
    };
    /**
     * 获取三维包围盒大小
     * @param [target=new Vector3()] - 结果保存对象
     * @returns 三维包围盒大小
     */
    Box3.prototype.getSize = function (target) {
        if (target === void 0) { target = new Vector3(); }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subtractVectors(this.max, this.min);
    };
    /**
     * 通过三维空间点扩展三维包围盒
     * @param point - 三维空间点
     * @returns 扩展结果
     */
    Box3.prototype.expandByPoint = function (point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    };
    /**
     * 通过三维向量扩展三维包围盒
     * @param vector - 三维向量
     * @returns 扩展结果
     */
    Box3.prototype.expandByVector = function (vector) {
        this.min.subtract(vector);
        this.max.add(vector);
        return this;
    };
    /**
     * 通过实数扩展三维包围盒
     * @param scalar - 扩展大小
     * @returns 扩展结果
     */
    Box3.prototype.expandByScalar = function (scalar) {
        this.min.add(-scalar);
        this.max.add(scalar);
        return this;
    };
    /**
     * 通过包围盒扩展三维包围盒
     * @param box
     * @returns
     */
    Box3.prototype.expandByBox = function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    // TODO
    /**
     * 通过实体扩展三维包围盒
     * @param object - 构件实体
     * @returns 扩展结果
     */
    Box3.prototype.expandByObject = function (object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        var geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
            }
            var box3 = new Box3();
            box3.copyFrom(geometry.boundingBox);
            box3.applyMatrix4(object.matrixWorld);
            this.union(box3);
        }
        var children = object.children;
        for (var i = 0, l = children.length; i < l; i++) {
            this.expandByObject(children[i]);
        }
        return this;
    };
    /**
     * 判断三维包围盒相交关系(if this intersect other)
     * @param point - 三维空间点
     * @returns 点包含判断结果
     */
    Box3.prototype.containsPoint = function (point) {
        return !(point.x < this.min.x
            || point.x > this.max.x
            || point.y < this.min.y
            || point.y > this.max.y
            || point.z < this.min.z
            || point.z > this.max.z);
    };
    /**
     * 判断三维包围盒与三维包围盒的包含关系
     * @param other - 三维包围盒
     * @returns 包围盒包含结果（true 表示包含 other, false 表示不包含 other）
     */
    Box3.prototype.containsBox = function (other) {
        return this.min.x <= other.min.x
            && this.max.x >= other.max.x
            && this.min.y <= other.min.y
            && this.max.y >= other.max.y
            && this.min.z <= other.min.z
            && this.max.z >= other.max.z;
    };
    // TODO
    /**
     * 获取点在三维包围盒的比例位置
     * @param point - 三维空间点
     * @param [target=new Vector3()] - 结果保存对象
     * @returns 点在包围盒比例位置
     */
    Box3.prototype.getParameter = function (point, target) {
        if (target === void 0) { target = new Vector3(); }
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    };
    /**
     * 判断三维包围盒相交关系(if this intersect other)
     * @param other - 三维包围盒
     * @returns 相交判断结果
     */
    Box3.prototype.intersectsBox = function (other) {
        // using 6 splitting planes to rule out intersections.
        return !(other.max.x < this.min.x || other.min.x > this.max.x
            || other.max.y < this.min.y || other.min.y > this.max.y
            || other.max.z < this.min.z || other.min.z > this.max.z);
    };
    /**
     * 判断三维包围盒和球是否相交
     * @param sphere
     * @returns
     */
    Box3.prototype.intersectsSphere = function (sphere) {
        // Find the point on the AABB closest to the sphere center.
        var vector = new Vector3();
        this.clampPoint(sphere.center, vector);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return vector.distanceSquared(sphere.center) <= (sphere.radius * sphere.radius);
    };
    /**
     * 求点与三维包围盒的最近点
     * @param point - 三维空间点
     * @param [target=new Vector3()] - 结果存放对象
     * @returns 计算结果
     */
    Box3.prototype.clampPoint = function (point, target) {
        if (target === void 0) { target = new Vector3(); }
        return target.copyFrom(point).clamp(this.min, this.max);
    };
    /**
     * 三维空间点到三维包围盒的距离
     * @param point - 三维包围盒
     * @returns 距离结果
     */
    Box3.prototype.distanceToPoint = function (point) {
        var clampedPoint = point.clone().clamp(this.min, this.max);
        return clampedPoint.subtract(point).length();
    };
    /**
     * 三维包围盒求交集
     * @param box - 三维包围盒
     * @returns 求交结果
     */
    Box3.prototype.intersect = function (box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) {
            this.makeEmpty();
        }
        return this;
    };
    /**
     * 三维包围盒求并集
     * @param box - 三维包围盒
     * @returns 求并结果
     */
    Box3.prototype.union = function (box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    /**
     * 通过三维变换矩阵变化三维包围盒
     * @param matrix - 三维变换矩阵
     * @returns 变换结果
     */
    Box3.prototype.applyMatrix4 = function (matrix, center) {
        if (center === void 0) { center = new Vector3(); }
        // transform of empty box is an empty box.
        if (this.isEmpty()) {
            return this;
        }
        var points = this.getOBBPoints(matrix, center);
        this.setFromPoints(points);
        return this;
    };
    Box3.prototype.getOBBPoints = function (matrix, center) {
        if (center === void 0) { center = new Vector3(); }
        // transform of empty box is an empty box.
        if (this.isEmpty()) {
            return [];
        }
        var points = [];
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        points[0] = new Vector3(this.min.x, this.min.y, this.min.z); // 000
        points[1] = new Vector3(this.min.x, this.min.y, this.max.z); // 001
        points[2] = new Vector3(this.min.x, this.max.y, this.min.z); // 010
        points[3] = new Vector3(this.min.x, this.max.y, this.max.z); // 011
        points[4] = new Vector3(this.max.x, this.min.y, this.min.z); // 100
        points[5] = new Vector3(this.max.x, this.min.y, this.max.z); // 101
        points[6] = new Vector3(this.max.x, this.max.y, this.min.z); // 110
        points[7] = new Vector3(this.max.x, this.max.y, this.max.z); // 111
        points.forEach(function (p) {
            p.subtract(center);
            p.applyMatrix(matrix);
            p.add(center);
        });
        return points;
    };
    /**
     * 通过包围盒获取包围球
     * @param target
     * @returns
     */
    Box3.prototype.getBoundingSphere = function (target) {
        this.getCenter(target.center);
        var vector = new Vector3();
        target.radius = this.getSize(vector).length() * 0.5;
        return target;
    };
    /**
     * 三维包围盒位移
     * @param offset - 三维位移向量
     * @returns 位移结果
     */
    Box3.prototype.translate = function (offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    };
    /**
     * 三维包围盒判等
     * @param other - 三维包围盒
     * @returns 判等结果
     */
    Box3.prototype.equals = function (other) {
        return other.min.equals(this.min) && other.max.equals(this.max);
    };
    return Box3;
}());

/**
 * 球
 */
var Sphere$1 = /** @class */ (function () {
    /**
     * 构造函数
     * @param [center=Vector3.ZERO] - 球心，默认值为(0, 0, 0)
     * @param [radius=-1] - 半径
     */
    function Sphere(center, radius) {
        if (center === void 0) { center = Vector3.ZERO; }
        if (radius === void 0) { radius = -1; }
        this.center = center.clone();
        this.radius = radius;
    }
    /**
     * 通过参数设置球
     * @param center - 球心
     * @param radius - 半径
     * @returns
     */
    Sphere.prototype.set = function (center, radius) {
        this.center.copyFrom(center);
        this.radius = radius;
        return this;
    };
    /**
     * 通过空间点与球心设置球
     * @param points - 三维空间点
     * @param [optionalCenter] - 指定球心
     * @returns
     */
    Sphere.prototype.setFromPoints = function (points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== undefined) {
            center.copyFrom(optionalCenter);
            var maxRadiusSq = 0;
            for (var i = 0; i < points.length; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
        }
        else {
            var box = new Box3().setFromPoints(points);
            box.getCenter(center);
            this.radius = box.getSize().length() / 2;
        }
        return this;
    };
    /**
     * 复制球
     * @param sphere - 球信息
     * @returns 复制结果
     */
    Sphere.prototype.copyFrom = function (sphere) {
        this.center.copyFrom(sphere.center);
        this.radius = sphere.radius;
        return this;
    };
    /**
     * 球判空
     * @returns 判空结果
     */
    Sphere.prototype.isEmpty = function () {
        return this.radius < 0;
    };
    /**
     * 球置空
     * @returns 置空结果
     */
    Sphere.prototype.makeEmpty = function () {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    };
    /**
     * 三维空间点包围判断
     * @param point - 三维空间点
     * @returns 空间点包含判断
     */
    Sphere.prototype.containsPoint = function (point) {
        return point.distanceSquared(this.center) <= (this.radius * this.radius);
    };
    /**
     * 空间点与球表面的最短距离
     * @param point - 三维空间点
     * @returns 距离结果
     */
    Sphere.prototype.distanceToPoint = function (point) {
        return (point.distance(this.center) - this.radius);
    };
    /**
     * 与球相交判断
     * @param sphere - 球
     * @returns 相交判断结果
     */
    Sphere.prototype.intersectsSphere = function (sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceSquared(this.center) <= (radiusSum * radiusSum);
    };
    /**
     * 与包围盒相交判断
     * @param box - 三维包围盒
     * @returns 相交判断结果
     */
    Sphere.prototype.intersectsBox = function (box) {
        return box.intersectsSphere(this);
    };
    /**
     * 收敛空间点在球范围内
     * 注：乘法的效率要比开方高很多
     * @param point - 三维空间点
     * @param [target] - 结果保存对象
     * @returns 收敛结果
     */
    Sphere.prototype.clampPoint = function (point, target) {
        var deltaLengthSq = this.center.distanceSquared(point);
        if (target === undefined) {
            target = new Vector3();
        }
        target.copyFrom(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
            target.subtract(this.center).normalize();
            target.multiply(this.radius).add(this.center);
        }
        return target;
    };
    /**
     * 根据包围盒获取球
     * @param target - 包围盒
     * @returns 球
     */
    Sphere.prototype.getBoundingBox = function (target) {
        if (target === undefined) {
            target = new Box3();
        }
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    };
    /**
     * 球空间变换
     * @param matrix - 空间变化矩阵
     * @returns 变换结果
     */
    Sphere.prototype.applyMatrix4 = function (matrix) {
        var mt = matrix.elements;
        var scaleXSq = mt[0] * mt[0] + mt[1] * mt[1] + mt[2] * mt[2];
        var scaleYSq = mt[4] * mt[4] + mt[5] * mt[5] + mt[6] * mt[6];
        var scaleZSq = mt[8] * mt[8] + mt[9] * mt[9] + mt[10] * mt[10];
        var maxScale = Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        this.center.applyMatrix(matrix);
        this.radius = this.radius * maxScale;
        return this;
    };
    /**
     * 球位移
     * @param offset - 位移信息
     * @returns 位移结果
     */
    Sphere.prototype.translate = function (offset) {
        this.center.add(offset);
        return this;
    };
    /**
     * 通过三维空间点对球进行扩展
     * @param point - 扩展点
     * @returns 扩展结果
     */
    Sphere.prototype.expandByPoint = function (point) {
        var vector = new Vector3().subtractVectors(point, this.center);
        var lengthSquared = vector.lengthSquared();
        if (lengthSquared > (this.radius * this.radius)) {
            var length_1 = Math.sqrt(lengthSquared);
            var missingRadiusHalf = (length_1 - this.radius) * 0.5;
            // Nudge this sphere towards the target point. Add half the missing distance to radius,
            // and the other half to position. This gives a tighter enclosure, instead of if
            // the whole missing distance were just added to radius.
            this.center.add(vector.multiply(missingRadiusHalf / length_1));
            this.radius += missingRadiusHalf;
        }
        return this;
    };
    /**
     * 包围球求并集
     * @param sphere - 包围球
     * @returns 求并结果
     */
    Sphere.prototype.union = function (sphere) {
        // To enclose another sphere into this sphere, we only need to enclose two points:
        // 1) Enclose the farthest point on the other sphere into this sphere.
        // 2) Enclose the opposite point of the farthest point into this sphere.
        var v1 = new Vector3();
        var toFarthestPoint = new Vector3();
        toFarthestPoint.subtractVectors(sphere.center, this.center).normalize().multiply(sphere.radius);
        this.expandByPoint(v1.copyFrom(sphere.center).add(toFarthestPoint));
        this.expandByPoint(v1.copyFrom(sphere.center).subtract(toFarthestPoint));
        return this;
    };
    /**
     * 包围球求交集
     * @param other - 其它包围球
     * @returns 求交结果
     */
    Sphere.prototype.intersect = function (other) {
        var vector = new Vector3().subtractVectors(this.center, other.center);
        var distance = vector.length();
        var radiusSum = this.radius + other.radius;
        if (distance > radiusSum) {
            return this.makeEmpty();
        }
        this.center = this.center.add(vector.normalize().multiply(distance / 2));
        this.radius = this.radius + other.radius - distance;
        return this;
    };
    /**
     * 包围球判等
     * @param sphere - 包围球
     * @returns 判等结果
     */
    Sphere.prototype.equals = function (sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
    };
    /**
     * 包围球克隆
     * @returns 克隆结果
     */
    Sphere.prototype.clone = function () {
        return new Sphere().copyFrom(this);
    };
    return Sphere;
}());

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get EulerOrder () { return EulerOrder; },
    Euler: Euler,
    Quaternion: Quaternion,
    Vector2: Vector2,
    Vector3: Vector3,
    Vector4: Vector4$1,
    Matrix3: Matrix3,
    Matrix4: Matrix4$1,
    Ray: Ray,
    PI2: PI2,
    DEG2RAD: DEG2RAD,
    RAD2DEG: RAD2DEG,
    NumberEpsilon: NumberEpsilon,
    isZero: isZero,
    isEqual: isEqual,
    damp: damp,
    lerp: lerp,
    degToRad: degToRad,
    radToDeg: radToDeg,
    clamp: clamp$1,
    Color: Color,
    Box3: Box3,
    Sphere: Sphere$1
});

var toHalf = (function () {
    var floatView = new Float32Array(1);
    var int32View = new Int32Array(floatView.buffer);
    /* This method is faster than the OpenEXR implementation (very often
     * used, eg. in Ogre), with the additional benefit of rounding, inspired
     * by James Tursa?s half-precision code. */
    return function toHalf(val) {
        floatView[0] = val;
        var x = int32View[0];
        var bits = (x >> 16) & 0x8000; /* Get the sign */
        var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */
        var e = (x >> 23) & 0xff; /* Using int is faster here */
        /* If zero, or denormal, or exponent underflows too much for a denormal
         * half, return signed zero. */
        if (e < 103) {
            return bits;
        }
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
        if (e > 142) {
            bits |= 0x7c00;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
             * not Inf, so make sure we set one mantissa bit too. */
            bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */
        if (e < 113) {
            m |= 0x0800;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
             * to 1, which is OK. */
            bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
            return bits;
        }
        bits |= ((e - 112) << 10) | (m >> 1);
        /* Extra rounding. An overflow will set mantissa to 0 and increment
         * the exponent, which is OK. */
        bits += m & 1;
        return bits;
    };
}());
var Float16ArrayWrapper = /** @class */ (function () {
    function Float16ArrayWrapper(num) {
        if (Number.isInteger(num)) {
            this.data = new Uint16Array(num);
        }
        else if (num && typeof num === 'object' && Number.isInteger(num.length)) {
            var data = this.data = new Uint16Array(num.length);
            for (var i = 0; i < data.length; i++) {
                data[i] = toHalf(num[i]);
            }
        }
    }
    Float16ArrayWrapper.prototype.set = function (number, startIndex) {
        for (var i = 0; i < number.length; i++) {
            this.data[i + startIndex] = toHalf(number[i]);
        }
    };
    return Float16ArrayWrapper;
}());

function translatePoint(x, y) {
    var origin = [-.5, .5, -.5, -.5, .5, .5, .5, -.5];
    for (var i = 0; i < 8; i += 2) {
        origin[i] += x;
        origin[i + 1] += y;
    }
    return origin;
}
var tempEuler$1 = new Euler();
var tempMat4$3 = new Matrix4$1();
function calculateTranslation(out, target, acc, time, duration, posData, velData) {
    var ret = out;
    var lifetime = time / duration;
    var speedIntegrate = time;
    var speedOverLifetime = target.speedOverLifetime;
    if (speedOverLifetime) {
        speedIntegrate = speedOverLifetime.getIntegrateValue(0, time, duration);
    }
    var d = target.gravityModifier ? target.gravityModifier.getIntegrateByTime(0, time) : 0;
    ret.copyFrom(posData);
    ret.addScaledVector(velData, speedIntegrate);
    ret.addScaledVector(acc, d);
    var linearVelocityOverLifetime = target.linearVelOverLifetime || {};
    var orbVelOverLifetime = target.orbitalVelOverLifetime || {};
    var map = ['x', 'y', 'z'];
    if (orbVelOverLifetime.enabled) {
        var center = new Vector3();
        if (orbVelOverLifetime.center) {
            center.setFromArray(orbVelOverLifetime.center);
        }
        var pos = ret.clone().subtract(center);
        var asRotation_1 = orbVelOverLifetime.asRotation;
        var orbVel = map.map(function (pro) {
            var value = orbVelOverLifetime[pro];
            if (value) {
                return (asRotation_1 ? value.getValue(lifetime) : value.getIntegrateValue(0, time, duration));
            }
            return 0;
        });
        tempEuler$1.setFromArray(orbVel).negate();
        tempMat4$3.setFromEuler(tempEuler$1);
        var rot = tempMat4$3.transformPoint(pos);
        ret.addVectors(center, rot);
    }
    if (linearVelocityOverLifetime.enabled) {
        var asMovement = linearVelocityOverLifetime.asMovement;
        for (var i = 0; i < 3; i++) {
            var pro = linearVelocityOverLifetime[map[i]];
            if (pro) {
                var val = asMovement ? pro.getValue(lifetime) : pro.getIntegrateValue(0, time, duration);
                ret.setElement(i, ret.getElement(i) + val);
            }
        }
    }
    return ret;
}

var _a$9;
function ensureVec3(num) {
    return Array.isArray(num) ? [num[0], num[1], num[2]] : [0, 0, 0];
}
function vecFill(out, number) {
    for (var i = 0, len = out.length; i < len; i++) {
        out[i] = number;
    }
    return out;
}
function vecAssign(out, a, count, start) {
    if (start === void 0) { start = 0; }
    for (var i = 0; i < count; i++) {
        out[i] = a[i + start];
    }
    return out;
}
function vecNormalize(out, a) {
    if (arguments.length === 1) {
        a = out;
        out = [];
    }
    var ap = a;
    var sum = Math.hypot.apply(Math, __spreadArray$2([], __read$3(ap), false));
    if (sum === 0) {
        return vecAssign(out, ap, ap.length);
    }
    for (var i = 0; i < ap.length; i++) {
        out[i] = ap[i] / sum;
    }
    return out;
}
function vecMulCombine(out, a, b) {
    if (a && b) {
        for (var i = 0, len = a.length; i < len; i++) {
            out[i] = a[i] * b[i];
        }
    }
    else if (a) {
        if (out !== a) {
            for (var i = 0; i < a.length; i++) {
                out[i] = a[i];
            }
        }
    }
    else if (b) {
        if (out !== b) {
            for (var i = 0; i < b.length; i++) {
                out[i] = b[i];
            }
        }
    }
    return out;
}
var particleOriginTranslateMap = (_a$9 = {},
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER] = [0, 0],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER_BOTTOM] = [0, -0.5],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_CENTER_TOP] = [0, 0.5],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_TOP] = [-0.5, 0.5],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_CENTER] = [-0.5, 0],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_LEFT_BOTTOM] = [-0.5, -0.5],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_CENTER] = [0.5, 0],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_BOTTOM] = [0.5, -0.5],
    _a$9[ParticleOrigin$1.PARTICLE_ORIGIN_RIGHT_TOP] = [0.5, 0.5],
    _a$9);
/**
 * 提取并转换 JSON 数据中的 anchor 值
 */
function convertAnchor(anchor, particleOrigin) {
    if (anchor) {
        return [anchor[0] - 0.5, 0.5 - anchor[1]];
    }
    else if (particleOrigin) {
        return particleOriginTranslateMap[particleOrigin];
    }
    else {
        return [0, 0];
    }
}
function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
}
function setRayFromCamera(x, y, camera) {
    var origin = camera.position;
    var direction = new Vector3(x, y, 0);
    var dir = new Vector3();
    var mat = camera.getInverseViewProjectionMatrix();
    mat.projectPoint(direction, dir);
    dir.subtract(origin);
    return new Ray(origin, dir);
}
function trianglesFromRect(position, halfWidth, halfHeight) {
    var x = position.x, y = position.y, z = position.z;
    var p0 = new Vector3(x - halfWidth, y + halfHeight, z);
    var p1 = new Vector3(x - halfWidth, y - halfHeight, z);
    var p2 = new Vector3(x + halfWidth, y - halfHeight, z);
    var p3 = new Vector3(x + halfWidth, y + halfHeight, z);
    return [
        { p0: p0, p1: p1, p2: p2 },
        { p0: p0.clone(), p1: p2.clone(), p2: p3 },
    ];
}
function decimalEqual(a, b, epsilon) {
    if (epsilon === void 0) { epsilon = 0.000001; }
    return Math.abs(a - b) < epsilon;
}
function numberToFix(a, fixed) {
    if (fixed === void 0) { fixed = 2; }
    var base = Math.pow(10, fixed);
    return Math.floor(a * base) / base;
}
function pointOnLine(x1, y1, x2, y2, x3, y3) {
    var det1 = (x1 * y2) + (y1 * x3) + (x2 * y3) - (x3 * y2) - (y3 * x1) - (x2 * y1);
    return det1 > -0.001 && det1 < 0.001;
}

var keyframeInfo = {
    /**
     * 根据不同关键帧类型，获取位于曲线上的点
     */
    getPointInCurve: function (keyframe) {
        var _a = __read$3(keyframe, 2); _a[0]; var data = _a[1];
        var _b = this.getPointIndexInCurve(keyframe), xIndex = _b.xIndex, yIndex = _b.yIndex;
        var time = data[xIndex];
        var value = data[yIndex];
        return new Vector2(time, value);
    },
    /**
     * 根据不同关键帧类型，获取位于曲线上的点的索引
     */
    getPointIndexInCurve: function (keyframe) {
        var _a = __read$3(keyframe, 3), type = _a[0], markType = _a[2];
        // 不同类型，存放的时间不同
        var index = type === BezierKeyframeType$1.LINE ? 0
            : type === BezierKeyframeType$1.EASE_OUT ? 0
                : type === BezierKeyframeType$1.EASE_IN ? 2
                    : type === BezierKeyframeType$1.EASE ? 2
                        : type === BezierKeyframeType$1.HOLD ? (markType === BezierKeyframeType$1.EASE_IN ? 2 : 0)
                            : 0;
        return { xIndex: index, yIndex: index + 1 };
    },
    /**
     * 关键帧左侧是否为缓动类型（否则为线段）
     */
    isLeftSideEase: function (keyframe) {
        var _a = __read$3(keyframe, 3), keyframeType = _a[0]; _a[1]; var markType = _a[2];
        // 定格关键帧的左侧类型，需要借助markType判断
        if (keyframeType === BezierKeyframeType$1.HOLD && this.isKeyframeTypeLeftSideEase(markType)) {
            return true;
        }
        return this.isKeyframeTypeLeftSideEase(keyframeType);
    },
    /**
     * 关键帧右侧是否为缓动类型（否则为线段）
     */
    isRightSideEase: function (keyframe) {
        var _a = __read$3(keyframe, 3), keyframeType = _a[0]; _a[1]; var markType = _a[2];
        // 定格关键帧的右侧类型，需要借助markType判断
        if (keyframeType === BezierKeyframeType$1.HOLD && this.isKeyframeTypeRightSideEase(markType)) {
            return true;
        }
        return this.isKeyframeTypeRightSideEase(keyframeType);
    },
    /**
     * 关键帧左侧是否为缓动类型（否则为线段）
     */
    isKeyframeTypeLeftSideEase: function (keyframeType) {
        return [BezierKeyframeType$1.EASE, BezierKeyframeType$1.EASE_IN, BezierKeyframeType$1.AUTO].includes(keyframeType);
    },
    /**
     * 关键帧右侧是否为缓动类型（否则为线段）
     */
    isKeyframeTypeRightSideEase: function (keyframeType) {
        return [BezierKeyframeType$1.EASE, BezierKeyframeType$1.EASE_OUT, BezierKeyframeType$1.AUTO].includes(keyframeType);
    },
    /**
     * 是否为定格进关键帧
     */
    isHoldInKeyframe: function (keyframe) {
        var _a = __read$3(keyframe, 3), keyframeType = _a[0]; _a[1]; var leftSubType = _a[2];
        return keyframeType === BezierKeyframeType$1.HOLD && [BezierKeyframeType$1.HOLD, BezierKeyframeType$1.LINE_OUT, BezierKeyframeType$1.EASE_OUT].includes(leftSubType);
    },
    /**
     * 是否为定格出关键帧
     */
    isHoldOutKeyframe: function (keyframe) {
        var _a = __read$3(keyframe, 3), keyframeType = _a[0]; _a[1]; var leftSubType = _a[2];
        return keyframeType === BezierKeyframeType$1.HOLD && [BezierKeyframeType$1.HOLD, BezierKeyframeType$1.LINE, BezierKeyframeType$1.EASE_IN].includes(leftSubType);
    },
};

var BezierLengthData = /** @class */ (function () {
    function BezierLengthData(points, totalLength) {
        this.points = points;
        this.totalLength = totalLength;
    }
    return BezierLengthData;
}());
var BezierMap = {};
var BezierDataMap = {};
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var CURVE_SEGMENTS = 300;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
function A(a1, a2) { return 1.0 - 3.0 * a2 + 3.0 * a1; }
function B(a1, a2) { return 3.0 * a2 - 6.0 * a1; }
function C(a1) { return 3.0 * a1; }
// A * t ^ 3 + B * t ^ 2 + C * t
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(t, a1, a2) {
    return ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(t, a1, a2) {
    return 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
// de Casteljau算法构建曲线
/**
 * @param p1 起始点
 * @param p2 终点
 * @param p3 起始控制点
 * @param p4 终止控制点
 * @returns
 */
function buildBezierData(p1, p2, p3, p4) {
    // 使用平移后的终点、控制点作为key
    var s1 = numberToFix(p2.x - p1.x, 3) + '_' + numberToFix(p2.y - p1.y, 3) + '_' + numberToFix(p2.z - p1.z, 3);
    var s2 = numberToFix(p3.x - p1.x, 3) + '_' + numberToFix(p3.y - p1.y, 3) + '_' + numberToFix(p3.z - p1.z, 3);
    var s3 = numberToFix(p4.x - p1.x, 3) + '_' + numberToFix(p4.y - p1.y, 3) + '_' + numberToFix(p4.z - p1.z, 3);
    var str = s1 + '&' + s2 + '&' + s3;
    if (BezierDataMap[str]) {
        return {
            data: BezierDataMap[str],
            interval: p1,
        };
    }
    else {
        var samples = [];
        var lastPoint = null, addedLength = 0, ptDistance = 0;
        var curveSegments = CURVE_SEGMENTS;
        for (var k = 0; k < curveSegments; k += 1) {
            var point = new Vector3();
            var perc = k / (curveSegments - 1);
            ptDistance = 0;
            point.x = 3 * Math.pow(1 - perc, 2) * perc * (p3.x - p1.x) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.x - p1.x) + Math.pow(perc, 3) * (p2.x - p1.x);
            point.y = 3 * Math.pow(1 - perc, 2) * perc * (p3.y - p1.y) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.y - p1.y) + Math.pow(perc, 3) * (p2.y - p1.y);
            point.z = 3 * Math.pow(1 - perc, 2) * perc * (p3.z - p1.z) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.z - p1.z) + Math.pow(perc, 3) * (p2.z - p1.z);
            if (lastPoint !== null) {
                ptDistance += Math.pow(point.x - lastPoint.x, 2);
                ptDistance += Math.pow(point.y - lastPoint.y, 2);
                ptDistance += Math.pow(point.z - lastPoint.z, 2);
            }
            lastPoint = point;
            ptDistance = Math.sqrt(ptDistance);
            addedLength += ptDistance;
            samples[k] = {
                partialLength: ptDistance,
                point: point,
            };
        }
        var data = new BezierLengthData(samples, addedLength);
        BezierDataMap[str] = data;
        return {
            data: data,
            interval: new Vector3(p1.x, p1.y, p1.z),
        };
    }
}
var BezierPath = /** @class */ (function () {
    function BezierPath(p1, p2, p3, p4) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
        this.p4 = p4;
        this.catching = {
            lastPoint: 0,
            lastAddedLength: 0,
        };
        var _a = buildBezierData(p1, p2, p3, p4), data = _a.data, interval = _a.interval;
        this.lengthData = data;
        this.interval = interval;
        this.totalLength = data.totalLength;
    }
    /**
     * 获取路径在指定比例长度上点的坐标
     * @param percent 路径长度的比例
     */
    BezierPath.prototype.getPointInPercent = function (percent) {
        var bezierData = this.lengthData;
        if (percent === 0) {
            return bezierData.points[0].point.clone().add(this.interval);
        }
        if (decimalEqual(1 - percent, 0)) {
            return bezierData.points[CURVE_SEGMENTS - 1].point.clone().add(this.interval);
        }
        if (decimalEqual(bezierData.totalLength, 0)) {
            return this.p1.clone();
        }
        var point = new Vector3();
        var segmentLength = numberToFix(bezierData.totalLength * percent, 4);
        var addedLength = this.catching.lastAddedLength;
        var j = this.catching.lastPoint;
        if (decimalEqual(addedLength, segmentLength)) {
            return bezierData.points[j].point.clone().add(this.interval);
        }
        var flag = true;
        var dir = 1;
        if (segmentLength < addedLength) {
            dir = -1;
        }
        while (flag) {
            if (segmentLength >= addedLength) {
                if (j === CURVE_SEGMENTS - 1) {
                    point.x = bezierData.points[j].point.x;
                    point.y = bezierData.points[j].point.y;
                    point.z = bezierData.points[j].point.z;
                    break;
                }
                if (segmentLength < addedLength + bezierData.points[j + 1].partialLength) {
                    var segmentPerc = (segmentLength - addedLength) / bezierData.points[j + 1].partialLength;
                    point.x = bezierData.points[j].point.x + (bezierData.points[j + 1].point.x - bezierData.points[j].point.x) * segmentPerc;
                    point.y = bezierData.points[j].point.y + (bezierData.points[j + 1].point.y - bezierData.points[j].point.y) * segmentPerc;
                    point.z = bezierData.points[j].point.z + (bezierData.points[j + 1].point.z - bezierData.points[j].point.z) * segmentPerc;
                    break;
                }
            }
            if (dir > 0 && j < (CURVE_SEGMENTS - 1)) {
                j += dir;
                addedLength += numberToFix(bezierData.points[j].partialLength, 5);
            }
            else if (dir < 0 && j > 0) {
                addedLength -= numberToFix(bezierData.points[j].partialLength, 5);
                j += dir;
            }
            else {
                flag = false;
            }
        }
        this.catching.lastPoint = j;
        this.catching.lastAddedLength = addedLength;
        point.add(this.interval);
        return point;
    };
    return BezierPath;
}());
var BezierEasing = /** @class */ (function () {
    function BezierEasing(mX1, mY1, mX2, mY2) {
        this.mX1 = mX1;
        this.mY1 = mY1;
        this.mX2 = mX2;
        this.mY2 = mY2;
        this.precomputed = false;
        this.mSampleValues = new Array(kSplineTableSize);
    }
    BezierEasing.prototype.precompute = function () {
        this.precomputed = true;
        if (this.mX1 !== this.mY1 || this.mX2 !== this.mY2) {
            this.calcSampleValues();
        }
    };
    BezierEasing.prototype.getValue = function (x) {
        if (this.mX1 === this.mY1 && this.mX2 === this.mY2) {
            return x;
        }
        if (isNaN(this.mY1) || isNaN(this.mY2)) {
            return 0;
        }
        if (x === 0 || x === 1) {
            return x;
        }
        if (!this.precomputed) {
            this.precompute();
        }
        var value = calcBezier(this.getTForX(x), this.mY1, this.mY2);
        return value;
    };
    BezierEasing.prototype.calcSampleValues = function () {
        for (var i = 0; i < kSplineTableSize; ++i) {
            this.mSampleValues[i] = calcBezier(i * kSampleStepSize, this.mX1, this.mX2);
        }
    };
    BezierEasing.prototype.getTForX = function (aX) {
        var mSampleValues = this.mSampleValues, lastSample = kSplineTableSize - 1;
        var intervalStart = 0, currentSample = 1;
        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, this.mX1, this.mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, this.mX1, this.mX2);
        }
        if (initialSlope === 0.0) {
            return guessForT;
        }
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, this.mX1, this.mX2);
    };
    return BezierEasing;
}());
function buildEasingCurve(leftKeyframe, rightKeyframe) {
    // 获取控制点和曲线类型
    var _a = getControlPoints(leftKeyframe, rightKeyframe, true), p0 = _a.p0, p1 = _a.p1, p2 = _a.p2, p3 = _a.p3;
    assertExist(p2);
    assertExist(p3);
    var timeInterval = p3.x - p0.x;
    var valueInterval = p3.y - p0.y;
    var y1, y2;
    var x1 = numberToFix((p1.x - p0.x) / timeInterval, 5);
    var x2 = numberToFix((p2.x - p0.x) / timeInterval, 5);
    if (decimalEqual(valueInterval, 0)) {
        y1 = y2 = NaN;
    }
    else {
        y1 = numberToFix((p1.y - p0.y) / valueInterval, 5);
        y2 = numberToFix((p2.y - p0.y) / valueInterval, 5);
    }
    if (x1 < 0) {
        console.error('invalid bezier points, x1 < 0', p0, p1, p2, p3);
        x1 = 0;
    }
    if (x2 < 0) {
        console.error('invalid bezier points, x2 < 0', p0, p1, p2, p3);
        x2 = 0;
    }
    if (x1 > 1) {
        console.error('invalid bezier points, x1 >= 1', p0, p1, p2, p3);
        x1 = 1;
    }
    if (x2 > 1) {
        console.error('invalid bezier points, x2 >= 1', p0, p1, p2, p3);
        x2 = 1;
    }
    var str = ('bez_' + x1 + '_' + y1 + '_' + x2 + '_' + y2).replace(/\./g, 'p');
    var bezEasing;
    if (BezierMap[str]) {
        bezEasing = BezierMap[str];
    }
    else {
        bezEasing = new BezierEasing(x1, y1, x2, y2);
        BezierMap[str] = bezEasing;
    }
    return {
        points: [p0, p1, p2, p3],
        timeInterval: timeInterval,
        valueInterval: valueInterval,
        curve: bezEasing,
    };
}
/**
 * 根据关键帧类型获取贝塞尔曲线上的关键点
 */
function getControlPoints(leftKeyframe, rightKeyframe, lineToBezier) {
    var _a = __read$3(leftKeyframe, 2), leftValue = _a[1];
    var leftHoldLine = keyframeInfo.isHoldOutKeyframe(leftKeyframe);
    var rightHoldLine = keyframeInfo.isHoldInKeyframe(rightKeyframe);
    var leftEase = !rightHoldLine && keyframeInfo.isRightSideEase(leftKeyframe);
    var rightEase = !leftHoldLine && keyframeInfo.isLeftSideEase(rightKeyframe);
    // 1. 左边为ease，右边为line（补充右边的控制点，该点在曲线上的点的偏左边位置）
    if (leftEase && !rightEase && !rightHoldLine) {
        var p0_1 = new Vector2(leftValue[leftValue.length - 4], leftValue[leftValue.length - 3]);
        var p1_1 = new Vector2(leftValue[leftValue.length - 2], leftValue[leftValue.length - 1]);
        var rightPoint = keyframeInfo.getPointInCurve(rightKeyframe);
        var p3 = new Vector2(rightPoint.x, rightPoint.y);
        var p2 = new Vector2(p3.x - (p3.x - p0_1.x) / 10, p3.y);
        return { type: 'ease', p0: p0_1, p1: p1_1, p2: p2, p3: p3 };
    }
    // 2. 左边为line，右边为ease（补充左边的控制点，该点在曲线上的点的偏右边位置）
    if (!leftEase && rightEase && !leftHoldLine) {
        var _b = __read$3(rightKeyframe, 2), rightValue = _b[1];
        var leftPoint = keyframeInfo.getPointInCurve(leftKeyframe);
        var p0_2 = new Vector2(leftPoint.x, leftPoint.y);
        var p2 = new Vector2(rightValue[0], rightValue[1]);
        var p3 = new Vector2(rightValue[2], rightValue[3]);
        var p1_2 = new Vector2(p0_2.x + (p3.x - p0_2.x) / 10, p0_2.y);
        return { type: 'ease', p0: p0_2, p1: p1_2, p2: p2, p3: p3 };
    }
    // 3. 左边为ease，右边为ease
    if (leftEase && rightEase) {
        var _c = __read$3(rightKeyframe, 2), rightValue = _c[1];
        var p0_3 = new Vector2(leftValue[leftValue.length - 4], leftValue[leftValue.length - 3]);
        var p1_3 = new Vector2(leftValue[leftValue.length - 2], leftValue[leftValue.length - 1]);
        var p2 = new Vector2(rightValue[0], rightValue[1]);
        var p3 = new Vector2(rightValue[2], rightValue[3]);
        return { type: 'ease', p0: p0_3, p1: p1_3, p2: p2, p3: p3 };
    }
    // 4. 左边为line，右边为line
    var p0 = keyframeInfo.getPointInCurve(leftKeyframe);
    var p1 = keyframeInfo.getPointInCurve(rightKeyframe);
    if (leftHoldLine) {
        p1.y = p0.y; // 定格关键帧使用相同的点
    }
    else if (rightHoldLine) {
        p0.y = p1.y;
    }
    if (lineToBezier) {
        // 补上两个在直线上的控制点
        var p2 = new Vector2((p1.x - p0.x) / 3 + p0.x, (p1.y - p0.y) / 3 + p0.y);
        var p3 = new Vector2((p1.x - p0.x) / 3 * 2 + p0.x, (p1.y - p0.y) / 3 * 2 + p0.y);
        return { type: 'ease', p0: p0, p1: p2, p2: p3, p3: p1, isHold: leftHoldLine || rightHoldLine, leftHoldLine: leftHoldLine, rightHoldLine: rightHoldLine };
    }
    else {
        return { type: 'line', p0: p0, p1: p1, isHold: leftHoldLine || rightHoldLine, leftHoldLine: leftHoldLine, rightHoldLine: rightHoldLine };
    }
}

var _a$8;
var NOT_IMPLEMENT = 'not_implement';
var ValueGetter = /** @class */ (function () {
    function ValueGetter(arg) {
        this.onCreate(arg);
    }
    ValueGetter.getAllData = function (meta, halfFloat) {
        var ret = new (halfFloat ? Float16ArrayWrapper : Float32Array)(meta.index * 4);
        for (var i = 0, cursor = 0, curves = meta.curves; i < curves.length; i++) {
            var data = curves[i].toData();
            ret.set(data, cursor);
            cursor += data.length;
        }
        return halfFloat ? ret.data : ret;
    };
    ValueGetter.prototype.onCreate = function (props) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getIntegrateValue = function (t0, t1, timeScale) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getIntegrateByTime = function (t0, time) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.getValue = function (time) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.toUniform = function (meta) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.map = function (func) {
        throw Error(NOT_IMPLEMENT);
    };
    ValueGetter.prototype.scaleXCoord = function (scale) {
        return this;
    };
    ValueGetter.prototype.toData = function () {
        throw Error(NOT_IMPLEMENT);
    };
    return ValueGetter;
}());
var StaticValue = /** @class */ (function (_super) {
    __extends(StaticValue, _super);
    function StaticValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StaticValue.prototype.onCreate = function (arg) {
        this.value = arg;
    };
    StaticValue.prototype.getIntegrateValue = function (t0, t1, ts) {
        return this.value * (t1 - t0);
    };
    StaticValue.prototype.getIntegrateByTime = function (t0, t1) {
        return 0.5 * this.value * (t1 * t1 - t0 * t0);
    };
    StaticValue.prototype.getValue = function (time) {
        return this.value;
    };
    StaticValue.prototype.toUniform = function () {
        return new Float32Array([0, this.value, 0, 0]);
    };
    StaticValue.prototype.map = function (func) {
        var val = this.value;
        this.value = func(val);
        return this;
    };
    return StaticValue;
}(ValueGetter));
var RandomSetValue = /** @class */ (function (_super) {
    __extends(RandomSetValue, _super);
    function RandomSetValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomSetValue.prototype.onCreate = function (arg) {
        this.items = arg;
    };
    RandomSetValue.prototype.getValue = function (t) {
        var items = this.items;
        return items[Math.floor(Math.random() * items.length)];
    };
    RandomSetValue.prototype.map = function (func) {
        this.items = this.items.map(func);
        return this;
    };
    return RandomSetValue;
}(ValueGetter));
var RandomValue = /** @class */ (function (_super) {
    __extends(RandomValue, _super);
    function RandomValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
    };
    RandomValue.prototype.getValue = function (time) {
        return random(this.min, this.max);
    };
    RandomValue.prototype.toUniform = function () {
        return new Float32Array([4, this.min, this.max, 0]);
    };
    RandomValue.prototype.map = function (func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    return RandomValue;
}(ValueGetter));
var RandomVectorValue = /** @class */ (function (_super) {
    __extends(RandomVectorValue, _super);
    function RandomVectorValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RandomVectorValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
    };
    RandomVectorValue.prototype.getValue = function (time) {
        var min = this.min;
        var max = this.max;
        var ret = [];
        for (var i = 0; i < min.length; i++) {
            var t = Math.random();
            ret[i] = min[i] * (1 - t) + max[i] * t;
        }
        return ret;
    };
    // TODO:
    RandomVectorValue.prototype.map = function (func) {
        this.min = this.min.map(func);
        this.max = this.max.map(func);
        return this;
    };
    return RandomVectorValue;
}(ValueGetter));
var LinearValue = /** @class */ (function (_super) {
    __extends(LinearValue, _super);
    function LinearValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LinearValue.prototype.onCreate = function (props) {
        this.min = props[0];
        this.max = props[1];
        this.xCoord = 1;
    };
    LinearValue.prototype.getValue = function (t) {
        t /= this.xCoord;
        return this.min * (1 - t) + this.max * t;
    };
    LinearValue.prototype.toUniform = function () {
        return new Float32Array([1, this.min, this.max, this.xCoord]);
    };
    LinearValue.prototype.getIntegrateValue = function (t0, t1, timeScale) {
        if (timeScale === void 0) { timeScale = 1; }
        var min = this.min;
        var max = this.max;
        var ts = this.xCoord * timeScale;
        var v1 = min + (max - min) * (t1 / ts);
        var v0 = min + (max - min) * (t0 / ts);
        return ((v1 + min) * t1 - (v0 + min) * t0) / 2;
    };
    LinearValue.prototype.getIntegrateByTime = function (t0, t1) {
        return lineSegIntegrateByTime(t1, 0, this.xCoord, this.min, this.max) - lineSegIntegrateByTime(t0, 0, this.xCoord, this.min, this.max);
    };
    LinearValue.prototype.map = function (func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    LinearValue.prototype.scaleXCoord = function (scale) {
        this.xCoord = scale;
        return this;
    };
    return LinearValue;
}(ValueGetter));
var GradientValue = /** @class */ (function (_super) {
    __extends(GradientValue, _super);
    function GradientValue() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GradientValue.prototype.onCreate = function (props) {
        this.stops = colorStopsFromGradient(props);
    };
    GradientValue.prototype.getStops = function () {
        return this.stops;
    };
    GradientValue.prototype.getValue = function (time) {
        var stops = this.stops;
        var last = stops.length - 1;
        for (var i = 0; i < last; i++) {
            var a = stops[i];
            var b = stops[i + 1];
            if (a.stop <= time && b.stop > time) {
                var t = (time - a.stop) / (b.stop - a.stop);
                return interpolateColor(a.color, b.color, t, true);
            }
        }
        return stops[last].color.slice();
    };
    return GradientValue;
}(ValueGetter));
var LineSegments = /** @class */ (function (_super) {
    __extends(LineSegments, _super);
    function LineSegments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LineSegments.prototype.onCreate = function (props) {
        this.keys = props
            .map(function (p) {
            if (p.slice) {
                return p.slice(0, 2);
            }
            return [p.time, p.value];
        })
            .sort(function (a, b) { return a[0] - b[0]; });
        var last = this.keys[this.keys.length - 1];
        if (last[0] < 1) {
            this.keys.push([1, last[1]]);
        }
        var first = this.keys[0];
        if (first[0] > 0) {
            this.keys.unshift([0, first[1]]);
        }
        this.isLineSeg = true;
    };
    LineSegments.prototype.getValue = function (time) {
        var keys = this.keys;
        if (time < keys[0][0]) {
            return keys[0][1];
        }
        var end = keys.length - 1;
        for (var i = 0; i < end; i++) {
            var key = keys[i];
            var k2 = keys[i + 1];
            var x0 = key[0];
            var x1 = k2[0];
            if (time >= x0 && time <= x1) {
                var p = (time - x0) / (x1 - x0);
                var y0 = key[1];
                return y0 + p * (k2[1] - y0);
            }
        }
        return keys[end][1];
    };
    LineSegments.prototype.getIntegrateValue = function (t0, t1, ts) {
        if (ts === void 0) { ts = 1; }
        return (this.integrate(t1, false) - this.integrate(t0, false)) * ts;
    };
    LineSegments.prototype.getIntegrateByTime = function (t0, t1) {
        return this.integrate(t1, true) - this.integrate(t0, true);
    };
    LineSegments.prototype.integrate = function (time, byTime) {
        var keys = this.keys;
        if (time <= keys[0][0]) {
            return 0;
        }
        var ret = 0;
        var end = keys.length - 1;
        var func = byTime ? lineSegIntegrateByTime : lineSegIntegrate;
        for (var i = 0; i < end; i++) {
            var k1 = keys[i];
            var k2 = keys[i + 1];
            var t0 = k1[0];
            var t1 = k2[0];
            if (time > t0 && time <= t1) {
                return ret + func(time, t0, t1, k1[1], k2[1]);
            }
            else {
                ret += func(t1, t0, t1, k1[1], k2[1]);
            }
        }
        return ret;
    };
    LineSegments.prototype.toData = function () {
        var keys = this.keys;
        var data = new Float32Array(Math.ceil(keys.length / 2) * 4);
        for (var i = 0, cursor = 0; i < keys.length; i++, cursor += 2) {
            data.set(keys[i], cursor);
        }
        data.set(keys[keys.length - 1], data.length - 2);
        return data;
    };
    LineSegments.prototype.toUniform = function (meta) {
        var index = meta.index;
        var keys = this.keys;
        var uniformCount = Math.ceil(keys.length / 2);
        meta.lineSegCount += uniformCount;
        meta.curves.push(this);
        meta.index += uniformCount;
        meta.max = Math.max(meta.max, uniformCount);
        return new Float32Array([3, index, uniformCount, 0]);
    };
    LineSegments.prototype.map = function (func) {
        this.keys.forEach(function (k) { return k[1] = func(k[1]); });
        return this;
    };
    LineSegments.prototype.scaleXCoord = function (scale) {
        this.keys.forEach(function (k) { return k[0] = scale * k[0]; });
        return this;
    };
    return LineSegments;
}(ValueGetter));
var BezierCurve = /** @class */ (function (_super) {
    __extends(BezierCurve, _super);
    function BezierCurve() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BezierCurve.prototype.onCreate = function (props) {
        var keyframes = props;
        this.curveMap = {};
        this.keys = [];
        for (var i = 0; i < keyframes.length - 1; i++) {
            var leftKeyframe = keyframes[i];
            var rightKeyframe = keyframes[i + 1];
            var _a = buildEasingCurve(leftKeyframe, rightKeyframe), points = _a.points, curve = _a.curve, timeInterval = _a.timeInterval, valueInterval = _a.valueInterval;
            var s = points[0];
            var e = points[points.length - 1];
            this.keys.push(__spreadArray$2(__spreadArray$2([], __read$3(s.toArray()), false), __read$3(points[1].toArray()), false));
            this.keys.push(__spreadArray$2(__spreadArray$2([], __read$3(e.toArray()), false), __read$3(points[2].toArray()), false));
            this.curveMap["".concat(s.x, "&").concat(e.x)] = {
                points: points,
                timeInterval: timeInterval,
                valueInterval: valueInterval,
                curve: curve,
            };
        }
    };
    BezierCurve.prototype.getValue = function (time) {
        var result = 0;
        var keyTimeData = Object.keys(this.curveMap);
        var keyTimeStart = Number(keyTimeData[0].split('&')[0]);
        var keyTimeEnd = Number(keyTimeData[keyTimeData.length - 1].split('&')[1]);
        if (time <= keyTimeStart) {
            return this.getCurveValue(keyTimeData[0], keyTimeStart);
        }
        if (time >= keyTimeEnd) {
            return this.getCurveValue(keyTimeData[keyTimeData.length - 1], keyTimeEnd);
        }
        for (var i = 0; i < keyTimeData.length; i++) {
            var _a = __read$3(keyTimeData[i].split('&'), 2), xMin = _a[0], xMax = _a[1];
            if (time >= Number(xMin) && time < Number(xMax)) {
                result = this.getCurveValue(keyTimeData[i], time);
                break;
            }
        }
        return result;
    };
    BezierCurve.prototype.getIntegrateValue = function (t0, t1, ts) {
        if (ts === void 0) { ts = 1; }
        var time = (t1 - t0) / ts;
        var result = 0;
        var keyTimeData = Object.keys(this.curveMap);
        var keyTimeStart = Number(keyTimeData[0].split('&')[0]);
        if (time <= keyTimeStart) {
            return 0;
        }
        for (var i = 0; i < keyTimeData.length; i++) {
            var _a = __read$3(keyTimeData[i].split('&'), 2), xMin = _a[0], xMax = _a[1];
            if (time >= Number(xMax)) {
                result += ts * this.getCurveIntegrateValue(keyTimeData[i], Number(xMax));
            }
            if (time >= Number(xMin) && time < Number(xMax)) {
                result += ts * this.getCurveIntegrateValue(keyTimeData[i], time);
                break;
            }
        }
        return result;
    };
    BezierCurve.prototype.getIntegrateByTime = function (t0, t1) {
        return this.getIntegrateValue(0, t1) - this.getIntegrateValue(0, t0);
    };
    // 速度变化曲线面板移除后下线
    BezierCurve.prototype.getCurveIntegrateValue = function (curveKey, time) {
        var curveInfo = this.curveMap[curveKey];
        var _a = __read$3(curveInfo.points, 1), p0 = _a[0];
        var timeInterval = curveInfo.timeInterval;
        var valueInterval = curveInfo.valueInterval;
        var segments = 20;
        var total = 0;
        var h = (time - p0.x) / segments;
        for (var i = 0; i <= segments; i++) {
            var t = i * h;
            var normalizeTime = t / timeInterval;
            var y = p0.y + valueInterval * curveInfo.curve.getValue(normalizeTime);
            if (i === 0 || i === segments) {
                total += y;
            }
            else if (i % 2 === 1) {
                total += 4 * y;
            }
            else {
                total += 2 * y;
            }
        }
        total *= h / 3;
        return total;
    };
    BezierCurve.prototype.getCurveValue = function (curveKey, time) {
        var curveInfo = this.curveMap[curveKey];
        var _a = __read$3(curveInfo.points, 1), p0 = _a[0];
        var timeInterval = curveInfo.timeInterval;
        var valueInterval = curveInfo.valueInterval;
        var normalizeTime = (time - p0.x) / timeInterval;
        var value = curveInfo.curve.getValue(normalizeTime);
        return p0.y + valueInterval * value;
    };
    BezierCurve.prototype.toUniform = function (meta) {
        var index = meta.index;
        var count = this.keys.length;
        meta.curves.push(this);
        meta.index = index + count;
        // 兼容 WebGL1
        meta.max = Math.max(meta.max, count);
        meta.curveCount += count;
        return new Float32Array([5, index + 1 / count, index, count]);
    };
    BezierCurve.prototype.toData = function () {
        var keys = this.keys;
        var data = new Float32Array(keys.length * 4);
        for (var i = 0, cursor = 0; i < keys.length; i++, cursor += 4) {
            data.set(keys[i], cursor);
        }
        return data;
    };
    return BezierCurve;
}(ValueGetter));
var BezierCurvePath = /** @class */ (function (_super) {
    __extends(BezierCurvePath, _super);
    function BezierCurvePath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BezierCurvePath.prototype.onCreate = function (props) {
        var _a = __read$3(props, 3), keyframes = _a[0], points = _a[1], controlPoints = _a[2];
        this.curveSegments = {};
        if (!controlPoints.length) {
            return;
        }
        for (var i = 0; i < keyframes.length - 1; i++) {
            var leftKeyframe = keyframes[i];
            var rightKeyframe = keyframes[i + 1];
            var ps1 = new Vector3(points[i][0], points[i][1], points[i][2]), ps2 = new Vector3(points[i + 1][0], points[i + 1][1], points[i + 1][2]);
            var cp1 = new Vector3(controlPoints[2 * i][0], controlPoints[2 * i][1], controlPoints[2 * i][2]), cp2 = new Vector3(controlPoints[2 * i + 1][0], controlPoints[2 * i + 1][1], controlPoints[2 * i + 1][2]);
            var _b = buildEasingCurve(leftKeyframe, rightKeyframe), ps = _b.points, easingCurve = _b.curve, timeInterval = _b.timeInterval, valueInterval = _b.valueInterval;
            var s = ps[0];
            var e = ps[ps.length - 1];
            var pathCurve = new BezierPath(ps1, ps2, cp1, cp2);
            this.curveSegments["".concat(s.x, "&").concat(e.x)] = {
                points: ps,
                timeInterval: timeInterval,
                valueInterval: valueInterval,
                easingCurve: easingCurve,
                pathCurve: pathCurve,
            };
        }
    };
    BezierCurvePath.prototype.getValue = function (time) {
        var t = numberToFix(time, 5);
        var perc = 0, point = new Vector3();
        var keyTimeData = Object.keys(this.curveSegments);
        if (!keyTimeData.length) {
            return point;
        }
        var keyTimeStart = Number(keyTimeData[0].split('&')[0]);
        var keyTimeEnd = Number(keyTimeData[keyTimeData.length - 1].split('&')[1]);
        if (t <= keyTimeStart) {
            var pathCurve = this.curveSegments[keyTimeData[0]].pathCurve;
            point = pathCurve.getPointInPercent(0);
            return point;
        }
        if (t >= keyTimeEnd) {
            var pathCurve = this.curveSegments[keyTimeData[keyTimeData.length - 1]].pathCurve;
            point = pathCurve.getPointInPercent(1);
            return point;
        }
        for (var i = 0; i < keyTimeData.length; i++) {
            var _a = __read$3(keyTimeData[i].split('&'), 2), xMin = _a[0], xMax = _a[1];
            if (t >= Number(xMin) && t < Number(xMax)) {
                var bezierPath = this.curveSegments[keyTimeData[i]].pathCurve;
                perc = this.getPercValue(keyTimeData[i], t);
                point = bezierPath.getPointInPercent(perc);
            }
        }
        return point;
    };
    BezierCurvePath.prototype.getPercValue = function (curveKey, time) {
        var curveInfo = this.curveSegments[curveKey];
        var _a = __read$3(curveInfo.points, 1), p0 = _a[0];
        var timeInterval = curveInfo.timeInterval;
        var normalizeTime = numberToFix((time - p0.x) / timeInterval, 4);
        var value = curveInfo.easingCurve.getValue(normalizeTime);
        // TODO 测试用 编辑器限制值域后移除clamp
        return clamp$1(value, 0, 1);
    };
    return BezierCurvePath;
}(ValueGetter));
var map$2 = (_a$8 = {},
    _a$8[ValueType$1.RANDOM] = function (props) {
        if (props[0] instanceof Array) {
            return new RandomVectorValue(props);
        }
        return new RandomValue(props);
    },
    _a$8[ValueType$1.CONSTANT] = function (props) {
        return new StaticValue(props);
    },
    _a$8[ValueType$1.CONSTANT_VEC2] = function (props) {
        return new StaticValue(props);
    },
    _a$8[ValueType$1.CONSTANT_VEC3] = function (props) {
        return new StaticValue(props);
    },
    _a$8[ValueType$1.CONSTANT_VEC4] = function (props) {
        return new StaticValue(props);
    },
    _a$8[ValueType$1.RGBA_COLOR] = function (props) {
        return new StaticValue(props);
    },
    _a$8[ValueType$1.COLORS] = function (props) {
        return new RandomSetValue(props.map(function (c) { return colorToArr$1(c, false); }));
    },
    _a$8[ValueType$1.LINE] = function (props) {
        if (props.length === 2 && props[0][0] === 0 && props[1][0] === 1) {
            return new LinearValue([props[0][1], props[1][1]]);
        }
        return new LineSegments(props);
    },
    _a$8[ValueType$1.GRADIENT_COLOR] = function (props) {
        return new GradientValue(props);
    },
    // [spec.ValueType.LINEAR_PATH] (pros: number[][][]) {
    //   return new PathSegments(pros);
    // },
    _a$8[ValueType$1.BEZIER_CURVE] = function (props) {
        if (props.length === 1) {
            return new StaticValue(props[0][1][1]);
        }
        return new BezierCurve(props);
    },
    _a$8[ValueType$1.BEZIER_CURVE_PATH] = function (props) {
        if (props[0].length === 1) {
            return new StaticValue(new (Vector3.bind.apply(Vector3, __spreadArray$2([void 0], __read$3(props[1][0]), false)))());
        }
        return new BezierCurvePath(props);
    },
    _a$8);
function createValueGetter(args) {
    if (!args || !isNaN(+args)) {
        return new StaticValue(args || 0);
    }
    if (args instanceof ValueGetter) {
        return args;
    }
    if (isFunction(map$2[args[0]])) {
        return map$2[args[0]](args[1]);
    }
    else {
        throw new Error("ValueType: ".concat(args[0], " is not support"));
    }
}
function lineSegIntegrate(t, t0, t1, y0, y1) {
    var h = t - t0;
    return (y0 + y0 + (y1 - y0) * h / (t1 - t0)) * h / 2;
}
function lineSegIntegrateByTime(t, t0, t1, y0, y1) {
    var t2 = t * t;
    var t3 = t2 * t;
    var t02 = t0 * t0;
    var t03 = t02 * t0;
    return (2 * t3 * (y0 - y1) + 3 * t2 * (t0 * y1 - t1 * y0) - t03 * (2 * y0 + y1) + 3 * t02 * t1 * y0) / (6 * (t0 - t1));
}
function getKeyFrameMetaByRawValue(meta, value) {
    if (value) {
        var type = value[0];
        var keys = value[1];
        if (type === ValueType$1.CURVE) {
            meta.curves.push(keys);
            var keyLen = keys.length;
            if (keys[0][0] > 0) {
                keyLen++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen++;
            }
            meta.index += keyLen;
            meta.max = Math.max(meta.max, keyLen);
            meta.curveCount += keyLen;
        }
        else if (type === ValueType$1.LINE) {
            var keyLen = keys.length;
            if (keyLen === 2 && keys[0][0] === 0 && keys[1][0] === 1) {
                return;
            }
            if (keys[0][0] > 0) {
                keyLen++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen++;
            }
            var uniformCount = Math.ceil(keyLen / 2);
            meta.lineSegCount += uniformCount;
            meta.curves.push(keys);
            meta.index += uniformCount;
            meta.max = Math.max(meta.max, uniformCount);
        }
        else if (type === ValueType$1.BEZIER_CURVE) {
            var keyLen = keys.length - 1;
            meta.index += 2 * keyLen;
            meta.curves.push(keys);
            meta.max = Math.max(meta.max, 2 * keyLen);
            meta.curveCount += 2 * keyLen;
        }
    }
}
function createKeyFrameMeta() {
    return {
        curves: [],
        index: 0,
        max: 0,
        lineSegCount: 0,
        curveCount: 0,
    };
}

var tempRot$2 = new Euler();
var tempSize$2 = new Vector3(1, 1, 1);
var tempPos = new Vector3(0, 0, 0);
var TimelineComponent = /** @class */ (function () {
    function TimelineComponent(options, ownerItem) {
        var _a;
        var _b = options.positionOverLifetime, positionOverLifetime = _b === void 0 ? {} : _b;
        var transform = ownerItem.transform, duration = ownerItem.duration, endBehavior = ownerItem.endBehavior;
        var scale = transform.scale;
        this.transform = transform;
        this.basicTransform = {
            position: transform.position.clone(),
            rotation: transform.getRotation(),
            scale: scale,
        };
        if (positionOverLifetime.path) {
            this.basicTransform.path = createValueGetter(positionOverLifetime.path);
        }
        this.positionOverLifetime = positionOverLifetime;
        this.options = {
            startSpeed: positionOverLifetime.startSpeed || 0,
            startSize: scale && scale.x || 1,
            sizeAspect: scale && (scale.x / (scale.y || 1)) || 1,
            startColor: [1, 1, 1, 1],
            duration: duration || 0,
            looping: endBehavior && endBehavior === ItemEndBehavior$1.loop,
            gravity: Vector3.fromArray(positionOverLifetime.gravity || []),
            gravityModifier: createValueGetter((_a = positionOverLifetime.gravityOverLifetime) !== null && _a !== void 0 ? _a : 0),
            direction: positionOverLifetime.direction ? Vector3.fromArray(positionOverLifetime.direction).normalize() : new Vector3(),
            endBehavior: endBehavior || END_BEHAVIOR_DESTROY$1,
        };
        var sizeOverLifetime = options.sizeOverLifetime;
        if (sizeOverLifetime) {
            if (sizeOverLifetime.separateAxes) {
                this.sizeSeparateAxes = true;
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.x || 1);
                this.sizeYOverLifetime = createValueGetter(sizeOverLifetime.y || 1);
                this.sizeZOverLifetime = createValueGetter(sizeOverLifetime.z || 1);
            }
            else {
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.size || 1);
            }
        }
        var linearVelEnable = positionOverLifetime.linearX || positionOverLifetime.linearY || positionOverLifetime.linearZ;
        if (linearVelEnable) {
            this.linearVelOverLifetime = {
                x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX),
                y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY),
                z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ),
                asMovement: positionOverLifetime.asMovement,
                enabled: !!linearVelEnable,
            };
        }
        var orbitalVelEnable = positionOverLifetime.orbitalX || positionOverLifetime.orbitalY || positionOverLifetime.orbitalZ;
        if (orbitalVelEnable) {
            this.orbitalVelOverLifetime = {
                x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
                y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
                z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
                center: ensureVec3(positionOverLifetime.orbCenter),
                asRotation: positionOverLifetime.asRotation,
                enabled: !!orbitalVelEnable,
            };
        }
        this.speedOverLifetime = positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime);
        var rot = options.rotationOverLifetime;
        if (rot) {
            this.rotationOverLifetime = {
                asRotation: rot.asRotation,
                separateAxes: rot.separateAxes,
                z: createValueGetter(rot.z || 0),
            };
            if (rot.separateAxes) {
                var rotLt = this.rotationOverLifetime;
                rotLt.x = createValueGetter(rot.x || 0);
                rotLt.y = createValueGetter(rot.y || 0);
            }
        }
        this.gravityModifier = this.options.gravityModifier;
    }
    TimelineComponent.prototype.getVelocity = function () {
        if (!this.velocity) {
            this.velocity = this.options.direction.clone().multiply(this.options.startSpeed);
        }
        return this.velocity;
    };
    TimelineComponent.prototype.willTranslate = function () {
        return !!((this.linearVelOverLifetime && this.linearVelOverLifetime.enabled) ||
            (this.orbitalVelOverLifetime && this.orbitalVelOverLifetime.enabled) ||
            (this.options.gravityModifier && !this.options.gravity.isZero()) ||
            (this.options.startSpeed && !this.options.direction.isZero()));
    };
    TimelineComponent.prototype.updatePosition = function (x, y, z) {
        this.basicTransform.position.set(x, y, z);
    };
    TimelineComponent.prototype.updateRotation = function (x, y, z) {
        this.basicTransform.rotation.set(x, y, z);
    };
    TimelineComponent.prototype.getRenderData = function (_time, init) {
        var options = this.options;
        var sizeInc = tempSize$2.setFromNumber(1);
        var rotInc = tempRot$2.set(0, 0, 0);
        var sizeChanged, rotChanged;
        var time = _time < 0 ? _time : Math.max(_time, 0.);
        var duration = options.duration;
        var life = time / duration;
        var ret = {
            life: life,
            transform: this.transform,
            startSize: this.basicTransform.scale.clone(),
        };
        var transform = this.basicTransform;
        life = life < 0 ? 0 : (life > 1 ? 1 : life);
        if (this.sizeXOverLifetime) {
            sizeInc.x = this.sizeXOverLifetime.getValue(life);
            if (this.sizeSeparateAxes) {
                sizeInc.y = this.sizeYOverLifetime.getValue(life);
                sizeInc.z = this.sizeZOverLifetime.getValue(life);
            }
            else {
                sizeInc.z = sizeInc.y = sizeInc.x;
            }
            sizeChanged = true;
        }
        if (sizeChanged || init) {
            ret.transform.setScale(sizeInc.x, sizeInc.y, sizeInc.z);
        }
        var rotationOverLifetime = this.rotationOverLifetime;
        if (rotationOverLifetime) {
            var func = function (v) { return rotationOverLifetime.asRotation ? v.getValue(life) : v.getIntegrateValue(0, life, duration); };
            var incZ = func(rotationOverLifetime.z);
            var separateAxes = rotationOverLifetime.separateAxes;
            rotInc.x = separateAxes ? func(rotationOverLifetime.x) : 0;
            rotInc.y = separateAxes ? func(rotationOverLifetime.y) : 0;
            rotInc.z = incZ;
            rotChanged = true;
        }
        if (rotChanged || init) {
            var rot = tempRot$2.addEulers(transform.rotation, rotInc);
            ret.transform.setRotation(rot.x, rot.y, rot.z);
        }
        var pos;
        if (this.willTranslate() || init) {
            var out = tempSize$2.setFromNumber(0);
            pos = calculateTranslation(out, this, options.gravity, time, duration, transform.position, this.getVelocity());
        }
        if (transform.path) {
            if (!pos) {
                pos = tempPos.copyFrom(transform.position);
            }
            pos.add(transform.path.getValue(life));
        }
        if (pos) {
            ret.transform.setPosition(pos.x, pos.y, pos.z);
        }
        if (ret.startSize) {
            var scaling = ret.transform.scale;
            ret.transform.setScale(scaling.x * ret.startSize.x, scaling.y * ret.startSize.y, scaling.z * ret.startSize.z);
        }
        return ret;
    };
    return TimelineComponent;
}());

var prefix = '[Galacean Effects]';
var localLogger;
function format(message) {
    return [
        "%c".concat(prefix),
        'background: #AA0100; color: white',
        "".concat(message),
    ];
}
function error(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    console.error.apply(console, __spreadArray$2(__spreadArray$2([], __read$3(format(message)), false), [args], false));
    localLogger === null || localLogger === void 0 ? void 0 : localLogger('error', message, args);
}
/**
 * info 会转换成浏览器的 console.debug
 * @param message
 * @param args
 */
function info(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    console.debug.apply(console, __spreadArray$2([], __read$3(format(message)), false));
    localLogger === null || localLogger === void 0 ? void 0 : localLogger('info', message, args);
}
function warn(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    console.warn.apply(console, __spreadArray$2([], __read$3(format(message)), false));
    localLogger === null || localLogger === void 0 ? void 0 : localLogger('warn', message, args);
}
/**
 * 注册自定义埋点函数
 *
 * @param fn
 */
function register(fn) {
    if (fn && isFunction(fn)) {
        localLogger = fn;
    }
}
var logger = {
    error: error,
    info: info,
    warn: warn,
    register: register,
};

exports.DestroyOptions = void 0;
(function (DestroyOptions) {
    DestroyOptions[DestroyOptions["destroy"] = 0] = "destroy";
    DestroyOptions[DestroyOptions["keep"] = 1] = "keep";
    DestroyOptions[DestroyOptions["force"] = 0] = "force";
})(exports.DestroyOptions || (exports.DestroyOptions = {}));
function noop() {
}
/**
 * 判断对象是否是`String`类型
 *
 * @static
 * @function isString
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isString(obj) {
    return typeof obj === 'string';
}
/**
 * 判断对象是否是`Array`类型
 *
 * @static
 * @function isArray
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
var isArray = (Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
});
/**
 * 判断对象是否是函数类型
 *
 * @static
 * @function isFunction
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
}
/**
 * 判断对象是否是`Object`类型
 *
 * @static
 * @function isObject
 * @param {object} obj - 要判断的对象
 * @return {boolean}
 */
function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
function deepClone(obj) {
    if (isArray(obj)) {
        return obj.map(deepClone);
    }
    else if (obj && typeof obj === 'object') {
        if (ArrayBuffer.isView(obj)) {
            return obj.slice();
        }
        var ret = {};
        var kas = Object.keys(obj);
        for (var i = 0; i < kas.length; i++) {
            var key = kas[i];
            ret[key] = deepClone(obj[key]);
        }
        return ret;
    }
    return obj;
}
// TODO: 改名
function random(min, max) {
    return min + Math.random() * (max - min);
}
function throwDestroyedError$1() {
    throw Error('destroyed item cannot be used again');
}

var tempQuat$1 = new Quaternion();
var seed$e = 1;
var Transform = /** @class */ (function () {
    function Transform(props, parent) {
        if (props === void 0) { props = {}; }
        /**
         * 自身位移
         */
        this.position = new Vector3(0, 0, 0);
        /**
         * 自身旋转对应的四元数，右手坐标系，旋转正方向左手螺旋（轴向的顺时针），旋转欧拉角的顺序为 ZYX
         */
        this.quat = new Quaternion(0, 0, 0, 1);
        /**
         * 自身旋转角度
         */
        this.rotation = new Euler(0, 0, 0);
        /**
         * 自身缩放
         */
        this.scale = new Vector3(1, 1, 1);
        /**
         * 自身锚点
         */
        this.anchor = new Vector3(0, 0, 0);
        /**
         * 子变换，可以有多个
         */
        this.children = [];
        /**
         * 包含父变换的最终模型矩阵
         */
        this.worldMatrix = Matrix4$1.fromIdentity();
        /**
         * 仅包含自身变换的模型矩阵
         */
        this.localMatrix = Matrix4$1.fromIdentity();
        /**
         * 变换是否需要生效，不生效返回的模型矩阵为单位矩阵，需要随元素生命周期改变
         */
        this.valid = false;
        /**
         * 数据变化标志位
         */
        this.dirtyFlags = {
            /* 自身变换是否有修改，若修改，localMatrix 需要更新 */
            localData: false,
            /* localMatrix 是否有修改，若修改，WorldMatrix 需要更新 */
            localMatrix: false,
            /* worldMatrix 是否有修改，若修改，worldTRS 需要更新 */
            worldMatrix: false,
            /* parentMatrix 是否有修改，若修改，WorldMatrix需要更新 */
            parentMatrix: false,
        };
        /**
         * 最终模型矩阵对应变换的缓存，当自身矩阵或父矩阵有修改时需要更新
         */
        this.worldTRSCache = { position: new Vector3(0, 0, 0), quat: new Quaternion(0, 0, 0, 1), scale: new Vector3(1, 1, 1) };
        this.name = "transform_".concat(seed$e++);
        if (props) {
            this.setTransform(props);
        }
        if (parent) {
            this.parentTransform = parent;
        }
        if (props.valid !== undefined) {
            this.setValid(props.valid);
        }
    }
    /**
     * 转换右手坐标系左手螺旋对应的四元数到对应的旋转角
     * @param quat - 四元数
     * @param out - 欧拉角
     * @returns
     */
    Transform.getRotation = function (quat, out) {
        var newQuat = tempQuat$1.copyFrom(quat);
        newQuat.conjugate();
        return out.setFromQuaternion(newQuat);
    };
    Object.defineProperty(Transform.prototype, "parentTransform", {
        get: function () {
            return this.parent;
        },
        set: function (transform) {
            if (!transform || this.parent === transform || this === transform) {
                return;
            }
            if (this.parent) {
                this.parent.removeChild(this);
            }
            transform.addChild(this);
            this.parent = transform;
            this.parentMatrixDirty = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "parentMatrixDirty", {
        get: function () {
            return this.dirtyFlags.parentMatrix;
        },
        set: function (val) {
            if (this.dirtyFlags.parentMatrix !== val) {
                this.dirtyFlags.parentMatrix = val;
                this.dispatchValueChange();
            }
        },
        enumerable: false,
        configurable: true
    });
    // /**
    //  * 自身数据修改 /  父变换修改 / 父变换的数据修改
    //  * @returns
    //  */
    // get traceDirty (): boolean {
    //   if (this.dirty || this.parentDirty) {
    //     return true;
    //   }
    //
    //   return !!(this.parent && this.parent.traceDirty);
    // }
    /**
     * 设置位置
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.setPosition = function (x, y, z) {
        if (this.position.x !== x || this.position.y !== y || this.position.z !== z) {
            this.position.x = x;
            this.position.y = y;
            this.position.z = z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 在当前位置的基础上添加位置偏移
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.translate = function (x, y, z) {
        if (x !== 0 || y !== 0 || z !== 0) {
            this.position.x += x;
            this.position.y += y;
            this.position.z += z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 设置旋转
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.setRotation = function (x, y, z) {
        if (this.rotation.x !== x || this.rotation.y !== y || this.rotation.z !== z) {
            this.rotation.x = x;
            this.rotation.y = y;
            this.rotation.z = z;
            this.quat.setFromEuler(this.rotation);
            this.quat.conjugate();
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 设置四元数
     * @param x
     * @param y
     * @param z
     * @param w
     * @private
     */
    Transform.prototype.setQuaternion = function (x, y, z, w) {
        if (this.quat.x !== x || this.quat.y !== y || this.quat.z !== z || this.quat.w !== w) {
            this.quat.x = x;
            this.quat.y = y;
            this.quat.z = z;
            this.quat.w = w;
            this.rotation.setFromQuaternion(this.quat);
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 设置缩放
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.setScale = function (x, y, z) {
        if (this.scale.x !== x || this.scale.y !== y || this.scale.z !== z) {
            this.scale.x = x;
            this.scale.y = y;
            this.scale.z = z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 在当前旋转的基础上使用四元素添加旋转
     * @param quat
     */
    Transform.prototype.rotateByQuat = function (quat) {
        this.quat.multiply(quat);
        this.rotation.setFromQuaternion(this.quat);
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
     * 在当前缩放基础上设置缩放系数
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.scaleBy = function (x, y, z) {
        this.scale.x *= x;
        this.scale.y *= y;
        this.scale.z *= z;
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
     * 设置锚点
     * @param x
     * @param y
     * @param z
     */
    Transform.prototype.setAnchor = function (x, y, z) {
        if (this.anchor.x !== x || this.anchor.y !== y || this.anchor.z !== z) {
            this.anchor.x = x;
            this.anchor.y = y;
            this.anchor.z = z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
     * 批量设置 transform 属性
     * @param props - 要设置的属性
     * @param reverseEuler - 设置 rotation时，欧拉角是否需要取负值
     */
    Transform.prototype.setTransform = function (props, reverseEuler) {
        var _a;
        var position = props.position, rotation = props.rotation, scale = props.scale, quat = props.quat, name = props.name, anchor = props.anchor;
        if (name) {
            this.name = name;
        }
        if (position) {
            if (position instanceof Vector3) {
                this.setPosition(position.x, position.y, position.z);
            }
            else {
                this.setPosition(position[0], position[1], position[2]);
            }
        }
        if (quat) {
            if (quat instanceof Quaternion) {
                this.setQuaternion(quat.x, quat.y, quat.z, quat.w);
            }
            else {
                this.setQuaternion(quat[0], quat[1], quat[2], quat[3]);
            }
        }
        else if (rotation) {
            var mul = reverseEuler ? -1 : 1;
            if (rotation instanceof Euler) {
                this.setRotation(rotation.x * mul, rotation.y * mul, rotation.z * mul);
            }
            else {
                this.setRotation(rotation[0] * mul, rotation[1] * mul, rotation[2] * mul);
            }
        }
        if (scale) {
            if (scale instanceof Vector3) {
                this.setScale(scale.x, scale.y, scale.z);
            }
            else {
                this.setScale(scale[0], scale[1], scale[2]);
            }
        }
        if (anchor) {
            if (anchor instanceof Vector3) {
                this.setAnchor(anchor.x, anchor.y, anchor.z);
            }
            else {
                this.setAnchor(anchor[0], anchor[1], (_a = anchor[2]) !== null && _a !== void 0 ? _a : 0);
            }
        }
    };
    /**
     * 添加子变换
     * @param child - 要添加的子变换
     */
    Transform.prototype.addChild = function (child) {
        addItem(this.children, child);
    };
    /**
     * 移除子变换
     */
    Transform.prototype.removeChild = function (child) {
        removeItem(this.children, child);
    };
    /**
     * 获取当前的旋转量
     * @returns
     */
    Transform.prototype.getRotation = function () {
        return Transform.getRotation(this.quat, new Euler());
    };
    /**
     * 获取当前的四元数
     * @returns
     */
    Transform.prototype.getQuaternion = function () {
        return this.quat;
    };
    /**
     * 更新元素自身变换矩阵
     */
    Transform.prototype.updateLocalMatrix = function () {
        if (this.valid) {
            if (this.dirtyFlags.localData) {
                this.localMatrix.compose(this.position, this.quat, this.scale, this.anchor);
                this.dirtyFlags.localMatrix = true;
            }
            this.dirtyFlags.localData = false;
        }
        else {
            if (!this.localMatrix.isIdentity()) {
                this.localMatrix.identity();
                this.dirtyFlags.localMatrix = true;
            }
        }
    };
    /**
     * 获取自身变换对应的模型矩阵
     * 数据修改且需要生效时更新自身矩阵
     * 当变换不需要生效时返回单位矩阵
     * @returns
     */
    Transform.prototype.getMatrix = function () {
        this.updateLocalMatrix();
        return this.localMatrix;
    };
    /**
     * 获取父矩阵，如果有多级父节点，返回整体变换
     * @returns
     */
    Transform.prototype.getParentMatrix = function () {
        if (this.parent) {
            this.parentMatrix = this.parent.getWorldMatrix();
            this.dirtyFlags.parentMatrix = this.dirtyFlags.parentMatrix || this.parent.dirtyFlags.localMatrix || this.parent.dirtyFlags.worldMatrix;
        }
        return this.parentMatrix;
    };
    /**
     * 获取包含自身变换和父变换的模型变换矩阵
     * @returns
     */
    Transform.prototype.getWorldMatrix = function () {
        var localMatrix = this.getMatrix();
        var parentMatrix = this.getParentMatrix();
        if (this.dirtyFlags.localMatrix || this.dirtyFlags.parentMatrix) {
            if (parentMatrix) {
                this.worldMatrix.multiplyMatrices(parentMatrix, localMatrix);
            }
            else {
                this.worldMatrix.copyFrom(localMatrix);
            }
            this.dirtyFlags.worldMatrix = true;
            this.dirtyFlags.localMatrix = false;
            this.dirtyFlags.parentMatrix = false;
        }
        return this.worldMatrix;
    };
    /**
     * 获取联合变换后的最终缩放因子
     * @returns
     */
    Transform.prototype.getWorldScale = function () {
        var cache = this.worldTRSCache;
        if (this.dirtyFlags.worldMatrix) {
            var mat = this.getWorldMatrix();
            mat.decompose(cache.position, cache.quat, cache.scale);
            this.dirtyFlags.worldMatrix = false;
        }
        return this.worldTRSCache.scale.clone();
    };
    /**
     * 获取联合变换后的最终位置
     * @returns
     */
    Transform.prototype.getWorldPosition = function () {
        this.updateTRSCache();
        return this.worldTRSCache.position.clone();
    };
    /**
     * 获取联合变换后的最终旋转量
     * @returns
     */
    Transform.prototype.getWorldRotation = function () {
        this.updateTRSCache();
        return Transform.getRotation(this.worldTRSCache.quat, new Euler());
    };
    /**
     * 根据世界变换矩阵计算位移、旋转、缩放向量
     * @param  position
     * @param  quat
     * @param  scale
     */
    Transform.prototype.assignWorldTRS = function (position, quat, scale) {
        this.updateTRSCache();
        if (position) {
            position.copyFrom(this.worldTRSCache.position);
        }
        if (quat) {
            quat.copyFrom(this.worldTRSCache.quat);
        }
        if (scale) {
            scale.copyFrom(this.worldTRSCache.scale);
        }
    };
    /**
     * 拆解并复制指定矩阵到自身变换
     * @param m4
     * @param scale
     * @returns
     */
    Transform.prototype.cloneFromMatrix = function (m4, scale) {
        m4.decompose(this.position, this.quat, this.scale);
        if (scale) {
            scale.copyFrom(this.scale);
        }
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
     * 设置 Transform 生效 / 失效， 默认元素生命周期开始后生效，结束后失效
     */
    Transform.prototype.setValid = function (val) {
        if (this.valid !== val) {
            this.valid = val;
            if (!val) {
                this.localMatrix.identity();
                this.dirtyFlags.localMatrix = true;
            }
            else {
                this.dirtyFlags.localData = true;
            }
            this.dispatchValueChange();
        }
    };
    /**
     * 获取 Transform 是否生效
     */
    Transform.prototype.getValid = function () {
        return this.valid;
    };
    Transform.prototype.dispose = function () { };
    Transform.prototype.updateTRSCache = function () {
        var worldMatrix = this.getWorldMatrix();
        if (this.dirtyFlags.worldMatrix) {
            var cache = this.worldTRSCache;
            worldMatrix.decompose(cache.position, cache.quat, cache.scale);
            this.dirtyFlags.worldMatrix = false;
        }
    };
    Transform.prototype.dispatchValueChange = function () {
        this.children.forEach(function (c) {
            c.parentMatrixDirty = true;
        });
    };
    return Transform;
}());

/**
 * 所有元素的继承的抽象类
 */
var VFXItem = /** @class */ (function () {
    function VFXItem(props, composition) {
        /**
         * 元素优先级
         */
        this._v_priority = 0;
        /**
         * 元素可见性，该值的改变会触发 `handleVisibleChanged` 回调
         * @protected
         */
        this.visible = true;
        /**
         * 是否允许渲染，元素生命周期开始后为 true，结束时为 false
         * @protected
         */
        this._contentVisible = false;
        /**
         * 合成元素当前的时间，单位毫秒
         * @protected
         */
        this.timeInms = 0;
        /**
         * 合成元素当前的时间，单位秒，兼容旧 player 使用秒的时间更新数据
         * @protected
         */
        this.time = 0;
        /**
         * 元素冻结属性，冻结后停止计算/更新数据
         */
        this._frozen = false;
        var id = props.id, name = props.name, delay = props.delay, parentId = props.parentId, endBehavior = props.endBehavior, transform = props.transform, _a = props.listIndex, listIndex = _a === void 0 ? 0 : _a, _b = props.duration, duration = _b === void 0 ? 0 : _b;
        this.composition = composition;
        this.id = id;
        this.name = name;
        this.delay = delay;
        this.transform = new Transform(__assign$1({ name: this.name }, transform), composition.transform);
        this.parentId = parentId;
        this.duration = duration;
        this.delayInms = (delay || 0) * 1000;
        this.durInms = this.duration * 1000;
        this.endBehavior = endBehavior;
        this.lifetime = -(this.delayInms / this.durInms);
        this.listIndex = listIndex;
        this.speed = 1;
        this.onConstructed(props);
        if (duration <= 0) {
            throw Error("Item duration can't be less than 0, see ".concat(HELP_LINK$1['Item duration can\'t be less than 0']));
        }
    }
    VFXItem.isComposition = function (item) {
        return item.type === ItemType$1.composition;
    };
    VFXItem.isSprite = function (item) {
        return item.type === ItemType$1.sprite;
    };
    VFXItem.isParticle = function (item) {
        return item.type === ItemType$1.particle;
    };
    VFXItem.isFilterSprite = function (item) {
        return item.type === ItemType$1.filter;
    };
    VFXItem.isNull = function (item) {
        return item.type === ItemType$1.null;
    };
    VFXItem.isTree = function (item) {
        return item.type === ItemType$1.tree;
    };
    VFXItem.isCamera = function (item) {
        return item.type === ItemType$1.camera;
    };
    VFXItem.isExtraCamera = function (item) {
        return item.id === 'extra-camera' && item.name === 'extra-camera';
    };
    Object.defineProperty(VFXItem.prototype, "contentVisible", {
        /**
         * 元素内容可见性
         */
        get: function () {
            return this._contentVisible && this.visible;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "content", {
        /**
         * 返回元素创建的数据
         */
        get: function () {
            // @ts-expect-error
            return this._content;
        },
        /**
         * 设置元素数据
         */
        set: function (t) {
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "reusable", {
        /**
         * 播放完成后是否需要再使用，是的话生命周期结束后不会 dispose
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this.composition) === null || _a === void 0 ? void 0 : _a.reusable) !== null && _b !== void 0 ? _b : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "type", {
        /**
         * 获取元素类型
         */
        get: function () {
            return ItemType$1.base;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "frozen", {
        /**
         * 获取元素冻结属性
         */
        get: function () {
            return this._frozen;
        },
        /**
         * 设置元素冻结属性
         */
        set: function (v) {
            this.handleFrozenChanged(this._frozen = !!v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(VFXItem.prototype, "lifetimeStarted", {
        /**
         * 获取元素生命周期是否开始
         */
        get: function () {
            return this.started && !this.delaying;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置元素的动画速度
     * @param speed - 速度
     */
    VFXItem.prototype.setSpeed = function (speed) {
        this.speed = speed;
    };
    /**
     * 获取元素的动画速度
     * @returns
     */
    VFXItem.prototype.getSpeed = function () {
        return this.speed;
    };
    /**
     * 重置元素状态属性
     */
    VFXItem.prototype.start = function () {
        if (!this.started || this.ended) {
            this.started = true;
            this.delaying = true;
            this.timeInms = 0;
            this.time = 0;
            this.callEnd = false;
            this.ended = false;
        }
    };
    /**
     * 停止播放元素动画
     */
    VFXItem.prototype.stop = function () {
        this.doStop();
        this.started = false;
    };
    VFXItem.prototype.doStop = function () {
        if (this._content && this._content.stop) {
            this._content.stop();
        }
    };
    /**
     * 创建元素内容，此函数可以在任何时间被调用
     * 第一帧渲染前会被调用
     * @returns
     */
    VFXItem.prototype.createContent = function () {
        if (!this._content) {
            this._content = this.doCreateContent(this.composition);
        }
        return this._content;
    };
    /**
     * 创建元素的内容
     * @override
     * @param composition
     * @returns
     */
    VFXItem.prototype.doCreateContent = function (composition) {
        return undefined;
    };
    /**
     * 元素构造函数调用时将调用该函数
     * @param options
     * @override
     */
    VFXItem.prototype.onConstructed = function (options) {
        // OVERRIDE
    };
    /**
     * 内部使用的更新回调，请不要重写此方法，重写 `onItemUpdate` 方法
     * @param deltaTime
     */
    VFXItem.prototype.onUpdate = function (deltaTime) {
        var _a, _b;
        if (this.started && !this.frozen && this.composition) {
            var dt = deltaTime * this.speed;
            var time = (this.timeInms += dt);
            this.time += dt / 1000;
            var now = time - this.delayInms;
            if (this.delaying && now >= 0) {
                this.delaying = false;
                this.transform.setValid(true);
                this.createContent();
                this._contentVisible = true;
                this.onLifetimeBegin(this.composition, this.content);
                this.composition.itemLifetimeEvent(this, true);
            }
            if (!this.delaying) {
                var lifetime = now / this.durInms;
                var ended = this.isEnded(now);
                var shouldUpdate = true;
                this.transform.setValid(true);
                if (ended) {
                    shouldUpdate = false;
                    if (!this.callEnd) {
                        this.callEnd = true;
                        this.composition.itemLifetimeEvent(this, false);
                        this.onEnd();
                    }
                    // 注意：不要定义私有变量替换 this.endBehavior，直接使用 this 上的！！！（Chrome 下会出现 endBehavior 为 5 时，能进入以下判断）
                    if (this.endBehavior !== END_BEHAVIOR_FORWARD$1 && this.endBehavior !== END_BEHAVIOR_RESTART$1) {
                        this.ended = true;
                        this.transform.setValid(false);
                        if (this.endBehavior === END_BEHAVIOR_PAUSE$1 ||
                            this.endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1) {
                            (_b = (_a = this.composition).onPlayerPause) === null || _b === void 0 ? void 0 : _b.call(_a, this);
                        }
                        else if (this.endBehavior === END_BEHAVIOR_FREEZE$1) {
                            this.transform.setValid(true);
                            shouldUpdate = true;
                            lifetime = 1;
                            dt = 0;
                        }
                        if (!this.reusable) {
                            if (this.endBehavior === END_BEHAVIOR_DESTROY$1 ||
                                this.endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1 ||
                                this.endBehavior === END_BEHAVIOR_DESTROY_CHILDREN$1) {
                                return this.dispose();
                            }
                            else if (this.endBehavior === END_BEHAVIOR_PAUSE$1) {
                                this.endBehavior = END_BEHAVIOR_FORWARD$1;
                            }
                        }
                        else if (this.endBehavior === END_BEHAVIOR_DESTROY$1) {
                            this._contentVisible = false;
                            shouldUpdate = true;
                            dt = 0;
                            // 预合成配置 reusable 且销毁时， 需要隐藏其中的元素
                            if (this.type === ItemType$1.composition) {
                                this.handleVisibleChanged(false);
                            }
                        }
                        lifetime = Math.min(lifetime, 1);
                    }
                    else {
                        shouldUpdate = true;
                        if (this.endBehavior === END_BEHAVIOR_RESTART$1) {
                            this.ended = true;
                        }
                    }
                }
                else if (this.callEnd && this.reusable) {
                    this.setVisible(true);
                    this.callEnd = false;
                }
                this.lifetime = lifetime % 1;
                shouldUpdate && this.onItemUpdate(dt, lifetime);
            }
        }
    };
    /**
     * 元素结束时的回调
     * @override
     * @param composition
     * @param content
     */
    VFXItem.prototype.onItemRemoved = function (composition, content) {
        // OVERRIDE
    };
    /**
     * 元素更新函数，在 Composition 对象的 tick 函数中被调用
     * @override
     * @param dt
     * @param lifetime
     */
    VFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        // OVERRIDE
    };
    /**
     * 元素 doCreateContent 函数调用后会立即调用该函数用于初始化数据
     * @override
     * @param composition
     * @param content
     */
    VFXItem.prototype.onLifetimeBegin = function (composition, content) {
        // OVERRIDE
    };
    /**
     * 元素动画结束播放时回调函数
     * @override
     */
    VFXItem.prototype.onEnd = function () {
        // OVERRIDE
    };
    /**
     * 通过指定 r、g、b、a 值设置元素的颜色
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     * @internal
     */
    VFXItem.prototype.setColor = function (r, g, b, a) {
    };
    /**
     * 设置元素的透明度
     * @param opacity - 透明度值，范围 [0,1]
     */
    VFXItem.prototype.setOpacity = function (opacity) {
    };
    /**
     * 获取元素显隐属性
     */
    VFXItem.prototype.getVisible = function () {
        return this.visible;
    };
    /**
     * 设置元素显隐属性 会触发 `handleVisibleChanged` 回调
     */
    VFXItem.prototype.setVisible = function (visible) {
        if (this.visible !== visible) {
            this.visible = !!visible;
            this.handleVisibleChanged(this.visible);
        }
    };
    /**
     * 元素显隐属性改变时调用的函数，当 visible 为 true 时，务必显示元素
     * @param visible
     * @override
     */
    VFXItem.prototype.handleVisibleChanged = function (visible) {
        // OVERRIDE
    };
    /**
     * 元素冻结属性改变时调用的函数
     * @param frozen
     * @override
     */
    VFXItem.prototype.handleFrozenChanged = function (frozen) {
        // OVERRIDE
    };
    /**
     * 获取元素变换包括位置、旋转、缩放
     * @param transform 将元素变换拷贝到该对象，并将其作为返回值
     * @returns 元素变换的拷贝
     */
    VFXItem.prototype.getWorldTransform = function (transform) {
        var tf = transform !== null && transform !== void 0 ? transform : new Transform({
            valid: true,
        });
        tf.cloneFromMatrix(this.transform.getWorldMatrix());
        return tf;
    };
    /**
     * 获取元素内部节点的变换，目前只有场景树元素在使用
     * @param itemId 元素id信息，如果带^就返回内部节点变换，否则返回自己的变换
     * @returns 元素变换或内部节点变换
     */
    VFXItem.prototype.getNodeTransform = function (itemId) {
        return this.transform;
    };
    /**
     * 设置元素在 3D 坐标轴上相对移动
     */
    VFXItem.prototype.translate = function (x, y, z) {
        this.transform.translate(x, y, z);
    };
    /**
     * 设置元素在 3D 坐标轴上相对旋转（角度）
     */
    VFXItem.prototype.rotate = function (x, y, z) {
        var euler = new Euler(x, y, z);
        var q = Quaternion.fromEuler(euler);
        q.conjugate();
        this.transform.rotateByQuat(q);
    };
    /**
     * 设置元素在 3D 坐标轴上相对缩放
     */
    VFXItem.prototype.scale = function (x, y, z) {
        this.transform.scaleBy(x, y, z);
    };
    /**
     * 设置元素的在画布上的像素位置, 坐标原点在 canvas 中心，x 正方向水平向右， y 正方向垂直向下
     */
    VFXItem.prototype.setPositionByPixel = function (x, y) {
        if (this.composition) {
            var z = this.transform.getWorldPosition().z;
            var _a = this.composition.camera.getInverseVPRatio(z), rx = _a.x, ry = _a.y;
            var width = this.composition.renderer.getWidth() / 2;
            var height = this.composition.renderer.getHeight() / 2;
            this.transform.setPosition(2 * x * rx / width, -2 * y * ry / height, z);
        }
    };
    /**
     * 设置元素在 3D 坐标轴的位置
     */
    VFXItem.prototype.setPosition = function (x, y, z) {
        this.transform.setPosition(x, y, z);
    };
    /**
     * 设置元素在 3D 坐标轴的角度
     */
    VFXItem.prototype.setRotation = function (x, y, z) {
        this.transform.setRotation(x, y, z);
    };
    /**
     * 设置元素在 3D 坐标轴的缩放
     */
    VFXItem.prototype.setScale = function (x, y, z) {
        this.transform.setScale(x, y, z);
    };
    /**
     * 获取元素包围盒
     * @override
     */
    VFXItem.prototype.getBoundingBox = function () {
        // OVERRIDE
    };
    /**
     * 获取元素用于计算光线投射的面片类型和参数
     * @override
     * @param force 元素没有开启交互也返回参数
     */
    VFXItem.prototype.getHitTestParams = function (force) {
        // OVERRIDE
    };
    /**
     * 获取元素的 transform、当前生命周期、可见性，当子元素需要时可继承
     * @override
     */
    VFXItem.prototype.getRenderData = function () {
        // OVERRIDE
        return {
            transform: this.transform,
            life: 0,
            visible: this.visible,
        };
    };
    /**
     * 获取元素当前世界坐标
     */
    VFXItem.prototype.getCurrentPosition = function () {
        var pos = new Vector3();
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    /**
     * 是否到达元素的结束时间
     * @param now
     * @returns
     */
    VFXItem.prototype.isEnded = function (now) {
        // at least 1 ms
        return now - this.durInms > 0.001;
    };
    /**
     * 重置元素，元素创建的内容将会被销毁
     */
    VFXItem.prototype.reset = function () {
        if (this.composition) {
            this.onItemRemoved(this.composition, this._content);
            this._content = undefined;
            this._contentVisible = false;
        }
        this.started = false;
    };
    VFXItem.prototype.translateByPixel = function (x, y) {
        if (this.composition) {
            // @ts-expect-error
            var _a = this.composition.renderer.canvas.getBoundingClientRect(), width = _a.width, height = _a.height;
            var z = this.transform.getWorldPosition().z;
            var _b = this.composition.camera.getInverseVPRatio(z), rx = _b.x, ry = _b.y;
            this.transform.translate(2 * x * rx / width, -2 * y * ry / height, 0);
        }
    };
    /**
     * 销毁元素
     */
    VFXItem.prototype.dispose = function () {
        if (this.composition) {
            this.composition.destroyItem(this);
            this.reset();
            this.onUpdate = function () { return -1; };
            this.composition = null;
            this._contentVisible = false;
            this.transform.setValid(false);
        }
    };
    return VFXItem;
}());
exports.Item = void 0;
(function (Item) {
    function is(item, type) {
        return item.type === type;
    }
    Item.is = is;
    function isFilter(item) {
        return item.type === ItemType$1.filter;
    }
    Item.isFilter = isFilter;
    function isComposition(item) {
        return item.type === ItemType$1.composition;
    }
    Item.isComposition = isComposition;
    function isParticle(item) {
        return item.type === ItemType$1.particle;
    }
    Item.isParticle = isParticle;
    function isNull(item) {
        return item.type === ItemType$1.null;
    }
    Item.isNull = isNull;
})(exports.Item || (exports.Item = {}));
/**
 * 根据元素的类型创建对应的 `VFXItem` 实例
 * @param props
 * @param composition
 */
function createVFXItem(props, composition) {
    var type = props.type;
    var pluginName = props.pluginName;
    if (!pluginName) {
        switch (type) {
            case ItemType$1.null:
            case ItemType$1.base:
                pluginName = 'cal';
                break;
            case ItemType$1.sprite:
                pluginName = 'sprite';
                break;
            case ItemType$1.particle:
                pluginName = 'particle';
                break;
            case ItemType$1.interact:
                pluginName = 'interact';
                break;
            case ItemType$1.camera:
                pluginName = 'camera';
                break;
            case ItemType$1.filter:
                pluginName = 'filter';
                break;
            case ItemType$1.text:
                pluginName = 'text';
                break;
            case ItemType$1.tree:
                pluginName = 'tree';
                break;
            default:
                throw new Error('invalid vfx item type');
        }
    }
    return composition.pluginSystem.createPluginItem(pluginName, props, composition);
}

var pluginLoaderMap = {};
var defaultPlugins = [];
var pluginCtrlMap = {};
/**
 * 注册 plugin
 * @param name
 * @param pluginClass class of plugin
 * @param itemClass class of item
 * @param isDefault load
 */
function registerPlugin(name, pluginClass, itemClass, isDefault) {
    pluginCtrlMap[name] = itemClass;
    pluginLoaderMap[name] = pluginClass;
    if (isDefault) {
        addItem(defaultPlugins, name);
    }
}
function unregisterPlugin(name) {
    delete pluginCtrlMap[name];
    delete pluginLoaderMap[name];
    removeItem(defaultPlugins, name);
}
var PluginSystem = /** @class */ (function () {
    function PluginSystem(pluginNames) {
        var loaders = {};
        var loaded = [];
        var addLoader = function (name) {
            var loader = pluginLoaderMap[name];
            if (!loaded.includes(loader)) {
                loaded.push(loader);
                loaders[name] = loader;
            }
        };
        defaultPlugins.forEach(addLoader);
        pluginNames.forEach(addLoader);
        this.plugins = Object.keys(loaders)
            .map(function (name) {
            var CTRL = pluginLoaderMap[name];
            if (!CTRL) {
                throw new Error("plugin '".concat(name, "' not found.") + getPluginUsageInfo(name));
            }
            var loader = new CTRL();
            loader.name = name;
            return loader;
        })
            .sort(function (a, b) { return a.order - b.order; });
    }
    PluginSystem.prototype.initializeComposition = function (composition, scene) {
        this.plugins.forEach(function (loader) { return loader.onCompositionConstructed(composition, scene); });
    };
    PluginSystem.prototype.destroyComposition = function (comp) {
        this.plugins.forEach(function (loader) { return loader.onCompositionDestroyed(comp); });
    };
    PluginSystem.prototype.resetComposition = function (comp, renderFrame) {
        this.plugins.forEach(function (loader) { return loader.onCompositionReset(comp, renderFrame); });
    };
    PluginSystem.prototype.createPluginItem = function (name, props, composition) {
        var CTRL = pluginCtrlMap[name];
        if (!CTRL) {
            throw new Error("plugin ".concat(name, " no registered constructor"));
        }
        var item = new CTRL(props, composition);
        if (!(item instanceof VFXItem)) {
            throw new Error("plugin ".concat(name, " invalid constructor type"));
        }
        return item;
    };
    PluginSystem.prototype.processRawJSON = function (json, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('processRawJSON', json, options)];
            });
        });
    };
    PluginSystem.prototype.callStatic = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var pendings, plugins, i, plugin, ctrl;
            return __generator(this, function (_a) {
                pendings = [];
                plugins = this.plugins;
                for (i = 0; i < plugins.length; i++) {
                    plugin = plugins[i];
                    ctrl = pluginLoaderMap[plugin.name];
                    if (name in ctrl) {
                        pendings.push(Promise.resolve(ctrl[name].apply(ctrl, __spreadArray$2([], __read$3(args), false))));
                    }
                }
                return [2 /*return*/, Promise.all(pendings)];
            });
        });
    };
    PluginSystem.prototype.precompile = function (compositions, renderer, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('precompile', compositions, renderer, options)];
            });
        });
    };
    PluginSystem.prototype.loadResources = function (scene, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.callStatic('prepareResource', scene, options)];
            });
        });
    };
    return PluginSystem;
}());
var pluginInfoMap = {
    'alipay-downgrade': '@galacean/effects-plugin-alipay-downgrade',
    'editor-gizmo': '@galacean/effects-plugin-editor-gizmo',
    'tree': '@galacean/effects-plugin-model',
    'model': '@galacean/effects-plugin-model',
    'orientation-transformer': '@galacean/effects-plugin-orientation-transformer',
    'spine': '@galacean/effects-plugin-spine',
};
function getPluginUsageInfo(name) {
    var info = pluginInfoMap[name];
    if (info) {
        return "\nInstall Plugin: npm i ".concat(info, "@latest --save\nImport Plugin: import '").concat(info, "'");
    }
    else {
        return '';
    }
}

/**
 * 抽象插件类
 * 注册合成不同生命周期的回调函数
 */
var AbstractPlugin = /** @class */ (function () {
    function AbstractPlugin() {
        this.order = 100;
        this.name = '';
    }
    /**
     * 在加载到 JSON 后，就可以进行提前编译
     * @param json
     * @param player
     */
    AbstractPlugin.precompile = function (compositions, renderer) {
        return Promise.resolve();
    };
    AbstractPlugin.prototype.onCompositionConstructed = function (composition, scene) { };
    AbstractPlugin.prototype.onCompositionItemLifeBegin = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionItemLifeEnd = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionItemRemoved = function (composition, item) { };
    AbstractPlugin.prototype.onCompositionReset = function (composition, frame) { };
    AbstractPlugin.prototype.onCompositionWillReset = function (composition, frame) { };
    AbstractPlugin.prototype.onCompositionDestroyed = function (composition) { };
    AbstractPlugin.prototype.onCompositionUpdate = function (composition, dt) { };
    AbstractPlugin.prototype.prepareRenderFrame = function (composition, frame) {
        return false;
    };
    AbstractPlugin.prototype.postProcessFrame = function (composition, frame) { };
    return AbstractPlugin;
}());

var CameraController = /** @class */ (function () {
    function CameraController(transform, model) {
        this.transform = transform;
        var position = transform.position;
        var rotation = transform.getRotation();
        var _a = model.options, near = _a.near, far = _a.far, fov = _a.fov, clipMode = _a.clipMode;
        this.clipMode = clipMode;
        this.options = {
            position: position.clone(),
            rotation: rotation.clone(),
            near: createValueGetter(near),
            far: createValueGetter(far),
            fov: createValueGetter(fov),
        };
        if (model.positionOverLifetime) {
            var _b = model.positionOverLifetime, path = _b.path, _c = _b.linearX, linearX = _c === void 0 ? 0 : _c, _d = _b.linearY, linearY = _d === void 0 ? 0 : _d, _e = _b.linearZ, linearZ = _e === void 0 ? 0 : _e;
            this.translateOverLifetime = {
                path: path && createValueGetter(path),
                x: createValueGetter(linearX),
                y: createValueGetter(linearY),
                z: createValueGetter(linearZ),
            };
        }
        if (model.rotationOverLifetime) {
            var _f = model.rotationOverLifetime, separateAxes = _f.separateAxes, _g = _f.x, x = _g === void 0 ? 0 : _g, _h = _f.y, y = _h === void 0 ? 0 : _h, _j = _f.z, z = _j === void 0 ? 0 : _j;
            this.rotationOverLifetime = {
                separateAxes: separateAxes,
                x: createValueGetter(x),
                y: createValueGetter(y),
                z: createValueGetter(z),
            };
        }
    }
    CameraController.prototype.update = function (lifetime) {
        var quat = new Quaternion();
        var position = new Vector3();
        var rotation = new Euler();
        position.copyFrom(this.options.position);
        rotation.copyFrom(this.options.rotation);
        var translateOverLifetime = this.translateOverLifetime;
        var rotationOverLifetime = this.rotationOverLifetime;
        lifetime = clamp$1(lifetime, 0, 1);
        if (translateOverLifetime) {
            position.x += translateOverLifetime.x.getValue(lifetime);
            position.y += translateOverLifetime.y.getValue(lifetime);
            position.z += translateOverLifetime.z.getValue(lifetime);
            if (translateOverLifetime.path) {
                var val = translateOverLifetime.path.getValue(lifetime);
                position.add(val);
            }
        }
        if (rotationOverLifetime) {
            var z = rotationOverLifetime.z.getValue(lifetime);
            rotation.z += z;
            if (rotationOverLifetime.separateAxes) {
                rotation.x += rotationOverLifetime.x.getValue(lifetime);
                rotation.y += rotationOverLifetime.y.getValue(lifetime);
            }
            else {
                rotation.x += z;
                rotation.y += z;
            }
        }
        this.far = this.options.far.getValue(lifetime);
        this.near = this.options.near.getValue(lifetime);
        this.fov = this.options.fov.getValue(lifetime);
        this.transform.setPosition(position.x, position.y, position.z);
        this.transform.setRotation(rotation.x, rotation.y, rotation.z);
        this.transform.assignWorldTRS(position, quat);
        this.position = position;
        this.rotation = Transform.getRotation(quat, rotation);
    };
    return CameraController;
}());

var CameraVFXItemLoader = /** @class */ (function (_super) {
    __extends(CameraVFXItemLoader, _super);
    function CameraVFXItemLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CameraVFXItemLoader;
}(AbstractPlugin));

var CameraVFXItem = /** @class */ (function (_super) {
    __extends(CameraVFXItem, _super);
    function CameraVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CameraVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.camera;
        },
        enumerable: false,
        configurable: true
    });
    CameraVFXItem.prototype.onConstructed = function (props) {
        this.model = props.content;
    };
    CameraVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        (_a = this.controller) === null || _a === void 0 ? void 0 : _a.update(lifetime);
        this.updateCamera();
    };
    CameraVFXItem.prototype.updateCamera = function () {
        if (this.controller && this.composition) {
            var camera = this.composition.camera;
            camera.near = this.controller.near;
            camera.far = this.controller.far;
            camera.fov = this.controller.fov;
            camera.clipMode = this.controller.clipMode;
            camera.position = this.controller.position;
            camera.rotation = this.controller.rotation;
        }
    };
    CameraVFXItem.prototype.getCurrentPosition = function () {
        return this.controller.position;
    };
    CameraVFXItem.prototype.doCreateContent = function () {
        if (!this.controller) {
            this.controller = new CameraController(this.transform, this.model);
        }
        return this.controller;
    };
    return CameraVFXItem;
}(VFXItem));

exports.HitTestType = void 0;
(function (HitTestType) {
    HitTestType[HitTestType["triangle"] = 1] = "triangle";
    HitTestType[HitTestType["box"] = 2] = "box";
    HitTestType[HitTestType["sphere"] = 3] = "sphere";
    HitTestType[HitTestType["custom"] = 4] = "custom";
})(exports.HitTestType || (exports.HitTestType = {}));

var EVENT_TYPE_CLICK = 'click';
var EVENT_TYPE_TOUCH_START = 'touchstart';
var EVENT_TYPE_TOUCH_MOVE = 'touchmove';
var EVENT_TYPE_TOUCH_END = 'touchend';
var InteractBehavior$1 = InteractBehavior$2;
var EventSystem = /** @class */ (function () {
    function EventSystem(target, allowPropagation) {
        if (allowPropagation === void 0) { allowPropagation = false; }
        this.target = target;
        this.allowPropagation = allowPropagation;
        this.enabled = true;
        this.handlers = {};
        this.nativeHandlers = {};
    }
    EventSystem.prototype.bindListeners = function () {
        var _a;
        var _this = this;
        var x;
        var y;
        var currentTouch;
        var lastTouch;
        var getTouch;
        getTouch = function (event) {
            return event;
        };
        var touchstart = 'mousedown';
        var touchmove = 'mousemove';
        var touchend = 'mouseup';
        var getTouchEventValue = function (event, x, y, dx, dy) {
            if (dx === void 0) { dx = 0; }
            if (dy === void 0) { dy = 0; }
            var vx = 0;
            var vy = 0;
            var ts = alipay.performance.now();
            if (!_this.target) {
                logger.error('Trigger TouchEvent after EventSystem is disposed');
                return {
                    x: x,
                    y: y,
                    vx: 0,
                    vy: vy,
                    dx: dx,
                    dy: dy,
                    ts: ts,
                    width: 0, height: 0, origin: event,
                };
            }
            var _a = _this.target, width = _a.width, height = _a.height;
            if (lastTouch) {
                var dt = ts - lastTouch.ts;
                vx = ((dx - lastTouch.dx) / dt) || 0;
                vy = ((dy - lastTouch.dy) / dt) || 0;
                lastTouch = { dx: dx, dy: dy, ts: ts };
            }
            return { x: x, y: y, vx: vx, vy: vy, dx: dx, dy: dy, ts: ts, width: width, height: height, origin: event };
        };
        if (isSimulatorCellPhone()) {
            getTouch = function (event) {
                var _a = event, touches = _a.touches, changedTouches = _a.changedTouches;
                return touches[0] || changedTouches[0];
            };
            touchstart = 'touchstart';
            touchmove = 'touchmove';
            touchend = 'touchend';
        }
        this.nativeHandlers = (_a = {},
            _a[touchstart] = function (event) {
                if (_this.enabled) {
                    var touch = getTouch(event);
                    var cood = getCoord(touch);
                    x = cood.x;
                    y = cood.y;
                    lastTouch = currentTouch = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        ts: alipay.performance.now(),
                        x: x,
                        y: y,
                    };
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_START, getTouchEventValue(event, x, y));
                }
            },
            _a[touchmove] = function (event) {
                if (currentTouch && _this.enabled) {
                    var cood = getCoord(getTouch(event));
                    x = cood.x;
                    y = cood.y;
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_MOVE, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
                }
            },
            _a[touchend] = function (event) {
                if (currentTouch && _this.enabled) {
                    if (!_this.allowPropagation && event.cancelable) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    var touch = getTouch(event);
                    var cood = getCoord(touch);
                    var dt = Math.abs(currentTouch.clientX - touch.clientX) + Math.abs(currentTouch.clientY - touch.clientY);
                    x = cood.x;
                    y = cood.y;
                    if (dt < 4) {
                        _this.dispatchEvent(EVENT_TYPE_CLICK, getTouchEventValue(event, x, y));
                    }
                    _this.dispatchEvent(EVENT_TYPE_TOUCH_END, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
                }
                currentTouch = 0;
            },
            _a);
        Object.keys(this.nativeHandlers).forEach(function (name) {
            var _a;
            (_a = _this.target) === null || _a === void 0 ? void 0 : _a.addEventListener(String(name), _this.nativeHandlers[name]);
        });
    };
    EventSystem.prototype.dispatchEvent = function (type, event) {
        var handlers = this.handlers[type];
        handlers === null || handlers === void 0 ? void 0 : handlers.forEach(function (fn) { return fn(event); });
    };
    EventSystem.prototype.addEventListener = function (type, callback) {
        var handlers = this.handlers[type];
        if (!handlers) {
            handlers = this.handlers[type] = [];
        }
        addItem(handlers, callback);
        return function () {
            removeItem(handlers, callback);
        };
    };
    EventSystem.prototype.removeEventListener = function (type, callback) {
        var handlers = this.handlers[type];
        if (handlers) {
            removeItem(handlers, callback);
        }
    };
    EventSystem.prototype.dispose = function () {
        var _this = this;
        if (this.target) {
            this.handlers = {};
            Object.keys(this.nativeHandlers).forEach(function (name) {
                var _a;
                (_a = _this.target) === null || _a === void 0 ? void 0 : _a.removeEventListener(String(name), _this.nativeHandlers[name]);
            });
            this.nativeHandlers = {};
            this.target = null;
        }
    };
    return EventSystem;
}());
function getCoord(event) {
    var ele = event.target;
    var clientX = event.clientX, clientY = event.clientY;
    var _a = ele.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
    var x = ((clientX - left) / width) * 2 - 1;
    var y = 1 - ((clientY - top) / height) * 2;
    return { x: x, y: y };
}

exports.ShaderType = void 0;
(function (ShaderType) {
    ShaderType[ShaderType["vertex"] = 0] = "vertex";
    ShaderType[ShaderType["fragment"] = 1] = "fragment";
})(exports.ShaderType || (exports.ShaderType = {}));

var _a$7;
function valIfUndefined(val, def) {
    if (val === undefined || val === null) {
        return def;
    }
    return val;
}
function getPreMultiAlpha(blending) {
    switch (blending) {
        case BlendingMode$1.ALPHA:
            return 1;
        case BlendingMode$1.ADD:
            return 1;
        case BlendingMode$1.SUBTRACTION:
            return 1;
        case BlendingMode$1.STRONG_LIGHT:
            return 1;
        case BlendingMode$1.WEAK_LIGHT:
            return 1;
        case BlendingMode$1.SUPERPOSITION:
            return 2;
        case BlendingMode$1.BRIGHTNESS:
            return 3;
        case BlendingMode$1.MULTIPLY:
            return 0;
        default:
            // 处理undefined
            return 1;
    }
}
var downgradeKeywords = (_a$7 = {},
    _a$7[exports.ShaderType.vertex] = {
        in: 'attribute',
        out: 'varying',
    },
    _a$7[exports.ShaderType.fragment] = {
        in: 'varying',
    },
    _a$7);
/**
 * 生成 shader，检测到 WebGL1 上下文会降级
 * @param marcos - 宏定义数组
 * @param shader - 原始 shader 文本
 * @param shaderType - shader 类型
 * @return 去除版本号的 shader 文本
 */
function createShaderWithMarcos(marcos, shader, shaderType, level) {
    var ret = [];
    var header = '';
    // shader 标志宏，没有其他含义，方便不支持完全的自定义 shader 的三方引擎接入使用
    ret.push('#define GE_RUNTIME');
    if (marcos) {
        marcos.forEach(function (_a) {
            var _b = __read$3(_a, 2), key = _b[0], value = _b[1];
            if (value === true) {
                ret.push("#define ".concat(key));
            }
            else if (Number.isFinite(value)) {
                ret.push("#define ".concat(key, " ").concat(value));
            }
        });
        header = ret.length ? (ret.join('\n') + '\n') : '';
    }
    var versionTag = /#version\s+\b\d{3}\b\s*(es)?/;
    var GL_TYPE = "WEBGL".concat(level);
    header = header + "\n#ifndef ".concat(GL_TYPE, "\n#define ").concat(GL_TYPE, "\n#endif");
    var fullShader = header + '\n' + shader;
    // 判断shader是否带有版本头
    var match = fullShader.match(versionTag);
    var version = match ? match[0] : '';
    if (version && version.includes('300')) {
        var reg = new RegExp("".concat(version), 'g');
        // 带版本头且level为1，降级
        if (level === 1) {
            fullShader = fullShader.replace(/\b(in|out)\b/g, function (str) { var _a; return (_a = downgradeKeywords[shaderType][str]) !== null && _a !== void 0 ? _a : str; });
        }
        fullShader = fullShader.replace(reg, '\n');
    }
    return fullShader;
}
function setBlendMode(material, blendMode) {
    switch (blendMode) {
        case undefined:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.ALPHA:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.ADD:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ONE, glContext.ONE];
            break;
        case BlendingMode$1.SUBTRACTION:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ZERO, glContext.ONE];
            material.blendEquation = [glContext.FUNC_REVERSE_SUBTRACT, glContext.FUNC_REVERSE_SUBTRACT];
            break;
        case BlendingMode$1.SUPERPOSITION:
            material.blendFunction = [glContext.ONE, glContext.ONE, glContext.ONE, glContext.ONE];
            break;
        case BlendingMode$1.MULTIPLY:
            material.blendFunction = [glContext.DST_COLOR, glContext.ONE_MINUS_SRC_ALPHA, glContext.DST_COLOR, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.BRIGHTNESS:
            material.blendFunction = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
            break;
        case BlendingMode$1.STRONG_LIGHT:
            material.blendFunction = [glContext.DST_COLOR, glContext.DST_ALPHA, glContext.ZERO, glContext.ONE];
            break;
        case BlendingMode$1.WEAK_LIGHT:
            material.blendFunction = [glContext.DST_COLOR, glContext.ZERO, glContext.ZERO, glContext.ONE];
            break;
        default:
            console.warn("blendMode ".concat(blendMode, " not in specification, please set blend params separately"));
    }
}
function setSideMode(material, side) {
    if (side === SideMode$1.DOUBLE) {
        material.culling = false;
    }
    else {
        material.culling = true;
        material.frontFace = glContext.CW;
        material.cullFace = side === SideMode$1.BACK ? glContext.BACK : glContext.FRONT;
    }
}
function setMaskMode(material, maskMode) {
    switch (maskMode) {
        case undefined:
            material.stencilTest = false;
            break;
        case MaskMode$1.MASK:
            material.stencilTest = true;
            material.stencilFunc = [glContext.ALWAYS, glContext.ALWAYS];
            material.stencilOpZPass = [glContext.REPLACE, glContext.REPLACE];
            break;
        case MaskMode$1.OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [glContext.EQUAL, glContext.EQUAL];
            break;
        case MaskMode$1.REVERSE_OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [glContext.NOTEQUAL, glContext.NOTEQUAL];
            break;
        case MaskMode$1.NONE:
            material.stencilTest = false;
            break;
        default:
            console.warn("maskMode ".concat(maskMode, " not in specification, please set stencil params seperately"));
    }
}

exports.TextureLoadAction = void 0;
(function (TextureLoadAction) {
    TextureLoadAction[TextureLoadAction["whatever"] = 0] = "whatever";
    //preserve previous attachment
    //load = 1,
    //clear attachment
    TextureLoadAction[TextureLoadAction["clear"] = 2] = "clear";
})(exports.TextureLoadAction || (exports.TextureLoadAction = {}));
exports.TextureSourceType = void 0;
(function (TextureSourceType) {
    TextureSourceType[TextureSourceType["none"] = 0] = "none";
    TextureSourceType[TextureSourceType["data"] = 1] = "data";
    TextureSourceType[TextureSourceType["image"] = 2] = "image";
    TextureSourceType[TextureSourceType["compressed"] = 3] = "compressed";
    TextureSourceType[TextureSourceType["video"] = 4] = "video";
    TextureSourceType[TextureSourceType["canvas"] = 5] = "canvas";
    TextureSourceType[TextureSourceType["framebuffer"] = 6] = "framebuffer";
    TextureSourceType[TextureSourceType["mipmaps"] = 7] = "mipmaps";
})(exports.TextureSourceType || (exports.TextureSourceType = {}));

/**
 * 负责下载各种资源，并提供了一些异步加载和缓存管理的功能
 */
var Downloader = /** @class */ (function () {
    function Downloader() {
        /**
         * 存储多个回调函数的对象
         */
        this.callbacks = {};
    }
    /**
     * 下载一个 JSON 文件
     * @param url - 要下载的 JSON 文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadJSON = function (url, onSuccess, onError) {
        this.download(url, 'json', onSuccess, onError);
    };
    /**
     * 下载一个二进制文件
     * @param url - 要下载的二进制文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadBinary = function (url, onSuccess, onError) {
        this.download(url, 'arraybuffer', onSuccess, onError);
    };
    /**
     * 下载一个 Blob 文件
     * @param url - 要下载的 Blob 文件的 URL
     * @param onSuccess - 下载成功后的回调函数
     * @param onError - 下载失败后的回调函数
     */
    Downloader.prototype.downloadBlob = function (url, onSuccess, onError) {
        this.download(url, 'blob', onSuccess, onError);
    };
    Downloader.prototype.download = function (url, responseType, onSuccess, onError) {
        var _this = this;
        if (responseType === void 0) { responseType = 'json'; }
        if (this.start(url, onSuccess, onError)) {
            return;
        }
        var xhr = new alipay.XMLHttpRequest();
        var handleError = function () {
            _this.finish(url, xhr.status, xhr.response);
        };
        var handleLoad = function () {
            if (xhr.status == 200 || xhr.status == 0) {
                _this.finish(url, 200, xhr.response);
            }
            else {
                handleError();
            }
        };
        xhr.responseType = responseType;
        xhr.addEventListener('load', handleLoad);
        xhr.addEventListener('error', handleError);
        xhr.open('GET', url, true);
        xhr.send();
    };
    Downloader.prototype.start = function (url, onSuccess, onError) {
        var callbacks = this.callbacks[url];
        try {
            if (callbacks) {
                return true;
            }
            this.callbacks[url] = callbacks = [];
        }
        finally {
            callbacks.push(onSuccess, onError);
        }
    };
    Downloader.prototype.finish = function (url, status, data) {
        var callbacks = this.callbacks[url];
        delete this.callbacks[url];
        var args = status == 200 || status == 0 ? [data] : [status, data];
        for (var i = args.length - 1, n = callbacks.length; i < n; i += 2) {
            callbacks[i].apply(null, args);
        }
    };
    return Downloader;
}());
var webPFailed = false;
/**
 * 异步加载一个 WebP 图片文件，如果不支持 WebP，则加载 PNG 图片文件
 * @param png - PNG 图片文件的 URL
 * @param webp - WebP 图片文件的 URL
 */
function loadWebPOptional(png, webp) {
    return __awaiter(this, void 0, void 0, function () {
        var image, image, image;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(webPFailed || !webp)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadImage(png)];
                case 1:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: png }];
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, loadImage(webp)];
                case 3:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: webp }];
                case 4:
                    _a.sent();
                    webPFailed = true;
                    return [4 /*yield*/, loadImage(png)];
                case 5:
                    image = _a.sent();
                    return [2 /*return*/, { image: image, url: png }];
                case 6: return [2 /*return*/];
            }
        });
    });
}
/**
 * 异步加载一个图片文件
 * @param source - 图片文件的 URL、Blob 或 HTMLImageElement 对象
 */
function loadImage(source) {
    return __awaiter(this, void 0, void 0, function () {
        var url, revokeURL;
        return __generator(this, function (_a) {
            url = '';
            // 1. string | Blob | HTMLImageElement 处理逻辑
            if (source instanceof alipay.HTMLImageElement) {
                if (source.complete) {
                    return [2 /*return*/, source];
                }
                url = source.src;
            }
            else if (source instanceof alipay.Blob) {
                url = alipay.URL.createObjectURL(source);
                revokeURL = true;
            }
            else if (typeof source === 'string') {
                url = source;
            }
            // 2. 非法类型
            if (!url) {
                throw new Error("Invalid url type: ".concat(JSON.stringify(source)));
            }
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var img = new alipay.Image();
                    if (!/^data:/.test(url)) {
                        img.crossOrigin = '*';
                    }
                    img.onload = function () {
                        img.onload = null;
                        if (revokeURL) {
                            alipay.URL.revokeObjectURL(url);
                        }
                        return resolve(img);
                    };
                    img.onerror = function (e) {
                        img.onerror = null;
                        if (revokeURL) {
                            alipay.URL.revokeObjectURL(url);
                        }
                        return reject("Load image fail: ".concat(url, ", reason: ").concat(JSON.stringify(e)));
                    };
                    img.src = url;
                })];
        });
    });
}
/**
 * 异步加载一个二进制文件
 * @param url - 二进制文件的 URL
 */
function loadBinary(url) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    new Downloader().downloadBinary(url, resolve, function (status, responseText) {
                        reject("Couldn't load bins ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                    });
                })];
        });
    });
}
/**
 * 异步加载一个 Blob 文件
 * @param url - Blob 文件的 URL
 */
function loadBlob(url) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    new Downloader().downloadBlob(url, resolve, function (status, responseText) {
                        reject("Couldn't load blob ".concat(url, ": status ").concat(status, ", ").concat(responseText));
                    });
                })];
        });
    });
}
/**
 * 异步加载一个视频文件
 * @param url - 视频文件的 URL 或 MediaProvider 对象
 */
function loadVideo(url) {
    return __awaiter(this, void 0, void 0, function () {
        var video;
        return __generator(this, function (_a) {
            video = alipay.document.createElement('video');
            if (typeof url === 'string') {
                video.src = url;
            }
            else {
                video.srcObject = url;
            }
            video.crossOrigin = 'anonymous';
            video.muted = true;
            if (isAndroid()) {
                video.setAttribute('renderer', 'standard');
            }
            video.setAttribute('playsinline', 'playsinline');
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var pending = video.play();
                    if (pending) {
                        void pending.then(function () { return resolve(video); });
                    }
                    else {
                        video.addEventListener('loadeddata', function listener() {
                            resolve(video);
                            video.removeEventListener('loadeddata', listener);
                        }, true);
                    }
                    video.addEventListener('error', function (e) {
                        reject(e);
                    });
                })];
        });
    });
}

function deserializeMipmapTexture(texOpts, bins, files) {
    if (files === void 0) { files = []; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, mipmaps, target, jobs, loadedMipmaps, bin, _b, mipmaps, target, jobs, loadedMipmaps, bin;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!(texOpts.target === 34067)) return [3 /*break*/, 2];
                    _a = texOpts, mipmaps = _a.mipmaps, target = _a.target;
                    jobs = mipmaps.map(function (mipmap) { return Promise.all(mipmap.map(function (pointer) { return loadMipmapImage(pointer, bins); })); });
                    return [4 /*yield*/, Promise.all(jobs)];
                case 1:
                    loadedMipmaps = _c.sent();
                    bin = files[mipmaps[0][0][1][0]].url;
                    return [2 /*return*/, __assign$1(__assign$1({ keepImageSource: false }, texOpts), {
                            mipmaps: loadedMipmaps,
                            sourceFrom: {
                                target: target,
                                bin: bin,
                                type: exports.TextureSourceType.mipmaps,
                                mipmaps: mipmaps.map(function (mipmap) { return mipmap.map(function (pointer) { return [pointer[1][1], pointer[1][2]]; }); }),
                            },
                        })];
                case 2:
                    _b = texOpts, mipmaps = _b.mipmaps, target = _b.target;
                    jobs = mipmaps.map(function (pointer) { return loadMipmapImage(pointer, bins); });
                    return [4 /*yield*/, Promise.all(jobs)];
                case 3:
                    loadedMipmaps = _c.sent();
                    bin = files[mipmaps[0][1][0]].url;
                    return [2 /*return*/, __assign$1(__assign$1({ keepImageSource: false }, texOpts), {
                            mipmaps: loadedMipmaps,
                            sourceType: exports.TextureSourceType.mipmaps,
                            sourceFrom: {
                                target: target,
                                bin: bin,
                                type: exports.TextureSourceType.mipmaps,
                                mipmaps: mipmaps.map(function (pointer) { return [pointer[1][1], pointer[1][2]]; }),
                            },
                        })];
            }
        });
    });
}
function loadMipmapImage(pointer, bins) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, index, start, length, bin;
        return __generator(this, function (_b) {
            _a = __read$3(pointer[1], 3), index = _a[0], start = _a[1], length = _a[2];
            bin = bins[index];
            if (!bin) {
                throw new Error("invalid bin pointer: ".concat(JSON.stringify(pointer)));
            }
            return [2 /*return*/, loadImage(new alipay.Blob([new Uint8Array(bin, start, length)]))];
        });
    });
}

var seed$d = 1;
/**
 * Texture 抽象类
 */
var Texture = /** @class */ (function () {
    function Texture() {
        this.destroyed = false;
        this.id = 'Tex' + seed$d++;
    }
    Object.defineProperty(Texture.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取 Texture 的宽度。
     */
    Texture.prototype.getWidth = function () {
        return this.width || 0;
    };
    /**
     * 获取 Texture 的高度。
     */
    Texture.prototype.getHeight = function () {
        return this.height || 0;
    };
    Texture.prototype.uploadCurrentVideoFrame = function () {
        // OVERRIDE
    };
    /**
     * 释放 Texture GPU 资源。
     * 注意：该方法只释放资源，并不销毁 GPU textureBuffer 对象。
     * @override
     */
    Texture.prototype.offloadData = function () {
        // OVERRIDE
    };
    /**
     * 重新加载 Texture  GPU 资源。
     * @override
     */
    Texture.prototype.reloadData = function () {
        // OVERRIDE
    };
    /**
     * 初始化 GPU 资源
     * @override
     */
    Texture.prototype.initialize = function () {
        // OVERRIDE
    };
    Texture.prototype.assembleOptions = function (options) {
        var _a = options.target, target = _a === void 0 ? glContext.TEXTURE_2D : _a, _b = options.format, internalFormat = _b === void 0 ? glContext.RGBA : _b;
        if (!options.sourceType) {
            if ('image' in options) {
                options.sourceType = exports.TextureSourceType.image;
            }
            else if ('data' in options) {
                options.sourceType = exports.TextureSourceType.data;
            }
            else if ('video' in options) {
                options.sourceType = exports.TextureSourceType.video;
            }
            else {
                options.sourceType = 0; // TextureSourceType.none
            }
        }
        return __assign$1({ minFilter: glContext.NEAREST, magFilter: glContext.NEAREST, wrapS: glContext.CLAMP_TO_EDGE, wrapT: glContext.CLAMP_TO_EDGE, target: target, format: glContext.RGBA, internalFormat: internalFormat, type: glContext.UNSIGNED_BYTE }, options);
    };
    return Texture;
}());
function generateHalfFloatTexture(engine, data, width, height) {
    var channel = data.length / width / height;
    var format;
    var internalFormat;
    if (channel === 4 || channel === 0) {
        internalFormat = format = glContext.RGBA;
    }
    else if (channel === 3) {
        internalFormat = format = glContext.RGB;
    }
    else if (channel === 2) {
        internalFormat = format = glContext.LUMINANCE_ALPHA;
    }
    else {
        internalFormat = format = glContext.LUMINANCE;
    }
    return Texture.createWithData(engine, {
        data: data,
        width: width,
        height: height,
    }, {
        type: glContext.HALF_FLOAT,
        format: format,
        internalFormat: internalFormat,
        wrapS: glContext.CLAMP_TO_EDGE,
        wrapT: glContext.CLAMP_TO_EDGE,
    });
}

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
var TEX_2D = 2; // uses a gl.texImage2D()
//const TEX_3D = 3; // uses a gl.texImage3D()
var KTXTexture = /** @class */ (function () {
    function KTXTexture(arrayBuffer, facesExpected, baseOffset) {
        if (baseOffset === void 0) { baseOffset = 0; }
        this.arrayBuffer = arrayBuffer;
        this.baseOffset = baseOffset;
        // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
        // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
        // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
        var identifier = new Uint8Array(this.arrayBuffer, this.baseOffset, 12);
        if (identifier[0] !== 0xab ||
            identifier[1] !== 0x4b ||
            identifier[2] !== 0x54 ||
            identifier[3] !== 0x58 ||
            identifier[4] !== 0x20 ||
            identifier[5] !== 0x31 ||
            identifier[6] !== 0x31 ||
            identifier[7] !== 0xbb ||
            identifier[8] !== 0x0d ||
            identifier[9] !== 0x0a ||
            identifier[10] !== 0x1a ||
            identifier[11] !== 0x0a) {
            throw Error('texture missing KTX identifier');
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(this.arrayBuffer, this.baseOffset + 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
        this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            logger.warn('Only 2D textures currently supported');
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            logger.warn('Texture arrays not currently supported');
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            logger.warn('Number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        if (this.glType === 0) {
            this.loadType = COMPRESSED_2D;
        }
        else {
            this.loadType = TEX_2D;
        }
    }
    KTXTexture.prototype.mipmaps = function (loadMipmaps) {
        var mipmaps = [];
        // initialize width & height for level 1
        var dataOffset = HEADER_LEN + this.bytesOfKeyValueData;
        var width = this.pixelWidth;
        var height = this.pixelHeight;
        var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for (var level = 0; level < mipmapCount; level++) {
            var imageSize = new Int32Array(this.arrayBuffer, this.baseOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            for (var face = 0; face < this.numberOfFaces; face++) {
                var data = new Uint8Array(this.arrayBuffer, this.baseOffset + dataOffset + 4, imageSize);
                mipmaps.push({
                    data: data,
                    width: width,
                    height: height,
                });
                dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field
                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
        return mipmaps;
    };
    return KTXTexture;
}());
function getKTXTextureOptions(data) {
    var tex = new KTXTexture(data, 1);
    var numberOfMipmapLevels = tex.numberOfMipmapLevels, pixelWidth = tex.pixelWidth, pixelHeight = tex.pixelHeight, glType = tex.glType, numberOfFaces = tex.numberOfFaces, glInternalFormat = tex.glInternalFormat, glFormat = tex.glFormat;
    var useMipmaps = numberOfMipmapLevels >= Math.floor(Math.log2(Math.max(pixelWidth, pixelHeight)) + 1);
    return {
        sourceType: exports.TextureSourceType.compressed,
        type: glType,
        target: numberOfFaces === 6 ? glContext.TEXTURE_CUBE_MAP : glContext.TEXTURE_2D,
        internalFormat: glInternalFormat,
        format: glFormat,
        mipmaps: tex.mipmaps(useMipmaps),
    };
}

var TextureFactory = /** @class */ (function () {
    function TextureFactory() {
        this.reloadPending = {};
    }
    TextureFactory.prototype.reload = function (texture) {
        return __awaiter(this, void 0, void 0, function () {
            var id, sourceOpts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = texture.id;
                        if (this.reloadPending[id]) {
                            return [2 /*return*/];
                        }
                        if (!texture.sourceFrom) return [3 /*break*/, 2];
                        this.reloadPending[id] = true;
                        return [4 /*yield*/, this.loadSource(texture.sourceFrom)];
                    case 1:
                        sourceOpts = _a.sent();
                        texture.updateSource(sourceOpts);
                        this.reloadPending[id] = false;
                        return [3 /*break*/, 3];
                    case 2: throw new Error('No source from');
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    TextureFactory.prototype.canOffloadTexture = function (sourceFrom) {
        if (sourceFrom) {
            var type = sourceFrom.type;
            if (type === exports.TextureSourceType.compressed ||
                type === exports.TextureSourceType.image) {
                var _a = sourceFrom, target = _a.target, map = _a.map;
                var url = sourceFrom.url;
                if (target === glContext.TEXTURE_CUBE_MAP) {
                    return typeof map === 'object' && !!map;
                }
                return isString(url) && url.length > 0;
            }
            if (type === exports.TextureSourceType.mipmaps) {
                var _b = sourceFrom, bin = _b.bin, mipmaps = _b.mipmaps;
                var _c = sourceFrom, target = _c.target, maps = _c.maps;
                var urls = sourceFrom.urls;
                if (bin) {
                    return mipmaps.length > 0;
                }
                if (target === glContext.TEXTURE_CUBE_MAP) {
                    return maps.every(function (map) { return typeof map === 'object' && map; });
                }
                return urls.every(function (url) { return isString(url) && url.length > 0; });
            }
        }
        return false;
    };
    TextureFactory.prototype.loadSource = function (sourceFrom, config) {
        return __awaiter(this, void 0, void 0, function () {
            var type, target, map, url, _a, bin, mipmaps, urls, maps, cube, image, video, buffer, data_1, newTarget, newMipmaps, loadedMipmaps, loadedMipmaps, loadedMipmaps;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        type = sourceFrom.type, target = sourceFrom.target;
                        map = sourceFrom.map;
                        url = sourceFrom.url;
                        _a = sourceFrom, bin = _a.bin, mipmaps = _a.mipmaps;
                        urls = sourceFrom.urls;
                        maps = sourceFrom.maps;
                        if (!(target === glContext.TEXTURE_CUBE_MAP && type !== exports.TextureSourceType.mipmaps)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadCubeMap(map)];
                    case 1:
                        cube = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { cube: cube, target: glContext.TEXTURE_CUBE_MAP, sourceType: exports.TextureSourceType.image, sourceFrom: { type: exports.TextureSourceType.image, map: __assign$1({}, map), target: glContext.TEXTURE_CUBE_MAP } })];
                    case 2:
                        if (!(type === exports.TextureSourceType.image)) return [3 /*break*/, 4];
                        return [4 /*yield*/, loadImage(url)];
                    case 3:
                        image = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { image: image, sourceType: exports.TextureSourceType.image, sourceFrom: { type: type, url: url, target: glContext.TEXTURE_2D } })];
                    case 4:
                        if (!(type === exports.TextureSourceType.video)) return [3 /*break*/, 6];
                        return [4 /*yield*/, loadVideo(url)];
                    case 5:
                        video = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { video: video, sourceType: exports.TextureSourceType.video })];
                    case 6:
                        if (!(type === exports.TextureSourceType.compressed)) return [3 /*break*/, 8];
                        return [4 /*yield*/, loadBinary(url)];
                    case 7:
                        buffer = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1(__assign$1({}, getKTXTextureOptions(buffer)), config), { sourceFrom: { url: url, type: exports.TextureSourceType.compressed } })];
                    case 8:
                        if (!(type === exports.TextureSourceType.mipmaps)) return [3 /*break*/, 17];
                        if (!bin) return [3 /*break*/, 13];
                        return [4 /*yield*/, loadBinary(bin)];
                    case 9:
                        data_1 = _b.sent();
                        newTarget = target !== null && target !== void 0 ? target : glContext.TEXTURE_2D;
                        newMipmaps = newTarget === glContext.TEXTURE_2D ? mipmaps.slice() : mipmaps.map(function (s) { return s.slice(); });
                        loadedMipmaps = void 0;
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [3 /*break*/, 11];
                        return [4 /*yield*/, Promise.all(mipmaps.map(function (mipmap) { return _this.loadMipmapImages(mipmap, data_1); }))];
                    case 10:
                        loadedMipmaps = _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        loadedMipmaps = this.loadMipmapImages(mipmaps, data_1);
                        _b.label = 12;
                    case 12: return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: newTarget, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { bin: bin, mipmaps: newMipmaps, target: newTarget, type: exports.TextureSourceType.mipmaps } })];
                    case 13:
                        if (!(target === glContext.TEXTURE_2D || !target)) return [3 /*break*/, 15];
                        return [4 /*yield*/, Promise.all(urls.map(function (url) { return loadImage(url); }))];
                    case 14:
                        loadedMipmaps = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: glContext.TEXTURE_2D, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { type: type, urls: urls.slice(), target: glContext.TEXTURE_2D } })];
                    case 15:
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [3 /*break*/, 17];
                        return [4 /*yield*/, Promise.all(maps.map(function (map) { return _this.loadCubeMap(map); }))];
                    case 16:
                        loadedMipmaps = _b.sent();
                        return [2 /*return*/, __assign$1(__assign$1({}, config), { mipmaps: loadedMipmaps, target: glContext.TEXTURE_CUBE_MAP, sourceType: exports.TextureSourceType.mipmaps, sourceFrom: { type: type, maps: maps.map(function (map) { return (__assign$1({}, map)); }), target: glContext.TEXTURE_CUBE_MAP } })];
                    case 17: throw new Error("Invalid resource type: ".concat(type));
                }
            });
        });
    };
    TextureFactory.prototype.loadMipmapImages = function (pointers, bin) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(pointers.map(function (pointer) {
                        var blob = new alipay.Blob([new Uint8Array(bin, pointer[0], pointer[1])]);
                        return loadImage(blob);
                    }))];
            });
        });
    };
    TextureFactory.prototype.loadCubeMap = function (cubemap) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(cubemap.map(function (key) { return loadImage(key); }))];
            });
        });
    };
    return TextureFactory;
}());
var g;
function getDefaultTextureFactory() {
    if (!g) {
        g = new TextureFactory();
    }
    return g;
}
function setDefaultTextureFactory(factory) {
    g = factory;
}

/**
 * 引擎接入暂时不需要实现
 */
var MaterialDataBlock = /** @class */ (function () {
    function MaterialDataBlock(props) {
        this.destroyed = false;
        var _a = props.name, name = _a === void 0 ? 'defaultDataBlock' : _a;
        this.name = name;
    }
    MaterialDataBlock.prototype.setUniformValues = function (uniformValue) {
        var _this = this;
        Object.keys(uniformValue).forEach(function (key) {
            _this.setUniformValue(key, uniformValue[key]);
        });
    };
    MaterialDataBlock.prototype.invalidAllFlags = function () {
        // OVERRIDE
    };
    MaterialDataBlock.prototype.updateUniformSubData = function (name, start, count) {
        // OVERRIDE
    };
    return MaterialDataBlock;
}());
function isUniformStruct(value) {
    return typeof value === 'object' && value && value.length === undefined && value instanceof Texture;
}
function isUniformStructArray(value) {
    return value && value.length !== undefined && isUniformStruct(value[0]);
}

/**
 * 材质渲染类型
 */
exports.MaterialRenderType = void 0;
(function (MaterialRenderType) {
    MaterialRenderType[MaterialRenderType["normal"] = 0] = "normal";
    MaterialRenderType[MaterialRenderType["transformFeedback"] = 1] = "transformFeedback";
})(exports.MaterialRenderType || (exports.MaterialRenderType = {}));
/**
 * 用于设置材质默认名称的自增序号
 * @internal
 */
var seed$c = 1;
/**
 * Material 抽象类
 */
var Material = /** @class */ (function () {
    /**
     *
     * @param props - 材质属性
     */
    function Material(props) {
        this.props = props;
        this.destroyed = false;
        this.initialized = false;
        var _a = props.name, name = _a === void 0 ? 'Material' + seed$c++ : _a, _b = props.renderType, renderType = _b === void 0 ? exports.MaterialRenderType.normal : _b, shader = props.shader, uniformSemantics = props.uniformSemantics;
        this.name = name;
        this.renderType = renderType;
        this.shaderSource = shader;
        this.uniformSemantics = __assign$1({}, uniformSemantics);
    }
    Object.defineProperty(Material.prototype, "blending", {
        /******** effects-core 中会调用 引擎必须实现 ***********************/
        /**
         * 设置 Material 的颜色融合开关
         * @param blending - 是否开启混合效果
         */
        set: function (blending) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendFunction", {
        /**
         * 分别指定 Material 的颜色混合函数乘数
         * @param func - 混合函数参数
         */
        set: function (func) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendEquation", {
        /**
         * 分别指定 Material 的颜色混合方式
         * @param equation - 混合方程参数
         */
        set: function (equation) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthTest", {
        /**
         * 设置 Material 的深度测试开关
         * @param value - 是否开启深度测试
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthMask", {
        /**
         * 设置 Material 的写入深度缓冲开关
         * @param value - 是否开启深度写入
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilTest", {
        /**
         * 设置 Material 的模板测试开关
         * @param value - 是否开启模板测试
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilRef", {
        /**
         * 分别指定 Material 的模板测试参考值
         * @param value  - 模板测试参考值参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilFunc", {
        /**
         * 分别指定 Material 的模板测试函数
         * @param value - 模板测试函数参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpZPass", {
        /**
         * 分别指定 Material 的模板测试和深度测试都通过时使用的函数
         * @param value - 模板测试深度测试通过时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "culling", {
        /**
         * 设置 Material 的正反面剔除开关
         * @param value - 是否开启剔除
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "frontFace", {
        /**
         * 设置 Material 的正反面计算方向
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "cullFace", {
        /**
         * 设置 Material 要剔除的面
         * @param value - 剔除面参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "blendColor", {
        /***************************************************/
        /******** effects-core 中暂无调用 引擎可以先不实现 ***********************/
        /**
         * 设置 Material 的源和目标混合因子
         * @param color
         */
        set: function (color) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthRange", {
        /**
         * 设置 Material 的深度映射范围
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "depthFunc", {
        /**
         * 设置 Material 的深度比较函数
         * @param value - 深度测试函数参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "polygonOffsetFill", {
        /**
         * 设置 Material 的多边形偏移（实现类似深度偏移的效果）
         * @param value - 多边形偏移参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "polygonOffset", {
        /**
         * 指定 Material 计算深度值的比例因子 factor 和单位 units
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "sampleAlphaToCoverage", {
        /**
         * 设置 Material 的通过 alpha 值决定临时覆盖值计算的开关
         * @param value - 是否开启 alpha 抖动
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "colorMask", {
        /**
         * 设置 Material 颜色缓冲区的写入开关
         * @param value
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilMask", {
        /**
         * 分别指定 Material 的模板测试掩码
         * @param value - 模板测试写入掩码参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpFail", {
        /**
         * 分别指定 Material 模板测试失败时要使用的函数
         * @param value - 模板测试失败时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Material.prototype, "stencilOpZFail", {
        /**
         * 分别指定 Material 模板测试通过但深度测试失败时要使用的函数
         * @param value - 模板测试深度测试失败时的操作参数
         */
        set: function (value) { },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化 GPU 资源
     * @override
     */
    Material.prototype.initialize = function () {
        // OVERRIDE
    };
    Material.prototype.use = function (render, globalUniforms) {
        // OVERRIDE
    };
    return Material;
}());

var copyFrag = "uniform vec2 uFilterSourceSize;uniform sampler2D uFilterSource;\n#define INTERPOLATION 1\nvec4 filterMain(vec2 texCoord,sampler2D tex){\n#ifdef INTERPOLATION\nvec2 texInPixel=texCoord*uFilterSourceSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uFilterSourceSize,(coordMin+vec2(1.))/uFilterSourceSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));return mix(mix(cLB,cRB,pp.x),mix(cLT,cRT,pp.x),pp.y);\n#else\nreturn texture2D(uFilterSource,texCoord);\n#endif\n}";

exports.ShaderCompileResultStatus = void 0;
(function (ShaderCompileResultStatus) {
    ShaderCompileResultStatus[ShaderCompileResultStatus["noShader"] = 0] = "noShader";
    ShaderCompileResultStatus[ShaderCompileResultStatus["success"] = 1] = "success";
    ShaderCompileResultStatus[ShaderCompileResultStatus["fail"] = 2] = "fail";
    ShaderCompileResultStatus[ShaderCompileResultStatus["compiling"] = 3] = "compiling";
})(exports.ShaderCompileResultStatus || (exports.ShaderCompileResultStatus = {}));
exports.GLSLVersion = void 0;
(function (GLSLVersion) {
    GLSLVersion["GLSL1"] = "100";
    GLSLVersion["GLSL3"] = "300 es";
})(exports.GLSLVersion || (exports.GLSLVersion = {}));
var Shader = /** @class */ (function () {
    function Shader(source) {
        this.source = source;
    }
    return Shader;
}());

var EFFECTS_COPY_MESH_NAME = 'effects-internal-copy';
var COPY_MESH_SHADER_ID = 'effects-internal-copy-mesh';
var COPY_VERTEX_SHADER = "\n#ifdef WEBGL2\n#define vsIn in\n#define vsOut out\n#else\n#define vsIn attribute\n#define vsOut varying\n#endif\nprecision highp float;\nvsIn vec2 aPos;\nvsOut vec2 vTex;\nvoid main(){\n    gl_Position = vec4(aPos,0.,1.0);\n    vTex = (aPos + vec2(1.0))/2.;\n}";
var COPY_FRAGMENT_SHADER = "precision mediump float;\n#ifdef WEBGL2\n#define fsIn in\n#define fsOut out\n#define texture2D texture\n#else\n#define fsIn varying\n#endif\n".concat(copyFrag, "\nfsIn vec2 vTex;\n#ifdef WEBGL2\nlayout (location = 0) out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\n\n#ifdef DEPTH_TEXTURE\nuniform sampler2D uDepth;\n#ifndef WEBGL2\n#extension GL_EXT_frag_depth : enable\n#define gl_FragDepth gl_FragDepthEXT\n#endif\n#endif\nvoid main(){\n    fragColor = filterMain(vTex,uFilterSource);\n    #ifdef DEPTH_TEXTURE\n    gl_FragDepth = texture2D(uDepth,vTex).r;\n    #endif\n}\n");
function createCopyShader(level, writeDepth) {
    var webgl2 = level === 2;
    var version = webgl2 ? '#version 300 es' : '';
    return {
        name: EFFECTS_COPY_MESH_NAME,
        vertex: createShaderWithMarcos([], version + '\n' + COPY_VERTEX_SHADER, exports.ShaderType.vertex, level),
        fragment: createShaderWithMarcos([], version + '\n' + COPY_FRAGMENT_SHADER, exports.ShaderType.fragment, level),
        glslVersion: webgl2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1,
        marcos: [
            ['WEBGL2', !!webgl2],
            ['DEPTH_TEXTURE', !!writeDepth],
        ],
        // @ts-expect-error
        cacheId: COPY_MESH_SHADER_ID + (+writeDepth),
    };
}

var def = {
    format: glContext.RGBA,
    type: glContext.UNSIGNED_BYTE,
    minFilter: glContext.LINEAR,
    magFilter: glContext.LINEAR,
    wrapS: glContext.CLAMP_TO_EDGE,
    wrapT: glContext.CLAMP_TO_EDGE,
};
var disposeSymbol = Symbol('dispose');
var PassTextureCache = /** @class */ (function () {
    function PassTextureCache(engine) {
        this.textureCache = {};
        this.textureRef = {};
        this.engine = engine;
    }
    PassTextureCache.prototype.requestColorAttachmentTexture = function (request) {
        var _this = this;
        var width = request.width, height = request.height, name = request.name;
        var options = {
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: width,
                height: height,
            },
            name: name,
        };
        var keys = [name];
        Object.getOwnPropertyNames(def).forEach(function (name) {
            var _a;
            var value = (_a = request[name]) !== null && _a !== void 0 ? _a : def[name];
            options[name] = value;
            keys.push(name, value);
        });
        var cacheId = keys.join(':');
        var tex = this.textureCache[cacheId];
        if (tex) {
            this.textureRef[cacheId]++;
        }
        else {
            var engine = this.engine;
            assertExist(engine);
            tex = Texture.create(engine, options);
            this.textureCache[cacheId] = tex;
            this.textureRef[cacheId] = 1;
            // @ts-expect-error
            tex[disposeSymbol] = tex.dispose;
            tex.dispose = function () { return _this.removeTexture(cacheId); };
        }
        return tex;
    };
    PassTextureCache.prototype.removeTexture = function (id) {
        var refCount = this.textureRef[id];
        if (refCount <= 1) {
            if (refCount < 0) {
                console.error('ref count < 0');
            }
            var tex = this.textureCache[id];
            if (tex) {
                // @ts-expect-error
                tex[disposeSymbol]();
                // @ts-expect-error
                tex.dispose = tex[disposeSymbol];
            }
            delete this.textureCache[id];
            delete this.textureRef[id];
        }
        else {
            this.textureRef[id] = refCount - 1;
        }
    };
    PassTextureCache.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.textureCache).forEach(function (key) {
            var texture = _this.textureCache[key];
            // @ts-expect-error
            texture[disposeSymbol]();
            // @ts-expect-error
            texture.dispose = texture[disposeSymbol];
        });
        this.textureCache = {};
        this.textureRef = {};
        this.engine = undefined;
    };
    return PassTextureCache;
}());

var SemanticMap = /** @class */ (function () {
    function SemanticMap(semantics) {
        if (semantics === void 0) { semantics = {}; }
        this.semantics = __assign$1({}, semantics);
    }
    SemanticMap.prototype.toObject = function () {
        return __assign$1({}, this.semantics);
    };
    SemanticMap.prototype.setSemantic = function (name, value) {
        if (value === undefined) {
            delete this.semantics[name];
        }
        else {
            this.semantics[name] = value;
        }
    };
    SemanticMap.prototype.getSemanticValue = function (name, state) {
        var ret = this.semantics[name];
        if (isFunction(ret)) {
            return ret(state);
        }
        return ret;
    };
    SemanticMap.prototype.hasSemanticValue = function (name) {
        return name in this.semantics;
    };
    SemanticMap.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.semantics).forEach(function (name) {
            delete _this.semantics[name];
        });
    };
    return SemanticMap;
}());

var _a$6;
var BYTES_TYPE_MAP = (_a$6 = {},
    _a$6[glContext.FLOAT] = Float32Array.BYTES_PER_ELEMENT,
    _a$6[glContext.INT] = Int32Array.BYTES_PER_ELEMENT,
    _a$6[glContext.SHORT] = Int16Array.BYTES_PER_ELEMENT,
    _a$6[glContext.BYTE] = Int8Array.BYTES_PER_ELEMENT,
    _a$6);
/**
 * Geometry 抽象类
 */
var Geometry = /** @class */ (function () {
    /**
     * Geometry 创建函数
     * @param name - 名称
     */
    function Geometry(name) {
        this.name = name;
    }
    /**
     * 初始化 GPU 资源
     * @override
     */
    Geometry.prototype.initialize = function () {
        // OVERRIDE
    };
    /**
     * 几何数据刷新
     */
    Geometry.prototype.flush = function () {
        // OVERRIDE
    };
    return Geometry;
}());
function generateEmptyTypedArray(type) {
    if (type === glContext.INT) {
        return new Int32Array(0);
    }
    if (type === glContext.SHORT) {
        return new Int16Array(0);
    }
    return new Float32Array(0);
}

var RUNTIME_ENV = 'runtime_env';
var RENDER_PREFER_LOOKUP_TEXTURE = 'lookup_texture';
// 数据模板使用 offscreen canvas 绘制
var TEMPLATE_USE_OFFSCREEN_CANVAS = 'offscreen_canvas';
// 后处理配置相关
var POST_PROCESS_SETTINGS = 'post_process_settings';
var config = {};
function getConfig(name) {
    return config[name];
}
function setConfig(name, value) {
    return config[name] = value;
}

var seed$b = 1;
/**
 * Mesh 抽象类
 */
var Mesh = /** @class */ (function () {
    function Mesh(engine, props) {
        this.engine = engine;
        this.destroyed = false;
        this.visible = true;
        var material = props.material, geometry = props.geometry, _a = props.name, name = _a === void 0 ? '<unnamed>' : _a, _b = props.priority, priority = _b === void 0 ? 0 : _b, _c = props.worldMatrix, worldMatrix = _c === void 0 ? Matrix4$1.fromIdentity() : _c;
        this.id = 'Mesh' + seed$b++;
        this.name = name;
        this.geometry = geometry;
        this.material = material;
        this.priority = priority;
        this.worldMatrix = worldMatrix;
    }
    Object.defineProperty(Mesh.prototype, "priority", {
        get: function () {
            return this._priority;
        },
        set: function (value) {
            this._priority = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mesh.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置当前 Mesh 的可见性。
     * @param visible - true：可见，false：不可见
     */
    Mesh.prototype.setVisible = function (visible) {
        this.visible = visible;
    };
    Mesh.prototype.render = function (renderer) {
        var renderingData = renderer.renderingData;
        var material = this.material;
        if (renderingData.currentFrame.globalUniforms) {
            if (renderingData.currentCamera) {
                renderer.setGlobalMatrix('effects_MatrixInvV', renderingData.currentCamera.getInverseViewMatrix());
                renderer.setGlobalMatrix('effects_MatrixV', renderingData.currentCamera.getViewMatrix());
                renderer.setGlobalMatrix('effects_MatrixVP', renderingData.currentCamera.getViewProjectionMatrix());
                renderer.setGlobalMatrix('_MatrixP', renderingData.currentCamera.getProjectionMatrix());
            }
            renderer.setGlobalMatrix('effects_ObjectToWorld', this.worldMatrix);
        }
        if (renderingData.currentFrame.editorTransform) {
            material.setVector4('uEditorTransform', renderingData.currentFrame.editorTransform);
        }
        material.use(renderer, renderingData.currentFrame.globalUniforms);
        var geo = this.geometry;
        // 执行 Geometry 的数据刷新
        geo.flush();
        renderer.drawGeometry(geo, material);
    };
    /**
     * 获取当前 Mesh 的可见性。
     */
    Mesh.prototype.getVisible = function () {
        return this.visible;
    };
    /**
     * 获取当前 Mesh 的第一个 geometry。
     */
    Mesh.prototype.firstGeometry = function () {
        return this.geometry;
    };
    /**
     * 设置当前 Mesh 的材质
     * @param material - 要设置的材质
     * @param destroy - 可选的材质销毁选项
     */
    Mesh.prototype.setMaterial = function (material, destroy) {
        if (destroy !== exports.DestroyOptions.keep) {
            this.material.dispose(destroy);
        }
        this.material = material;
    };
    Mesh.prototype.restore = function () {
    };
    /**
     * 销毁当前资源
     * @param options - 可选的销毁选项
     */
    Mesh.prototype.dispose = function (options) {
        if (this.destroyed) {
            //console.error('call mesh.destroy multiple times', this);
            return;
        }
        if ((options === null || options === void 0 ? void 0 : options.geometries) !== exports.DestroyOptions.keep) {
            this.geometry.dispose();
        }
        var materialDestroyOption = options === null || options === void 0 ? void 0 : options.material;
        if (materialDestroyOption !== exports.DestroyOptions.keep) {
            this.material.dispose(materialDestroyOption);
        }
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMesh(this);
            // @ts-expect-error
            this.engine = undefined;
        }
    };
    return Mesh;
}());

var RenderPassPriorityPrepare = 0;
var RenderPassPriorityNormal = 1000;
var RenderPassPriorityPostprocess = 3000;
/**
 * RenderPass Attachment 存储类型
 */
exports.RenderPassAttachmentStorageType = void 0;
(function (RenderPassAttachmentStorageType) {
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["none"] = 0] = "none";
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["color"] = 1] = "color";
    //stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["stencil_8_opaque"] = 2] = "stencil_8_opaque";
    //stencil 16 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_opaque"] = 3] = "depth_16_opaque";
    //depth 16 & stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_stencil_opaque"] = 4] = "depth_stencil_opaque";
    //depth 16 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_texture"] = 5] = "depth_16_texture";
    //depth 24 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_24_stencil_8_texture"] = 6] = "depth_24_stencil_8_texture";
})(exports.RenderPassAttachmentStorageType || (exports.RenderPassAttachmentStorageType = {}));
/**
 * Attachment 结束后清除行为
 */
exports.TextureStoreAction = void 0;
(function (TextureStoreAction) {
    /**
     * 不清除 Attachment
     */
    TextureStoreAction[TextureStoreAction["store"] = 0] = "store";
    /**
     * 清除 Attachment
     */
    TextureStoreAction[TextureStoreAction["clear"] = 2] = "clear";
})(exports.TextureStoreAction || (exports.TextureStoreAction = {}));
var RenderTargetHandle = /** @class */ (function () {
    function RenderTargetHandle(engine, options) {
        this.destroyed = false;
        if (!options) {
            return;
        }
        var texture = options.texture, size = options.size;
        if (texture instanceof Texture) {
            this.texture = texture;
            this.externalTexture = true;
        }
        else if (texture) {
            var wrapT = texture.wrapT, wrapS = texture.wrapS, minFilter = texture.minFilter, magFilter = texture.magFilter, internalFormat = texture.internalFormat, _a = texture.format, format = _a === void 0 ? glContext.RGBA : _a, _b = texture.type, type = _b === void 0 ? glContext.UNSIGNED_BYTE : _b;
            this.externalTexture = false;
            this.textureOptions = {
                size: size,
                format: format,
                type: type,
                internalFormat: internalFormat || format,
                wrapT: wrapT,
                wrapS: wrapS,
                minFilter: minFilter,
                magFilter: magFilter,
                name: options.name,
            };
            this.texture = Texture.create(engine, __assign$1(__assign$1({}, this.textureOptions), { sourceType: exports.TextureSourceType.framebuffer, data: { width: size[0], height: size[1] } }));
        }
        else ;
    }
    RenderTargetHandle.prototype.dispose = function () {
        if (this.destroyed) {
            return;
        }
        this.texture.dispose();
        this.destroyed = true;
    };
    Object.defineProperty(RenderTargetHandle.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "storageType", {
        get: function () {
            return exports.RenderPassAttachmentStorageType.color;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "size", {
        get: function () {
            var tex = this.texture;
            return tex ? [tex.getWidth(), tex.getHeight()] : [0, 0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "width", {
        get: function () {
            return this.texture.getWidth() || 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderTargetHandle.prototype, "height", {
        get: function () {
            return this.texture.getHeight() || 0;
        },
        enumerable: false,
        configurable: true
    });
    return RenderTargetHandle;
}());
/**
 * RenderPass Attachment 销毁类型
 */
exports.RenderPassDestroyAttachmentType = void 0;
(function (RenderPassDestroyAttachmentType) {
    /**
     * 强制销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["force"] = 0] = "force";
    /**
     * 保留，不销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keep"] = 1] = "keep";
    /**
     * 如果是外部传入的 Attachment，就不销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keepExternal"] = 2] = "keepExternal";
    /**
     * 强制销毁
     */
    RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["destroy"] = 0] = "destroy";
})(exports.RenderPassDestroyAttachmentType || (exports.RenderPassDestroyAttachmentType = {}));
var seed$a = 1;
/**
 * RenderPass 抽象类
 */
var RenderPass = /** @class */ (function () {
    function RenderPass(renderer, options) {
        /**
         * ColorAttachment 数组
         */
        this.attachments = [];
        this.destroyed = false;
        this.initialized = false;
        var _a = options.name, name = _a === void 0 ? 'RenderPass_' + seed$a++ : _a, clearAction = options.clearAction, semantics = options.semantics, depthStencilAttachment = options.depthStencilAttachment, storeAction = options.storeAction, _b = options.priority, priority = _b === void 0 ? 0 : _b, _c = options.meshOrder, meshOrder = _c === void 0 ? exports.OrderType.ascending : _c, _d = options.meshes, meshes = _d === void 0 ? [] : _d, _e = options.delegate, delegate = _e === void 0 ? {} : _e;
        this.name = name;
        this.renderer = renderer;
        this.priority = priority;
        this.meshOrder = meshOrder;
        this.meshes = sortByOrder(meshes.slice(), this.meshOrder);
        this.depthStencilType = (depthStencilAttachment === null || depthStencilAttachment === void 0 ? void 0 : depthStencilAttachment.storageType) || exports.RenderPassAttachmentStorageType.none;
        this.clearAction = __assign$1({}, clearAction);
        this.storeAction = __assign$1({ colorAction: exports.TextureStoreAction.store, depthAction: exports.TextureStoreAction.store, stencilAction: exports.TextureStoreAction.store }, storeAction);
        this.semantics = new SemanticMap(semantics);
        this.options = options;
        this.delegate = delegate;
        this.setViewportOptions(options);
    }
    Object.defineProperty(RenderPass.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "viewport", {
        get: function () {
            return this.getViewport();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "stencilAttachment", {
        get: function () {
            return this.getStencilAttachment();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderPass.prototype, "depthAttachment", {
        get: function () {
            return this.getDepthAttachment();
        },
        enumerable: false,
        configurable: true
    });
    RenderPass.prototype.addMesh = function (mesh) {
        addByOrder(this.meshes, mesh, this.meshOrder);
    };
    RenderPass.prototype.removeMesh = function (mesh) {
        removeItem(this.meshes, mesh);
    };
    RenderPass.prototype.setMeshes = function (meshes) {
        var _a;
        this.meshes.length = 0;
        (_a = this.meshes).splice.apply(_a, __spreadArray$2([0, 0], __read$3(meshes), false));
        sortByOrder(this.meshes, this.meshOrder);
        return this.meshes;
    };
    /**
     * 获取当前 Attachment 数组，注意 RenderPass 可能没有创建完成
     */
    RenderPass.prototype.getInitAttachments = function () {
        if (this.attachments.length > 0) {
            return this.attachments;
        }
        else {
            return this.options.attachments;
        }
    };
    // TODO 所有pass在子类配置
    /**
     * 配置当前pass的RT，在每帧渲染前调用
     */
    RenderPass.prototype.configure = function (renderer) {
        if (this.frameBuffer) {
            renderer.setFrameBuffer(this.frameBuffer);
        }
        else {
            var _a = __read$3(this.getViewport(), 4), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
            renderer.setViewport(x, y, width, height);
        }
    };
    /**
     * 执行当前pass，每帧调用一次
     */
    RenderPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        renderer.renderMeshes(this.meshes);
        renderer.clear(this.storeAction);
    };
    /**
     * 每帧所有的pass渲染完后调用，通常用于清空临时的RT资源
     */
    RenderPass.prototype.frameCleanup = function (renderer) {
    };
    /**
     * 重置 ColorAttachment 数组，会直接替换掉
     * @param colors - 纹理数组，作为新的 ColorAttachment
     */
    RenderPass.prototype.resetColorAttachments = function (colors) {
        var _this = this;
        if (!colors.length) {
            this.resetAttachments({ attachments: [] });
        }
        if (!this.attachments.length) {
            this.resetAttachments({ attachments: colors.map(function (t) { return ({ texture: t }); }) });
        }
        else {
            var attachments = colors.map(function (texture) {
                texture.updateSource({ sourceType: exports.TextureSourceType.framebuffer });
                return new RenderTargetHandle(_this.renderer.engine, { texture: texture });
            });
            this.attachments.forEach(function (att) { return !att.externalTexture && att.dispose(); });
            this.attachments = attachments;
            if (this.frameBuffer) {
                this.frameBuffer.bind();
                this.frameBuffer.resetColorTextures(colors.map(function (color) { return color; }));
            }
        }
    };
    /**
     * 重置所有 Attachment，会替换掉所有 Attachment
     * @param options - Attachment 和视口数据
     */
    RenderPass.prototype.resetAttachments = function (options) {
        this.options = options;
        this.setViewportOptions(options);
        if (this.renderer) {
            this._resetAttachments();
        }
    };
    RenderPass.prototype.setViewportOptions = function (options) {
        if (options.viewport) {
            this.isCustomViewport = true;
            this.viewportScale = 1;
            this.customViewport = options.viewport.slice(0, 4);
            if (this.frameBuffer) {
                var vp = this.customViewport;
                // TODO 为什么framebuffer和renderpass的isCustomViewport不一样？
                this.frameBuffer.isCustomViewport = false;
                this.frameBuffer.resize(vp[0], vp[1], vp[2], vp[3]);
            }
        }
        else {
            this.isCustomViewport = false;
            this.viewportScale = options.viewportScale || 1;
            if (this.frameBuffer) {
                this.frameBuffer.isCustomViewport = true;
                this.frameBuffer.viewportScale = this.viewportScale;
            }
        }
    };
    RenderPass.prototype._resetAttachments = function () {
        var _this = this;
        var _a, _b;
        var renderer = this.renderer;
        var options = this.options;
        if (this.attachments.length) {
            this.attachments.forEach(function (att) { return !att.externalTexture && att.dispose(); });
            this.attachments.length = 0;
            (_a = this.frameBuffer) === null || _a === void 0 ? void 0 : _a.dispose({ depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keepExternal });
            // @ts-expect-error safe to assign
            this.frameBuffer = null;
        }
        var vs = this.viewportScale;
        // renderpass 的 viewport 相关参数都需要动态的修改
        var viewport = (this.isCustomViewport ? this.customViewport : [0, 0, renderer.getWidth() * vs, renderer.getHeight() * vs]);
        var size = [viewport[2], viewport[3]];
        var name = this.name;
        if ((_b = options.attachments) === null || _b === void 0 ? void 0 : _b.length) {
            var attachments = options.attachments.map(function (attr, index) {
                var _a;
                var attachment = new RenderTargetHandle(_this.renderer.engine, __assign$1({ size: size, name: ((_a = attr.texture) === null || _a === void 0 ? void 0 : _a.name) || "".concat(name, "##color_").concat(index) }, attr));
                return attachment;
            });
            this.attachments = attachments;
            var framebuffer = FrameBuffer.create({
                storeAction: this.storeAction,
                name: name,
                viewport: viewport,
                viewportScale: this.viewportScale,
                isCustomViewport: this.isCustomViewport,
                attachments: attachments.map(function (att) { return att.texture; }),
                depthStencilAttachment: options.depthStencilAttachment || { storageType: exports.RenderPassAttachmentStorageType.none },
            }, renderer);
            framebuffer.bind();
            framebuffer.unbind();
            this.frameBuffer = framebuffer;
        }
        else {
            this.attachments.length = 0;
        }
    };
    /**
     * 获取当前视口大小，格式：[x偏移，y偏移，宽度，高度]
     */
    RenderPass.prototype.getViewport = function () {
        var _a;
        var ret = ((_a = this.frameBuffer) === null || _a === void 0 ? void 0 : _a.viewport) || this.customViewport;
        if (ret) {
            return ret;
        }
        var renderer = this.renderer;
        var vs = this.viewportScale;
        return renderer ? [0, 0, renderer.getWidth() * vs, renderer.getHeight() * vs] : [0, 0, 0, 0];
    };
    /**
     * 获取深度 Attachment，可能没有
     */
    RenderPass.prototype.getDepthAttachment = function () {
        var frameBuffer = this.frameBuffer;
        if (frameBuffer) {
            return {
                storageType: frameBuffer.depthStencilStorageType,
                storage: frameBuffer.depthStorage,
                texture: frameBuffer.getDepthTexture() ? this.getDepthTexture(frameBuffer.getDepthTexture(), frameBuffer.externalStorage) : undefined,
            };
        }
    };
    /**
     * 获取蒙版 Attachment，可能没有
     */
    RenderPass.prototype.getStencilAttachment = function () {
        var frameBuffer = this.frameBuffer;
        if (frameBuffer) {
            return {
                storageType: frameBuffer.depthStencilStorageType,
                storage: frameBuffer.stencilStorage,
                texture: frameBuffer.getStencilTexture() ? this.getStencilTexture(frameBuffer.getStencilTexture(), frameBuffer.externalStorage) : undefined,
            };
        }
    };
    RenderPass.prototype.getDepthTexture = function (texture, external) {
        var _a;
        if (!this.depthTexture) {
            var outTex = (_a = this.options.depthStencilAttachment) === null || _a === void 0 ? void 0 : _a.texture;
            var tex = texture === outTex ? outTex : texture;
            // TODO 为什么要initialize？
            //tex.initialize(this.renderer.glRenderer.pipelineContext);
            if (!external) {
                this.depthTexture = tex;
            }
            return tex;
        }
        return this.depthTexture;
    };
    RenderPass.prototype.getStencilTexture = function (texture, external) {
        var _a;
        if (!this.stencilTexture) {
            var outTex = (_a = this.options.depthStencilAttachment) === null || _a === void 0 ? void 0 : _a.texture;
            var tex = texture === outTex ? outTex : texture;
            if (!external) {
                this.stencilTexture = tex;
            }
            return tex;
        }
        return this.stencilTexture;
    };
    // 生成并初始化帧缓冲
    RenderPass.prototype.initialize = function (renderer) {
        if (!this.initialized) {
            this._resetAttachments();
            this.initialized = true;
        }
        return this;
    };
    /**
     * 销毁 RenderPass
     * @param options - 有选择销毁内部对象
     */
    RenderPass.prototype.dispose = function (options) {
        var _a, _b;
        if (this.destroyed) {
            return;
        }
        var destroyMeshOption = (options === null || options === void 0 ? void 0 : options.meshes) || undefined;
        if (destroyMeshOption !== exports.DestroyOptions.keep) {
            this.meshes.forEach(function (mesh) {
                mesh.dispose(destroyMeshOption);
            });
        }
        this.meshes.length = 0;
        var colorOpt = (options === null || options === void 0 ? void 0 : options.colorAttachment) ? options.colorAttachment : exports.RenderPassDestroyAttachmentType.force;
        this.attachments.forEach(function (att) {
            var keep = (att.externalTexture && colorOpt === exports.RenderPassDestroyAttachmentType.keepExternal) || colorOpt === exports.RenderPassDestroyAttachmentType.keep;
            if (!keep) {
                att.dispose();
            }
        });
        this.attachments.length = 0;
        if ((options === null || options === void 0 ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        this.destroyed = true;
        var depthStencilOpt = (options === null || options === void 0 ? void 0 : options.depthStencilAttachment) ? options.depthStencilAttachment : exports.RenderPassDestroyAttachmentType.force;
        var fbo = this.frameBuffer;
        if (fbo) {
            fbo.dispose({ depthStencilAttachment: depthStencilOpt });
            var keep = (fbo.externalStorage && depthStencilOpt === exports.RenderPassDestroyAttachmentType.keepExternal) || depthStencilOpt === exports.RenderPassDestroyAttachmentType.keep;
            if (!keep) {
                (_a = this.stencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
                (_b = this.depthTexture) === null || _b === void 0 ? void 0 : _b.dispose();
            }
        }
        // @ts-expect-error safe to assign
        this.options = this.renderer = null;
        this.initialize = throwDestroyedError$1;
    };
    return RenderPass;
}());

var blend = "vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}";

var compatible_frag = "#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\n";

var compatible_vert = "#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n";

var itemFrameFrag = "#version 300 es\nprecision highp float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}in vec4 vColor;in vec4 vTexCoord;in highp vec2 vParams;uniform vec3 uFrameColor;void main(){fragColor=vec4(uFrameColor.xyz,1.0);}";

var integrate = "float calculateMovement(float t,vec2 p1,vec2 p2,vec2 p3,vec2 p4){float movement=0.0;float h=(t-p1.x)*0.05;for(int i=0;i<=20;i++){float t=float(i)*h;float nt=binarySearchT(t,p1.x,p2.x,p3.x,p4.x);float y=cubicBezier(nt,p1.y,p2.y,p3.y,p4.y);float weight=(i==0||i==20)? 1.0 :(mod(float(i),2.)!=0.)? 4.0 : 2.0;movement+=weight*y;}movement*=h/3.;return movement;}float integrateFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i+=2){vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return ret;}vec2 p1=vec2(k0.x,k0.y);vec2 p2=vec2(k0.z,k0.w);vec2 p3=vec2(k1.z,k1.w);vec2 p4=vec2(k1.x,k1.y);if(time>=k1.x){ret+=calculateMovement(k1.x,p1,p2,p3,p4);}if(time>=k0.x&&time<k1.x){return ret+calculateMovement(time,p1,p2,p3,p4);}}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;vec4 tSqr=vec4(t,t,t0,t0);tSqr=tSqr*tSqr;vec4 a=vec4(2.*t,3.,-t0,3.)*tSqr;float t1y0=t1*y0;vec4 b=vec4(y0-y1,t0*y1-t1y0,2.*y0+y1,t1y0);float r=dot(a,b);return r/(t0-t1)*0.16666667;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w);}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w)-integrateFromBezierCurveFrames(t0,value.z,value.w);}return 0.;}";

var itemVert = "#version 300 es\nprecision highp float;\n#define SHADER_VERTEX 1\n#define SPRITE_SHADER 1\nin vec4 aPoint;in vec2 aIndex;uniform mat4 uMainData[MAX_ITEM_COUNT];uniform vec4 uTexParams[MAX_ITEM_COUNT];uniform vec4 uTexOffset[MAX_ITEM_COUNT];uniform mat4 effects_ObjectToWorld;uniform mat4 effects_MatrixInvV;uniform mat4 effects_MatrixVP;out vec4 vColor;out vec4 vTexCoord;\n#ifdef ADJUST_LAYER\nout vec2 vFeatherCoord;\n#endif\nout highp vec3 vParams;const float d2r=3.141592653589793/180.;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvec4 filterMain(float t,vec4 position);\n#pragma FILTER_VERT\nvec3 rotateByQuat(vec3 a,vec4 quat){vec3 qvec=quat.xyz;vec3 uv=cross(qvec,a);vec3 uuv=cross(qvec,uv)*2.;return a+(uv*2.*quat.w+uuv);}void main(){int index=int(aIndex.x);vec4 texParams=uTexParams[index];mat4 mainData=uMainData[index];float life=mainData[1].z;if(life<0.||life>1.){gl_Position=vec4(3.,3.,3.,1.);}else{vec4 _pos=mainData[0];vec2 size=mainData[1].xy;vec3 point=rotateByQuat(vec3(aPoint.xy*size,0.),mainData[2]);vec4 pos=vec4(_pos.xyz,1.0);float renderMode=texParams.z;if(renderMode==0.){pos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixInvV[0].xyz*point.x+effects_MatrixInvV[1].xyz*point.y;}else if(renderMode==1.){pos.xyz+=point;pos=effects_ObjectToWorld*pos;}else if(renderMode==2.){pos=effects_ObjectToWorld*pos;pos.xy+=point.xy;}else if(renderMode==3.){pos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixInvV[0].xyz*point.x+effects_MatrixInvV[2].xyz*point.y;}gl_Position=effects_MatrixVP*pos;\n#ifdef ADJUST_LAYER\nvec4 filter_Position=filterMain(life,pos);\n#endif\ngl_PointSize=6.0;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#ifdef ADJUST_LAYER\nfilter_Position=vec4(filter_Position.xy*uEditorTransform.xy+uEditorTransform.zw*filter_Position.w,filter_Position.zw);\n#endif\n#endif\n#ifdef ADJUST_LAYER\nvTexCoord=vec4(filter_Position.xy/filter_Position.w+1.,gl_Position.xy/gl_Position.w+1.)/2.;vFeatherCoord=aPoint.zw;\n#else\nvec4 texOffset=uTexOffset[index];vTexCoord=vec4(aPoint.zw*texOffset.zw+texOffset.xy,texParams.xy);\n#endif\nvColor=mainData[3];vParams=vec3(aIndex.y,texParams.y,texParams.x);}}";

var itemFrag = "#version 300 es\nprecision highp float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}\n#define SPRITE_SHADER 1\nin vec4 vColor;in vec4 vTexCoord;in highp vec3 vParams;\n#ifdef ADJUST_LAYER\nuniform sampler2D uSamplerPre;vec4 filterMain(vec2 coord,sampler2D tex);in vec2 vFeatherCoord;uniform sampler2D uFeatherSampler;\n#endif\nuniform sampler2D uSampler0;uniform sampler2D uSampler1;uniform sampler2D uSampler2;uniform sampler2D uSampler3;uniform sampler2D uSampler4;uniform sampler2D uSampler5;uniform sampler2D uSampler6;uniform sampler2D uSampler7;\n#if MAX_FRAG_TEX == 16\nuniform sampler2D uSampler8;uniform sampler2D uSampler9;uniform sampler2D uSampler10;uniform sampler2D uSampler11;uniform sampler2D uSampler12;uniform sampler2D uSampler13;uniform sampler2D uSampler14;uniform sampler2D uSampler15;\n#endif\nvec4 texture2DbyIndex(float index,vec2 coord);\n#pragma FILTER_FRAG\n#ifndef WEBGL2\n#define round(a) floor(0.5+a)\n#endif\nvoid main(){vec4 color=vec4(0.);\n#ifdef ADJUST_LAYER\nvec2 featherCoord=abs(vFeatherCoord-vec2(0.5))/0.5;float cc=sqrt(max(featherCoord.x,featherCoord.y));float blend=vColor.a*texture2D(uFeatherSampler,vec2(cc,0.)).r;if(blend>=1.){color=filterMain(vTexCoord.xy,uSamplerPre);}else if(blend<=0.){color=texture2D(uSamplerPre,vTexCoord.zw);}else{color=mix(texture2D(uSamplerPre,vTexCoord.zw),filterMain(vTexCoord.xy,uSamplerPre),blend);}\n#else\nvec4 texColor=texture2DbyIndex(round(vParams.x),vTexCoord.xy);color=blendColor(texColor,vColor,round(vParams.y));if(vParams.z==0.&&color.a<0.04){discard;}\n#endif\ncolor.a=clamp(color.a,0.0,1.0);fragColor=color;}vec4 texture2DbyIndex(float index,vec2 coord){\n#ifndef ADJUST_LAYER\nif(index==0.){return texture2D(uSampler0,coord);}if(index==1.){return texture2D(uSampler1,coord);}if(index==2.){return texture2D(uSampler2,coord);}if(index==3.){return texture2D(uSampler3,coord);}if(index==4.){return texture2D(uSampler4,coord);}if(index==5.){return texture2D(uSampler5,coord);}if(index==6.){return texture2D(uSampler6,coord);}if(index==7.){return texture2D(uSampler7,coord);}\n#if MAX_FRAG_TEX == 16\nif(index==8.){return texture2D(uSampler8,coord);}if(index==9.){return texture2D(uSampler9,coord);}if(index==10.){return texture2D(uSampler10,coord);}if(index==11.){return texture2D(uSampler11,coord);}if(index==12.){return texture2D(uSampler12,coord);}if(index==13.){return texture2D(uSampler13,coord);}if(index==14.){return texture2D(uSampler14,coord);}if(index==15.){return texture2D(uSampler15,coord);}\n#endif\nreturn texture2D(uSampler0,coord);\n#else\nreturn vec4(0.);\n#endif\n}";

var particleFrag = "#version 300 es\nprecision mediump float;\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#define textureCube texture\n#define textureCubeLodEXT textureLod\nlayout(location=0)out vec4 fragColor;\n#else\n#define fragColor gl_FragColor\n#endif\nvec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;\n#ifdef PRE_MULTIPLY_ALPHA\nfloat alpha=vc.a;\n#else\nfloat alpha=ret.a;\n#endif\nif(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}\n#define PATICLE_SHADER 1\nin float vLife;in vec2 vTexCoord;in vec4 vColor;uniform vec3 emissionColor;uniform float emissionIntensity;uniform sampler2D uMaskTex;uniform vec4 uColorParams;uniform vec2 uTexOffset;\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#ifdef USE_SPRITE\nin vec4 vTexCoordBlend;\n#ifdef USE_FILTER\nuniform vec4 uFSprite;\n#endif\n#endif\nin float vSeed;\n#ifdef PREVIEW_BORDER\nuniform vec4 uPreviewColor;\n#endif\n#ifdef USE_SPRITE\nvec4 getTextureColor(sampler2D tex,vec2 texCoord){if(vTexCoordBlend.w>0.){return mix(texture2D(tex,texCoord),texture2D(tex,vTexCoordBlend.xy+texCoord),vTexCoordBlend.z);}return texture2D(tex,texCoord);}\n#else\n#define getTextureColor texture2D\n#endif\n#ifndef WEBGL2\n#define round(a) floor(0.5+a)\n#endif\n#ifdef PREVIEW_BORDER\nvoid main(){fragColor=uPreviewColor;}\n#else\n#pragma FILTER_FRAG\nvoid main(){vec4 color=vec4(1.0);vec4 tempColor=vColor;vec2 texOffset=uTexOffset;if(vLife<0.){discard;}\n#ifdef USE_FILTER\n#ifdef USE_SPRITE\ntexOffset=uTexOffset/uFSprite.xy;\n#endif\ncolor=filterMain(vTexCoord,uMaskTex);\n#else\nif(uColorParams.x>0.0){color=getTextureColor(uMaskTex,vTexCoord);}\n#endif\n#ifdef COLOR_OVER_LIFETIME\n#ifndef ENABLE_VERTEX_TEXTURE\ntempColor*=texture2D(uColorOverLifetime,vec2(vLife,0.));\n#endif\n#endif\ncolor=blendColor(color,tempColor,round(uColorParams.y));if(color.a<=0.01&&uColorParams.w>0.){float _at=texture2D(uMaskTex,vTexCoord+texOffset).a+texture2D(uMaskTex,vTexCoord+texOffset*-1.).a;if(_at<=0.02){discard;}}vec3 emission=emissionColor*pow(2.0,emissionIntensity);color=vec4(pow(pow(color.rgb,vec3(2.2))+emission,vec3(1.0/2.2)),color.a);fragColor=color;}\n#endif\n";

var particleVert = "#version 300 es\nprecision mediump float;\n#define SHADER_VERTEX 1\n#define PATICLE_SHADER 1\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}float calculateMovement(float t,vec2 p1,vec2 p2,vec2 p3,vec2 p4){float movement=0.0;float h=(t-p1.x)*0.05;for(int i=0;i<=20;i++){float t=float(i)*h;float nt=binarySearchT(t,p1.x,p2.x,p3.x,p4.x);float y=cubicBezier(nt,p1.y,p2.y,p3.y,p4.y);float weight=(i==0||i==20)? 1.0 :(mod(float(i),2.)!=0.)? 4.0 : 2.0;movement+=weight*y;}movement*=h/3.;return movement;}float integrateFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i+=2){vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return ret;}vec2 p1=vec2(k0.x,k0.y);vec2 p2=vec2(k0.z,k0.w);vec2 p3=vec2(k1.z,k1.w);vec2 p4=vec2(k1.x,k1.y);if(time>=k1.x){ret+=calculateMovement(k1.x,p1,p2,p3,p4);}if(time>=k0.x&&time<k1.x){return ret+calculateMovement(time,p1,p2,p3,p4);}}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;vec4 tSqr=vec4(t,t,t0,t0);tSqr=tSqr*tSqr;vec4 a=vec4(2.*t,3.,-t0,3.)*tSqr;float t1y0=t1*y0;vec4 b=vec4(y0-y1,t0*y1-t1y0,2.*y0+y1,t1y0);float r=dot(a,b);return r/(t0-t1)*0.16666667;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w);}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w)-integrateFromBezierCurveFrames(t0,value.z,value.w);}return 0.;}const float d2r=3.141592653589793/180.;in vec3 aPos;in vec4 aOffset;in vec3 aVel;in vec3 aRot;in vec4 aColor;in vec3 aDirX;in vec3 aDirY;\n#ifdef USE_SPRITE\nin vec3 aSprite;uniform vec4 uSprite;struct UVDetail{vec2 uv0;vec3 uv1;};UVDetail getSpriteUV(vec2 uv,float lifeTime);out vec4 vTexCoordBlend;\n#endif\n#ifdef FINAL_TARGET\nuniform vec3 uFinalTarget;uniform vec4 uForceCurve;\n#endif\nuniform mat4 effects_ObjectToWorld;uniform mat4 effects_MatrixV;uniform mat4 effects_MatrixVP;uniform vec4 uParams;uniform vec4 uAcceleration;uniform vec4 uGravityModifierValue;uniform vec4 uOpacityOverLifetimeValue;\n#ifdef ROT_X_LIFETIME\nuniform vec4 uRXByLifeTimeValue;\n#endif\n#ifdef ROT_Y_LIFETIME\nuniform vec4 uRYByLifeTimeValue;\n#endif\n#ifdef ROT_Z_LIFETIME\nuniform vec4 uRZByLifeTimeValue;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n#if LINEAR_VEL_X\nuniform vec4 uLinearXByLifetimeValue;\n#endif\n#if LINEAR_VEL_Y\nuniform vec4 uLinearYByLifetimeValue;\n#endif\n#if LINEAR_VEL_Z\nuniform vec4 uLinearZByLifetimeValue;\n#endif\n#endif\n#ifdef SPEED_OVER_LIFETIME\nuniform vec4 uSpeedLifetimeValue;\n#endif\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n#if ORB_VEL_X\nuniform vec4 uOrbXByLifetimeValue;\n#endif\n#if ORB_VEL_Y\nuniform vec4 uOrbYByLifetimeValue;\n#endif\n#if ORB_VEL_Z\nuniform vec4 uOrbZByLifetimeValue;\n#endif\nuniform vec3 uOrbCenter;\n#endif\nuniform vec4 uSizeByLifetimeValue;\n#ifdef SIZE_Y_BY_LIFE\nuniform vec4 uSizeYByLifetimeValue;\n#endif\nout float vLife;out vec4 vColor;out vec2 vTexCoord;\n#ifdef USE_FILTER\n#pragma FILTER_VERT\n#endif\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvec3 calOrbitalMov(float _life,float _dur){vec3 orb=vec3(0.0);\n#ifdef AS_ORBITAL_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if ORB_VEL_X\norb.x=FUNC(uOrbXByLifetimeValue);\n#endif\n#if ORB_VEL_Y\norb.y=FUNC(uOrbYByLifetimeValue);\n#endif\n#if ORB_VEL_Z\norb.z=FUNC(uOrbZByLifetimeValue);\n#endif\n#undef FUNC\nreturn orb;}vec3 calLinearMov(float _life,float _dur){vec3 mov=vec3(0.0);\n#ifdef AS_LINEAR_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if LINEAR_VEL_X\nmov.x=FUNC(uLinearXByLifetimeValue);\n#endif\n#if LINEAR_VEL_Y\nmov.y=FUNC(uLinearYByLifetimeValue);\n#endif\n#if LINEAR_VEL_Z\nmov.z=FUNC(uLinearZByLifetimeValue);\n#endif\n#undef FUNC\nreturn mov;}mat3 mat3FromRotation(vec3 rotation){vec3 sinR=sin(rotation*d2r);vec3 cosR=cos(rotation*d2r);return mat3(cosR.z,-sinR.z,0.,sinR.z,cosR.z,0.,0.,0.,1.)*mat3(cosR.y,0.,sinR.y,0.,1.,0.,-sinR.y,0,cosR.y)*mat3(1.,0.,0.,0,cosR.x,-sinR.x,0.,sinR.x,cosR.x);}\n#ifdef USE_SPRITE\nUVDetail getSpriteUV(vec2 uv,float lifeTime){float t=fract(clamp((lifeTime-aSprite.x)/aSprite.y,0.0,1.)*aSprite.z);float frame=uSprite.z*t;float frameIndex=max(ceil(frame)-1.,0.);float row=floor((frameIndex+0.1)/uSprite.x);float col=frameIndex-row*uSprite.x;vec2 retUV=(vec2(col,row)+uv)/uSprite.xy;UVDetail ret;if(uSprite.w>0.){float blend=frame-frameIndex;float frameIndex1=min(ceil(frame),uSprite.z-1.);float row1=floor((frameIndex1+0.1)/uSprite.x);float col1=frameIndex1-row1*uSprite.x;vec2 coord=(vec2(col1,row1)+uv)/uSprite.xy-retUV;ret.uv1=vec3(coord.x,1.-coord.y,blend);}ret.uv0=vec2(retUV.x,1.-retUV.y);return ret;}\n#endif\nvec3 calculateTranslation(vec3 vel,float t0,float t1,float dur){float dt=t1-t0;float d=getIntegrateByTimeFromTime(0.,dt,uGravityModifierValue);vec3 acc=uAcceleration.xyz*d;\n#ifdef SPEED_OVER_LIFETIME\nreturn vel*getIntegrateFromTime0(dt/dur,uSpeedLifetimeValue)*dur+acc;\n#endif\nreturn vel*dt+acc;}mat3 transformFromRotation(vec3 rot,float _life,float _dur){vec3 rotation=rot;\n#ifdef ROT_LIFETIME_AS_MOVEMENT\n#define FUNC1(a) getValueFromTime(_life,a)\n#else\n#define FUNC1(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#ifdef ROT_X_LIFETIME\nrotation.x+=FUNC1(uRXByLifeTimeValue);\n#endif\n#ifdef ROT_Y_LIFETIME\nrotation.y+=FUNC1(uRYByLifeTimeValue);\n#endif\n#ifdef ROT_Z_LIFETIME\nrotation.z+=FUNC1(uRZByLifeTimeValue);\n#endif\nif(dot(rotation,rotation)==0.0){return mat3(1.0);}\n#undef FUNC1\nreturn mat3FromRotation(rotation);}void main(){float time=uParams.x-aOffset.z;float dur=aOffset.w;if(time<0.||time>dur){gl_Position=vec4(-3.,-3.,-3.,1.);}else{float life=clamp(time/dur,0.0,1.0);vLife=life;\n#ifdef USE_SPRITE\nUVDetail uvD=getSpriteUV(aOffset.xy,time);vTexCoord=uvD.uv0;vTexCoordBlend=vec4(uvD.uv1,uSprite.w);\n#else\nvTexCoord=aOffset.xy;\n#endif\nvColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(life,0.));\n#endif\n#endif\nvColor.a*=clamp(getValueFromTime(life,uOpacityOverLifetimeValue),0.,1.);vec3 size=vec3(vec2(getValueFromTime(life,uSizeByLifetimeValue)),1.0);\n#ifdef SIZE_Y_BY_LIFE\nsize.y=getValueFromTime(life,uSizeYByLifetimeValue);\n#endif\nvec3 point=transformFromRotation(aRot,life,dur)*(aDirX*size.x+aDirY*size.y);vec3 pt=calculateTranslation(aVel,aOffset.z,uParams.x,dur);vec3 _pos=aPos+pt;\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n_pos=mat3FromRotation(calOrbitalMov(life,dur))*(_pos-uOrbCenter);_pos+=uOrbCenter;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n_pos.xyz+=calLinearMov(life,dur);\n#endif\n#ifdef FINAL_TARGET\nfloat force=getValueFromTime(life,uForceCurve);vec4 pos=vec4(mix(_pos,uFinalTarget,force),1.);\n#else\nvec4 pos=vec4(_pos,1.0);\n#endif\n#if RENDER_MODE == 1\npos.xyz+=point;pos=effects_ObjectToWorld*pos;\n#elif RENDER_MODE == 3\npos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixV[0].xyz*point.x+effects_MatrixV[2].xyz*point.y;\n#elif RENDER_MODE == 2\npos=effects_ObjectToWorld*pos;pos.xy+=point.xy;\n#elif RENDER_MODE == 0\npos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixV[0].xyz*point.x+effects_MatrixV[1].xyz*point.y;\n#endif\ngl_Position=effects_MatrixVP*pos;vSeed=aSeed;gl_PointSize=6.0;\n#ifdef USE_FILTER\nfilterMain(life);\n#endif\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}}";

var trailVert = "#version 300 es\nprecision mediump float;\n#define SHADER_VERTEX 1\n#version 300 es\n#ifdef WEBGL2\n#define texture2D texture\n#else\n#endif\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}in vec4 aPos;in vec3 aDir;in vec3 aInfo;in vec4 aColor;in float aTime;\n#ifdef ATTR_TRAIL_START\nin float aTrailStart;\n#else\nuniform float uTrailStart[64];in float aTrailStartIndex;\n#endif\nuniform mat4 effects_MatrixInvV;uniform mat4 effects_ObjectToWorld;uniform mat4 effects_MatrixVP;uniform vec4 uTextureMap;uniform float uTime;uniform vec4 uParams;uniform vec4 uColorParams;uniform vec4 uOpacityOverLifetimeValue;uniform vec4 uWidthOverTrail;\n#ifdef COLOR_OVER_TRAIL\nuniform sampler2D uColorOverTrail;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\nout float vLife;out vec2 vTexCoord;out vec4 vColor;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvoid main(){vec4 _pa=effects_MatrixVP*vec4(aPos.xyz,1.);vec4 _pb=effects_MatrixVP*vec4(aPos.xyz+aDir,1.);vec2 dir=normalize(_pb.xy/_pb.w-_pa.xy/_pa.w);vec2 screen_xy=vec2(-dir.y,dir.x);vec4 pos=effects_ObjectToWorld*vec4(aPos.xyz,1.);\n#ifdef ATTR_TRAIL_START\nfloat ts=aTrailStart;\n#else\nfloat ts=uTrailStart[int(aTrailStartIndex)];\n#endif\nfloat trail=(ts-aInfo.y)/uParams.y;float width=aPos.w*getValueFromTime(trail,uWidthOverTrail)/max(abs(screen_xy.x),abs(screen_xy.y));pos.xyz+=(effects_MatrixInvV[0].xyz*screen_xy.x+effects_MatrixInvV[1].xyz*screen_xy.y)*width;float time=min((uTime-aTime)/aInfo.x,1.0);gl_Position=effects_MatrixVP*pos;vColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(time,0.));\n#endif\n#endif\n#ifdef COLOR_OVER_TRAIL\nvColor*=texture2D(uColorOverTrail,vec2(trail,0.));\n#endif\nvColor.a*=clamp(getValueFromTime(time,uOpacityOverLifetimeValue),0.,1.);vLife=time;vTexCoord=uTextureMap.xy+vec2(trail,aInfo.z)*uTextureMap.zw;vSeed=aSeed;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}";

var value = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nin float aSeed;out float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}";

var valueDefine = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n";

var alphaFrameFrag = "uniform vec4 uTexRange;uniform vec2 uFilterSourceSize;\n#define INTERPOLATION 0\nvec4 filterMain(vec2 texCoord,sampler2D source){float x=uTexRange.x+texCoord.x*uTexRange.y;\n#if INTERPOLATION\nvec2 texInPixel=texCoord*uFilterSourceSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uFilterSourceSize,(coordMin+vec2(1.))/uFilterSourceSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));vec4 color=mix(mix(cLB,cRB,pp.x),mix(cLT,cRT,pp.x),pp.y);\n#else\nvec4 color=texture2D(source,vec2(x,texCoord.y));\n#endif\nx=uTexRange.z+texCoord.x*uTexRange.w;vec4 opacity=texture2D(source,vec2(x,texCoord.y));return vec4(color.rgb,opacity.r);}";

var alphaMaskFrag = "uniform sampler2D uAlphaXSample;uniform sampler2D uAlphaYSample;vec4 filterMain(vec2 texCoord,sampler2D source){vec4 color=texture2D(source,texCoord);float x=texture2D(uAlphaXSample,vec2(vFeatherCoord.x,0.)).r;float y=texture2D(uAlphaYSample,vec2(vFeatherCoord.y,0.)).r;return vec4(color.rgb,color.a*min(x,y));}";

var cameraMove_frag = "uniform vec2 uMoveTexSize;uniform sampler2D uFilterSource;\n#define INTERPOLATION 1\nvec4 filterMain(vec2 texCoord,sampler2D tex){\n#ifdef INTERPOLATION\nvec2 texInPixel=texCoord*uMoveTexSize;vec2 coordMin=floor(texInPixel);vec2 pp=texInPixel-coordMin;vec4 fCoord=vec4(coordMin/uMoveTexSize,(coordMin+vec2(1.))/uMoveTexSize);vec4 cLT=texture2D(uFilterSource,vec2(fCoord.x,fCoord.w));vec4 cLB=texture2D(uFilterSource,vec2(fCoord.x,fCoord.y));vec4 cRT=texture2D(uFilterSource,vec2(fCoord.z,fCoord.w));vec4 cRB=texture2D(uFilterSource,vec2(fCoord.z,fCoord.y));vec4 cB=mix(cLB,cRB,pp.x);vec4 cT=mix(cLT,cRT,pp.x);return mix(cB,cT,pp.y);\n#else\nreturn texture2D(uFilterSource,texCoord);\n#endif\n}";

var cameraMoveVert = "uniform mat4 uMoveCameraViewPro;vec4 filterMain(float p,vec4 pos){return uMoveCameraViewPro*pos;}";

var delayFrag = "uniform sampler2D uLastSource;uniform vec4 uParams;vec4 filterMain(vec2 coord,sampler2D tex){vec4 c1=texture2D(tex,coord);if(uParams.x<1.){return c1;}vec4 c2=texture2D(uLastSource,coord);return mix(c1,c2,uParams.y);}";

var distortionFrag = "uniform vec4 uWaveParams;\n#ifdef PATICLE_SHADER\nin vec4 vWaveParams;\n#else\nuniform vec4 vWaveParams;\n#endif\nvec4 filterMain(vec2 texCoord,sampler2D tex){vec2 vp=texCoord-uWaveParams.xy;float xx=dot(vp,uWaveParams.zw);float d=sin(vWaveParams.x*xx+vWaveParams.y)*vWaveParams.z;vec2 up=vec2(-uWaveParams.w,uWaveParams.z)*d;return texture2D(tex,clamp(texCoord+up,0.,1.));}";

var distortionVert = "uniform vec4 uMovementValue;uniform vec4 uStrengthValue;uniform vec4 uPeriodValue;out vec4 vWaveParams;void filterMain(float lifetime){const float pi2=3.14159265;vWaveParams=vec4(getValueFromTime(lifetime,uPeriodValue)*pi2,getValueFromTime(lifetime,uMovementValue)*pi2,getValueFromTime(lifetime,uStrengthValue),0.);}";

var bloomMixVert = "uniform sampler2D uBloomBlur;uniform vec4 uBloomParams;vec4 filterMain(vec2 coord,sampler2D tex){const vec3 gamma=vec3(1./2.2);vec4 c1=texture2D(tex,coord);vec4 bloomColor=texture2D(uBloomBlur,coord);float alpha=max(c1.a,bloomColor.a);vec3 color=max(c1.rgb*c1.a,bloomColor.rgb*bloomColor.a)/alpha*uBloomParams.y+bloomColor.rgb*uBloomParams.x;return vec4(color,alpha);}";

var bloomThresholdVert = "uniform vec4 uColorThreshold;vec4 filterMain(vec2 coord,sampler2D tex){vec4 c1=texture2D(tex,coord);vec3 color=c1.rgb*c1.a;vec3 s=step(uColorThreshold.xyz,color);float m=min(s.r+s.g+s.b,1.);return c1*m;}";

var screenMeshVert = "precision highp float;attribute vec2 aPos;varying vec2 uv;void main(){gl_Position=vec4(aPos,0.,1.0);uv=(aPos+vec2(1.0))/2.;}";

var colorGradingFrag = "precision highp float;\n#define HALF_MAX 60000.0\n#define ACEScc_MIDGRAY 0.4135884\nvarying vec2 uv;uniform sampler2D _GaussianTex;uniform sampler2D _SceneTex;uniform float _BloomIntensity;uniform float _Brightness;uniform float _Saturation;uniform float _Contrast;uniform bool _UseBloom;uniform bool _UseToneMapping;mat3 LinearToACES=mat3(0.59719,0.07600,0.02840,0.35458,0.90834,0.13383,0.04823,0.01566,0.83777);mat3 ACESToLinear=mat3(1.60475,-0.10208,-0.00327,-0.53108,1.10813,-0.07276,-0.07367,-0.00605,1.07602);float log10(float x){return log(x)/log(10.0);}vec3 log10(vec3 v){return vec3(log10(v.x),log10(v.y),log10(v.z));}vec3 LinearToLogC(vec3 x){return 0.244161*log10(5.555556*x+0.047996)+0.386036;}vec3 LogCToLinear(vec3 x){return(pow(vec3(10.0),(x-0.386036)/0.244161)-0.047996)/5.555556;}vec3 rrt_and_odt_fit(vec3 col){vec3 a=col*(col+0.0245786)-0.000090537;vec3 b=col*(0.983729*col+0.4329510)+0.238081;return a/b;}vec3 ACESToneMapping(vec3 col){vec3 aces=LinearToACES*col;aces=rrt_and_odt_fit(aces);col=ACESToLinear*aces;return col;}vec3 LinearToSrgb(vec3 c){return mix(1.055*pow(c,vec3(1./2.4))-0.055,12.92*c,step(c,vec3(0.0031308)));}vec3 GammaCorrection(vec3 c){return pow(c,vec3(1.0/2.2));}void main(){vec4 hdrColor=texture2D(_SceneTex,uv);hdrColor.rgb=pow(hdrColor.rgb,vec3(2.2));vec3 finalColor=hdrColor.rgb;if(_UseBloom){vec4 bloomColor=texture2D(_GaussianTex,uv);bloomColor.rgb*=_BloomIntensity;finalColor+=bloomColor.rgb;}finalColor=finalColor*_Brightness;vec3 colorLog=LinearToLogC(finalColor);colorLog=(colorLog-ACEScc_MIDGRAY)*_Contrast+ACEScc_MIDGRAY;finalColor=LogCToLinear(colorLog);finalColor=max(finalColor,0.0);float luminance=0.2125*finalColor.r+0.7154*finalColor.g+0.0721*finalColor.b;vec3 luminanceColor=vec3(luminance,luminance,luminance);finalColor=(finalColor-luminanceColor)*_Saturation+luminanceColor;finalColor=max(finalColor,0.0);if(_UseToneMapping){finalColor=ACESToneMapping(finalColor);}gl_FragColor=vec4(clamp(GammaCorrection(finalColor),0.0,1.0),1.0);}";

var gaussianDown_frag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;float GaussWeight2D(float x,float y,float sigma){float PI=3.14159265358;float E=2.71828182846;float sigma_2=pow(sigma,2.0);float a=-(x*x+y*y)/(2.0*sigma_2);return pow(E,a)/(2.0*PI*sigma_2);}vec3 GaussNxN(sampler2D tex,vec2 uv,vec2 stride,float sigma){vec3 color=vec3(0.,0.,0.);const int r=5/2;float weight=0.0;for(int i=-r;i<=r;i++){for(int j=-r;j<=r;j++){float w=GaussWeight2D(float(i),float(j),sigma);vec2 coord=uv+vec2(i,j)*stride;color+=texture2D(tex,coord).rgb*w;weight+=w;}}color/=weight;return color;}void main(){vec4 mainColor=texture2D(_MainTex,uv);vec3 color=mainColor.rgb;color=GaussNxN(_MainTex,uv,1.0/_TextureSize,1.0);gl_FragColor=vec4(color,1.0);}";

var gaussianDownHFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;vec3 GaussH(sampler2D tex,vec2 uv){vec3 color=vec3(0.0);float offsets[9];offsets[0]=-4.0;offsets[1]=-3.0;offsets[2]=-2.0;offsets[3]=-1.0;offsets[4]=0.0;offsets[5]=1.0;offsets[6]=2.0;offsets[7]=3.0;offsets[8]=4.0;float weights[9];weights[0]=0.01621622;weights[1]=0.05405405;weights[2]=0.12162162;weights[3]=0.19459459;weights[4]=0.22702703;weights[5]=0.19459459;weights[6]=0.12162162;weights[7]=0.05405405;weights[8]=0.01621622;for(int i=0;i<9;i++){vec2 offset=vec2(offsets[i]*2.0*(1.0/_TextureSize.x),0);color+=texture2D(tex,uv+offset).rgb*weights[i];}return color;}void main(){vec3 color=GaussH(_MainTex,uv);gl_FragColor=vec4(color,1.0);}";

var gaussianDownVFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;vec3 GaussV(sampler2D tex,vec2 uv){vec3 color=vec3(0.0);float offsets[5];offsets[0]=-3.23076923;offsets[1]=-1.38461538;offsets[2]=0.0;offsets[3]=1.38461538;offsets[4]=3.23076923;float weights[5];weights[0]=0.07027027;weights[1]=0.31621622;weights[2]=0.22702703;weights[3]=0.31621622;weights[4]=0.07027027;for(int i=0;i<5;i++){vec2 offset=vec2(0,offsets[i]*(1.0/_TextureSize.y));color+=texture2D(tex,uv+offset).rgb*weights[i];}return color;}void main(){vec3 color=GaussV(_MainTex,uv);gl_FragColor=vec4(color,1.0);}";

var gaussianUpFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform sampler2D _GaussianDownTex;uniform vec2 _GaussianDownTextureSize;float GaussWeight2D(float x,float y,float sigma){float PI=3.14159265358;float E=2.71828182846;float sigma_2=pow(sigma,2.0);float a=-(x*x+y*y)/(2.0*sigma_2);return pow(E,a)/(2.0*PI*sigma_2);}vec3 GaussNxN(sampler2D tex,vec2 uv,vec2 stride,float sigma){vec3 color=vec3(0.,0.,0.);const int r=1;float weight=0.0;for(int i=-r;i<=r;i++){for(int j=-r;j<=r;j++){float w=GaussWeight2D(float(i),float(j),sigma);vec2 coord=uv+vec2(i,j)*stride;color+=texture2D(tex,coord).rgb*w;weight+=w;}}color/=weight;return color;}void main(){vec3 lowResColor=GaussNxN(_MainTex,uv,0.5/_GaussianDownTextureSize,1.0);vec3 highResColor=GaussNxN(_GaussianDownTex,uv,1.0/_GaussianDownTextureSize,1.0);vec3 color=mix(highResColor,lowResColor,0.7);gl_FragColor=vec4(color,1.0);}";

var thresholdFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform float _Threshold;void main(){vec4 mainColor=texture2D(_MainTex,uv);mainColor.rgb=pow(mainColor.rgb,vec3(2.2));float brightness=max(mainColor.r,max(mainColor.g,mainColor.b));float w=max(0.0,brightness-_Threshold)/max(brightness,0.00001);mainColor.rgb*=w;gl_FragColor=vec4(mainColor.rgb,1.0);}";

// Bloom 阈值 Pass
var BloomThresholdPass = /** @class */ (function (_super) {
    __extends(BloomThresholdPass, _super);
    function BloomThresholdPass(renderer, option) {
        var _this = _super.call(this, renderer, option) || this;
        var engine = _this.renderer.engine;
        var geometry = Geometry.create(engine, {
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var material = Material.create(engine, {
            shader: {
                vertex: screenMeshVert,
                fragment: thresholdFrag,
                glslVersion: exports.GLSLVersion.GLSL1,
            },
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            geometry: geometry,
            material: material,
            priority: 0,
        });
        _this.priority = 5000;
        return _this;
    }
    BloomThresholdPass.prototype.configure = function (renderer) {
        this.mainTexture = renderer.getFrameBuffer().getColorTextures()[0];
        this.sceneTextureHandle.texture = this.mainTexture;
        renderer.setFrameBuffer(this.frameBuffer);
    };
    BloomThresholdPass.prototype.execute = function (renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear,
        });
        this.screenMesh.material.setTexture('_MainTex', this.mainTexture);
        var threshold = renderer.renderingData.currentFrame.globalVolume.threshold;
        this.screenMesh.material.setFloat('_Threshold', threshold);
        renderer.renderMeshes([this.screenMesh]);
    };
    return BloomThresholdPass;
}(RenderPass));
var HQGaussianDownSamplePass = /** @class */ (function (_super) {
    __extends(HQGaussianDownSamplePass, _super);
    function HQGaussianDownSamplePass(renderer, type, options) {
        var _this = _super.call(this, renderer, options) || this;
        _this.type = type;
        var engine = _this.renderer.engine;
        var name = 'PostProcess';
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var fragment = type == 'H' ? gaussianDownHFrag : gaussianDownVFrag;
        var shader = {
            vertex: screenMeshVert,
            fragment: fragment,
            glslVersion: exports.GLSLVersion.GLSL1,
        };
        var material = Material.create(engine, {
            name: name,
            shader: shader,
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
        _this.priority = 5000;
        return _this;
    }
    HQGaussianDownSamplePass.prototype.configure = function (renderer) {
        this.mainTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    HQGaussianDownSamplePass.prototype.execute = function (renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear,
        });
        this.screenMesh.material.setTexture('_MainTex', this.mainTexture);
        this.screenMesh.material.setVector2('_TextureSize', getTextureSize(this.mainTexture));
        renderer.renderMeshes([this.screenMesh]);
        if (this.type === 'V') {
            this.gaussianResult.texture = renderer.getFrameBuffer().getColorTextures()[0];
        }
    };
    return HQGaussianDownSamplePass;
}(RenderPass));
var HQGaussianUpSamplePass = /** @class */ (function (_super) {
    __extends(HQGaussianUpSamplePass, _super);
    function HQGaussianUpSamplePass(renderer, options) {
        var _this = _super.call(this, renderer, options) || this;
        var name = 'PostProcess';
        var engine = _this.renderer.engine;
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var shader = { vertex: screenMeshVert, fragment: gaussianUpFrag };
        var material = Material.create(engine, {
            name: name,
            shader: shader,
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
        _this.priority = 5000;
        return _this;
    }
    HQGaussianUpSamplePass.prototype.configure = function (renderer) {
        this.mainTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    HQGaussianUpSamplePass.prototype.execute = function (renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear,
        });
        this.screenMesh.material.setTexture('_MainTex', this.mainTexture);
        this.screenMesh.material.setTexture('_GaussianDownTex', this.gaussianDownSampleResult.texture);
        this.screenMesh.material.setVector2('_GaussianDownTextureSize', getTextureSize(this.gaussianDownSampleResult.texture));
        renderer.renderMeshes([this.screenMesh]);
    };
    return HQGaussianUpSamplePass;
}(RenderPass));
// 合并Bloom的高斯模糊结果，并应用ACES Tonemapping
var ToneMappingPass = /** @class */ (function (_super) {
    __extends(ToneMappingPass, _super);
    function ToneMappingPass(renderer, sceneTextureHandle) {
        var _this = _super.call(this, renderer, {}) || this;
        var name = 'PostProcess';
        var engine = _this.renderer.engine;
        _this.sceneTextureHandle = sceneTextureHandle ? sceneTextureHandle : new RenderTargetHandle(engine);
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var material = Material.create(engine, {
            name: name,
            shader: {
                vertex: screenMeshVert,
                fragment: colorGradingFrag,
                glslVersion: exports.GLSLVersion.GLSL1,
            },
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
        _this.priority = 5000;
        return _this;
    }
    ToneMappingPass.prototype.configure = function (renderer) {
        this.mainTexture = renderer.getFrameBuffer().getColorTextures()[0];
        if (!this.sceneTextureHandle.texture) {
            this.sceneTextureHandle.texture = this.mainTexture;
        }
        renderer.setFrameBuffer(null);
    };
    ToneMappingPass.prototype.execute = function (renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear,
        });
        var _a = renderer.renderingData.currentFrame.globalVolume, bloomIntensity = _a.bloomIntensity, brightness = _a.brightness, saturation = _a.saturation, contrast = _a.contrast, useBloom = _a.useBloom, useToneMapping = _a.useToneMapping;
        this.screenMesh.material.setTexture('_SceneTex', this.sceneTextureHandle.texture);
        this.screenMesh.material.setFloat('_Brightness', brightness);
        this.screenMesh.material.setFloat('_Saturation', saturation);
        this.screenMesh.material.setFloat('_Contrast', contrast);
        this.screenMesh.material.setInt('_UseBloom', useBloom);
        if (useBloom) {
            this.screenMesh.material.setTexture('_GaussianTex', this.mainTexture);
            this.screenMesh.material.setFloat('_BloomIntensity', bloomIntensity);
        }
        this.screenMesh.material.setInt('_UseToneMapping', useToneMapping);
        renderer.renderMeshes([this.screenMesh]);
    };
    return ToneMappingPass;
}(RenderPass));

var defaultGlobalVolume = {
    useHDR: false,
    usePostProcessing: false,
    /***** Material Uniform *****/
    // Bloom
    useBloom: 1.0,
    threshold: 1.0,
    bloomIntensity: 1.0,
    // ColorAdjustments
    brightness: 1.0,
    saturation: 1.0,
    contrast: 1.0,
    // ToneMapping
    useToneMapping: 1, // 1: true, 0: false
};

var RENDER_PASS_NAME_PREFIX = '_effects_default_';
var seed$9 = 1;
/**
 * RenderFrame 抽象类
 */
var RenderFrame = /** @class */ (function () {
    function RenderFrame(options) {
        var _a;
        this.destroyed = false;
        this.renderPassInfoMap = new WeakMap();
        var camera = options.camera, keepColorBuffer = options.keepColorBuffer, renderer = options.renderer, _b = options.editorTransform, editorTransform = _b === void 0 ? [1, 1, 0, 0] : _b, globalVolume = options.globalVolume, _c = options.clearAction, clearAction = _c === void 0 ? {
            colorAction: exports.TextureLoadAction.whatever,
            stencilAction: exports.TextureLoadAction.clear,
            depthAction: exports.TextureLoadAction.whatever,
        } : _c;
        var engine = renderer.engine;
        if (globalVolume) {
            this.globalVolume = __assign$1(__assign$1({}, defaultGlobalVolume), globalVolume);
        }
        this.globalUniforms = new GlobalUniforms();
        var attachments = []; //渲染场景物体Pass的RT
        var depthStencilAttachment;
        var drawObjectPassClearAction = {};
        this.renderer = renderer;
        if (this.globalVolume) {
            var useHDR = this.globalVolume.useHDR;
            // 使用HDR浮点纹理，FLOAT在IOS上报错，使用HALF_FLOAT
            var textureType = useHDR ? glContext.HALF_FLOAT : glContext.UNSIGNED_BYTE;
            attachments = [{ texture: { format: glContext.RGBA, type: textureType, magFilter: glContext.LINEAR, minFilter: glContext.LINEAR } }];
            depthStencilAttachment = { storageType: exports.RenderPassAttachmentStorageType.depth_stencil_opaque };
            drawObjectPassClearAction = {
                colorAction: exports.TextureLoadAction.clear,
                stencilAction: exports.TextureLoadAction.clear,
                depthAction: exports.TextureLoadAction.clear,
            };
        }
        // 创建 drawObjectPass
        var renderPasses = [
            new RenderPass(renderer, {
                name: RENDER_PASS_NAME_PREFIX,
                priority: RenderPassPriorityNormal,
                meshOrder: exports.OrderType.ascending,
                depthStencilAttachment: depthStencilAttachment,
                attachments: attachments,
                clearAction: drawObjectPassClearAction,
            }),
        ];
        this.setRenderPasses(renderPasses);
        if (this.globalVolume) {
            var useBloom = this.globalVolume.useBloom;
            var sceneTextureHandle = new RenderTargetHandle(engine); //保存后处理前的屏幕图像
            if (useBloom) {
                var gaussianStep = 7; // 高斯模糊的迭代次数，次数越高模糊范围越大
                var viewport = [0, 0, this.renderer.getWidth() / 2, this.renderer.getHeight() / 2];
                var gaussianDownResults = new Array(gaussianStep); //存放多个高斯Pass的模糊结果，用于Bloom
                var textureType = this.globalVolume.useHDR ? glContext.HALF_FLOAT : glContext.UNSIGNED_BYTE;
                var bloomThresholdPass = new BloomThresholdPass(renderer, {
                    name: 'BloomThresholdPass',
                    attachments: [{
                            texture: {
                                format: glContext.RGBA,
                                type: textureType,
                                minFilter: glContext.LINEAR,
                                magFilter: glContext.LINEAR,
                            },
                        }],
                });
                bloomThresholdPass.sceneTextureHandle = sceneTextureHandle;
                this.addRenderPass(bloomThresholdPass);
                for (var i = 0; i < gaussianStep; i++) {
                    gaussianDownResults[i] = new RenderTargetHandle(engine);
                    var gaussianDownHPass = new HQGaussianDownSamplePass(renderer, 'H', {
                        name: 'GaussianDownPassH' + i,
                        viewport: viewport,
                        attachments: [{
                                texture: {
                                    format: glContext.RGBA,
                                    type: textureType,
                                    minFilter: glContext.LINEAR,
                                    magFilter: glContext.LINEAR,
                                },
                            }],
                    });
                    var gaussianDownVPass = new HQGaussianDownSamplePass(renderer, 'V', {
                        name: 'GaussianDownPassV' + i,
                        viewport: viewport,
                        attachments: [{
                                texture: {
                                    format: glContext.RGBA,
                                    type: textureType,
                                    minFilter: glContext.LINEAR,
                                    magFilter: glContext.LINEAR,
                                },
                            }],
                    });
                    gaussianDownVPass.gaussianResult = gaussianDownResults[i];
                    this.addRenderPass(gaussianDownHPass);
                    this.addRenderPass(gaussianDownVPass);
                    viewport[2] /= 2;
                    viewport[3] /= 2;
                    // TODO 限制最大迭代
                }
                viewport[2] *= 4;
                viewport[3] *= 4;
                for (var i = 0; i < gaussianStep - 1; i++) {
                    var gaussianUpPass = new HQGaussianUpSamplePass(renderer, {
                        name: 'GaussianUpPass' + i,
                        viewport: viewport,
                        attachments: [{
                                texture: {
                                    format: glContext.RGBA,
                                    type: textureType,
                                    minFilter: glContext.LINEAR,
                                    magFilter: glContext.LINEAR,
                                },
                            }],
                    });
                    gaussianUpPass.gaussianDownSampleResult = gaussianDownResults[gaussianStep - 2 - i];
                    this.addRenderPass(gaussianUpPass);
                    viewport[2] *= 2;
                    viewport[3] *= 2;
                }
            }
            var postProcessPass = void 0;
            if (useBloom) {
                postProcessPass = new ToneMappingPass(renderer, sceneTextureHandle);
            }
            else {
                postProcessPass = new ToneMappingPass(renderer);
            }
            this.addRenderPass(postProcessPass);
        }
        this.semantics = new SemanticMap(options.semantics);
        this.clearAction = clearAction;
        this.name = "RenderFrame".concat(seed$9++);
        var firstRP = renderPasses[0];
        var sourceOpts = {
            type: glContext.UNSIGNED_BYTE,
            format: glContext.RGBA,
            internalFormat: glContext.RGBA,
            wrapS: glContext.MIRRORED_REPEAT,
            wrapT: glContext.MIRRORED_REPEAT,
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST,
        };
        this.emptyTexture = Texture.create(engine, __assign$1({ data: {
                width: 1,
                height: 1,
                data: new Uint8Array([255, 255, 255, 255]),
            }, sourceType: exports.TextureSourceType.data }, sourceOpts));
        this.transparentTexture = Texture.create(engine, __assign$1({ data: {
                width: 1,
                height: 1,
                data: new Uint8Array([0, 0, 0, 0]),
            }, sourceType: exports.TextureSourceType.data }, sourceOpts));
        this.camera = camera;
        this.keepColorBuffer = keepColorBuffer;
        this.renderPassInfoMap.set(firstRP, { listStart: 0, listEnd: 0, renderPass: firstRP, intermedia: false });
        this.editorTransform = Vector4$1.fromArray(editorTransform);
        if (!options.clearAction) {
            this.resetClearActions();
        }
        this.passTextureCache = new PassTextureCache(engine);
        // FIXME: addShader是为了性能考虑，如果影响不大，下面代码可以删除
        var _d = engine.gpuCapability, detail = _d.detail, level = _d.level;
        var writeDepth = detail.readableDepthStencilTextures && detail.writableFragDepth;
        var shader = createCopyShader(level, writeDepth);
        (_a = this.renderer.getShaderLibrary()) === null || _a === void 0 ? void 0 : _a.addShader(shader);
    }
    Object.defineProperty(RenderFrame.prototype, "renderPasses", {
        get: function () {
            return this._renderPasses.slice();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RenderFrame.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 根据 Mesh 优先级添加到 RenderPass
     * @param mesh - 要添加的 Mesh 对象
     */
    RenderFrame.prototype.addMeshToDefaultRenderPass = function (mesh) {
        var renderPasses = this.renderPasses;
        var infoMap = this.renderPassInfoMap;
        var priority = mesh.priority;
        for (var i = 1; i < renderPasses.length; i++) {
            var renderPass = renderPasses[i - 1];
            var info = infoMap.get(renderPasses[i]);
            var infoBefore = infoMap.get(renderPass);
            if (!info || !infoBefore) {
                continue;
            }
            if (info.listStart > priority && (priority > infoBefore.listEnd || i === 1)) {
                return this.addToRenderPass(renderPass, mesh);
            }
        }
        // TODO diff逻辑待优化，有时会添加进找不到的元素
        var lastId = renderPasses.length - 1;
        var lastDefaultPass = renderPasses[lastId];
        // 找到最后一个 DefaultPass, 直接将元素添加进去
        while (lastId >= 0 && !lastDefaultPass.name.includes(RENDER_PASS_NAME_PREFIX)) {
            lastId--;
            lastDefaultPass = renderPasses[lastId];
        }
        return this.addToRenderPass(lastDefaultPass, mesh);
    };
    /**
     * 把 Mesh 从 RenderPass 中移除，
     * 如果 renderPass 中没有 mesh，此 renderPass 会被删除
     * @param mesh - 要删除的 Mesh 对象
     */
    RenderFrame.prototype.removeMeshFromDefaultRenderPass = function (mesh) {
        var _this = this;
        var _a, _b, _c;
        var renderPasses = this.renderPasses;
        var infoMap = this.renderPassInfoMap;
        for (var i = renderPasses.length - 1; i >= 0; i--) {
            var renderPass = renderPasses[i];
            var info = infoMap.get(renderPass);
            // 只有渲染场景物体的pass才有 info
            if (!info) {
                continue;
            }
            if (info.listStart <= mesh.priority && info.listEnd >= mesh.priority) {
                var idx = renderPass.meshes.indexOf(mesh);
                if (idx === -1) {
                    return;
                }
                // TODO hack: 现在的除了rp1和finalcopy pass，所有renderpass的meshes是一个copy加上一个filter mesh，这里的判断当filter mesh被删除后当前pass需不需要删除，
                // 判断需要更鲁棒。
                var shouldRestoreRenderPass = idx === 1 && renderPass.meshes[0].name === EFFECTS_COPY_MESH_NAME;
                renderPass.removeMesh(mesh);
                if (shouldRestoreRenderPass) {
                    var nextRenderPass = renderPasses[i + 1];
                    var meshes = renderPass.meshes;
                    if (!info.intermedia) {
                        (_a = info.preRenderPass) === null || _a === void 0 ? void 0 : _a.resetColorAttachments([]);
                        //this.renderer.extension.resetColorAttachments?.(info.preRenderPass, []);
                    }
                    for (var j = 1; j < meshes.length; j++) {
                        (_b = info.preRenderPass) === null || _b === void 0 ? void 0 : _b.addMesh(meshes[j]);
                    }
                    var cp = (_c = renderPass.attachments[0]) === null || _c === void 0 ? void 0 : _c.texture;
                    var keepColor = cp === this.resource.color_a || cp === this.resource.color_b;
                    renderPass.dispose({
                        meshes: exports.DestroyOptions.keep,
                        colorAttachment: keepColor ? exports.RenderPassDestroyAttachmentType.keep : exports.RenderPassDestroyAttachmentType.destroy,
                        depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keep,
                    });
                    removeItem(renderPasses, renderPass);
                    this.removeRenderPass(renderPass);
                    infoMap.delete(renderPass);
                    if (nextRenderPass) {
                        this.updateRenderInfo(nextRenderPass);
                    }
                    if (info.preRenderPass) {
                        this.updateRenderInfo(info.preRenderPass);
                    }
                    if (info.prePasses) {
                        info.prePasses.forEach(function (rp) {
                            _this.removeRenderPass(rp.pass);
                            if ((rp === null || rp === void 0 ? void 0 : rp.destroyOptions) !== false) {
                                rp.pass.attachments.forEach(function (c) {
                                    if (c.texture !== _this.resource.color_b || c.texture !== _this.resource.color_a) {
                                        c.texture.dispose();
                                    }
                                });
                                var options = __assign$1(__assign$1({}, ((rp === null || rp === void 0 ? void 0 : rp.destroyOptions) ? rp.destroyOptions : {})), { depthStencilAttachment: exports.RenderPassDestroyAttachmentType.keep });
                                rp.pass.dispose(options);
                            }
                        });
                    }
                    this.resetRenderPassDefaultAttachment(renderPasses, Math.max(i - 1, 0));
                    if (renderPasses.length === 1) {
                        renderPasses[0].resetColorAttachments([]);
                        //this.renderer.extension.resetColorAttachments?.(renderPasses[0], []);
                        this.removeRenderPass(this.resource.finalCopyRP);
                    }
                }
                return this.resetClearActions();
            }
        }
    };
    /**
     * 将 Mesh 所有在 RenderPass 进行切分
     * @param mesh - 目标 Mesh 对象
     * @param options - 切分选项，包含 RenderPass 相关的 Attachment 等数据
     */
    RenderFrame.prototype.splitDefaultRenderPassByMesh = function (mesh, options) {
        var _a, _b, _c;
        var index = this.findMeshRenderPassIndex(mesh);
        var renderPass = this.renderPasses[index];
        this.createResource();
        var meshIndex = renderPass.meshes.indexOf(mesh);
        var ms0 = renderPass.meshes.slice(0, meshIndex);
        var ms1 = renderPass.meshes.slice(meshIndex);
        var infoMap = this.renderPassInfoMap;
        // TODO 为什么要加这个判断？
        // if (renderPass.attachments[0] && this.renderPasses[index + 1] !== this.resource.finalCopyRP) {
        //   throw Error('not implement');
        // } else {
        if (!((_a = options.attachments) === null || _a === void 0 ? void 0 : _a.length)) {
            throw Error('should include at least one color attachment');
        }
        var defRPS = this.renderPasses;
        var defIndex = defRPS.indexOf(renderPass);
        defRPS[defIndex - 1];
        removeItem(defRPS, renderPass);
        var lastInfo = infoMap.get(renderPass);
        infoMap.delete(renderPass);
        var filter = this.renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
        var rp0 = new RenderPass(this.renderer, {
            name: RENDER_PASS_NAME_PREFIX + defIndex,
            priority: renderPass.priority,
            attachments: [{
                    texture: {
                        sourceType: exports.TextureSourceType.framebuffer,
                        format: glContext.RGBA,
                        name: 'frame_a',
                        minFilter: filter,
                        magFilter: filter,
                    },
                }],
            clearAction: renderPass.clearAction || { colorAction: exports.TextureLoadAction.clear },
            storeAction: renderPass.storeAction,
            depthStencilAttachment: this.resource.depthStencil,
            meshes: ms0,
            meshOrder: exports.OrderType.ascending,
        });
        ms1.unshift(this.createCopyMesh());
        var renderPasses = this.renderPasses;
        renderPasses[index] = rp0;
        var prePasses = [];
        var restMeshes = ms1.slice();
        if (options.prePasses) {
            options.prePasses.forEach(function (pass, i) {
                pass.priority = renderPass.priority + 1 + i;
                pass.setMeshes(ms1);
                prePasses.push(pass);
            });
            renderPasses.splice.apply(renderPasses, __spreadArray$2([index + 1, 0], __read$3(prePasses), false));
            restMeshes.splice(0, 2);
        }
        var copyRP = this.resource.finalCopyRP;
        if (!renderPasses.includes(copyRP)) {
            renderPasses.push(copyRP);
        }
        // let sourcePass = (prePasses.length && !options.useLastDefaultPassColor) ? prePasses[prePasses.length - 1] : rp0;
        var finalFilterPass = prePasses[prePasses.length - 1];
        finalFilterPass.initialize(this.renderer);
        // 不切RT，接着上一个pass的渲染结果渲染
        var rp1 = new RenderPass(this.renderer, {
            name: RENDER_PASS_NAME_PREFIX + (defIndex + 1),
            priority: renderPass.priority + 1 + (((_b = options.prePasses) === null || _b === void 0 ? void 0 : _b.length) || 0),
            meshes: restMeshes,
            meshOrder: exports.OrderType.ascending,
            depthStencilAttachment: this.resource.depthStencil,
            storeAction: options.storeAction,
            clearAction: {
                depthAction: exports.TextureLoadAction.whatever,
                stencilAction: exports.TextureLoadAction.whatever,
                colorAction: exports.TextureLoadAction.whatever,
            },
        });
        renderPasses.splice(index + 1 + (((_c = options.prePasses) === null || _c === void 0 ? void 0 : _c.length) || 0), 0, rp1);
        this.setRenderPasses(renderPasses);
        this.updateRenderInfo(finalFilterPass);
        this.updateRenderInfo(rp0);
        this.updateRenderInfo(rp1);
        // 目的是删除滤镜元素后，把之前滤镜用到的prePass给删除，逻辑有些复杂，考虑优化
        infoMap.get(rp0).prePasses = lastInfo.prePasses;
        prePasses.pop();
        infoMap.get(finalFilterPass).prePasses = prePasses.map(function (pass, i) {
            return { pass: pass, destroyOptions: false };
        });
        this.resetClearActions();
        return finalFilterPass;
    };
    /**
     * 销毁 RenderFrame
     * @param options - 可以有选择销毁一些对象
     */
    RenderFrame.prototype.dispose = function (options) {
        var _a, _b;
        if ((options === null || options === void 0 ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        var pass = (options === null || options === void 0 ? void 0 : options.passes) ? options.passes : undefined;
        if (pass !== exports.DestroyOptions.keep) {
            this._renderPasses.forEach(function (renderPass) {
                renderPass.dispose(pass);
            });
        }
        this.passTextureCache.dispose();
        this._renderPasses.length = 0;
        this.emptyTexture.dispose();
        this.transparentTexture.dispose();
        if (this.resource) {
            this.resource.color_a.dispose();
            this.resource.color_b.dispose();
            (_b = (_a = this.resource.depthStencil) === null || _a === void 0 ? void 0 : _a.texture) === null || _b === void 0 ? void 0 : _b.dispose();
            this.resource.finalCopyRP.dispose();
            this.resource.resRP.dispose();
            // @ts-expect-error
            this.resource = null;
        }
        this.destroyed = true;
    };
    /**
     * 重置 RenderPass ColorAttachment，解决 FrameBuffer 即读又写的问题
     * @param renderPasses - RenderPass 对象数组
     * @param startIndex - 开始重置的索引
     */
    RenderFrame.prototype.resetRenderPassDefaultAttachment = function (renderPasses, startIndex) {
        var _a, _b;
        var pre;
        var _c = this.resource, color_a = _c.color_a, color_b = _c.color_b;
        for (var i = startIndex; i < renderPasses.length; i++) {
            var rp = renderPasses[i];
            var tex = (_a = rp.attachments[0]) === null || _a === void 0 ? void 0 : _a.texture;
            // @ts-expect-error
            if (tex && pre === tex) {
                var next = tex === color_a ? color_b : color_a;
                rp.resetColorAttachments([next]);
                //this.renderer.extension.resetColorAttachments?.(rp as GLRenderPass, [next as GLTexture]);
            }
            tex = (_b = rp.attachments[0]) === null || _b === void 0 ? void 0 : _b.texture;
            if (tex) {
                pre = tex;
            }
        }
    };
    /**
     * 查找 Mesh 所在的 RenderPass 索引，没找到是-1
     * @param mesh - 需要查找的 Mesh
     */
    RenderFrame.prototype.findMeshRenderPassIndex = function (mesh) {
        var index = -1;
        this.renderPasses.every(function (rp, idx) {
            if (rp.name.startsWith(RENDER_PASS_NAME_PREFIX) && rp.meshes.includes(mesh)) {
                index = idx;
                return false;
            }
            return true;
        });
        return index;
    };
    RenderFrame.prototype.addToRenderPass = function (renderPass, mesh) {
        var info = this.renderPassInfoMap.get(renderPass);
        var priority = mesh.priority;
        if (renderPass.meshes.length === 0) {
            info.listStart = info.listEnd = priority;
        }
        else {
            if (priority < info.listStart) {
                info.listStart = priority;
            }
            else if (priority > info.listEnd) {
                info.listEnd = priority;
            }
        }
        renderPass.addMesh(mesh);
    };
    RenderFrame.prototype.getRPAttachments = function (attachments, preRP) {
        var _a;
        if ((attachments === null || attachments === void 0 ? void 0 : attachments.length) === 1) {
            var _b = attachments[0], texture = _b.texture, persistent = _b.persistent;
            var format = texture.format;
            var previousAttachmens = (_a = preRP === null || preRP === void 0 ? void 0 : preRP.getInitAttachments()) !== null && _a !== void 0 ? _a : [];
            if (format === glContext.RGBA && !persistent) {
                var texA = this.resource.color_a;
                if (previousAttachmens.length === 0) {
                    return [{ texture: texA }];
                }
                var texture_1 = previousAttachmens[0].texture === texA ? this.resource.color_b : texA;
                return [{ texture: texture_1 }];
            }
        }
        return attachments;
    };
    RenderFrame.prototype.resetClearActions = function () {
        var action = this.renderPasses.length > 1 ? exports.TextureLoadAction.clear : exports.TextureLoadAction.whatever;
        this.clearAction.stencilAction = action;
        this.clearAction.depthAction = action;
        this.clearAction.colorAction = action;
        if (this.keepColorBuffer) {
            this.clearAction.colorAction = exports.TextureLoadAction.whatever;
        }
    };
    RenderFrame.prototype.updateRenderInfo = function (renderPass) {
        var _this = this;
        var map = this.renderPassInfoMap;
        var passes = this.renderPasses;
        var info;
        if (!map.has(renderPass)) {
            info = {
                intermedia: false,
                renderPass: renderPass,
                listStart: 0,
                listEnd: 0,
            };
            map.set(renderPass, info);
        }
        else {
            info = map.get(renderPass);
        }
        info.intermedia = renderPass.attachments.length > 0;
        var meshes = renderPass.meshes;
        if (meshes[0]) {
            info.listStart = (meshes[0].name === EFFECTS_COPY_MESH_NAME ? meshes[1] : meshes[0]).priority;
            info.listEnd = meshes[meshes.length - 1].priority;
        }
        else {
            info.listStart = 0;
            info.listEnd = 0;
        }
        var index = passes.indexOf(renderPass);
        var depthStencilActon = index === 0 ? exports.TextureLoadAction.clear : exports.TextureLoadAction.whatever;
        if (index === 0) {
            renderPass.clearAction.colorAction = exports.TextureLoadAction.clear;
        }
        renderPass.clearAction.depthAction = depthStencilActon;
        renderPass.clearAction.stencilAction = depthStencilActon;
        if (index > -1) {
            renderPass.semantics.setSemantic('EDITOR_TRANSFORM', function () { return _this.editorTransform; });
        }
        else {
            renderPass.semantics.setSemantic('EDITOR_TRANSFORM', undefined);
        }
        info.preRenderPass = passes[index - 1];
        return info;
    };
    /**
     * 设置 RenderPass 数组，直接修改内部的 RenderPass 数组
     * @param passes - RenderPass 数组
     */
    RenderFrame.prototype.setRenderPasses = function (passes) {
        var _this = this;
        if (this.renderer !== undefined) {
            passes.forEach(function (pass) { return pass.initialize(_this.renderer); });
        }
        this._renderPasses = passes.slice();
    };
    /**
     * 添加 RenderPass
     * @param pass - 需要添加的 RenderPass
     */
    RenderFrame.prototype.addRenderPass = function (pass) {
        if (this.renderer !== undefined) {
            pass.initialize(this.renderer);
        }
        this._renderPasses.push(pass);
    };
    /**
     * 创建 RenderPass 切分时需要的 GPU 资源
     */
    RenderFrame.prototype.createResource = function () {
        var _a;
        var engine = this.renderer.engine;
        if (!this.resource) {
            var _b = engine.gpuCapability, detail = _b.detail, level = _b.level;
            var width = this.renderer.getWidth();
            var height = this.renderer.getHeight();
            var filter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
            var texA = Texture.create(engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                name: 'frame_a',
                minFilter: filter,
                magFilter: filter,
            });
            var texB = Texture.create(engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                data: {
                    width: width,
                    height: height,
                },
                minFilter: filter,
                magFilter: filter,
                name: 'frame_b',
            });
            var depthStencilType = detail.readableDepthStencilTextures && detail.writableFragDepth ?
                exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture :
                exports.RenderPassAttachmentStorageType.depth_stencil_opaque;
            var resRP = new RenderPass(this.renderer, {
                depthStencilAttachment: { storageType: depthStencilType },
                attachments: [{ texture: texA }],
            }).initialize(this.renderer);
            var finalCopyRP = new FinalCopyRP(this.renderer, {
                name: 'effects-final-copy',
                priority: RenderPassPriorityNormal + 600,
                clearAction: {
                    depthAction: exports.TextureLoadAction.clear,
                    stencilAction: exports.TextureLoadAction.clear,
                    colorAction: exports.TextureLoadAction.clear,
                },
                meshOrder: exports.OrderType.ascending,
                meshes: [this.createCopyMesh({ blend: true, depthTexture: (_a = resRP.getDepthAttachment()) === null || _a === void 0 ? void 0 : _a.texture })],
            });
            this.resource = {
                color_a: resRP.attachments[0].texture,
                color_b: texB,
                finalCopyRP: finalCopyRP,
                depthStencil: resRP.depthAttachment,
                resRP: resRP,
            };
        }
    };
    // TODO tex和size没有地方用到。
    /**
     * 创建拷贝 RenderPass 用到的 Mesh 对象
     * @param semantics - RenderPass 渲染时 FrameBuffer 的颜色和深度纹理、大小和是否混合
     */
    RenderFrame.prototype.createCopyMesh = function (semantics) {
        var name = EFFECTS_COPY_MESH_NAME;
        var engine = this.renderer.engine;
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var shader = createCopyShader(engine.gpuCapability.level, !!(semantics === null || semantics === void 0 ? void 0 : semantics.depthTexture));
        // FIXME: 如果不把shader添加进shaderLibrary，这里可以移到core中，有性能上的考虑
        this.renderer.getShaderLibrary().addShader(shader);
        var material = Material.create(engine, {
            uniformValues: {
                // @ts-expect-error
                uDepth: semantics === null || semantics === void 0 ? void 0 : semantics.depthTexture,
            },
            name: name,
            shader: shader,
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        if (semantics === null || semantics === void 0 ? void 0 : semantics.blend) {
            material.blending = true;
            material.blendFunction = [glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA, glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA];
        }
        return Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
    };
    /**
     * 移除 RenderPass
     * @param pass - 需要移除的 RenderPass
     */
    RenderFrame.prototype.removeRenderPass = function (pass) {
        removeItem(this._renderPasses, pass);
    };
    return RenderFrame;
}());
function getTextureSize(tex) {
    return tex ? new Vector2(tex.getWidth(), tex.getHeight()) : new Vector2();
}
function findPreviousRenderPass(renderPasses, renderPass) {
    var index = renderPasses.indexOf(renderPass);
    return renderPasses[index - 1];
}
var FinalCopyRP = /** @class */ (function (_super) {
    __extends(FinalCopyRP, _super);
    function FinalCopyRP() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FinalCopyRP.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(null);
    };
    FinalCopyRP.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
    };
    return FinalCopyRP;
}(RenderPass));
var GlobalUniforms = /** @class */ (function () {
    function GlobalUniforms() {
        this.floats = {};
        this.ints = {};
        // vector3s: Record<string, vec3> = {};
        this.matrices = {};
        //...
        this.samplers = []; // 存放的sampler名称。
        this.uniforms = []; // 存放的uniform名称（不包括sampler）。
    }
    return GlobalUniforms;
}());

var RenderBuffer = /** @class */ (function () {
    function RenderBuffer(props) {
        this.size = [0, 0];
        this.multiSample = 1;
        this.destroyed = false;
        var storageType = props.storageType, format = props.format, attachment = props.attachment;
        this.storageType = storageType;
        this.format = format;
        this.attachment = attachment;
    }
    Object.defineProperty(RenderBuffer.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    return RenderBuffer;
}());

var isWebGL2Available = typeof alipay.WebGL2RenderingContext === 'function';
var GPUCapability = /** @class */ (function () {
    function GPUCapability(gl) {
        this.setupCapability(gl);
    }
    GPUCapability.prototype.setupCapability = function (gl) {
        var _a;
        var level = isWebGL2Available && gl instanceof alipay.WebGL2RenderingContext ? 2 : 1;
        var level2 = level === 2;
        var textureAnisotropicExt = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        var depthTextureExtension = gl.getExtension('WEBGL_depth_texture');
        var halfFloatLinear = !!gl.getExtension('OES_texture_half_float_linear');
        var floatLinear = !!gl.getExtension('OES_texture_float_linear');
        this.level = level;
        this.type = level2 ? 'webgl2' : 'webgl';
        this.vaoExt = gl.getExtension('OES_vertex_array_object');
        this.glAsyncCompileExt = gl.getExtension('KHR_parallel_shader_compile');
        this.UNSIGNED_INT_24_8 = gl.UNSIGNED_INT_24_8;
        this.drawBufferExtension = gl.getExtension('WEBGL_draw_buffers');
        if (depthTextureExtension) {
            this.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
        }
        if (level2 && !halfFloatLinear) {
            halfFloatLinear = checkLinearTextureFilter(gl, gl.HALF_FLOAT);
        }
        if (level2 && !floatLinear) {
            floatLinear = checkLinearTextureFilter(gl, gl.FLOAT);
        }
        this.internalFormatDepth16 = level2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT;
        this.internalFormatDepth24_stencil8 = level2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL;
        var floatTexture = (level2 || gl.getExtension('OES_texture_float')) ? gl.FLOAT : 0;
        var halfFloatTexture = level2 ? alipay.WebGL2RenderingContext.HALF_FLOAT : (((_a = gl.getExtension('OES_texture_half_float')) === null || _a === void 0 ? void 0 : _a.HALF_FLOAT_OES) || 0);
        var detail = {
            floatTexture: floatTexture,
            halfFloatTexture: halfFloatTexture,
            maxSample: level2 ? gl.getParameter(gl.MAX_SAMPLES) : 1,
            maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
            maxVertexTextures: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
            maxFragmentTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
            floatColorAttachment: level2 ? !!gl.getExtension('EXT_color_buffer_float') : (floatTexture > 0 && !!gl.getExtension('WEBGL_color_buffer_float')),
            halfFloatColorAttachment: level2 ? !!gl.getExtension('EXT_color_buffer_float') : (halfFloatTexture > 0 && !!gl.getExtension('EXT_color_buffer_half_float')),
            maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
            maxShaderTexCount: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            compressedTexture: registerCompressedTexture(gl),
            halfFloatLinear: halfFloatLinear,
            floatLinear: floatLinear,
            maxTextureAnisotropy: textureAnisotropicExt ? gl.getParameter(textureAnisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
            shaderTextureLod: level2 || !!gl.getExtension('EXT_shader_texture_lod'),
            instanceDraw: level2 || !!gl.getExtension('ANGLE_instanced_arrays'),
            drawBuffers: level2 || !!this.drawBufferExtension,
            asyncShaderCompile: !!gl.getExtension('KHR_parallel_shader_compile'),
            intIndexElementBuffer: !!gl.getExtension('OES_element_index_uint'),
            standardDerivatives: level2 || !!gl.getExtension('OES_standard_derivatives'),
            readableDepthStencilTextures: level2 || !!depthTextureExtension,
            writableFragDepth: level2 || !!gl.getExtension('EXT_frag_depth'),
        };
        this['detail'] = detail;
        if (textureAnisotropicExt) {
            this.textureMaxAnisotropyExt = textureAnisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT;
        }
    };
    GPUCapability.prototype.framebufferTexture2D = function (gl, target, index, textarget, texture) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext && index > 0) {
            throw new Error('draw multiple color buffers not available');
        }
        var attachment = ext ?
            ext["COLOR_ATTACHMENT".concat(index, "_WEBGL")] :
            gl["COLOR_ATTACHMENT".concat(index)];
        if (attachment) {
            gl.framebufferTexture2D(target, attachment, textarget, texture, 0);
        }
        else {
            console.error('invalid color attachment index: ' + index);
        }
    };
    GPUCapability.prototype.drawBuffers = function (gl, bufferStates) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext) {
            if (bufferStates.length > 1) {
                throw Error('draw buffers not available');
            }
            else {
                return;
            }
        }
        var buffers = bufferStates.map(function (enabled, index) {
            if (enabled) {
                return ext ?
                    ext["COLOR_ATTACHMENT".concat(index, "_WEBGL")] :
                    gl["COLOR_ATTACHMENT".concat(index)];
            }
            return gl.NONE;
        });
        if (ext) {
            ext.drawBuffersWEBGL(buffers);
        }
        else {
            gl.drawBuffers(buffers);
        }
    };
    GPUCapability.prototype.setTextureAnisotropic = function (gl, target, level) {
        var maxTextureAnisotropy = this.detail.maxTextureAnisotropy;
        if (maxTextureAnisotropy) {
            gl.texParameterf(target, this.textureMaxAnisotropyExt, Math.min(maxTextureAnisotropy, level || 4));
        }
    };
    return GPUCapability;
}());
function checkLinearTextureFilter(gl, type) {
    var tex = gl.createTexture();
    var ret = false;
    gl.getError();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R16F, 1, 1, 0, gl.RED, type, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    if (!gl.getError()) {
        ret = true;
    }
    gl.deleteTexture(tex);
    return ret;
}
var COMPRESSED_TEXTURE = {
    NONE: 0,
    PVRTC: 1,
    ASTC: 2,
};
function registerCompressedTexture(gl) {
    if (gl.getExtension('WEBGL_compressed_texture_astc')) {
        return COMPRESSED_TEXTURE.ASTC;
    }
    if (gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')) {
        return COMPRESSED_TEXTURE.PVRTC;
    }
    return COMPRESSED_TEXTURE.NONE;
}

exports.FilterMode = void 0;
(function (FilterMode) {
    FilterMode[FilterMode["Nearest"] = 0] = "Nearest";
    FilterMode[FilterMode["Linear"] = 1] = "Linear";
})(exports.FilterMode || (exports.FilterMode = {}));
exports.RenderTextureFormat = void 0;
(function (RenderTextureFormat) {
    RenderTextureFormat[RenderTextureFormat["RGBA32"] = 0] = "RGBA32";
    RenderTextureFormat[RenderTextureFormat["RGBAHalf"] = 1] = "RGBAHalf";
})(exports.RenderTextureFormat || (exports.RenderTextureFormat = {}));
/**
 *
 */
var FrameBuffer = /** @class */ (function () {
    function FrameBuffer() {
    }
    FrameBuffer.prototype.resize = function (x, y, width, height) {
        // OVERRIDE
    };
    FrameBuffer.prototype.resetColorTextures = function (textures) {
        // OVERRIDE
    };
    FrameBuffer.prototype.unbind = function () {
        // OVERRIDE
    };
    FrameBuffer.prototype.bind = function () {
        // OVERRIDE
    };
    Object.defineProperty(FrameBuffer.prototype, "stencilStorage", {
        get: function () {
            // OVERRIDE
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FrameBuffer.prototype, "depthStorage", {
        get: function () {
            // OVERRIDE
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    FrameBuffer.prototype.getDepthTexture = function () {
        // OVERRIDE
        return undefined;
    };
    FrameBuffer.prototype.getStencilTexture = function () {
        // OVERRIDE
        return undefined;
    };
    FrameBuffer.prototype.getColorTextures = function () {
        // OVERRIDE
        return [];
    };
    FrameBuffer.prototype.dispose = function (opt) {
        // OVERRIDE
    };
    return FrameBuffer;
}());

var Renderer = /** @class */ (function () {
    function Renderer() {
    }
    Renderer.prototype.setGlobalFloat = function (name, value) {
        // OVERRIDE
    };
    Renderer.prototype.setGlobalInt = function (name, value) {
        // OVERRIDE
    };
    Renderer.prototype.setGlobalMatrix = function (name, value) {
        // OVERRIDE
    };
    Renderer.prototype.getFrameBuffer = function () {
        // OVERRIDE
        return null;
    };
    Renderer.prototype.setFrameBuffer = function (frameBuffer) {
    };
    Renderer.prototype.setViewport = function (x, y, width, height) {
        // OVERRIDE
    };
    Renderer.prototype.resize = function (canvasWidth, canvasHeight) {
        // OVERRIDE
    };
    Renderer.prototype.clear = function (action) {
        // OVERRIDE
    };
    Renderer.prototype.getWidth = function () {
        // OVERRIDE
        return 0;
    };
    Renderer.prototype.getHeight = function () {
        // OVERRIDE
        return 0;
    };
    /**
     * 添加 webglcontextlost 事件回调
     * @override
     * @param lostHandler
     */
    Renderer.prototype.addLostHandler = function (lostHandler) {
        // OVERRIDE
    };
    /**
     * 添加 webglContextrestored 事件的回调
     * @override
     * @param restoreHandler
     */
    Renderer.prototype.addRestoreHandler = function (restoreHandler) {
        // OVERRIDE
    };
    /**
     * @override
     * @param e
     */
    Renderer.prototype.lost = function (e) {
        // OVERRIDE
    };
    /**
     * @override
     */
    Renderer.prototype.restore = function () {
        // OVERRIDE
    };
    /**
     *
     * @override
     * @returns
     */
    Renderer.prototype.getShaderLibrary = function () {
        // OVERRIDE
        return undefined;
    };
    Renderer.prototype.renderRenderFrame = function (renderFrame) {
        // OVERRIDE
    };
    Renderer.prototype.renderMeshes = function (meshes) {
        // OVERRIDE
    };
    Renderer.prototype.drawGeometry = function (geometry, material) {
        // OVERRIDE
    };
    Renderer.prototype.getTemporaryRT = function (name, width, height, depthBuffer, filter, format) {
        // OVERRIDE
        return null;
    };
    Renderer.prototype.dispose = function (haltGL) {
        // OVERRIDE
    };
    return Renderer;
}());

var vertex = "\nprecision highp float;\n\nattribute vec2 aPoint;\nuniform vec4 uPos;\nuniform vec2 uSize;\nuniform vec4 uQuat;\nuniform vec4 uColor;\nuniform mat4 effects_ObjectToWorld;\nuniform mat4 effects_MatrixInvV;\nuniform mat4 effects_MatrixVP;\nvarying vec4 vColor;\n#ifdef ENV_EDITOR\n  uniform vec4 uEditorTransform;\n#endif\n\nvec3 rotateByQuat(vec3 a, vec4 quat){\n  vec3 qvec = quat.xyz;\n  vec3 uv = cross(qvec, a);\n  vec3 uuv = cross(qvec, uv) * 2.;\n  return a +(uv * 2. * quat.w + uuv);\n}\n\nvoid main() {\n  vec4 _pos = uPos;\n  vec3 point = rotateByQuat(vec3(aPoint.xy * uSize, 0.),uQuat);\n  vec4 pos = vec4(_pos.xyz, 1.0);\n  pos = effects_ObjectToWorld * pos;\n  pos.xyz += effects_MatrixInvV[0].xyz * point.x+ effects_MatrixInvV[1].xyz * point.y;\n  gl_Position = effects_MatrixVP * pos;\n  vColor = uColor;\n  #ifdef ENV_EDITOR\n    gl_Position = vec4(gl_Position.xy * uEditorTransform.xy + uEditorTransform.zw * gl_Position.w, gl_Position.zw);\n  #endif\n}\n";
var fragment = "\nprecision highp float;\n\n#define fragColor gl_FragColor\n\nvarying vec4 vColor;\nvoid main() {\n  gl_FragColor = vColor;\n}\n";
var seed$8 = 1;
var InteractMesh = /** @class */ (function () {
    function InteractMesh(props, rendererOptions, transform, engine) {
        this.transform = transform;
        this.engine = engine;
        this.color = props.options.previewColor;
        var material = this.createMaterial(rendererOptions);
        var geometry = this.createGeometry();
        this.mesh = this.createMesh(geometry, material);
        this.updateMesh();
    }
    InteractMesh.prototype.updateMesh = function () {
        var material = this.mesh.material;
        var uSize = material.getVector2('uSize').clone();
        var uPos = material.getVector4('uPos').clone();
        var tempPos = new Vector3();
        var tempQuat = new Quaternion();
        var tempScale = this.transform.scale.clone();
        this.transform.assignWorldTRS(tempPos, tempQuat, tempScale);
        uSize.x = tempScale.x;
        uSize.y = tempScale.y;
        uPos.x = tempPos.x;
        uPos.y = tempPos.y;
        uPos.z = tempPos.z;
        material.setVector2('uSize', uSize);
        material.setVector4('uPos', uPos);
        material.setQuaternion('uQuat', tempQuat);
    };
    InteractMesh.prototype.createMaterial = function (rendererOptions) {
        var _a;
        var marcos = [
            ['ENV_EDITOR', ((_a = this.engine.renderer) === null || _a === void 0 ? void 0 : _a.env) === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var color = createValueGetter(this.color).getValue(0);
        var level = this.engine.gpuCapability.level;
        var materialProps = {
            shader: {
                vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex, level),
                fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment, level),
                glslVersion: exports.GLSLVersion.GLSL1,
                cacheId: "".concat(rendererOptions.cachePrefix, "_effects_interact"),
            },
            uniformSemantics: {
                effects_MatrixVP: 'VIEWPROJECTION',
                effects_MatrixInvV: 'VIEWINVERSE',
                effects_ObjectToWorld: 'MODEL',
                uEditorTransform: 'EDITOR_TRANSFORM',
            },
        };
        var material = Material.create(this.engine, materialProps);
        material.depthTest = false;
        material.setVector4('uPos', new Vector4$1(0, 0, 0, 0));
        material.setVector2('uSize', new Vector2(1, 1));
        material.setVector4('uColor', new Vector4$1(color[0] / 255, color[1] / 255, color[2] / 255, color[3]));
        material.setQuaternion('uQuat', new Quaternion(0, 0, 0, 0));
        return material;
    };
    InteractMesh.prototype.createGeometry = function () {
        var indexData = new Uint8Array([0, 1, 1, 2, 2, 3, 3, 0]);
        return Geometry.create(this.engine, {
            attributes: {
                aPoint: {
                    size: 2,
                    offset: 0,
                    stride: 2 * Float32Array.BYTES_PER_ELEMENT,
                    data: new Float32Array([
                        -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5,
                    ]),
                },
            },
            drawCount: indexData.length,
            indices: { data: indexData },
            mode: glContext.LINES,
            maxVertex: 4,
        });
    };
    InteractMesh.prototype.createMesh = function (geometry, material) {
        return Mesh.create(this.engine, {
            name: 'Interact_preview' + seed$8++,
            priority: 0,
            worldMatrix: Matrix4$1.fromIdentity(),
            geometry: geometry,
            material: material,
        });
    };
    return InteractMesh;
}());

var InteractVFXItem = /** @class */ (function (_super) {
    __extends(InteractVFXItem, _super);
    function InteractVFXItem(props, composition) {
        var _a;
        var _this = _super.call(this, props, composition) || this;
        /**
         * 拖拽的惯性衰减系数，范围[0, 1], 越大惯性越强
         */
        _this.downgrade = 0.95;
        /**
         * 拖拽的距离映射系数，越大越容易拖动
         */
        _this.dragRatio = [1, 1];
        _this.engine = (_a = _this.composition) === null || _a === void 0 ? void 0 : _a.getEngine();
        return _this;
    }
    Object.defineProperty(InteractVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.interact;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InteractVFXItem.prototype, "enable", {
        get: function () {
            return this.enabled;
        },
        set: function (enable) {
            this.enabled = enable;
            if (!enable) {
                // 立刻停止惯性滑动
                this.bouncingArg = null;
            }
        },
        enumerable: false,
        configurable: true
    });
    InteractVFXItem.prototype.onConstructed = function (options) {
        this.ui = options.content;
        this.enabled = true;
    };
    InteractVFXItem.prototype.onLifetimeBegin = function (composition) {
        var _a, _b, _c;
        var options = this.ui.options;
        var env = ((_b = (_a = this.engine) === null || _a === void 0 ? void 0 : _a.renderer) !== null && _b !== void 0 ? _b : {}).env;
        (_c = this.composition) === null || _c === void 0 ? void 0 : _c.addInteractiveItem(this, options.type);
        if (options.type === InteractType$1.DRAG) {
            if (env !== PLAYER_OPTIONS_ENV_EDITOR || options.enableInEditor) {
                composition.event && this.beginDragTarget(options, composition.event);
            }
        }
    };
    InteractVFXItem.prototype.onItemUpdate = function () {
        var _a;
        (_a = this.previewContent) === null || _a === void 0 ? void 0 : _a.updateMesh();
        if (!this.dragEvent || !this.bouncingArg) {
            return;
        }
        this.bouncingArg.vx *= this.downgrade;
        this.bouncingArg.vy *= this.downgrade;
        this.bouncingArg.dy += this.bouncingArg.vy;
        this.bouncingArg.dx += this.bouncingArg.vx;
        if (shouldIgnoreBouncing(this.bouncingArg)) {
            this.dragEvent = null;
            this.bouncingArg = null;
        }
        else {
            this.handleDragMove(this.dragEvent, this.bouncingArg);
        }
    };
    InteractVFXItem.prototype.onEnd = function () {
        if (this.composition) {
            this.composition.removeInteractiveItem(this, this.ui.options.type);
        }
    };
    InteractVFXItem.prototype.onItemRemoved = function () {
        var _a;
        this.clickable = false;
        (_a = this.previewContent) === null || _a === void 0 ? void 0 : _a.mesh.dispose();
        this.endDragTarget();
    };
    InteractVFXItem.prototype.getBoundingBox = function () {
        var worldMatrix = this.transform.getWorldMatrix();
        var triangles = trianglesFromRect(Vector3.ZERO, 0.5, 0.5);
        triangles.forEach(function (triangle) {
            worldMatrix.transformPoint(triangle.p0);
            worldMatrix.transformPoint(triangle.p1);
            worldMatrix.transformPoint(triangle.p2);
        });
        return {
            type: exports.HitTestType.triangle,
            area: triangles,
        };
    };
    InteractVFXItem.prototype.getHitTestParams = function () {
        if (!this.clickable || !this.canInteract()) {
            return;
        }
        var behavior = this.ui.options.behavior;
        var area = this.getBoundingBox();
        if (area) {
            return {
                type: area.type,
                triangles: area.area,
                behavior: behavior,
            };
        }
    };
    InteractVFXItem.prototype.doCreateContent = function (composition) {
        var _a;
        var _b = this.ui.options, type = _b.type, showPreview = _b.showPreview;
        var engine = this.engine;
        var env = ((_a = engine === null || engine === void 0 ? void 0 : engine.renderer) !== null && _a !== void 0 ? _a : {}).env;
        assertExist(engine);
        if (type === InteractType$1.CLICK) {
            this.clickable = true;
            if (showPreview && env === PLAYER_OPTIONS_ENV_EDITOR) {
                var rendererOptions = composition.getRendererOptions();
                this.previewContent = new InteractMesh(this.ui, rendererOptions, this.transform, engine);
            }
        }
        return {};
    };
    InteractVFXItem.prototype.beginDragTarget = function (options, eventSystem) {
        var _this = this;
        if (options.target !== 'camera') {
            return;
        }
        var dragEvent;
        var handlerMap = {
            touchstart: function (event) {
                var _a;
                if (!_this.canInteract()) {
                    return;
                }
                _this.dragEvent = null;
                _this.bouncingArg = null;
                var camera = (_a = _this.composition) === null || _a === void 0 ? void 0 : _a.camera;
                dragEvent = {
                    x: event.x,
                    y: event.y,
                    cameraParam: {
                        position: (camera === null || camera === void 0 ? void 0 : camera.position.toArray()) || [0, 0, 8],
                        fov: (camera === null || camera === void 0 ? void 0 : camera.fov) || 60,
                    },
                };
            },
            touchmove: function (event) {
                _this.handleDragMove(dragEvent, event);
                _this.bouncingArg = event;
            },
            touchend: function (event) {
                if (!_this.canInteract()) {
                    return;
                }
                var bouncingArg = _this.bouncingArg;
                if (!shouldIgnoreBouncing(bouncingArg, 3) && bouncingArg) {
                    var speed = 5;
                    bouncingArg.vx *= speed;
                    bouncingArg.vy *= speed;
                    _this.dragEvent = __assign$1({}, dragEvent);
                }
                dragEvent = null;
            },
        };
        Object.keys(handlerMap).forEach(function (name) {
            eventSystem.addEventListener(name, handlerMap[name]);
        });
        handlerMap.touchmove({ dx: 0, dy: 0, width: 1, height: 1 });
        this.endDragTarget = function () {
            Object.keys(handlerMap).forEach(function (name) {
                eventSystem.removeEventListener(name, handlerMap[name]);
            });
        };
    };
    InteractVFXItem.prototype.endDragTarget = function () {
        // OVERRIDE
    };
    InteractVFXItem.prototype.handleDragMove = function (evt, event) {
        var _a, _b;
        if (!(evt === null || evt === void 0 ? void 0 : evt.cameraParam) || !this.canInteract() || !this.composition) {
            return;
        }
        var options = this.ui.options;
        var _c = evt.cameraParam, position = _c.position, fov = _c.fov;
        var dy = event.dy;
        var dx = event.dx * event.width / event.height;
        var depth = position[2];
        var sp = Math.tan(fov * Math.PI / 180 / 2) * Math.abs(depth);
        var height = dy * sp;
        var width = dx * sp;
        var nx = position[0] - this.dragRatio[0] * width;
        var ny = position[1] - this.dragRatio[1] * height;
        if (options.dxRange) {
            var _d = __read$3(options.dxRange, 2), min = _d[0], max = _d[1];
            nx = clamp$1(nx, min, max);
            if (nx !== min && nx !== max && min !== max) {
                (_a = event.origin) === null || _a === void 0 ? void 0 : _a.preventDefault();
            }
        }
        if (options.dyRange) {
            var _e = __read$3(options.dyRange, 2), min = _e[0], max = _e[1];
            ny = clamp$1(ny, min, max);
            if (ny !== min && ny !== max && min !== max) {
                (_b = event.origin) === null || _b === void 0 ? void 0 : _b.preventDefault();
            }
        }
        this.composition.camera.position = new Vector3(nx, ny, depth);
    };
    InteractVFXItem.prototype.canInteract = function () {
        var _a;
        return Boolean((_a = this.composition) === null || _a === void 0 ? void 0 : _a.interactive) && this.enabled;
    };
    return InteractVFXItem;
}(VFXItem));
function shouldIgnoreBouncing(arg, mul) {
    var threshold = 0.00001 * (mul || 1);
    return arg && Math.abs(arg.vx || 0) < threshold && Math.abs(arg.vy || 0) < threshold;
}

var InteractLoader = /** @class */ (function (_super) {
    __extends(InteractLoader, _super);
    function InteractLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.mesh = [];
        return _this;
    }
    InteractLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        if (item instanceof InteractVFXItem && item.previewContent) {
            this.addMesh(item.previewContent.mesh);
        }
    };
    InteractLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        if (item instanceof InteractVFXItem && item.previewContent) {
            this.removeMesh(item.previewContent.mesh, composition.renderFrame);
        }
    };
    InteractLoader.prototype.prepareRenderFrame = function (composition, renderFrame) {
        this.mesh && this.mesh.forEach(function (mesh) { return renderFrame.addMeshToDefaultRenderPass(mesh); });
        this.mesh = [];
        return false;
    };
    InteractLoader.prototype.addMesh = function (mesh) {
        this.mesh.push(mesh);
    };
    InteractLoader.prototype.removeMesh = function (mesh, frame) {
        frame.removeMeshFromDefaultRenderPass(mesh);
    };
    return InteractLoader;
}(AbstractPlugin));

var InteractItem = /** @class */ (function () {
    function InteractItem() {
    }
    return InteractItem;
}());

exports.maxSpriteMeshItemCount = 8;
exports.maxSpriteTextureCount = 8;
var seed$7 = 1;
var SpriteMesh = /** @class */ (function () {
    function SpriteMesh(engine, renderInfo, composition) {
        this.engine = engine;
        this.composition = composition;
        this.items = [];
        this.dirty = false;
        var wireframe = renderInfo.wireframe;
        var geometry = this.createGeometry(wireframe ? glContext.LINES : glContext.TRIANGLES);
        var material = this.createMaterial(renderInfo, 2);
        this.wireframe = wireframe;
        this.mesh = Mesh.create(engine, {
            name: 'MSprite' + seed$7++,
            priority: 0,
            worldMatrix: Matrix4$1.fromIdentity(),
            geometry: geometry,
            material: material,
        });
    }
    SpriteMesh.prototype.setItems = function (items) {
        var _a, _b, _c, _d;
        var datas = [];
        var textures = [];
        var itemSlot = 2;
        var aPointLen = 0;
        var indexLen = 0;
        var pointCount = 0;
        var renderInfo;
        if (!items.length) {
            this.mesh.setVisible(false);
            return true;
        }
        for (var i = 0; i < items.length; i++) {
            if (items[i].renderInfo) {
                renderInfo = items[i].renderInfo;
                break;
            }
        }
        if (!renderInfo) {
            return true;
        }
        this.items = items.slice();
        if (items.length > 2) {
            itemSlot = exports.maxSpriteMeshItemCount;
        }
        if (this.mtlSlotCount !== itemSlot) {
            this.mesh.setMaterial(this.createMaterial(renderInfo, itemSlot), { textures: exports.DestroyOptions.keep });
        }
        var attachmentLength = (_d = (_c = (_b = (_a = renderInfo.filter) === null || _a === void 0 ? void 0 : _a.passSplitOptions) === null || _b === void 0 ? void 0 : _b.attachments) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.splitLayer = attachmentLength > 0;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var texture = item === null || item === void 0 ? void 0 : item.renderer.texture;
            if (texture) {
                addItem(textures, texture);
            }
            item.mesh = this;
        }
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var texture = item === null || item === void 0 ? void 0 : item.renderer.texture;
            var textureIndex = texture ? textures.indexOf(texture) : -1;
            var data = this.getItemInitData(item, i, pointCount, textureIndex);
            aPointLen += data.aPoint.length;
            indexLen += data.index.length;
            datas.push(data);
            pointCount += data.aPoint.length / 6;
            this.updateItem(item, true);
        }
        var bundle = {
            aPoint: new Float32Array(aPointLen),
            index: new Uint16Array(indexLen),
        };
        var cursor = {
            aPoint: 0,
            index: 0,
        };
        var _loop_1 = function (i) {
            var data = datas[i];
            Object.keys(bundle).forEach(function (name) {
                var arr = bundle[name];
                var ta = data[name];
                arr.set(ta, cursor[name]);
                cursor[name] += ta.length;
            });
        };
        for (var i = 0; i < datas.length; i++) {
            _loop_1(i);
        }
        var _e = this.mesh, material = _e.material, geometry = _e.geometry;
        var indexData = bundle.index;
        geometry.setIndexData(indexData);
        geometry.setAttributeData('aPoint', bundle.aPoint);
        geometry.setDrawCount(indexLen);
        this.mesh.setVisible(!!geometry.getDrawCount());
        this.mesh.priority = items[0].listIndex;
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            material.setTexture('uSampler' + i, texture);
        }
        // FIXME: 内存泄漏的临时方案，后面再调整
        var emptyTexture = items[0].emptyTexture;
        for (var k = textures.length; k < exports.maxSpriteMeshItemCount; k++) {
            material.setTexture('uSampler' + k, emptyTexture);
        }
        if (this.splitLayer) {
            var tex = generateFeatureTexture(this.engine, items[0].feather);
            material.setTexture('uFeatherSampler', tex);
        }
    };
    SpriteMesh.prototype.updateItem = function (item, init) {
        var index = this.items.indexOf(item);
        if (index <= -1) {
            return;
        }
        var texDataArray = this.mesh.material.getVector4Array('uTexParams');
        var idxStart = index * 4;
        var selfData = item.getRenderData(item.time, init);
        var mainDataArray = this.mesh.material.getMatrixArray('uMainData');
        var start = index * 16;
        var uPosStart = start;
        var uSizeStart = start + 4;
        var uQuatStart = start + 8;
        var uColorStart = start + 12;
        var tempPos = new Vector3();
        var tempQuat = new Quaternion();
        var tempScale = new Vector3();
        var uColor = selfData.color || [mainDataArray[uColorStart], mainDataArray[uColorStart + 1], mainDataArray[uColorStart + 2], mainDataArray[uColorStart + 3]];
        if (selfData.visible) {
            selfData.transform.assignWorldTRS(tempPos, tempQuat, tempScale);
        }
        else {
            if (!init) {
                mainDataArray[uSizeStart + 2] = -1;
                return;
            }
        }
        var uPos = __spreadArray$2(__spreadArray$2([], __read$3(tempPos.toArray()), false), [0], false);
        var uSize = __spreadArray$2(__spreadArray$2([], __read$3(tempScale.toArray()), false), [0], false);
        var uQuat = tempQuat.toArray();
        if (!isNaN(item.getCustomOpacity())) {
            uColor[3] = item.getCustomOpacity();
        }
        // selfData.transform.assignWorldTRS(uPos, uQuat, uSize);
        /* 要过包含父节点颜色/透明度变化的动画的帧对比 打开这段兼容代码 */
        // vecMulCombine(uColor, selfData.color, parentData.color);
        /***********************/
        for (var i = 0; i < 4; i++) {
            mainDataArray[uPosStart + i] = uPos[i];
            mainDataArray[uQuatStart + i] = uQuat[i];
            mainDataArray[uSizeStart + i] = uSize[i];
            mainDataArray[uColorStart + i] = uColor[i];
        }
        uSize[2] = selfData.life;
        mainDataArray[uSizeStart + 2] = selfData.life;
        if (init) {
            var renderer = item.renderer;
            texDataArray[idxStart] = renderer.occlusion ? +(renderer.transparentOcclusion) : 1;
            texDataArray[idxStart + 2] = renderer.renderMode;
            texDataArray[idxStart + 1] = +this.preMultiAlpha;
        }
        if (selfData.texOffset) {
            var texOffsetDataArray = this.mesh.material.getVector4Array('uTexOffset');
            for (var i = 0; i < 4; i++) {
                texOffsetDataArray[index * 4 + i] = selfData.texOffset[i];
            }
        }
    };
    SpriteMesh.prototype.applyChange = function () {
        if (this.dirty) {
            this.setItems(this.items);
            this.dirty = false;
        }
    };
    SpriteMesh.prototype.getItemInitData = function (item, idx, pointStartIndex, textureIndex) {
        var geoData = item.geoData;
        if (this.lineMode) {
            geoData = this.getItemGeometryData(item, idx);
        }
        else if (!geoData) {
            geoData = item.geoData = this.getItemGeometryData(item, idx);
        }
        var pointData = geoData.aPoint;
        if (pointData[4] !== idx || pointData[5] !== textureIndex) {
            for (var i = 0; i < pointData.length; i += 6) {
                pointData[i + 4] = idx;
                pointData[i + 5] = textureIndex;
            }
        }
        var index = geoData.index;
        var idxCount = index.length;
        // @ts-expect-error
        var indexData = this.wireframe ? new Uint8Array([0, 1, 1, 3, 2, 3, 2, 0]) : new index.constructor(idxCount);
        if (!this.wireframe) {
            for (var i = 0; i < idxCount; i++) {
                indexData[i] = pointStartIndex + index[i];
            }
        }
        return {
            aPoint: geoData.aPoint,
            index: indexData,
        };
    };
    SpriteMesh.prototype.getItemRegionData = function (item) {
        var index = this.items.indexOf(item);
        if (index > -1) {
            //const mainData = this.mainDataBlock.getUniformValue('uMainData') as spec.TypedArray;
            var mainData = this.mesh.material.getMatrixArray('uMainData');
            var idx = index * 16;
            if (mainData === null) {
                return;
            }
            return {
                position: [mainData[idx] || 0, mainData[idx + 1] || 0, mainData[idx + 2] || 0],
                size: [mainData[idx + 4], mainData[idx + 5]],
                quat: [mainData[idx + 8], mainData[idx + 9], mainData[idx + 10], mainData[idx + 11]],
                color: [mainData[idx + 12], mainData[idx + 13], mainData[idx + 14], mainData[idx + 15]],
            };
        }
    };
    SpriteMesh.prototype.invalidMaterial = function () {
        this.mtlSlotCount = 0;
    };
    SpriteMesh.prototype.createGeometry = function (mode) {
        var BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
        return Geometry.create(this.engine, {
            attributes: {
                aPoint: {
                    size: 4,
                    offset: 0,
                    stride: SPRITE_VERTEX_STRIDE * BYTES_PER_ELEMENT,
                    releasable: true,
                    type: glContext.FLOAT,
                    data: new Float32Array(0),
                },
                aIndex: {
                    size: 2,
                    offset: 4 * BYTES_PER_ELEMENT,
                    stride: SPRITE_VERTEX_STRIDE * BYTES_PER_ELEMENT,
                    dataSource: 'aPoint',
                    type: glContext.FLOAT,
                },
            },
            indices: { data: new Uint16Array(0), releasable: true },
            mode: mode,
            maxVertex: 4 * exports.maxSpriteMeshItemCount,
        });
    };
    SpriteMesh.prototype.createMaterial = function (renderInfo, count) {
        var e_1, _a;
        var _b;
        var filter = renderInfo.filter, side = renderInfo.side, occlusion = renderInfo.occlusion, blending = renderInfo.blending, maskMode = renderInfo.maskMode, mask = renderInfo.mask;
        var filterMesh = (filter === null || filter === void 0 ? void 0 : filter.mesh) || {};
        var engine = this.engine;
        var materialProps = {
            shader: spriteMeshShaderFromRenderInfo(renderInfo, count, engine.gpuCapability.level, (_b = engine.renderer) === null || _b === void 0 ? void 0 : _b.env),
        };
        this.preMultiAlpha = getPreMultiAlpha(blending);
        this.mtlSlotCount = count;
        var material = Material.create(engine, materialProps);
        var states = __assign$1({ side: side, blending: true, blendMode: blending, mask: mask, maskMode: maskMode, depthTest: true, depthMask: occlusion }, filterMesh.materialStates);
        material.blending = states.blending;
        material.stencilRef = states.mask !== undefined ? [states.mask, states.mask] : undefined;
        material.depthTest = states.depthTest;
        material.depthMask = states.depthMask;
        states.blending && setBlendMode(material, states.blendMode);
        material.blendFunction = states.blendFunction;
        setMaskMode(material, states.maskMode);
        setSideMode(material, states.side);
        var filterUniform = filterMesh.uniformValues;
        // TODO uniform的数据组织形式待优化，临时方案。
        if (filterUniform) {
            try {
                for (var _c = __values$1(Object.keys(filterUniform)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    var value = filterUniform[key];
                    if (value instanceof Texture) {
                        material.setTexture(key, value);
                    }
                    else if (typeof value === 'number') {
                        material.setFloat(key, value);
                    }
                    else if (value.length === 2) {
                        material.setVector2(key, Vector2.fromArray(value));
                    }
                    else if (value.length === 4) {
                        material.setVector4(key, Vector4$1.fromArray(value));
                    }
                    else {
                        material.setMatrix(key, Matrix4$1.fromArray(value));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var uMainData = [];
        var uTexParams = [];
        var uTexOffset = [];
        for (var i = 0; i < count; i++) {
            uMainData.push(Matrix4$1.fromIdentity());
            uTexParams.push(new Vector4$1());
            uTexOffset.push(new Vector4$1());
        }
        if (!material.hasUniform('uMainData')) {
            material.setMatrixArray('uMainData', uMainData);
        }
        if (!material.hasUniform('uTexParams')) {
            material.setVector4Array('uTexParams', uTexParams);
        }
        if (!material.hasUniform('uTexOffset')) {
            material.setVector4Array('uTexOffset', uTexOffset);
        }
        return material;
    };
    SpriteMesh.prototype.getItemGeometryData = function (item, aIndex) {
        var splits = item.splits, renderer = item.renderer, textureSheetAnimation = item.textureSheetAnimation, startSize = item.startSize;
        var sx = startSize.x, sy = startSize.y;
        if (renderer.shape) {
            var _a = renderer.shape, index_1 = _a.index, aPoint_1 = _a.aPoint;
            var point = new Float32Array(aPoint_1);
            for (var i = 0; i < point.length; i += 6) {
                point[i] *= sx;
                point[i + 1] *= sy;
            }
            return {
                index: index_1,
                aPoint: Array.from(point),
            };
        }
        var originData = [-.5, .5, -.5, -.5, .5, .5, .5, -.5];
        var aPoint = [];
        var index = [];
        var col = 2;
        var row = 2;
        if (splits.length === 1) {
            col = 1;
            row = 1;
        }
        for (var x = 0; x < col; x++) {
            for (var y = 0; y < row; y++) {
                var base = (y * 2 + x) * 4;
                // @ts-expect-error
                var split = textureSheetAnimation ? [0, 0, 1, 1, splits[0][4]] : splits[y * 2 + x];
                var texOffset = split[4] ? [0, 0, 1, 0, 0, 1, 1, 1] : [0, 1, 0, 0, 1, 1, 1, 0];
                var dw = ((x + x + 1) / col - 1) / 2;
                var dh = ((y + y + 1) / row - 1) / 2;
                var tox = split[0];
                var toy = split[1];
                var tsx = split[4] ? split[3] : split[2];
                var tsy = split[4] ? split[2] : split[3];
                var origin_1 = [
                    originData[0] / col + dw,
                    originData[1] / row + dh,
                    originData[2] / col + dw,
                    originData[3] / row + dh,
                    originData[4] / col + dw,
                    originData[5] / row + dh,
                    originData[6] / col + dw,
                    originData[7] / row + dh,
                ];
                aPoint.push((origin_1[0]) * sx, (origin_1[1]) * sy, texOffset[0] * tsx + tox, texOffset[1] * tsy + toy, aIndex, 0, (origin_1[2]) * sx, (origin_1[3]) * sy, texOffset[2] * tsx + tox, texOffset[3] * tsy + toy, aIndex, 0, (origin_1[4]) * sx, (origin_1[5]) * sy, texOffset[4] * tsx + tox, texOffset[5] * tsy + toy, aIndex, 0, (origin_1[6]) * sx, (origin_1[7]) * sy, texOffset[6] * tsx + tox, texOffset[7] * tsy + toy, aIndex, 0);
                if (this.lineMode) {
                    index.push(base, 1 + base, 1 + base, 3 + base, 3 + base, 2 + base, 2 + base, base);
                }
                else {
                    index.push(base, 1 + base, 2 + base, 2 + base, 1 + base, 3 + base);
                }
            }
        }
        return { index: index, aPoint: aPoint };
    };
    return SpriteMesh;
}());
function setSpriteMeshMaxItemCountByGPU(gpuCapability) {
    // 8 or 16
    exports.maxSpriteTextureCount = Math.min(gpuCapability.maxFragmentTextures, 16);
    if (gpuCapability.maxVertexUniforms >= 256) {
        return exports.maxSpriteMeshItemCount = 32;
    }
    else if (gpuCapability.maxVertexUniforms >= 128) {
        return exports.maxSpriteMeshItemCount = 16;
    }
    exports.maxSpriteTextureCount = 8;
}
function getImageItemRenderInfo(item) {
    var _a;
    var renderer = item.renderer;
    var filter = item.filter;
    var blending = renderer.blending, side = renderer.side, occlusion = renderer.occlusion, mask = renderer.mask, maskMode = renderer.maskMode, order = renderer.order;
    var blendingCache = +blending;
    var cachePrefix = item.cachePrefix || '-';
    var filterId = ((_a = filter === null || filter === void 0 ? void 0 : filter.mesh) === null || _a === void 0 ? void 0 : _a.shaderCacheId) || '$F$';
    return {
        side: side,
        occlusion: occlusion,
        blending: blending,
        mask: mask,
        maskMode: maskMode,
        cachePrefix: cachePrefix,
        filter: filter,
        cacheId: "".concat(cachePrefix, ".").concat(filterId, ".").concat(+side, "+").concat(+occlusion, "+").concat(blendingCache, "+").concat(order, "+").concat(maskMode, ".").concat(mask),
    };
}
function spriteMeshShaderFromFilter(level, filter, options) {
    var _a = options !== null && options !== void 0 ? options : {}, _b = _a.count, count = _b === void 0 ? 2 : _b, _c = _a.env, env = _c === void 0 ? '' : _c, ignoreBlend = _a.ignoreBlend, wireframe = _a.wireframe;
    var marcos = [
        ['MAX_ITEM_COUNT', count],
        ['PRE_MULTIPLY_ALPHA', false],
        ['ENV_EDITOR', env === PLAYER_OPTIONS_ENV_EDITOR],
        ['ADJUST_LAYER', !!filter],
        ['USE_BLEND', !ignoreBlend],
        ['MAX_FRAG_TEX', exports.maxSpriteTextureCount >= 16 ? 16 : 8],
    ];
    var fragment = wireframe ? itemFrameFrag : itemFrag.replace(/#pragma\s+FILTER_FRAG/, (filter === null || filter === void 0 ? void 0 : filter.fragment) || '');
    var vertex = itemVert.replace(/#pragma\s+FILTER_VERT/, (filter === null || filter === void 0 ? void 0 : filter.vertex) || 'vec4 filterMain(float t,vec4 pos){return effects_MatrixVP * pos;}');
    return {
        fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment, level),
        vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex, level),
        glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
        marcos: marcos,
        shared: true,
    };
}
function spriteMeshShaderIdFromRenderInfo(renderInfo, count) {
    return renderInfo.filter ? "".concat(renderInfo.filter.mesh.shaderCacheId, "_effects_filter") : "".concat(renderInfo.cachePrefix, "_effects_sprite_").concat(count);
}
function spriteMeshShaderFromRenderInfo(renderInfo, count, level, env) {
    var filter = renderInfo.filter, wireframe = renderInfo.wireframe;
    var shader = spriteMeshShaderFromFilter(level, filter === null || filter === void 0 ? void 0 : filter.mesh, {
        count: count,
        wireframe: wireframe,
        env: env,
    });
    shader.shared = true;
    if (!wireframe) {
        shader.cacheId = spriteMeshShaderIdFromRenderInfo(renderInfo, count);
    }
    return shader;
}
function generateFeatureTexture(engine, feather) {
    var tex;
    if (!feather) {
        tex = Texture.createWithData(engine);
    }
    else {
        var len = 128;
        var data = new Uint8Array(len);
        for (var i = 0, s = len - 1; i < len; i++) {
            var p = i / s;
            var val = feather.getValue(p);
            data[i] = Math.round(val * 255);
        }
        tex = Texture.createWithData(engine, { width: len, height: 1, data: data }, {
            name: 'feather',
            format: glContext.LUMINANCE,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
        });
    }
    return tex;
}
// TODO 只有单测用
function setMaxSpriteMeshItemCount(count) {
    exports.maxSpriteMeshItemCount = count;
}
function setSpriteMeshMaxFragmentTextures(count) {
    exports.maxSpriteTextureCount = count;
}

var itemSortProperty = 'listIndex';
var SpriteGroup = /** @class */ (function () {
    function SpriteGroup(composition) {
        this.composition = composition;
        this.meshSplits = [];
        this.items = [];
        this.meshes = []; // meshSplits对应的mesh数组 每次diff后更新
        this.time = 0;
        this.itemsToRemove = [];
        this.itemsToAdd = [];
        this.engine = composition.getEngine();
    }
    /**
     * 合成reset的时候执行 清空items相关数组
     */
    SpriteGroup.prototype.resetMeshSplits = function () {
        this.meshSplits.length = 0;
        this.meshes.length = 0;
        this.items.length = 0;
        this.itemsToAdd.length = 0;
        this.itemsToRemove.length = 0;
    };
    /**
     * 根据需要添加/移除的元素计算需要增加/移除/修改顺序的mesh并返回
     */
    SpriteGroup.prototype.diffMeshSplits = function () {
        var _a, _b, _c, _d, _e, _f;
        var splits = this.meshSplits;
        var itemsToRemove = this.itemsToRemove;
        var itemsToAdd = this.itemsToAdd;
        var splitsToRemove = [];
        var meshToAdd = [];
        var meshToRemove = [];
        var meshToModify = [];
        var items = this.items;
        var layer = { layerToAdd: [] };
        var combined = [];
        /**
         * 移除元素
         * 图层元素，从items和含有元素的meshSplit中移除元素并获取需要移除的MeshSplit
         * 滤镜元素，从items移除元素，判断前一个元素 / 后一个元素所在meshSplit能否合并
         */
        for (var i = 0; i < itemsToRemove.length; i++) {
            var item = itemsToRemove[i];
            if (isSprite(item)) {
                splitsToRemove.push.apply(splitsToRemove, __spreadArray$2([], __read$3(this.removeMeshSplitsItem(items, item, splits, itemsToRemove)), false));
                this.check();
            }
            else {
                var itemIndex = items.indexOf(item);
                if (itemIndex > -1) {
                    items.splice(itemIndex, 1);
                    combined.length = 0;
                    if (itemIndex > 0) {
                        combined = this.combineSplits(items, itemIndex - 1, splits);
                        splitsToRemove.push.apply(splitsToRemove, __spreadArray$2([], __read$3(combined), false));
                    }
                    if (!combined.length && itemIndex <= items.length - 1) {
                        combined = this.combineSplits(items, itemIndex, splits);
                        splitsToRemove.push.apply(splitsToRemove, __spreadArray$2([], __read$3(combined), false));
                    }
                    this.check();
                }
            }
        }
        var checkCombine = false;
        /**
         * 添加元素
         * 获取item增加后需要新增的meshSplit，根据renderInfo创建spriteMesh并增加到meshToAdd数组
         * 新增meshSplit都添加后(checkCombine) 检查meshSplit数组是否有相邻可以合并的meshSplit
         */
        for (var i = 0; i < itemsToAdd.length; i++) {
            var item = itemsToAdd[i];
            var neoSplits = this.addMeshSplitsItem(items, item, splits);
            for (var j = 0; j < neoSplits.length; j++) {
                var neoSplit = neoSplits[j];
                if (neoSplit.spriteMesh) {
                    throw new Error('no sprite mesh in neo split');
                }
                var sp = neoSplit.spriteMesh = new SpriteMesh(this.engine, neoSplit.renderInfo, this.composition);
                meshToAdd.push(sp.mesh);
                sp.setItems(neoSplit.items.map(function (c) { return c.content; }));
                sp.applyChange();
                if (sp.splitLayer) {
                    (_a = layer.layerToAdd) === null || _a === void 0 ? void 0 : _a.push(sp);
                }
                neoSplit.dirty = false;
                this.check();
                checkCombine = true;
            }
        }
        if (checkCombine) {
            var _loop_1 = function (i) {
                var currentSplit = splits[i];
                var nextSplit = splits[i + 1];
                if (nextSplit.cacheId === currentSplit.cacheId &&
                    !((_b = nextSplit.spriteMesh) === null || _b === void 0 ? void 0 : _b.splitLayer) &&
                    !((_c = currentSplit.spriteMesh) === null || _c === void 0 ? void 0 : _c.splitLayer) &&
                    currentSplit.items.length + nextSplit.items.length <= exports.maxSpriteMeshItemCount) {
                    var first = currentSplit.items[0];
                    var last = nextSplit.items[nextSplit.items.length - 1];
                    var neo_1 = this_1.getMeshSplits(items, items.indexOf(first), items.indexOf(last));
                    if (neo_1.length === 1) {
                        Object.keys(neo_1[0]).forEach(function (key) {
                            // @ts-expect-error
                            currentSplit[key] = neo_1[0][key];
                        });
                        (_d = currentSplit.spriteMesh) === null || _d === void 0 ? void 0 : _d.setItems(currentSplit.items.map(function (i) { return i.content; }));
                        (_e = currentSplit.spriteMesh) === null || _e === void 0 ? void 0 : _e.applyChange();
                        var mesh = (_f = nextSplit.spriteMesh) === null || _f === void 0 ? void 0 : _f.mesh;
                        if (currentSplit.spriteMesh && currentSplit.spriteMesh.mesh) {
                            currentSplit.spriteMesh.mesh.priority = nextSplit.indexEnd;
                        }
                        // @ts-expect-error
                        if (meshToAdd.includes(mesh)) {
                            removeItem(meshToAdd, mesh);
                        }
                        else {
                            addItem(meshToRemove, mesh);
                        }
                        splits.splice(i + 1, 1);
                        i--; //recheck
                    }
                }
                out_i_1 = i;
            };
            var this_1 = this, out_i_1;
            for (var i = 0; i < splits.length - 1; i++) {
                _loop_1(i);
                i = out_i_1;
            }
        }
        // FIXME 重复赋值?
        itemsToRemove.length = 0;
        /**
         * 根据每个meshSplit的indexStart和mesh的priority判断mesh是否需要修改
         * 需要则添加到meshToModify数组
         */
        for (var i = 0; i < splits.length; i++) {
            var split = splits[i];
            // @ts-expect-error
            var spriteMesh = split.spriteMesh;
            if (split.items.length === 0) {
                throw new Error('split not combined');
            }
            if (split.dirty) {
                var priority = split.indexStart;
                if (spriteMesh.mesh.priority !== priority) {
                    spriteMesh.mesh.priority = priority;
                    meshToModify.push(spriteMesh.mesh);
                }
                spriteMesh.setItems(split.items.map(function (item) { return item.content; }));
            }
            spriteMesh.applyChange();
            split.dirty = false;
        }
        /**
         * 有需要移除的meshSplit 则废弃对应的mesh 保留material
         * 添加到meshToRemove数组
         */
        if (splitsToRemove.length) {
            for (var i = 0; i < splitsToRemove.length; i++) {
                var split = splitsToRemove[i];
                var sp = split.spriteMesh;
                // @ts-expect-error
                var mesh = sp.mesh;
                mesh.dispose({ material: { textures: exports.DestroyOptions.keep } });
                meshToRemove.push(mesh);
            }
        }
        this.itemsToRemove.length = 0;
        this.itemsToAdd.length = 0;
        /**
         * 有mesh需要改动 返回
         */
        if (meshToAdd.length + meshToRemove.length + meshToModify.length) {
            var ms_1 = this.meshes;
            // @ts-expect-error
            this.meshSplits.forEach(function (split, i) { return ms_1[i] = split.spriteMesh.mesh; });
            ms_1.length = this.meshSplits.length;
            return {
                add: meshToAdd.length ? meshToAdd : undefined,
                remove: meshToRemove.length ? meshToRemove : undefined,
                modify: meshToModify.length ? meshToModify : undefined,
                // @ts-expect-error
                layer: layer.layerToAdd.length > 0 ? layer : undefined,
            };
        }
    };
    /**
     * 合成生命周期开始时执行
     * 如果 items 中有该 sprite/filter 类型的 vfxItem 则添加到 itemsToRemove 数组中
     * 如果没有该 vfxItem 添加到 itemsToAdd 数组
     * @param vfxItem
     */
    SpriteGroup.prototype.addItem = function (vfxItem) {
        if (!this.items.includes(vfxItem)) {
            addItem(this.itemsToAdd, vfxItem);
        }
        else {
            removeItem(this.itemsToRemove, vfxItem);
        }
    };
    /**
     * 合成dispose时执行
     * 如果items中有该vfxItem 则添加到itemsToRemove数组中(sprite在头 filter在尾)
     * 如果没有该vfxItem 添加到 itemsToAdd数组
     */
    SpriteGroup.prototype.removeItem = function (item) {
        if (this.items.includes(item)) {
            if (isSprite(item)) {
                this.itemsToRemove.unshift(item);
            }
            else {
                this.itemsToRemove.push(item);
            }
        }
        else {
            removeItem(this.itemsToAdd, item);
        }
    };
    /**
     * 找到指定 item 所在的 spriteMesh
     * @param item
     * @returns
     */
    SpriteGroup.prototype.getSpriteMesh = function (item) {
        var splits = this.meshSplits;
        for (var i = 0; i < splits.length; i++) {
            // FIXME: spriteMesh 的可选性
            var mesh = splits[i].spriteMesh;
            var itemIndex = mesh.items.indexOf(item);
            if (itemIndex > -1) {
                return mesh;
            }
        }
    };
    /**
     * 合成在每帧 tick 时元素更新后执行
     * 更新 mesh 的 geometry 和 material 中 item 对应位置上的数据
     */
    SpriteGroup.prototype.onUpdate = function (dt) {
        var splits = this.meshSplits;
        for (var i = 0; i < splits.length; i++) {
            // FIXME: spriteMesh 的可选性
            var mesh = splits[i].spriteMesh;
            //mesh.time = time;
            var items = mesh.items;
            for (var j = 0; j < items.length; j++) {
                var item = items[j];
                if (!item.ended) {
                    mesh.updateItem(item);
                }
            }
            mesh.applyChange();
        }
    };
    SpriteGroup.prototype.dispose = function () {
        this.meshSplits.forEach(function (mesh) {
            var _a;
            (_a = mesh.spriteMesh) === null || _a === void 0 ? void 0 : _a.mesh.dispose();
        });
    };
    SpriteGroup.prototype.check = function () {
    };
    /**
     * 添加元素到合适的 meshSplit 上
     * 返回新添加的 meshSplit 数组（返回 meshSplit 没有真的创建 spriteMesh）
     * @internal
     */
    SpriteGroup.prototype.addMeshSplitsItem = function (items, item, splits) {
        var itemIndex = items.indexOf(item);
        if (itemIndex !== -1) {
            throw Error('item has been added');
        }
        var firstSplit = splits[0];
        if (!firstSplit) {
            addItemWithOrder(items, item, itemSortProperty);
            if (isSprite(item)) {
                var content = item.createContent();
                var split = {
                    indexStart: item.listIndex,
                    indexEnd: item.listIndex,
                    items: [item],
                    renderInfo: content.renderInfo,
                    cacheId: content.renderInfo.cacheId,
                    textures: [item.content.renderer.texture],
                };
                splits.unshift(split);
                return [split];
            }
            return [];
        }
        var _loop_2 = function (i) {
            var split = splits[i];
            var listIndex = item.listIndex;
            if (isSprite(item)) {
                // @ts-expect-error
                if (listIndex <= split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    var itemIndex_1 = items.indexOf(item);
                    var indexStart = Math.min(itemIndex_1, items.indexOf(split.items[0]));
                    var indexEnd = Math.max(itemIndex_1, items.indexOf(split.items[split.items.length - 1]));
                    var neoSplits_1 = this_2.getMeshSplits(items, indexStart, indexEnd);
                    var neoSplitIndex_1 = neoSplits_1.findIndex(function (split) { return split.items.includes(item); });
                    if (neoSplits_1.length === 2) {
                        splits.splice(i + neoSplitIndex_1, 0, neoSplits_1[neoSplitIndex_1]);
                        //1 or 0
                        Object.keys(neoSplits_1[1 - neoSplitIndex_1]).forEach(function (key) {
                            // @ts-expect-error
                            split[key] = neoSplits_1[1 - neoSplitIndex_1][key];
                        });
                        return { value: [neoSplits_1[neoSplitIndex_1]] };
                    }
                    else if (neoSplits_1.length === 3) {
                        Object.keys(neoSplits_1[0]).forEach(function (key) {
                            // @ts-expect-error
                            split[key] = neoSplits_1[0][key];
                        });
                        splits.splice(i + 1, 0, neoSplits_1[1], neoSplits_1[2]);
                        if (neoSplitIndex_1 !== 1) {
                            throw Error('neo split not in middle');
                        }
                        return { value: [neoSplits_1[1], neoSplits_1[2]] };
                    }
                    else if (neoSplits_1.length !== 1) {
                        throw Error('invalid splits 1');
                    }
                    //todo add case
                    Object.keys(neoSplits_1[0]).forEach(function (key) {
                        // @ts-expect-error
                        split[key] = neoSplits_1[0][key];
                    });
                    return { value: [] };
                }
            }
            else {
                if (listIndex < split.indexStart || listIndex === split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    return { value: [] };
                    // @ts-expect-error
                }
                else if (listIndex < split.indexEnd) {
                    addItemWithOrder(items, item, itemSortProperty);
                    var lastItem = split.items[split.items.length - 1];
                    var endIndex = items.indexOf(lastItem);
                    var neoSplits_2 = this_2.getMeshSplits(items, items.indexOf(split.items[0]), endIndex);
                    Object.keys(neoSplits_2[0]).forEach(function (key) {
                        // @ts-expect-error
                        split[key] = neoSplits_2[0][key];
                    });
                    if (neoSplits_2.length === 2) {
                        splits.splice(i + 1, 0, neoSplits_2[1]);
                        return { value: [neoSplits_2[1]] };
                    }
                    else if (neoSplits_2.length !== 1) {
                        throw Error('invalid splits 2');
                    }
                }
            }
        };
        var this_2 = this;
        /**
         * 插入 item 到合适的 meshSplit 上
         * 对图层元素：
         *   1. 存在 item.listIndex < split.indexEnd 的 meshSplit，判断加入 item 后是否需要添加 meshSplit，把新增的 meshSplit（1或2个）插入到到 meshSplits 中, 并更新原来 meshSplit 上的数据
         *   2. 添加 item 到 items 数组
         *   3. 再执行一次 item 添加到最后一张 meshSplit 的合并算法，判断是否新增 meshSplit 并更新对应数据
         * 对滤镜元素：
         *   1. 存在 item.listIndex === split.indexEnd 的 meshSplit，执行 item 添加到 items 数组
         *   2. 否则若存在 item.listIndex < split.indexEnd 的 meshSplit，判断加入 item 后是否需要添加 meshSplit，把新增的 meshSplit（1个）插入到到 meshSplits 中, 并更新原来 meshSplit 上的数据
         *
         */
        for (var i = 0; i < splits.length; i++) {
            var state_1 = _loop_2(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        addItemWithOrder(items, item, itemSortProperty);
        if (isSprite(item)) {
            var last_1 = splits[splits.length - 1];
            var neoSplits_3 = this.getMeshSplits(items, items.indexOf(last_1.items[0]), items.indexOf(item));
            Object.keys(neoSplits_3[0]).forEach(function (key) {
                // @ts-expect-error
                last_1[key] = neoSplits_3[0][key];
            });
            if (neoSplits_3.length === 2) {
                splits.push(neoSplits_3[1]);
                return [neoSplits_3[1]];
            }
            else if (neoSplits_3.length !== 1) {
                throw Error('invalid splits 3');
            }
        }
        return [];
    };
    /**
     * 从包含指定item的meshSplit、this.items中移除指定item
     * 并判断指定meshSplit能否与this.meshSplits中的其它meshSplit合并
     * 返回不需要的meshSplit(没有items/内容合并到其它meshSplit)
     */
    SpriteGroup.prototype.removeMeshSplitsItem = function (items, item, splits, itemsToRemove) {
        var _a, _b;
        var targetSplit = null;
        var targetSplitIndex = -1;
        var ret = [];
        /**
         * 遍历this.meshSplits，找到元素的listIndex在split的indexStart和indexEnd范围内的第一个meshSplit
         */
        for (var i = 0; i < splits.length; i++) {
            var split = splits[i];
            // @ts-expect-error
            if (split.indexStart <= item.listIndex && split.indexEnd >= item.listIndex) {
                targetSplit = split;
                targetSplitIndex = i;
                break;
            }
        }
        if (targetSplit) {
            var index = targetSplit.items.indexOf(item);
            if (index < 0) {
                if (itemsToRemove === null || itemsToRemove === void 0 ? void 0 : itemsToRemove.includes(item)) {
                    //ignore removed
                    return [];
                }
                throw Error('item not found');
            }
            targetSplit.items.splice(index, 1);
            targetSplit.dirty = true;
            removeItem(items, item);
            /**
             * 如果找到的meshSplit中items为空 说明不需要这个meshSplit了
             * 把它从this.meshSplits中移除，并添加到返回的结果数组ret中
             * 如果meshSplit中还包含item，就把indexStart和indexEnd做对应修改
             */
            if (targetSplit.items.length === 0) {
                removeItem(splits, targetSplit);
                ret.push(targetSplit);
                targetSplitIndex = targetSplitIndex - 1;
                targetSplit = splits[targetSplitIndex];
                // this.meshSplits为空 不需要执行合并算法 直接返回
                if (!splits.length || targetSplitIndex < 0) {
                    return ret;
                }
            }
            else {
                targetSplit.indexEnd = targetSplit.items[targetSplit.items.length - 1].listIndex;
                targetSplit.indexStart = targetSplit.items[0].listIndex;
            }
            /**
             * 根据targetSplit(含有目标元素的meshSplit/ 它的前一个)在meshSplits数组中的位置，执行合并算法：
             * 如果是第一个或倒数第二个，与它后面一个判断能否执行合并
             * 如果最后一个，则判断能否和前一个合并
             * 不是上述位置,则和前后的meshSplit都需要判断能否合并
             * 如果两个meshSplit允许共用mesh 则合并
             */
            if (targetSplitIndex === 0 || targetSplitIndex === splits.length - 2) {
                // this.meshSplits中的最前两个或者最后两个meshSplit
                var p0 = splits[targetSplitIndex];
                var p1 = splits[targetSplitIndex + 1];
                if (p0 && p1) {
                    var i0 = p0.items[0];
                    var i1 = p1.items[p1.items.length - 1];
                    var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                    // 两个meshSplit可以合并成一个 把后者并入前一个meshSplit 共用前者的spriteMesh
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                        (_a = meshes[0].spriteMesh) === null || _a === void 0 ? void 0 : _a.invalidMaterial();
                        splits[targetSplitIndex] = meshes[0];
                        ret.push(splits.splice(targetSplitIndex + 1, 1)[0]);
                    }
                }
            }
            else if (targetSplitIndex === splits.length - 1) {
                // 和前一个判断能否合并
                if (targetSplit.items.length === 0) {
                    ret.push(splits.splice(targetSplitIndex, 1)[0]);
                }
                else {
                    var p0 = splits[targetSplitIndex - 1];
                    var p1 = splits[targetSplitIndex];
                    var i0 = p0.items[0];
                    var i1 = p1.items[p1.items.length - 1];
                    var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex - 1].spriteMesh;
                        (_b = meshes[0].spriteMesh) === null || _b === void 0 ? void 0 : _b.invalidMaterial();
                        splits[targetSplitIndex - 1] = meshes[0];
                        ret.push(splits.splice(targetSplitIndex, 1)[0]);
                    }
                }
            }
            else {
                // 和前后都需要判断能否合并
                var p0 = splits[targetSplitIndex - 1];
                var p1 = splits[targetSplitIndex + 1];
                var i0 = p0.items[0];
                var i1 = p1.items[p1.items.length - 1];
                var meshes = this.getMeshSplits(items, items.indexOf(i0), items.indexOf(i1));
                if (meshes.length === 2) {
                    meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                    meshes[1].spriteMesh = splits[targetSplitIndex + 1].spriteMesh;
                    splits[targetSplitIndex] = meshes[0];
                    splits[targetSplitIndex + 1] = meshes[1];
                    ret.push(splits.splice(targetSplitIndex - 1, 1)[0]);
                }
            }
        }
        return ret;
    };
    /**
     * 合并Mesh
     * 找到item所在的meshSplit 判断能否和前一张/后一张合并
     * 返回不需要的meshSplit(内容合并到其它meshSplit)
     */
    SpriteGroup.prototype.combineSplits = function (items, itemIndex, splits) {
        var item = items[itemIndex];
        var ret = [];
        // item.composition 不存在表示元素已经dispose
        if (isSprite(item) && item.composition) {
            // FIXME: 可选性
            var targetSplitIndex = void 0;
            for (var i = 0; i < splits.length; i++) {
                var split = splits[i];
                if (split.items.includes(item)) {
                    targetSplitIndex = i;
                    break;
                }
            }
            var p0 = void 0;
            var p1 = void 0;
            if (targetSplitIndex === 0) {
                p0 = splits[targetSplitIndex];
                p1 = splits[targetSplitIndex + 1];
            }
            else {
                p0 = splits[targetSplitIndex - 1];
                p1 = splits[targetSplitIndex];
            }
            if (p0 && p1) {
                var startIndex = items.indexOf(p0.items[0]);
                var endIndex = items.indexOf(p1.items[p1.items.length - 1]);
                if (Number.isInteger(startIndex) && Number.isInteger(endIndex)) {
                    var meshes = this.getMeshSplits(items, startIndex, endIndex);
                    if (meshes.length === 1) {
                        meshes[0].spriteMesh = splits[targetSplitIndex].spriteMesh;
                        if (targetSplitIndex === 0) {
                            splits[0] = meshes[0];
                            ret.push(splits.splice(1, 1)[0]);
                        }
                        else {
                            ret.push(splits.splice(targetSplitIndex - 1, 1)[0]);
                            splits[targetSplitIndex - 1] = meshes[0];
                        }
                    }
                }
            }
        }
        return ret;
    };
    /**
     *  判断items中[startIndex, endIndex]范围的元素需要多少个meshSplit
     *  item的filter、材质的显示面、蒙板、混合模式、顺序、深度遮挡等信息一致且在mesh容纳的范围内
     *  则放置到同一个meshSplit上，上述信息记录在cacheId中
     */
    SpriteGroup.prototype.getMeshSplits = function (items, startIndex, endIndex, init) {
        if (startIndex === void 0) { startIndex = 0; }
        if (endIndex === void 0) { endIndex = items.length - 1; }
        var current = null;
        var ret = [];
        for (var i = startIndex; i <= endIndex; i++) {
            var item = items[i];
            // 不可见的元素跳过 不参与合并
            if (!init && (!item.started || item.lifetime < 0)) {
                continue;
            }
            if (!isSprite(item)) {
                if (init && (!item.contentVisible)) {
                    continue;
                }
                if (current) {
                    ret.push(current);
                    current = null;
                }
            }
            else {
                var cacheId = item.createContent().renderInfo.cacheId;
                var texture = item.content.renderer.texture;
                var replaceCurrent = true;
                if (current) {
                    var texInc = current.textures.includes(texture) ? 0 : 1;
                    if (current.cacheId === cacheId &&
                        VFXItem.isSprite(item) &&
                        current.items.length < exports.maxSpriteMeshItemCount &&
                        (texInc + current.textures.length) <= exports.maxSpriteTextureCount) {
                        addItemWithOrder(current.items, item, itemSortProperty);
                        addItem(current.textures, texture);
                        replaceCurrent = false;
                    }
                    else {
                        ret.push(current);
                    }
                }
                if (replaceCurrent) {
                    current = {
                        indexStart: item.listIndex,
                        cacheId: cacheId,
                        renderInfo: item.content.renderInfo,
                        items: [item],
                        textures: [texture],
                    };
                }
            }
        }
        if (current) {
            ret.push(current);
        }
        ret.forEach(function (split) {
            split.indexEnd = split.items[split.items.length - 1].listIndex;
            split.dirty = true;
        });
        return ret;
    };
    return SpriteGroup;
}());
function isSprite(item) {
    return VFXItem.isSprite(item) || VFXItem.isFilterSprite(item);
}

var defRenderInfo = {
    blending: 0,
    cacheId: '-',
    mask: 0,
    maskMode: 0,
    occlusion: false,
    side: 0,
    cachePrefix: '-',
};
var SpriteLoader = /** @class */ (function (_super) {
    __extends(SpriteLoader, _super);
    function SpriteLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'sprite';
        return _this;
    }
    SpriteLoader.precompile = function (compositions, render, options) {
        var _a;
        var shaderLibrary = render.getShaderLibrary();
        var _b = render.engine.gpuCapability, level = _b.level, detail = _b.detail;
        var env = (options !== null && options !== void 0 ? options : {}).env;
        if (!shaderLibrary.shaderResults[spriteMeshShaderIdFromRenderInfo(defRenderInfo, 2)]) {
            shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, 2, level, env));
            shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, exports.maxSpriteMeshItemCount, level, env));
            var hasFilter_1 = false;
            (_a = compositions[0]) === null || _a === void 0 ? void 0 : _a.items.forEach(function (item) {
                if (exports.Item.isFilter(item) && item.content.filter) {
                    hasFilter_1 = true;
                    var shaderDefs = createFilterShaders(item.content.filter);
                    shaderDefs.forEach(function (def) {
                        if (!def.isParticle) {
                            var shader = spriteMeshShaderFromFilter(level, def, def);
                            if (def.shaderCacheId) {
                                shader.cacheId = "".concat(def.shaderCacheId, "_effects_filter");
                            }
                            shaderLibrary.addShader(shader);
                        }
                    });
                }
            });
            if (hasFilter_1) {
                shaderLibrary.addShader(createCopyShader(level, false));
            }
            if (detail.writableFragDepth) {
                shaderLibrary.addShader(createCopyShader(level, true));
            }
        }
        return Promise.resolve();
    };
    SpriteLoader.prototype.onCompositionDestroyed = function (composition) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.dispose();
        delete composition.loaderData.spriteGroup;
    };
    SpriteLoader.prototype.onCompositionReset = function (composition, pipeline) {
        if (!composition.loaderData.spriteGroup) {
            var spriteGroup = new SpriteGroup(composition);
            composition.loaderData.spriteGroup = spriteGroup;
            spriteGroup.resetMeshSplits();
        }
    };
    SpriteLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        var spriteGroup = composition.loaderData.spriteGroup;
        if (item.type !== ItemType$1.composition) {
            spriteGroup.addItem(item);
        }
    };
    SpriteLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.removeItem(item);
    };
    SpriteLoader.prototype.onCompositionUpdate = function (composition, dt) {
        var spriteGroup = composition.loaderData.spriteGroup;
        spriteGroup.onUpdate(dt);
    };
    SpriteLoader.prototype.prepareRenderFrame = function (composition, renderFrame) {
        var _a, _b, _c;
        var spriteGroup = composition.loaderData.spriteGroup;
        var ret = spriteGroup.diffMeshSplits();
        if (ret) {
            (_a = ret.remove) === null || _a === void 0 ? void 0 : _a.forEach(function (mesh) { return renderFrame.removeMeshFromDefaultRenderPass(mesh); });
            (_b = ret.add) === null || _b === void 0 ? void 0 : _b.forEach(function (mesh) { return renderFrame.addMeshToDefaultRenderPass(mesh); });
            (_c = ret.modify) === null || _c === void 0 ? void 0 : _c.forEach(function (mesh) {
                // reset priority
                renderFrame.removeMeshFromDefaultRenderPass(mesh);
                renderFrame.addMeshToDefaultRenderPass(mesh);
            });
            return !!(this.layerInfo = ret.layer);
        }
        return false;
    };
    SpriteLoader.prototype.postProcessFrame = function (composition, pipeline) {
        var _a, _b;
        (_b = (_a = this.layerInfo) === null || _a === void 0 ? void 0 : _a.layerToAdd) === null || _b === void 0 ? void 0 : _b.forEach(function (layer) {
            var filterDefine = layer.items[0].filter;
            if (filterDefine !== undefined) {
                var options = filterDefine.passSplitOptions;
                var renderPass = pipeline.splitDefaultRenderPassByMesh(layer.mesh, options);
                // layer.mesh.material.setUniformSemantic('uSamplerPre', SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0);
                if (filterDefine.renderPassDelegate) {
                    renderPass.delegate = filterDefine.renderPassDelegate;
                }
                if (filterDefine.onRenderPassCreated) {
                    filterDefine.onRenderPassCreated(renderPass, pipeline);
                }
            }
        });
        this.layerInfo = undefined;
    };
    return SpriteLoader;
}(AbstractPlugin));

var tempRot$1 = new Euler();
var tempSize$1 = new Vector3(1, 1, 1);
new Vector3();
var CalculateItem = /** @class */ (function () {
    function CalculateItem(props, vfxItem) {
        var _a;
        this.vfxItem = vfxItem;
        this.active = false;
        this.transform = vfxItem.transform;
        var scale = this.transform.scale;
        this.basicTransform = {
            position: this.transform.position.clone(),
            rotation: this.transform.getRotation(),
            scale: new Vector3(scale.x, scale.y, scale.x),
        };
        var rotationOverLifetime = props.rotationOverLifetime, sizeOverLifetime = props.sizeOverLifetime, _b = props.positionOverLifetime, positionOverLifetime = _b === void 0 ? {} : _b;
        if (positionOverLifetime) {
            if (positionOverLifetime.path) {
                this.basicTransform.path = createValueGetter(positionOverLifetime.path);
            }
            var linearVelEnable = positionOverLifetime.linearX || positionOverLifetime.linearY || positionOverLifetime.linearZ;
            if (linearVelEnable) {
                this.linearVelOverLifetime = {
                    x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX),
                    y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY),
                    z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ),
                    asMovement: positionOverLifetime.asMovement,
                    enabled: !!linearVelEnable,
                };
            }
            var orbitalVelEnable = positionOverLifetime.orbitalX || positionOverLifetime.orbitalY || positionOverLifetime.orbitalZ;
            if (orbitalVelEnable) {
                this.orbitalVelOverLifetime = {
                    x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
                    y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
                    z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
                    center: ensureVec3(positionOverLifetime.orbCenter),
                    asRotation: positionOverLifetime.asRotation,
                    enabled: !!orbitalVelEnable,
                };
            }
            this.speedOverLifetime = positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime);
        }
        if (sizeOverLifetime) {
            if (sizeOverLifetime.separateAxes) {
                this.sizeSeparateAxes = true;
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.x || 1);
                this.sizeYOverLifetime = createValueGetter(sizeOverLifetime.y || 1);
                this.sizeZOverLifetime = createValueGetter(sizeOverLifetime.z || 1);
            }
            else {
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.size || 1);
            }
        }
        if (rotationOverLifetime) {
            this.rotationOverLifetime = {
                asRotation: rotationOverLifetime.asRotation,
                separateAxes: rotationOverLifetime.separateAxes,
                z: createValueGetter(rotationOverLifetime.z || 0),
            };
            if (rotationOverLifetime.separateAxes) {
                var rotLt = this.rotationOverLifetime;
                rotLt.x = createValueGetter(rotationOverLifetime.x || 0);
                rotLt.y = createValueGetter(rotationOverLifetime.y || 0);
            }
        }
        /* 要过包含父节点颜色/透明度变化的动画的帧对比 打开这段兼容代码 */
        // const colorOverLifetime = props.colorOverLifetime;
        //
        // if (colorOverLifetime) {
        //   this.opacityOverLifetime = createValueGetter(colorOverLifetime.opacity ?? 1);
        //   if (colorOverLifetime.color && colorOverLifetime.color[0] === spec.ValueType.GRADIENT_COLOR) {
        //     this.colorOverLifetime = colorStopsFromGradient(colorOverLifetime.color[1]);
        //   }
        // }
        /**************************8*/
        this.options = {
            reusable: !!vfxItem.reusable,
            delay: vfxItem.delay || 0,
            startSpeed: positionOverLifetime.startSpeed || 0,
            startSize: scale && scale.x || 1,
            sizeAspect: scale && (scale.x / (scale.y || 1)) || 1,
            duration: vfxItem.duration || 0,
            looping: vfxItem.endBehavior && vfxItem.endBehavior === ItemEndBehavior$1.loop,
            endBehavior: vfxItem.endBehavior || END_BEHAVIOR_DESTROY$1,
            gravity: Vector3.fromArray(positionOverLifetime.gravity || []),
            gravityModifier: createValueGetter((_a = positionOverLifetime.gravityOverLifetime) !== null && _a !== void 0 ? _a : 0),
            direction: positionOverLifetime.direction ? Vector3.fromArray(positionOverLifetime.direction).normalize() : new Vector3(),
            /* 要过包含父节点颜色/透明度变化的动画的帧对比 打开这段兼容代码 */
            // startColor: props.options.startColor || [1, 1, 1, 1],
            /*********************/
        };
        this.id = vfxItem.id;
        this.time = 0;
        this.name = vfxItem.name;
        this.visible = vfxItem.getVisible();
    }
    Object.defineProperty(CalculateItem.prototype, "ended", {
        get: function () {
            return this.time > this.options.duration && !this.options.looping && !this.options.reusable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CalculateItem.prototype, "startSize", {
        get: function () {
            return this.basicTransform.scale;
        },
        set: function (scale) {
            this.basicTransform.scale = scale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CalculateItem.prototype, "velocity", {
        get: function () {
            if (!this._velocity) {
                this._velocity = this.options.direction.clone();
                this._velocity.multiply(this.options.startSpeed);
            }
            return this._velocity;
        },
        enumerable: false,
        configurable: true
    });
    CalculateItem.prototype.getWillTranslate = function () {
        return !!((this.linearVelOverLifetime && this.linearVelOverLifetime.enabled) ||
            (this.orbitalVelOverLifetime && this.orbitalVelOverLifetime.enabled) ||
            (this.options.gravityModifier && !this.options.gravity.isZero()) ||
            (this.options.startSpeed && !this.options.direction.isZero()));
    };
    CalculateItem.prototype.updateTime = function (globalTime) {
        var time = globalTime - this.options.delay;
        var duration = this.options.duration;
        if (time >= duration && this.options.looping) {
            var start = time - duration;
            while (start > duration) {
                start -= duration;
            }
            this.time = start;
        }
        else {
            var freeze = this.options.endBehavior === END_BEHAVIOR_FREEZE$1;
            this.time = freeze ? Math.min(duration, time) : time;
        }
    };
    CalculateItem.prototype.getRenderData = function (_time, init) {
        var options = this.options;
        var sizeInc = tempSize$1.setFromNumber(1);
        var rotInc = tempRot$1.set(0, 0, 0);
        var sizeChanged = false, rotChanged = false;
        var time = _time < 0 ? _time : Math.max(_time, 0.);
        var duration = options.duration;
        var life = time / duration;
        var ret = {
            life: life,
            transform: this.transform,
        };
        life = life < 0 ? 0 : (life > 1 ? 1 : life);
        if (this.sizeXOverLifetime) {
            sizeInc.x = this.sizeXOverLifetime.getValue(life);
            if (this.sizeSeparateAxes) {
                sizeInc.y = this.sizeYOverLifetime.getValue(life);
                sizeInc.z = this.sizeZOverLifetime.getValue(life);
            }
            else {
                sizeInc.z = sizeInc.y = sizeInc.x;
            }
            sizeChanged = true;
        }
        this.calculateScaling(sizeChanged, sizeInc, init);
        var rotationOverLifetime = this.rotationOverLifetime;
        if (rotationOverLifetime) {
            var func = function (v) { return rotationOverLifetime.asRotation ? v.getValue(life) : v.getIntegrateValue(0, life, duration); };
            var incZ = func(rotationOverLifetime.z);
            var separateAxes = rotationOverLifetime.separateAxes;
            rotInc.x = separateAxes ? func(rotationOverLifetime.x) : 0;
            rotInc.y = separateAxes ? func(rotationOverLifetime.y) : 0;
            rotInc.z = incZ;
            rotChanged = true;
        }
        if (rotChanged || init) {
            var rot = tempRot$1.addEulers(this.basicTransform.rotation, rotInc);
            ret.transform.setRotation(rot.x, rot.y, rot.z);
        }
        var pos;
        if (this.getWillTranslate() || init) {
            pos = new Vector3();
            calculateTranslation(pos, this, this.options.gravity, time, duration, this.basicTransform.position, this.velocity);
        }
        if (this.basicTransform.path) {
            if (!pos) {
                pos = this.basicTransform.position.clone();
            }
            pos.add(this.basicTransform.path.getValue(life));
        }
        if (pos) {
            this.transform.setPosition(pos.x, pos.y, pos.z);
        }
        /* 要过包含父节点颜色/透明度变化的动画的帧对比 打开这段兼容代码 */
        // let colorInc = vecFill(tempColor, 1);
        // let colorChanged;
        // const opacityOverLifetime = this.opacityOverLifetime;
        // const colorOverLifetime = this.colorOverLifetime;
        //
        // if (colorOverLifetime) {
        //   colorInc = getColorFromGradientStops(colorOverLifetime, life, true) as vec4;
        //   colorChanged = true;
        // }
        // if (opacityOverLifetime) {
        //   colorInc[3] *= opacityOverLifetime.getValue(life);
        //   colorChanged = true;
        // }
        //
        // if (colorChanged || init) {
        //   // @ts-expect-error
        //   ret.color = vecMulCombine<vec4>(this.startColor, colorInc, this.options.startColor);
        // }
        /*************************/
        ret.active = this.active;
        return ret;
    };
    CalculateItem.prototype.calculateScaling = function (sizeChanged, sizeInc, init) {
        this.transform.setScale(sizeInc.x * this.startSize.x, sizeInc.y * this.startSize.y, sizeInc.z * this.startSize.z);
    };
    return CalculateItem;
}());

var singleSplits = [[0, 0, 1, 1, undefined]];
var tempColor = [1, 1, 1, 1];
var SpriteItem = /** @class */ (function (_super) {
    __extends(SpriteItem, _super);
    function SpriteItem(props, opts, vfxItem) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var _this = _super.call(this, props, vfxItem) || this;
        _this.startColor = [1, 1, 1, 1];
        var interaction = props.interaction, renderer = props.renderer, options = props.options, _j = props.listIndex, listIndex = _j === void 0 ? 0 : _j;
        var emptyTexture = opts.emptyTexture;
        var transform = vfxItem.transform;
        var scale = transform.scale;
        _this.options = __assign$1(__assign$1({}, _this.options), { startColor: options.startColor || [1, 1, 1, 1] });
        _this.interaction = interaction;
        _this.renderer = {
            renderMode: (_a = renderer.renderMode) !== null && _a !== void 0 ? _a : RenderMode$1.BILLBOARD,
            blending: (_b = renderer.blending) !== null && _b !== void 0 ? _b : BlendingMode$1.ALPHA,
            texture: _this.initTexture(renderer.texture, emptyTexture),
            occlusion: !!(renderer.occlusion),
            transparentOcclusion: !!(renderer.transparentOcclusion) || (renderer.maskMode === MaskMode$1.MASK),
            side: (_c = renderer.side) !== null && _c !== void 0 ? _c : SideMode$1.DOUBLE,
            shape: renderer.shape,
            mask: (_d = renderer.mask) !== null && _d !== void 0 ? _d : 0,
            maskMode: (_e = renderer.maskMode) !== null && _e !== void 0 ? _e : MaskMode$1.NONE,
            order: listIndex,
        };
        var realAnchor = convertAnchor(renderer.anchor, renderer.particleOrigin);
        // 兼容旧JSON（anchor和particleOrigin可能同时存在）
        if (!renderer.anchor && renderer.particleOrigin !== undefined) {
            _this.basicTransform.position.add([-realAnchor[0] * scale.x, -realAnchor[1] * scale.y, 0]);
        }
        _this.transform.setAnchor(realAnchor[0] * scale.x, realAnchor[1] * scale.y, 0);
        var colorOverLifetime = props.colorOverLifetime;
        if (colorOverLifetime) {
            _this.opacityOverLifetime = createValueGetter((_f = colorOverLifetime.opacity) !== null && _f !== void 0 ? _f : 1);
            if (colorOverLifetime.color && colorOverLifetime.color[0] === ValueType$1.GRADIENT_COLOR) {
                _this.colorOverLifetime = colorStopsFromGradient(colorOverLifetime.color[1]);
            }
        }
        if (((_g = props.filter) === null || _g === void 0 ? void 0 : _g.feather) && ((_h = props.filter) === null || _h === void 0 ? void 0 : _h.feather) !== 1) {
            _this.feather = createValueGetter(props.filter.feather);
        }
        _this.emptyTexture = emptyTexture;
        _this.splits = props.splits || singleSplits;
        _this.listIndex = vfxItem.listIndex || 0;
        _this.textureSheetAnimation = props.textureSheetAnimation;
        _this.cachePrefix = '-';
        _this.parentId = vfxItem.parentId;
        _this.reusable = vfxItem.reusable;
        _this._renderInfo = getImageItemRenderInfo(_this);
        return _this;
    }
    Object.defineProperty(SpriteItem.prototype, "filter", {
        get: function () {
            return this._filter;
        },
        set: function (f) {
            this._filter = f;
            this._renderInfo.filter = f;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteItem.prototype, "renderInfo", {
        get: function () {
            return this._renderInfo;
        },
        enumerable: false,
        configurable: true
    });
    SpriteItem.prototype.initTexture = function (texture, emptyTexture) {
        var tex = texture !== null && texture !== void 0 ? texture : emptyTexture;
        return tex;
    };
    SpriteItem.prototype.getTextures = function () {
        var ret = [];
        var tex = this.renderer.texture;
        if (tex) {
            ret.push(tex);
        }
        return ret;
    };
    /**
     * @internal
     */
    SpriteItem.prototype.setColor = function (r, g, b, a) {
        this.customColor = [r, g, b, a];
    };
    SpriteItem.prototype.setOpacity = function (opacity) {
        this.customOpacity = opacity;
    };
    /**
     * @internal
     */
    SpriteItem.prototype.getCustomOpacity = function () {
        return this.customOpacity;
    };
    SpriteItem.prototype.getRenderData = function (_time, init) {
        var ret = _super.prototype.getRenderData.call(this, _time, init);
        var colorInc = vecFill(tempColor, 1);
        var colorChanged;
        var time = _time < 0 ? _time : Math.max(_time, 0.);
        var duration = this.options.duration;
        var life = time / duration < 0 ? 0 : (time / duration > 1 ? 1 : time / duration);
        if (this.customColor) {
            ret.color = this.customColor;
        }
        else {
            var opacityOverLifetime = this.opacityOverLifetime;
            var colorOverLifetime = this.colorOverLifetime;
            if (colorOverLifetime) {
                colorInc = getColorFromGradientStops(colorOverLifetime, life, true);
                colorChanged = true;
            }
            if (opacityOverLifetime) {
                colorInc[3] *= opacityOverLifetime.getValue(life);
                colorChanged = true;
            }
            if (colorChanged || init) {
                ret.color = vecMulCombine(this.startColor, colorInc, this.options.startColor);
            }
        }
        var ta = this.textureSheetAnimation;
        if (ta) {
            var total = ta.total || (ta.row * ta.col);
            var texRectX = 0;
            var texRectY = 0;
            var texRectW = 1;
            var texRectH = 1;
            var flip = void 0;
            if (this.splits) {
                var sp = this.splits[0];
                flip = sp[4];
                texRectX = sp[0];
                texRectY = sp[1];
                if (flip) {
                    texRectW = sp[3];
                    texRectH = sp[2];
                }
                else {
                    texRectW = sp[2];
                    texRectH = sp[3];
                }
            }
            var dx = void 0, dy = void 0;
            if (flip) {
                dx = 1 / ta.row * texRectW;
                dy = 1 / ta.col * texRectH;
            }
            else {
                dx = 1 / ta.col * texRectW;
                dy = 1 / ta.row * texRectH;
            }
            var texOffset = void 0;
            if (ta.animate) {
                var frameIndex = Math.round(life * (total - 1));
                var yIndex = Math.floor(frameIndex / ta.col);
                var xIndex = frameIndex - yIndex * ta.col;
                texOffset = flip ? [dx * yIndex, dy * (ta.col - xIndex)] : [dx * xIndex, dy * (1 + yIndex)];
            }
            else {
                texOffset = [0, dy];
            }
            ret.texOffset = [
                texRectX + texOffset[0],
                texRectH + texRectY - texOffset[1],
                dx, dy,
            ];
        }
        else if (init) {
            ret.texOffset = [0, 0, 1, 1];
        }
        ret.visible = this.vfxItem.contentVisible;
        ret.startSize = this.startSize;
        return ret;
    };
    SpriteItem.prototype.calculateScaling = function (sizeChanged, sizeInc, init) {
        if (sizeChanged || init) {
            this.transform.setScale(sizeInc.x, sizeInc.y, sizeInc.z);
        }
    };
    return SpriteItem;
}(CalculateItem));

var SpriteVFXItem = /** @class */ (function (_super) {
    __extends(SpriteVFXItem, _super);
    function SpriteVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SpriteVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.sprite;
        },
        enumerable: false,
        configurable: true
    });
    SpriteVFXItem.prototype.onConstructed = function (props) {
        this.sprite = props.content;
    };
    SpriteVFXItem.prototype.onLifetimeBegin = function (composition, content) {
        content.active = true;
    };
    SpriteVFXItem.prototype.onItemRemoved = function (composition, content) {
        if (content) {
            delete content.mesh;
            composition.destroyTextures(content.getTextures());
        }
    };
    SpriteVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        (_a = this.content) === null || _a === void 0 ? void 0 : _a.updateTime(this.time);
    };
    SpriteVFXItem.prototype.getCurrentPosition = function () {
        var pos = new Vector3();
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    /**
     * @internal
     */
    SpriteVFXItem.prototype.setColor = function (r, g, b, a) {
        this.content.setColor(r, g, b, a);
    };
    SpriteVFXItem.prototype.setOpacity = function (opacity) {
        this.content.setOpacity(opacity);
    };
    /**
     * 获取图层包围盒的类型和世界坐标
     * @returns
     */
    SpriteVFXItem.prototype.getBoundingBox = function () {
        var item = this.content;
        if (!item || !this.transform) {
            return;
        }
        var worldMatrix = this.transform.getWorldMatrix();
        var size = item.startSize;
        var triangles = trianglesFromRect(Vector3.ZERO, size.x / 2, size.y / 2);
        triangles.forEach(function (triangle) {
            worldMatrix.transformPoint(triangle.p0);
            worldMatrix.transformPoint(triangle.p1);
            worldMatrix.transformPoint(triangle.p2);
        });
        return {
            type: exports.HitTestType.triangle,
            area: triangles,
        };
    };
    SpriteVFXItem.prototype.getHitTestParams = function (force) {
        var _a, _b;
        var item = this.content;
        var ig = (_a = this.composition) === null || _a === void 0 ? void 0 : _a.loaderData.spriteGroup;
        var ui = item && item.interaction;
        if ((force || ui) && ig && item) {
            var area = this.getBoundingBox();
            if (area) {
                return {
                    behavior: ((_b = item.interaction) === null || _b === void 0 ? void 0 : _b.behavior) || 0,
                    type: area.type,
                    triangles: area.area,
                    backfaceCulling: item.renderer.side === SideMode$1.FRONT,
                };
            }
        }
    };
    SpriteVFXItem.prototype.getRenderData = function () {
        return this.content.getRenderData(this.content.time);
    };
    SpriteVFXItem.prototype.doCreateContent = function (composition) {
        var emptyTexture = composition.getRendererOptions().emptyTexture;
        var content = new SpriteItem(this.sprite, { emptyTexture: emptyTexture }, this);
        content.getRenderData(0, true);
        return content;
    };
    SpriteVFXItem.prototype.createWireframeMesh = function (item, color) {
        var spMesh = new SpriteMesh(this.composition.getEngine(), __assign$1({ wireframe: true }, item.renderInfo), this.composition);
        spMesh.setItems([item]);
        spMesh.mesh.material.setVector3('uFrameColor', Vector3.fromArray(color));
        spMesh.mesh.priority = 999;
        return spMesh;
    };
    return SpriteVFXItem;
}(VFXItem));

var seed$6 = 1;
var FilterSpriteVFXItem = /** @class */ (function (_super) {
    __extends(FilterSpriteVFXItem, _super);
    function FilterSpriteVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FilterSpriteVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.filter;
        },
        enumerable: false,
        configurable: true
    });
    FilterSpriteVFXItem.prototype.onConstructed = function (props) {
        _super.prototype.onConstructed.call(this, props);
        this.filterOptions = props.content.filter;
        this.cachePrefix = 'filter:' + seed$6++;
        // @ts-expect-error
        this.sprite.renderer.texture = this.composition.renderFrame.transparentTexture;
    };
    FilterSpriteVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var e_1, _a;
        var _b, _c, _d;
        _super.prototype.onItemUpdate.call(this, dt, lifetime);
        var mesh = (_b = this._content) === null || _b === void 0 ? void 0 : _b.mesh;
        if (mesh) {
            var variables = this.filter.mesh.variables;
            if (variables) {
                var material = mesh.mesh.material;
                try {
                    // TODO 考虑其他的variable类型
                    for (var _e = __values$1(Object.keys(variables)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var key = _f.value;
                        var value = variables[key](lifetime);
                        if (value.length > 4) {
                            material.setMatrix(key, Matrix4$1.fromArray(value));
                        }
                        else {
                            material.setVector4(key, Vector4$1.fromArray(value));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
        (_d = (_c = this.filter).onItemUpdate) === null || _d === void 0 ? void 0 : _d.call(_c, dt, this);
    };
    FilterSpriteVFXItem.prototype.onItemRemoved = function (composition, content) {
        var _a, _b;
        (_b = (_a = this.filter).onItemRemoved) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        _super.prototype.onItemRemoved.call(this, composition, content);
    };
    FilterSpriteVFXItem.prototype.doCreateContent = function (composition) {
        var _a;
        var spriteItem = _super.prototype.doCreateContent.call(this, composition);
        var filter = createFilter(this.filterOptions, composition);
        this.filter = filter;
        spriteItem.renderInfo.filter = filter;
        spriteItem.filter = filter;
        spriteItem.renderInfo.cacheId = spriteItem.renderInfo.cacheId.replace('$F$', (_a = filter.mesh.shaderCacheId) !== null && _a !== void 0 ? _a : '');
        var variables = filter.mesh.variables;
        if (!filter.mesh.uniformValues) {
            filter.mesh.uniformValues = {};
        }
        if (variables) {
            Object.keys(variables).forEach(function (uniformName) {
                var func = variables[uniformName];
                filter.mesh.uniformValues[uniformName] = func(0);
            });
        }
        return spriteItem;
    };
    return FilterSpriteVFXItem;
}(SpriteVFXItem));

var LinkNode = /** @class */ (function () {
    function LinkNode(content) {
        this.content = content;
    }
    return LinkNode;
}());
var Link = /** @class */ (function () {
    function Link(sort) {
        this.sort = sort;
        this.length = 0;
    }
    Link.prototype.findNodeByContent = function (filter) {
        var node = this.first;
        if (node) {
            do {
                if (filter(node.content)) {
                    return node;
                }
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.next);
        }
    };
    Link.prototype.insertNode = function (a, next) {
        var b = a.next;
        a.next = next;
        next.pre = a;
        next.next = b;
        if (b) {
            b.pre = next;
        }
        // a -> next -> b
    };
    Link.prototype.shiftNode = function (content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.first = this.last = node;
        }
        var current = this.first;
        while (current) {
            if (this.sort(current.content, node.content) <= 0) {
                if (current.next) {
                    current = current.next;
                }
                else {
                    this.insertNode(current, node);
                    return this.last = node;
                }
            }
            else {
                if (current.pre) {
                    this.insertNode(current.pre, node);
                }
                else {
                    this.first = node;
                    node.next = current;
                    current.pre = node;
                }
                return node;
            }
        }
    };
    Link.prototype.pushNode = function (content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.last = this.first = node;
        }
        var current = this.last;
        while (current) {
            if (this.sort(node.content, current.content) <= 0) {
                if (this.first === current) {
                    current.pre = node;
                    node.next = current;
                    return this.first = node;
                }
                else {
                    // @ts-expect-error
                    current = current.pre;
                }
            }
            else {
                this.insertNode(current, node);
                if (current === this.last) {
                    this.last = node;
                }
                return node;
            }
        }
    };
    Link.prototype.removeNode = function (node) {
        var current = this.first;
        this.length--;
        if (current === node) {
            // @ts-expect-error
            var a = this.first = current.next;
            if (a) {
                a.pre = null;
            }
        }
        else if ((current = this.last) === node) {
            // @ts-expect-error
            var a = this.last = current.pre;
            if (a) {
                a.next = null;
            }
        }
        else if (node) {
            var pre = node.pre;
            var next = node.next;
            // @ts-expect-error
            pre.next = next;
            if (next) {
                next.pre = pre;
            }
        }
        node.pre = null;
        node.next = null;
    };
    Link.prototype.forEach = function (func, thisObj) {
        var node = this.first;
        var i = 0;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i++);
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.next);
        }
    };
    Link.prototype.forEachReverse = function (func, thisObj) {
        var node = this.last;
        var i = this.length - 1;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i--);
                // @ts-expect-error
                // eslint-disable-next-line no-cond-assign
            } while (node = node.pre);
        }
    };
    return Link;
}());

var Cone = /** @class */ (function () {
    function Cone(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Cone.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt);
        var a = arc * DEG2RAD;
        var x = Math.cos(a) * this.radius;
        var y = Math.sin(a) * this.radius;
        var position = new Vector3(x, y, 0);
        var l = Math.tan(this.angle * DEG2RAD);
        var dir = position.clone().multiply(l);
        // dir + [0,0,1]
        dir.z += 1;
        return {
            position: position.multiply(random(0, 1)),
            direction: dir.normalize(),
        };
    };
    return Cone;
}());
function getArcAngle(arc, arcMode, opt) {
    if (arcMode === ShapeArcMode$1.RANDOM) {
        arc = random(0, arc);
    }
    else if (arcMode === ShapeArcMode$1.UNIDIRECTIONAL_CYCLE) {
        var d = opt.index % (opt.total + 1);
        arc = arc / opt.total * d;
    }
    else if (arcMode === ShapeArcMode$1.BIDIRECTIONAL_CYCLE) {
        var d = opt.index / (opt.total + 1);
        var i = d - Math.floor(d);
        arc = arc * ((Math.floor(d) % 2) ? (1 - i) : i);
    }
    else if (arcMode === ShapeArcMode$1.UNIFORM_BURST) {
        arc = arc * opt.burstIndex / opt.burstCount;
    }
    return arc;
}

var Circle = /** @class */ (function () {
    function Circle(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Circle.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = new Vector3(Math.cos(arc), Math.sin(arc), 0);
        var radius = this.radius;
        return {
            direction: direction,
            position: direction.clone().multiply(radius),
        };
    };
    return Circle;
}());
var Rectangle = /** @class */ (function () {
    function Rectangle(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
    }
    Rectangle.prototype.generate = function (opt) {
        var x = random(-this._d, this._d);
        var y = random(-this._h, this._h);
        return {
            direction: new Vector3(0, 0, 1),
            position: new Vector3(x, y, 0),
        };
    };
    return Rectangle;
}());
var RectangleEdge = /** @class */ (function () {
    function RectangleEdge(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
        this.arcMode = arg.arcMode;
        this.arc = arg.arc;
    }
    RectangleEdge.prototype.generate = function (opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = new Vector3(Math.cos(arc), Math.sin(arc), 0);
        var w = this._d;
        var h = this._h;
        var r0 = Math.atan2(h, w);
        var tan = Math.tan(arc);
        var position = new Vector3();
        if (arc < r0) {
            position.set(w, w * tan, 0);
        }
        else if (arc >= r0 && arc < Math.PI - r0) {
            position.set(h / tan, h, 0);
        }
        else if (arc < Math.PI + r0) {
            position.set(-w, -w * tan, 0);
        }
        else if (arc < Math.PI * 2 - r0) {
            position.set(-h / tan, -h, 0);
        }
        else {
            position.set(w, w * tan, 0);
        }
        return {
            direction: direction,
            position: position,
        };
    };
    return RectangleEdge;
}());
var Edge = /** @class */ (function () {
    function Edge(args) {
        this._d = args.width || 1;
        this.arcMode = args.arcMode;
    }
    Edge.prototype.generate = function (options) {
        var x = this.arcMode === ShapeArcMode$1.UNIFORM_BURST ? ((options.burstIndex % options.burstCount) / (options.burstCount - 1)) : random(0, 1);
        return {
            direction: new Vector3(0, 1, 0),
            position: new Vector3(this._d * (x - 0.5), 0, 0),
        };
    };
    return Edge;
}());

var tempMat4$2 = new Matrix4$1();
var Donut = /** @class */ (function () {
    function Donut(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Donut.prototype.generate = function (opt) {
        var dradius = this.donutRadius;
        var center = this.radius - dradius;
        var angle = random(0, Math.PI * 2);
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rot = tempMat4$2.setFromRotationZ(arc);
        var direction = new Vector3(Math.cos(angle), Math.sin(angle), 0);
        var position = new Vector3(center + Math.cos(angle) * dradius, 0, Math.sin(angle) * dradius);
        return {
            direction: rot.transformNormal(direction),
            position: rot.transformPoint(position),
        };
    };
    return Donut;
}());

var tempMat4$1 = new Matrix4$1();
var Sphere = /** @class */ (function () {
    function Sphere(props) {
        var _this = this;
        Object.keys(props).forEach(function (key) {
            _this[key] = props[key];
        });
    }
    Sphere.prototype.getHorizontalAngle = function () {
        return random(-90, 90);
    };
    Sphere.prototype.generate = function (opt) {
        var rz = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rh = this.getHorizontalAngle() * DEG2RAD;
        var radius = this.radius;
        var point = new Vector3(Math.cos(rh), 0, Math.sin(rh));
        var mat4 = tempMat4$1.setFromRotationZ(rz);
        var p = mat4.transformNormal(point);
        return {
            position: p.clone().multiply(radius),
            direction: p,
        };
    };
    return Sphere;
}());
var Hemisphere = /** @class */ (function (_super) {
    __extends(Hemisphere, _super);
    function Hemisphere() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Hemisphere.prototype.getHorizontalAngle = function () {
        return random(0, 90);
    };
    return Hemisphere;
}(Sphere));

var TextureShape = /** @class */ (function () {
    function TextureShape(arg) {
        var detail = arg.detail || { anchors: [0.5, 0.5], block: [0, 0] };
        this.anchors = new Float32Array(detail.anchors);
        this.width = arg.width || 1;
        this.height = arg.height || 1;
        this.block = detail.block;
        this.arcMode = arg.arcMode;
        this.random = clamp$1(arg.random || 0, 0, 1);
    }
    TextureShape.prototype.generate = function (opt) {
        var anchors = this.anchors;
        var pointCount = (anchors.length / 2 - 1);
        var index = Math.floor(getArcAngle(pointCount, this.arcMode, opt));
        var pointX = (anchors[index * 2] + this.block[0] * this.random * Math.random()) % 1 - 0.5;
        var pointY = (anchors[index * 2 + 1] + this.block[1] * this.random * Math.random()) % 1 - 0.5;
        var dir = new Vector3(pointX, pointY, 0);
        return {
            position: new Vector3(pointX * this.width, pointY * this.height, 0),
            direction: dir.normalize(),
        };
    };
    return TextureShape;
}());

var _a$5;
var ShapeNone = /** @class */ (function () {
    function ShapeNone() {
    }
    ShapeNone.prototype.generate = function () {
        return {
            position: new Vector3(),
            direction: new Vector3(),
        };
    };
    return ShapeNone;
}());
var map$1 = (_a$5 = {},
    _a$5[ShapeType$1.NONE] = ShapeNone,
    _a$5[ShapeType$1.CONE] = Cone,
    _a$5[ShapeType$1.SPHERE] = Sphere,
    _a$5[ShapeType$1.HEMISPHERE] = Hemisphere,
    _a$5[ShapeType$1.CIRCLE] = Circle,
    _a$5[ShapeType$1.DONUT] = Donut,
    _a$5[ShapeType$1.RECTANGLE] = Rectangle,
    _a$5[ShapeType$1.EDGE] = Edge,
    _a$5[ShapeType$1.RECTANGLE_EDGE] = RectangleEdge,
    _a$5[ShapeType$1.TEXTURE] = TextureShape,
    _a$5);
function createShape(shapeOptions) {
    if (!shapeOptions) {
        return new ShapeNone();
    }
    var options = __assign$1({ radius: 1, arc: 360, angle: 0, arcMode: ShapeArcMode$1.RANDOM }, shapeOptions);
    var type = shapeOptions.type;
    var Ctrl = map$1[type];
    if (!Ctrl) {
        throw Error('invalid shape:' + type);
    }
    var ctrl = new Ctrl(options);
    if (type !== ShapeType$1.NONE) {
        var _a = shapeOptions, alignSpeedDirection = _a.alignSpeedDirection, _b = _a.upDirection, upDirection = _b === void 0 ? [0, 0, 1] : _b;
        ctrl.alignSpeedDirection = alignSpeedDirection;
        ctrl.upDirection = Vector3.fromArray(upDirection).normalize();
    }
    return ctrl;
}

/**
 * Earcut.js from: https://github.com/mapbox/earcut/tree/v2.2.2
 */

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);

        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

var indexBase = 0;
function earcut(data, holeIndices, dim, ib) {
    dim = dim || 2;
    indexBase = ib || 0;
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var outerNode = linkedList(data, 0, outerLen, dim, true);
    var triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) {
        return triangles;
    }
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) {
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    }
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    hackEarcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) {
        return;
    }
    // interlink polygon nodes in z-order
    if (!pass && invSize) {
        indexCurve(ear, minX, minY, invSize);
    }
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim + indexBase);
            triangles.push(ear.i / dim + indexBase);
            triangles.push(next.i / dim + indexBase);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering triangles and slicing again
            if (!pass) {
                hackEarcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                // if this didn't work, try curing all small self-intersections locally
            }
            else if (pass === 1) {
                ear = hackCureLocalIntersections(filterPoints(ear), triangles, dim);
                hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                // as a last resort, try splitting the remaining polygon into two
            }
            else if (pass === 2) {
                hackSplitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// go through all polygon nodes and cure small local self-intersections
function hackCureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim + indexBase);
            triangles.push(p.i / dim + indexBase);
            triangles.push(b.i / dim + indexBase);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    } while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function hackSplitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear triangles around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                hackEarcutLinked(a, triangles, dim, minX, minY, invSize);
                hackEarcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

var POINT_INDEX = 2;
function getGeometryTriangles(geometry, options) {
    var s = geometry.s, p = geometry.p;
    var segments = s[1];
    var points = p[1];
    var pointCount = 0;
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        pointCount += segment.length - 1;
    }
    var pointData = new Float32Array(pointCount * SPRITE_VERTEX_STRIDE);
    var _a = options.indexBase, indexBase = _a === void 0 ? 0 : _a, uvTransform = options.uvTransform;
    var index = 0;
    var dx = 0, dy = 0, sw = 1, sh = 1, r;
    if (uvTransform) {
        dx = uvTransform[0];
        dy = uvTransform[1];
        r = uvTransform[4];
        sw = r ? uvTransform[3] : uvTransform[2];
        sh = r ? uvTransform[2] : uvTransform[3];
    }
    var temp = [0, 0];
    var angle = r === 0 ? 0 : -Math.PI / 2;
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        var p0 = points[i];
        var p1 = points[i + 1] || points[0];
        var keys = segment;
        var point = [0, 0];
        for (var j = 0; j < keys.length - 1; j++) {
            var key = keys[j];
            getBezier2DValue(point, key, p0, p1, p0[4], p0[5], p1[2], p1[3]);
            setPoint(point[0], point[1]);
        }
    }
    var indices = earcut(Array.from(pointData), null, SPRITE_VERTEX_STRIDE, indexBase);
    return { aPoint: pointData, index: new Uint16Array(indices) };
    function setPoint(x, y) {
        pointData[index++] = x / 2;
        pointData[index++] = y / 2;
        if (uvTransform) {
            temp[0] = x;
            temp[1] = y;
            rotateVec2(temp, temp, angle);
            pointData[index++] = dx + (temp[0] + 1) / 2 * sw;
            pointData[index++] = dy + (temp[1] + 1) / 2 * sh;
        }
        else {
            pointData[index++] = (x + 1) / 2;
            pointData[index++] = (y + 1) / 2;
        }
        index += POINT_INDEX;
    }
}
/**
 * 根据新老版形状数据获取形状几何数据
 * @param shape 新老版形状数据
 */
function getGeometriesByShapeData(shape) {
    var geometries = [];
    // 该版本的单个形状数据可以包含多个形状，可以加个埋点，五福之后没有就可以下掉
    if (shape.gs) {
        shape.gs.forEach(function (gs) {
            geometries.push({
                p: [ValueType$1.SHAPE_POINTS, gs.p],
                s: [ValueType$1.SHAPE_SPLITS, gs.s],
            });
        });
    }
    else if (shape.g) {
        geometries.push({
            p: [ValueType$1.SHAPE_POINTS, shape.g.p],
            s: [ValueType$1.SHAPE_SPLITS, shape.g.s],
        });
    }
    else {
        geometries.push(shape);
    }
    return geometries;
}
function getGeometryByShape(shape, uvTransform) {
    var datas = [];
    // 老数据兼容处理
    var geometries = getGeometriesByShapeData(shape);
    var indexBase = 0;
    var aPoint = 0;
    var index = 0;
    for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var data = getGeometryTriangles(geometry, { indexBase: indexBase, uvTransform: uvTransform });
        indexBase += data.aPoint.length / 5;
        datas.push(data);
        aPoint += data.aPoint.length;
        index += data.index.length;
    }
    if (datas.length === 1) {
        return datas[0];
    }
    var aPointData = new Float32Array(aPoint);
    var indexData = new Uint16Array(index);
    // @ts-expect-error
    for (var i = 0, pointIndex = 0, idx = 0; i < datas[i]; i++) {
        var data = datas[i];
        aPointData.set(data.aPoint, pointIndex);
        pointIndex += data.aPoint.length;
        indexData.set(data.index, idx);
        idx += data.index.length;
    }
    return {
        aPoint: aPointData,
        index: indexData,
    };
}
function rotateVec2(out, vec2, angleInRad) {
    var c = Math.cos(angleInRad);
    var s = Math.sin(angleInRad);
    var x = vec2[0];
    var y = vec2[1];
    out[0] = c * x + s * y;
    out[1] = -s * x + c * y;
    return out;
}
function getBezier2DValue(out, t, p0, p1, cpx0, cpy0, cpx1, cpy1) {
    var ddt = 1 - t;
    var a = ddt * ddt * ddt;
    var b = 3 * t * ddt * ddt;
    var c = 3 * t * t * ddt;
    var d = t * t * t;
    out[0] = a * p0[0] + b * cpx0 + c * cpx1 + d * p1[0];
    out[1] = a * p0[1] + b * cpy0 + c * cpy1 + d * p1[1];
    return out;
}

var Burst = /** @class */ (function () {
    function Burst(opts) {
        var time = opts.time, interval = opts.interval, count = opts.count, cycles = opts.cycles, probability = opts.probability;
        this.time = +time || 0;
        this.interval = +interval || 1;
        this.count = count instanceof ValueGetter ? count : createValueGetter(count);
        this.cycles = +cycles || Infinity;
        this.probability = isNaN(probability) ? 1 : +probability;
        this.reset();
    }
    Burst.prototype.getGeneratorOptions = function (timePassed, lifetime) {
        var dt = timePassed - this.time - this.now;
        if (dt > this.interval * this.index && this.internalCycles > 0) {
            this.internalCycles--;
            this.index++;
            return Math.random() <= this.probability ? {
                index: this.index,
                total: 1 / this.interval,
                count: this.count.getValue(lifetime),
                cycleIndex: this.cycles - this.internalCycles - 1,
            } : null;
        }
    };
    Burst.prototype.reset = function () {
        this.internalCycles = this.cycles;
        this.index = 0;
        this.now = 0;
    };
    Burst.prototype.clone = function () {
        return new Burst(this);
    };
    return Burst;
}());

var tmp0 = new Vector3();
var tmp1 = new Vector3();
var TrailMesh = /** @class */ (function () {
    // TODO: engine 挪到第一个参数
    function TrailMesh(props, engine) {
        var _a;
        this.pointStart = [];
        var colorOverLifetime = props.colorOverLifetime, colorOverTrail = props.colorOverTrail, maxTrailCount = props.maxTrailCount, _b = props.opacityOverLifetime, opacityOverLifetime = _b === void 0 ? createValueGetter(1) : _b, widthOverTrail = props.widthOverTrail, name = props.name, occlusion = props.occlusion, blending = props.blending, maskMode = props.maskMode, order = props.order, _c = props.textureMap, textureMap = _c === void 0 ? [0, 0, 1, 1] : _c, texture = props.texture, transparentOcclusion = props.transparentOcclusion, minimumVertexDistance = props.minimumVertexDistance, lifetime = props.lifetime, matrix = props.matrix;
        var _d = engine.gpuCapability, detail = _d.detail, level = _d.level;
        var pointCountPerTrail = Math.max(props.pointCountPerTrail, 2);
        var keyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = detail.maxVertexTextures > 0;
        var env = ((_a = engine.renderer) !== null && _a !== void 0 ? _a : {}).env;
        var uniformValues = {};
        // const lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
        var lookUpTexture = 0;
        var marcos = [
            ['ENABLE_VERTEX_TEXTURE', enableVertexTexture],
            ['LOOKUP_TEXTURE_CURVE', lookUpTexture],
            ['ENV_EDITOR', env === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var useAttributeTrailStart = maxTrailCount > 64;
        var shaderCacheId = 0;
        if (colorOverLifetime) {
            marcos.push(['COLOR_OVER_LIFETIME', true]);
            shaderCacheId |= 1;
            uniformValues.uColorOverLifetime = Texture.createWithData(engine, imageDataFromGradient(colorOverLifetime));
        }
        if (colorOverTrail) {
            marcos.push(['COLOR_OVER_TRAIL', true]);
            shaderCacheId |= 1 << 2;
            uniformValues.uColorOverTrail = Texture.createWithData(engine, imageDataFromGradient(colorOverTrail));
        }
        if (useAttributeTrailStart) {
            marcos.push(['ATTR_TRAIL_START', 1]);
            shaderCacheId |= 1 << 3;
        }
        else {
            uniformValues.uTrailStart = new Float32Array(maxTrailCount);
        }
        uniformValues.uOpacityOverLifetimeValue = opacityOverLifetime.toUniform(keyFrameMeta);
        var uWidthOverTrail = widthOverTrail.toUniform(keyFrameMeta);
        marcos.push(['VERT_CURVE_VALUE_COUNT', keyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', keyFrameMeta.max]);
        if (enableVertexTexture && lookUpTexture) {
            var tex = generateHalfFloatTexture(engine, ValueGetter.getAllData(keyFrameMeta, true), keyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
        }
        else {
            uniformValues.uVCurveValues = ValueGetter.getAllData(keyFrameMeta);
        }
        var vertex = createShaderWithMarcos(marcos, trailVert, exports.ShaderType.vertex, level);
        var fragment = createShaderWithMarcos(marcos, particleFrag, exports.ShaderType.fragment, level);
        var mtl = ({
            shader: {
                vertex: vertex,
                fragment: fragment,
                marcos: marcos,
                glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
                shared: true,
                name: "trail#".concat(name),
                cacheId: "-t:+".concat(shaderCacheId, "+").concat(keyFrameMeta.index, "+").concat(keyFrameMeta.max),
            },
            uniformSemantics: {
                effects_MatrixVP: 'VIEWPROJECTION',
                effects_MatrixInvV: 'VIEWINVERSE',
                effects_ObjectToWorld: 'MODEL',
                uEditorTransform: 'EDITOR_TRANSFORM',
            },
        });
        var maxVertexCount = pointCountPerTrail * maxTrailCount * 2;
        var maxTriangleCount = (pointCountPerTrail - 1) * maxTrailCount;
        var bpe = Float32Array.BYTES_PER_ELEMENT;
        var v12 = 12 * bpe;
        var geometryOptions = {
            attributes: {
                aColor: { size: 4, stride: v12, data: new Float32Array(maxVertexCount * 12) },
                aSeed: { size: 1, stride: v12, offset: 4 * bpe, dataSource: 'aColor' },
                aInfo: { size: 3, stride: v12, offset: 5 * bpe, dataSource: 'aColor' },
                aPos: { size: 4, stride: v12, offset: 8 * bpe, dataSource: 'aColor' },
                //
                aTime: { size: 1, data: new Float32Array(maxVertexCount) },
                //
                aDir: { size: 3, data: new Float32Array(maxVertexCount * 3) },
            },
            indices: { data: new Uint16Array(maxVertexCount * 6) },
            drawCount: maxTriangleCount * 6,
            name: "trail#".concat(name),
            bufferUsage: glContext.DYNAMIC_DRAW,
        };
        if (useAttributeTrailStart) {
            geometryOptions.attributes.aTrailStart = { size: 1, data: new Float32Array(maxVertexCount) };
        }
        else {
            var indexData = new Float32Array(maxVertexCount);
            geometryOptions.attributes.aTrailStartIndex = { size: 1, data: indexData };
            for (var i = 0; i < maxTrailCount; i++) {
                var c = pointCountPerTrail * 2;
                var s = i * c;
                for (var j = 0; j < c; j++) {
                    indexData[s + j] = i;
                }
            }
        }
        var preMulAlpha = getPreMultiAlpha(blending);
        var material = Material.create(engine, mtl);
        material.blending = true;
        material.depthMask = occlusion;
        material.depthTest = true;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        var mesh = this.mesh = Mesh.create(engine, {
            name: "MTrail_".concat(name),
            material: material,
            geometry: Geometry.create(engine, geometryOptions),
            priority: order,
        });
        var uMaskTex = texture !== null && texture !== void 0 ? texture : Texture.createWithData(engine);
        Object.keys(uniformValues).map(function (name) {
            var value = uniformValues[name];
            if (value instanceof Texture) {
                material.setTexture(name, value);
            }
            else if (name === 'uTrailStart') {
                material.setFloats('uTrailStart', value);
            }
            else if (name === 'uVCurveValues') {
                var array = [];
                for (var i = 0; i < value.length; i = i + 4) {
                    var v = new Vector4$1(value[i], value[i + 1], value[i + 2], value[i + 3]);
                    array.push(v);
                }
                material.setVector4Array(name, array);
            }
            else {
                material.setVector4(name, Vector4$1.fromArray(value));
            }
        });
        material.setFloat('uTime', 0);
        // TODO: 修改下长度
        material.setVector4('uWidthOverTrail', Vector4$1.fromArray(uWidthOverTrail));
        material.setVector2('uTexOffset', new Vector2(0, 0));
        material.setVector4('uTextureMap', Vector4$1.fromArray(textureMap));
        material.setVector4('uParams', new Vector4$1(0, pointCountPerTrail - 1, 0, 0));
        material.setTexture('uMaskTex', uMaskTex);
        material.setVector4('uColorParams', new Vector4$1(texture ? 1 : 0, +preMulAlpha, 0, +(occlusion && !transparentOcclusion)));
        this.maxTrailCount = maxTrailCount;
        this.pointCountPerTrail = pointCountPerTrail;
        this.checkVertexDistance = minimumVertexDistance > 0;
        this.minimumVertexDistance = Math.pow(minimumVertexDistance || 0.001, 2);
        this.useAttributeTrailStart = useAttributeTrailStart;
        this.lifetime = lifetime;
        if (matrix) {
            this.mesh.worldMatrix = matrix;
        }
        this.geometry = mesh.firstGeometry();
        this.trailCursors = new Uint16Array(maxTrailCount);
    }
    Object.defineProperty(TrailMesh.prototype, "time", {
        get: function () {
            return this.mesh.material.getFloat('uTime') || 0;
        },
        set: function (t) {
            this.mesh.material.setFloat('uTime', t !== null && t !== void 0 ? t : 0);
        },
        enumerable: false,
        configurable: true
    });
    TrailMesh.prototype.addPoint = function (trailIndex, position, opt) {
        opt = opt || {};
        var cursor = this.trailCursors[trailIndex];
        var pointCountPerTrail = this.pointCountPerTrail;
        var geometry = this.geometry;
        var segmentPerTrail = pointCountPerTrail - 1;
        var pointIndex = cursor % pointCountPerTrail;
        var previousIndex = (cursor - 1) % pointCountPerTrail;
        var bpreviousIndex = (cursor - 2) % pointCountPerTrail;
        var previousPoint = this.getTrailPosition(trailIndex, previousIndex, tmp0);
        // point too close
        if (previousPoint && this.checkVertexDistance && (previousPoint === null || previousPoint === void 0 ? void 0 : previousPoint.distanceSquared(position)) < this.minimumVertexDistance) {
            return;
        }
        var pointStartIndex = trailIndex * pointCountPerTrail + pointIndex;
        var dir = calculateDirection(previousPoint, position);
        var time = opt.time || this.time;
        var info = [Math.random(), opt.lifetime || this.lifetime, cursor];
        var size = opt.size || 1;
        var dirStartIndex = pointStartIndex * 6;
        var dirData = new Float32Array(6);
        dirData.set(dir, 0);
        dirData.set(dir, 3);
        geometry.setAttributeSubData('aDir', dirStartIndex, dirData);
        geometry.setAttributeSubData('aTime', pointStartIndex * 2, new Float32Array([time, time]));
        var color = opt.color || [1, 1, 1, 1];
        var colorData = new Float32Array(24);
        var positionData = position.toArray();
        colorData.set(color, 0);
        colorData.set(info, 4);
        colorData[7] = 0;
        colorData.set(positionData, 8);
        colorData[11] = 0.5 * size;
        colorData.set(color, 12);
        colorData.set(info, 16);
        colorData[19] = 1;
        colorData.set(positionData, 20);
        colorData[23] = -0.5 * size;
        geometry.setAttributeSubData('aColor', pointStartIndex * 24, colorData);
        if (previousIndex >= 0) {
            var bPreviousPoint = this.getTrailPosition(trailIndex, bpreviousIndex, tmp1);
            var previousDir = new Float32Array(calculateDirection(bPreviousPoint, previousPoint, position));
            var previousDirStartIndex = (trailIndex * pointCountPerTrail + previousIndex) * 6;
            geometry.setAttributeSubData('aDir', previousDirStartIndex, previousDir);
            geometry.setAttributeSubData('aDir', previousDirStartIndex + 3, previousDir);
            var indicesStart = trailIndex * pointCountPerTrail * 2;
            var indicesData = new Uint16Array([
                previousIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + indicesStart,
                pointIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + 1 + indicesStart,
            ]);
            var start = (trailIndex * segmentPerTrail + (cursor - 1) % segmentPerTrail) * 6;
            geometry.setIndexSubData(start, indicesData);
        }
        cursor = ++this.trailCursors[trailIndex];
        var mtl = this.mesh.material;
        var params = mtl.getVector4('uParams');
        var trailStart = info[2];
        if (this.useAttributeTrailStart) {
            var len = pointCountPerTrail * 2;
            var startData = new Float32Array(len);
            for (var i = 0; i < len; i++) {
                startData[i] = trailStart;
            }
            geometry.setAttributeSubData('aTrailStart', trailIndex * startData.length, startData);
        }
        else {
            var value = mtl.getFloats('uTrailStart');
            if (value != undefined) {
                value[trailIndex] = trailStart;
                mtl.setFloats('uTrailStart', value);
            }
        }
        if (params) {
            params.y = Math.max(params.y, cursor - 1) - Math.max(0, cursor - pointCountPerTrail);
            mtl.setVector4('uParams', params);
        }
    };
    TrailMesh.prototype.getTrailPosition = function (trail, index, out) {
        var pointCountPerTrail = this.pointCountPerTrail;
        if (index >= 0 && index < pointCountPerTrail) {
            var startIndex = (trail * pointCountPerTrail + index) * 24 + 8;
            var data = this.geometry.getAttributeData('aColor');
            out.x = data[startIndex];
            out.y = data[1 + startIndex];
            out.z = data[2 + startIndex];
            return out;
        }
    };
    TrailMesh.prototype.clearAllTrails = function () {
        var geo = this.geometry;
        this.trailCursors = new Uint16Array(this.trailCursors.length);
        // @ts-expect-error
        geo.setIndexData(new Uint16Array(geo.getIndexData().length));
    };
    TrailMesh.prototype.minusTime = function (time) {
        // FIXME: 可选性
        var data = this.geometry.getAttributeData('aTime');
        for (var i = 0; i < data.length; i++) {
            data[i] -= time;
        }
        this.geometry.setAttributeData('aTime', data);
        this.time -= time;
    };
    TrailMesh.prototype.clearTrail = function (index) {
        if (this.trailCursors[index] !== 0) {
            var pointCountPerTrail = this.pointCountPerTrail;
            var indicesPerTrail = (pointCountPerTrail - 1) * 6;
            var indices = this.geometry.getIndexData();
            indices === null || indices === void 0 ? void 0 : indices.set(new Uint16Array(indicesPerTrail), index * indicesPerTrail);
            this.geometry.setIndexData(indices);
            this.trailCursors[index] = 0;
        }
    };
    TrailMesh.prototype.getPointStartPos = function (index) {
        return this.pointStart[index];
    };
    TrailMesh.prototype.setPointStartPos = function (index, pos) {
        this.pointStart[index] = pos;
    };
    TrailMesh.prototype.onUpdate = function (escapeTime) {
    };
    return TrailMesh;
}());
var tempDir$1 = new Vector3();
var tempDa = new Vector3();
var tempDb = new Vector3();
function calculateDirection(prePoint, point, nextPoint) {
    var dir = tempDir$1;
    if (!prePoint && !nextPoint) {
        return [0, 0, 0];
    }
    else if (!prePoint) {
        dir.subtractVectors(nextPoint, point);
    }
    else if (!nextPoint) {
        dir.subtractVectors(point, prePoint);
    }
    else {
        tempDa.subtractVectors(point, prePoint).normalize();
        // FIXME: 这里有bug。。。
        tempDa.subtractVectors(nextPoint, point);
        tempDb.copyFrom(tempDa).normalize();
        dir.addVectors(tempDa, tempDb);
    }
    return dir.normalize().toArray();
}
function getTrailMeshShader(trails, particleMaxCount, name, env, gpuCapability) {
    if (env === void 0) { env = ''; }
    var shaderCacheId = 0;
    var lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
    var enableVertexTexture = gpuCapability.detail.maxVertexTextures > 0;
    var marcos = [
        ['ENABLE_VERTEX_TEXTURE', enableVertexTexture],
        ['LOOKUP_TEXTURE_CURVE', lookUpTexture],
        ['ENV_EDITOR', env === PLAYER_OPTIONS_ENV_EDITOR],
    ];
    var keyFrameMeta = createKeyFrameMeta();
    if (trails.colorOverLifetime) {
        marcos.push(['COLOR_OVER_LIFETIME', true]);
        shaderCacheId |= 1;
    }
    if (trails.colorOverTrail) {
        marcos.push(['COLOR_OVER_TRAIL', true]);
        shaderCacheId |= 1 << 2;
    }
    var useAttributeTrailStart = particleMaxCount > 64;
    if (useAttributeTrailStart) {
        marcos.push(['ATTR_TRAIL_START', 1]);
        shaderCacheId |= 1 << 3;
    }
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.opacityOverLifetime);
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.widthOverTrail);
    marcos.push(['VERT_CURVE_VALUE_COUNT', keyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', keyFrameMeta.max]);
    return {
        vertex: trailVert,
        fragment: particleFrag,
        marcos: marcos,
        shared: true,
        name: 'trail#' + name,
        cacheId: "-t:+".concat(shaderCacheId, "+").concat(keyFrameMeta.index, "+").concat(keyFrameMeta.max),
    };
}

var ParticleSystem = /** @class */ (function () {
    function ParticleSystem(props, rendererOptions, vfxItem) {
        var _a, _b, _c, _d, _e, _f;
        var composition = vfxItem.composition, endBehavior = vfxItem.endBehavior, name = vfxItem.name;
        if (!composition) {
            return;
        }
        var engine = composition.getEngine();
        var _g = rendererOptions.cachePrefix, cachePrefix = _g === void 0 ? '' : _g;
        var options = props.options;
        var positionOverLifetime = props.positionOverLifetime;
        var shape = props.shape;
        var duration = vfxItem.duration || 1;
        var gravityModifier = positionOverLifetime.gravityOverLifetime;
        var gravity = ensureVec3(positionOverLifetime.gravity);
        var _textureSheetAnimation = props.textureSheetAnimation;
        var textureSheetAnimation = _textureSheetAnimation ? {
            animationDelay: createValueGetter(_textureSheetAnimation.animationDelay || 0),
            animationDuration: createValueGetter(_textureSheetAnimation.animationDuration || 1),
            cycles: createValueGetter(_textureSheetAnimation.cycles || 1),
            animate: _textureSheetAnimation.animate,
            col: _textureSheetAnimation.col,
            row: _textureSheetAnimation.row,
            total: _textureSheetAnimation.total || _textureSheetAnimation.col * _textureSheetAnimation.row,
        } : undefined;
        var renderMatrix = Matrix4$1.fromIdentity();
        var startTurbulence = !!(shape && shape.turbulenceX || shape.turbulenceY || shape.turbulenceZ);
        var turbulence;
        if (startTurbulence) {
            turbulence = [
                createValueGetter((_a = shape.turbulenceX) !== null && _a !== void 0 ? _a : 0),
                createValueGetter((_b = shape.turbulenceY) !== null && _b !== void 0 ? _b : 0),
                createValueGetter((_c = shape.turbulenceZ) !== null && _c !== void 0 ? _c : 0),
            ];
        }
        this.name = name;
        this.shape = createShape(shape);
        this.emission = {
            rateOverTime: createValueGetter(props.emission.rateOverTime),
            burstOffsets: getBurstOffsets((_d = props.emission.burstOffsets) !== null && _d !== void 0 ? _d : []),
            bursts: (props.emission.bursts || []).map(function (c) { return new Burst(c); }),
        };
        this.textureSheetAnimation = textureSheetAnimation;
        var renderer = props.renderer || {};
        var rotationOverLifetime = {};
        var rotOverLt = props.rotationOverLifetime;
        if (rotOverLt) {
            rotationOverLifetime.asRotation = !!rotOverLt.asRotation;
            rotationOverLifetime.z = rotOverLt.z ? createValueGetter(rotOverLt.z) : createValueGetter(0);
            if (rotOverLt.separateAxes) {
                rotationOverLifetime.x = rotOverLt.x && createValueGetter(rotOverLt.x);
                rotationOverLifetime.y = rotOverLt.y && createValueGetter(rotOverLt.y);
            }
        }
        var forceTarget;
        if (positionOverLifetime.forceTarget) {
            forceTarget = {
                target: positionOverLifetime.target || [0, 0, 0],
                curve: createValueGetter(positionOverLifetime.forceCurve || [ValueType$1.LINE, [[0, 0], [1, 1]]]),
            };
        }
        var linearVelOverLifetime = {
            x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX || 0),
            y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY || 0),
            z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ || 0),
            asMovement: positionOverLifetime.asMovement,
        };
        var orbitalVelOverLifetime = {
            x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
            y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
            z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
            center: positionOverLifetime.orbCenter,
            asRotation: positionOverLifetime.asRotation,
        };
        var sizeOverLifetime = props.sizeOverLifetime || {};
        var colorOverLifetime = props.colorOverLifetime;
        var order = vfxItem.listIndex;
        var shaderCachePrefix = cachePrefix;
        var sizeOverLifetimeGetter = (sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.separateAxes) ?
            {
                separateAxes: true,
                x: createValueGetter(sizeOverLifetime.x),
                y: createValueGetter(sizeOverLifetime.y),
            } :
            {
                separateAxes: false,
                x: createValueGetter(('size' in sizeOverLifetime ? sizeOverLifetime.size : sizeOverLifetime.x) || 1),
            };
        var anchor = Vector2.fromArray(convertAnchor(renderer.anchor, renderer.particleOrigin));
        this.options = {
            particleFollowParent: !!options.particleFollowParent,
            startLifetime: createValueGetter(options.startLifetime),
            startDelay: createValueGetter(options.startDelay || 0),
            startSpeed: createValueGetter(positionOverLifetime.startSpeed || 0),
            startColor: createValueGetter(options.startColor),
            endBehavior: endBehavior,
            duration: duration,
            looping: endBehavior === ItemEndBehavior$1.loop,
            maxCount: (_e = options.maxCount) !== null && _e !== void 0 ? _e : 0,
            gravityModifier: createValueGetter(gravityModifier || 0).scaleXCoord(duration),
            gravity: gravity,
            start3DSize: !!options.start3DSize,
            startTurbulence: startTurbulence,
            turbulence: turbulence,
            speedOverLifetime: positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime),
            linearVelOverLifetime: linearVelOverLifetime,
            orbitalVelOverLifetime: orbitalVelOverLifetime,
            forceTarget: forceTarget,
        };
        if (options.startRotationZ) {
            this.options.startRotation = createValueGetter(options.startRotationZ || 0);
        }
        if (options.startRotationX || options.startRotationY) {
            this.options.start3DRotation = true;
            this.options.startRotationX = createValueGetter(options.startRotationX || 0);
            this.options.startRotationY = createValueGetter(options.startRotationY || 0);
            this.options.startRotationZ = createValueGetter(options.startRotationZ || 0);
        }
        if (options.start3DSize) {
            this.options.startSizeX = createValueGetter(options.startSizeX);
            this.options.startSizeY = createValueGetter(options.startSizeY);
        }
        else {
            this.options.startSize = createValueGetter(options.startSize);
            this.options.sizeAspect = createValueGetter(options.sizeAspect || 1);
        }
        var meshOptions = {
            listIndex: order,
            meshSlots: options.meshSlots,
            name: name,
            matrix: renderMatrix,
            filter: props.filter,
            shaderCachePrefix: shaderCachePrefix,
            renderMode: renderer.renderMode || RenderMode$1.BILLBOARD,
            side: renderer.side || SideMode$1.DOUBLE,
            gravity: gravity,
            duration: vfxItem.duration,
            blending: renderer.blending || BlendingMode$1.ALPHA,
            rotationOverLifetime: rotationOverLifetime,
            gravityModifier: this.options.gravityModifier,
            linearVelOverLifetime: this.options.linearVelOverLifetime,
            orbitalVelOverLifetime: this.options.orbitalVelOverLifetime,
            speedOverLifetime: this.options.speedOverLifetime,
            sprite: textureSheetAnimation,
            occlusion: !!renderer.occlusion,
            transparentOcclusion: !!renderer.transparentOcclusion,
            maxCount: options.maxCount,
            mask: renderer.mask,
            maskMode: (_f = renderer.maskMode) !== null && _f !== void 0 ? _f : MaskMode$1.NONE,
            forceTarget: forceTarget,
            diffuse: renderer.texture,
            sizeOverLifetime: sizeOverLifetimeGetter,
            anchor: anchor,
        };
        if (colorOverLifetime) {
            var color = colorOverLifetime.color, opacity = colorOverLifetime.opacity;
            meshOptions.colorOverLifetime = {};
            if (opacity) {
                meshOptions.colorOverLifetime.opacity = createValueGetter(colorOverLifetime.opacity);
            }
            if (color) {
                if (color[0] === ValueType$1.GRADIENT_COLOR) {
                    meshOptions.colorOverLifetime.color = colorOverLifetime.color[1];
                }
                else if (color[0] === ValueType$1.RGBA_COLOR) {
                    meshOptions.colorOverLifetime.color = Texture.createWithData(engine, {
                        data: new Uint8Array(color[1]),
                        width: 1,
                        height: 1,
                    });
                }
                else if (color instanceof Texture) {
                    meshOptions.colorOverLifetime.color = color;
                }
            }
        }
        var uvs = [];
        var textureMap = [0, 0, 1, 1];
        var flip;
        if (props.splits) {
            var s = props.splits[0];
            flip = s[4];
            textureMap = flip ? [s[0], s[1], s[3], s[2]] : [s[0], s[1], s[2], s[3]];
        }
        if (textureSheetAnimation && !textureSheetAnimation.animate) {
            var col = flip ? textureSheetAnimation.row : textureSheetAnimation.col;
            var row = flip ? textureSheetAnimation.col : textureSheetAnimation.row;
            var total = textureSheetAnimation.total || col * row;
            var index = 0;
            for (var x = 0; x < col; x++) {
                for (var y = 0; y < row && index < total; y++, index++) {
                    uvs.push([
                        x * textureMap[2] / col + textureMap[0],
                        y * textureMap[3] / row + textureMap[1],
                        textureMap[2] / col,
                        textureMap[3] / row
                    ]);
                }
            }
        }
        else {
            uvs.push(textureMap);
        }
        // @ts-expect-error
        meshOptions.textureFlip = flip;
        this.uvs = uvs;
        this.particleMesh = new ParticleMesh(meshOptions, {
            composition: composition,
        });
        var trails = props.trails;
        if (trails) {
            this.trails = {
                lifetime: createValueGetter(trails.lifetime),
                dieWithParticles: trails.dieWithParticles !== false,
                sizeAffectsWidth: !!trails.sizeAffectsWidth,
                sizeAffectsLifetime: !!trails.sizeAffectsLifetime,
                inheritParticleColor: !!trails.inheritParticleColor,
                parentAffectsPosition: !!trails.parentAffectsPosition,
            };
            var trailMeshProps = {
                name: vfxItem.name + '_trail',
                matrix: renderMatrix,
                minimumVertexDistance: trails.minimumVertexDistance || 0.02,
                maxTrailCount: options.maxCount,
                pointCountPerTrail: Math.round(trails.maxPointPerTrail) || 32,
                blending: trails.blending,
                texture: trails.texture,
                opacityOverLifetime: createValueGetter(trails.opacityOverLifetime || 1),
                widthOverTrail: createValueGetter(trails.widthOverTrail || 1),
                order: order + (trails.orderOffset || 0),
                shaderCachePrefix: shaderCachePrefix,
                lifetime: this.trails.lifetime,
                occlusion: !!trails.occlusion,
                transparentOcclusion: !!trails.transparentOcclusion,
                textureMap: trails.textureMap,
                mask: renderer.mask,
                maskMode: renderer.maskMode,
            };
            if (trails.colorOverLifetime && trails.colorOverLifetime[0] === ValueType$1.GRADIENT_COLOR) {
                trailMeshProps.colorOverLifetime = trails.colorOverLifetime[1];
            }
            if (trails.colorOverTrail && trails.colorOverTrail[0] === ValueType$1.GRADIENT_COLOR) {
                trailMeshProps.colorOverTrail = trails.colorOverTrail[1];
            }
            this.trailMesh = new TrailMesh(trailMeshProps, engine);
        }
        this.transform = vfxItem.transform;
        var position = this.transform.position.clone();
        var rotation = this.transform.rotation.clone();
        var transformPath = props.emitterTransform && props.emitterTransform.path;
        var path;
        if (transformPath) {
            if (transformPath[0] === ValueType$1.CONSTANT_VEC3) {
                position.add(transformPath[1]);
            }
            else {
                path = createValueGetter(transformPath);
            }
        }
        this.basicTransform = {
            position: position,
            rotation: rotation,
            path: path,
        };
        this.updateEmitterTransform(0);
        var meshes = [this.particleMesh.mesh];
        if (this.trailMesh) {
            meshes.push(this.trailMesh.mesh);
        }
        this.meshes = meshes;
        this.reusable = vfxItem.reusable;
        this.setVisible(vfxItem.contentVisible);
        var interaction = props.interaction;
        if (interaction) {
            this.interaction = {
                multiple: interaction.multiple,
                radius: interaction.radius,
                behavior: interaction.behavior,
            };
        }
    }
    Object.defineProperty(ParticleSystem.prototype, "timePassed", {
        get: function () {
            return this.lastUpdate - this.loopStartTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticleSystem.prototype, "lifetime", {
        get: function () {
            return this.timePassed / this.options.duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ParticleSystem.prototype, "particleCount", {
        get: function () {
            return this.particleLink.length;
        },
        enumerable: false,
        configurable: true
    });
    ParticleSystem.prototype.updateEmitterTransform = function (time) {
        var parentTransform = this.transform.parentTransform;
        var _a = this.basicTransform, path = _a.path, position = _a.position;
        var selfPos = position.clone();
        if (path) {
            var duration = this.options.duration;
            selfPos.add(path.getValue(time / duration));
        }
        this.transform.setPosition(selfPos.x, selfPos.y, selfPos.z);
        if (this.options.particleFollowParent && parentTransform) {
            var tempMatrix = parentTransform.getWorldMatrix();
            this.particleMesh.mesh.worldMatrix = tempMatrix;
            if (this.trailMesh) {
                this.trailMesh.mesh.worldMatrix = tempMatrix;
            }
        }
    };
    ParticleSystem.prototype.addParticle = function (point, maxCount) {
        var link = this.particleLink;
        var linkContent = [point.delay + point.lifetime, 0, point.delay, point];
        var pointIndex;
        if (link.length < maxCount) {
            pointIndex = linkContent[1] = link.length;
        }
        else {
            var first = link.first;
            link.removeNode(first);
            pointIndex = linkContent[1] = first.content[1];
        }
        link.pushNode(linkContent);
        this.particleMesh.setPoint(point, pointIndex);
        this.clearPointTrail(pointIndex);
        if (this.trailMesh) {
            this.trailMesh.setPointStartPos(pointIndex, this.transform.parentTransform.position.clone());
        }
    };
    ParticleSystem.prototype.setVisible = function (visible) {
        this.particleMesh.mesh.setVisible(visible);
        if (this.trailMesh) {
            this.trailMesh.mesh.setVisible(visible);
        }
    };
    ParticleSystem.prototype.setOpacity = function (opacity) {
        var _a;
        var material = this.particleMesh.mesh.material;
        var geometry = this.particleMesh.mesh.geometry;
        var originalColor = ((_a = material.getVector4('uOpacityOverLifetimeValue')) === null || _a === void 0 ? void 0 : _a.toArray()) || [1, 1, 1, 1];
        material.setVector4('uOpacityOverLifetimeValue', new Vector4$1(originalColor[0], originalColor[1], originalColor[2], opacity));
        var data = geometry.getAttributeData('aColor') || [];
        for (var i = 0; i < data.length; i += 32) {
            data[i * 8 + 7] = opacity;
        }
    };
    /**
     * @internal
     */
    ParticleSystem.prototype.setColor = function (r, g, b, a) {
        var _a;
        var material = this.particleMesh.mesh.material;
        var geometry = this.particleMesh.mesh.geometry;
        var originalColor = ((_a = material.getVector4('uOpacityOverLifetimeValue')) === null || _a === void 0 ? void 0 : _a.toArray()) || [1, 1, 1, 1];
        material.setVector4('uOpacityOverLifetimeValue', new Vector4$1(originalColor[0], originalColor[1], originalColor[2], a));
        var data = geometry.getAttributeData('aColor') || [];
        for (var i = 0; i < data.length; i += 32) {
            data[i * 8 + 4] = r;
            data[i * 8 + 5] = g;
            data[i * 8 + 6] = b;
            data[i * 8 + 7] = a;
        }
    };
    ParticleSystem.prototype.setParentTransform = function (transform) {
        // this.transform.parentTransform = transform;
        // this.parentTransform = transform;
    };
    ParticleSystem.prototype.getTextures = function () {
        var textures = [];
        // @ts-expect-error textures 是否可以考虑挂在 Material 上
        var particleMeshTextures = this.particleMesh.mesh.material.textures;
        Object.keys(particleMeshTextures).forEach(function (key) {
            textures.push(particleMeshTextures[key]);
        });
        if (this.trailMesh) {
            // @ts-expect-error 同上
            var trailMeshTextures_1 = this.trailMesh.mesh.material.textures;
            Object.keys(trailMeshTextures_1).forEach(function (key) {
                textures.push(trailMeshTextures_1[key]);
            });
        }
        return textures;
    };
    ParticleSystem.prototype.start = function () {
        if (!this.started || this.ended) {
            this.reset();
            this.started = true;
            this.ended = false;
        }
    };
    ParticleSystem.prototype.stop = function () {
        this.ended = true;
        this.started = false;
    };
    ParticleSystem.prototype.reset = function () {
        var _a;
        this.particleMesh.clearPoints();
        (_a = this.trailMesh) === null || _a === void 0 ? void 0 : _a.clearAllTrails();
        this.lastUpdate = 0;
        this.loopStartTime = 0;
        this.lastEmitTime = -1 / this.emission.rateOverTime.getValue(0);
        this.generatedCount = 0;
        this.particleLink = new Link(function (a, b) { return a[0] - b[0]; });
        this.emission.bursts.forEach(function (b) { return b.reset(); });
        this.frozen = false;
    };
    ParticleSystem.prototype.onUpdate = function (delta) {
        var _a;
        var _this = this;
        if (this.started && !this.frozen) {
            var now = this.lastUpdate + delta / 1000;
            var particleMesh = this.particleMesh;
            var trailMesh = this.trailMesh;
            var options = this.options;
            var loopStartTime_1 = this.loopStartTime;
            var emission = this.emission;
            this.lastUpdate = now;
            this.upDirectionWorld = null;
            particleMesh.time = now;
            if (trailMesh) {
                trailMesh.time = now;
                trailMesh.onUpdate(delta);
            }
            var link_1 = this.particleLink;
            var emitterLifetime_1 = (now - loopStartTime_1) / options.duration;
            var timePassed_1 = this.timePassed;
            var trailUpdated_1 = false;
            var updateTrail = function () {
                if (_this.trails && !trailUpdated_1) {
                    trailUpdated_1 = true;
                    link_1.forEach(function (_a) {
                        var _b = __read$3(_a, 4), time = _b[0], pointIndex = _b[1], delay = _b[2], point = _b[3];
                        if (time < timePassed_1) {
                            _this.clearPointTrail(pointIndex);
                        }
                        else if (timePassed_1 > delay) {
                            _this.updatePointTrail(pointIndex, emitterLifetime_1, point, delay);
                        }
                    });
                }
            };
            if (!this.ended) {
                var duration_1 = options.duration;
                var lifetime = this.lifetime;
                if (timePassed_1 < duration_1) {
                    var interval = 1 / emission.rateOverTime.getValue(lifetime);
                    var pointCount = Math.floor((timePassed_1 - this.lastEmitTime) / interval);
                    var maxEmissionCount = pointCount;
                    var timeDelta = interval / pointCount;
                    var meshTime = now;
                    var maxCount_1 = options.maxCount;
                    this.updateEmitterTransform(timePassed_1);
                    var shouldSkipGenerate = function () {
                        var first = link_1.first;
                        return _this.emissionStopped || (link_1.length === maxCount_1 && first && (first.content[0] - loopStartTime_1) > timePassed_1);
                    };
                    for (var i = 0; i < maxEmissionCount && i < maxCount_1; i++) {
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var p = this.createPoint(lifetime);
                        p.delay += meshTime + i * timeDelta;
                        this.addParticle(p, maxCount_1);
                        this.lastEmitTime = timePassed_1;
                    }
                    var bursts = emission.bursts;
                    for (var j = (bursts === null || bursts === void 0 ? void 0 : bursts.length) - 1, cursor = 0; j >= 0 && cursor < maxCount_1; j--) {
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var burst = bursts[j];
                        var opts = !burst.disabled && burst.getGeneratorOptions(timePassed_1, lifetime);
                        if (opts) {
                            var originVec = [0, 0, 0];
                            var offsets = emission.burstOffsets[j];
                            var burstOffset = (offsets && offsets[opts.cycleIndex]) || originVec;
                            if (burst.once) {
                                this.removeBurst(j);
                            }
                            for (var i = 0; i < opts.count && cursor < maxCount_1; i++) {
                                if (shouldSkipGenerate()) {
                                    break;
                                }
                                var p = this.initPoint(this.shape.generate({
                                    total: opts.total,
                                    index: opts.index,
                                    burstIndex: i,
                                    burstCount: opts.count,
                                }));
                                p.delay += meshTime;
                                cursor++;
                                (_a = p.transform).translate.apply(_a, __spreadArray$2([], __read$3(burstOffset), false));
                                this.addParticle(p, maxCount_1);
                            }
                        }
                    }
                }
                else if (options.looping) {
                    updateTrail();
                    this.loopStartTime = now - duration_1;
                    this.lastEmitTime -= duration_1;
                    this.lastUpdate -= duration_1;
                    emission.bursts.forEach(function (b) { return b.reset(); });
                    this.particleLink.forEach(function (content) {
                        content[0] -= duration_1;
                        content[2] -= duration_1;
                        content[3].delay -= duration_1;
                    });
                    particleMesh.minusTime(duration_1);
                    if (trailMesh) {
                        trailMesh.minusTime(duration_1);
                    }
                    this.onIterate(this);
                }
                else {
                    this.ended = true;
                    this.onEnd(this);
                    var endBehavior = options.endBehavior;
                    if (endBehavior === END_BEHAVIOR_FREEZE$1) {
                        this.frozen = true;
                    }
                }
            }
            else if (!options.looping) {
                if (this.reusable) ;
                else if (END_BEHAVIOR_DESTROY$1 === options.endBehavior) {
                    var node = link_1.last;
                    if (node && (node.content[0] - loopStartTime_1) < timePassed_1) {
                        this.onUpdate = function () { return _this.onDestroy(); };
                    }
                }
            }
            updateTrail();
        }
    };
    ParticleSystem.prototype.onDestroy = function () {
    };
    ParticleSystem.prototype.getParticleBoxes = function () {
        var link = this.particleLink;
        var mesh = this.particleMesh;
        var res = [];
        var maxCount = this.particleCount;
        var counter = 0;
        if (!(link && mesh)) {
            return res;
        }
        var node = link.last;
        var finish = false;
        while (!finish) {
            var currentTime = node.content[0];
            var point = node.content[3];
            if (currentTime > this.timePassed) {
                var pos = this.getPointPosition(point);
                res.push({
                    center: pos,
                    size: point.transform.scale,
                });
                if (node.pre) {
                    node = node.pre;
                }
                else {
                    finish = true;
                }
            }
            counter++;
            if (counter > maxCount) {
                finish = true;
            }
        }
        return res;
    };
    ParticleSystem.prototype.raycast = function (options) {
        var link = this.particleLink;
        var mesh = this.particleMesh;
        if (!(link && mesh)) {
            return;
        }
        var node = link.last;
        var hitPositions = [];
        var temp = new Vector3();
        var finish = false;
        if (node && node.content) {
            do {
                var _a = __read$3(node.content, 4), currentTime = _a[0], pointIndex = _a[1]; _a[2]; var point = _a[3];
                if (currentTime > this.timePassed) {
                    var pos = this.getPointPosition(point);
                    var ray = options.ray;
                    var pass = false;
                    if (ray) {
                        pass = !!ray.intersectSphere({
                            center: pos,
                            radius: options.radius,
                        }, temp);
                    }
                    if (pass) {
                        if (options.removeParticle) {
                            mesh.removePoint(pointIndex);
                            this.clearPointTrail(pointIndex);
                            node.content[0] = 0;
                        }
                        hitPositions.push(pos);
                        if (!options.multiple) {
                            finish = true;
                        }
                    }
                }
                else {
                    break;
                }
                // @ts-expect-error
            } while ((node = node.pre) && !finish);
        }
        return hitPositions;
    };
    ParticleSystem.prototype.clearPointTrail = function (pointIndex) {
        var _a;
        if (this.trails && this.trails.dieWithParticles) {
            (_a = this.trailMesh) === null || _a === void 0 ? void 0 : _a.clearTrail(pointIndex);
        }
    };
    ParticleSystem.prototype.updatePointTrail = function (pointIndex, emitterLifetime, point, startTime) {
        if (!this.trailMesh) {
            return;
        }
        var trails = this.trails;
        var particleMesh = this.particleMesh;
        var position = this.getPointPosition(point);
        var color = trails.inheritParticleColor ? particleMesh.getPointColor(pointIndex) : [1, 1, 1, 1];
        var size = point.transform.getWorldScale().toArray();
        var width = 1;
        var lifetime = trails.lifetime.getValue(emitterLifetime);
        if (trails.sizeAffectsWidth) {
            width *= size[0];
        }
        if (trails.sizeAffectsLifetime) {
            lifetime *= size[0];
        }
        if (trails.parentAffectsPosition && this.transform.parentTransform) {
            position.add(this.transform.parentTransform.position);
            var pos = this.trailMesh.getPointStartPos(pointIndex);
            if (pos) {
                position.subtract(pos);
            }
        }
        this.trailMesh.addPoint(pointIndex, position, {
            color: color,
            lifetime: lifetime,
            size: width,
            time: startTime,
        });
    };
    ParticleSystem.prototype.getPointPosition = function (point) {
        var transform = point.transform, vel = point.vel, lifetime = point.lifetime, delay = point.delay, _a = point.gravity, gravity = _a === void 0 ? [] : _a;
        var forceTarget = this.options.forceTarget;
        var time = this.lastUpdate - delay;
        var tempPos = new Vector3();
        var acc = Vector3.fromArray(gravity);
        transform.assignWorldTRS(tempPos);
        var ret = calculateTranslation(new Vector3(), this.options, acc, time, lifetime, tempPos, vel);
        if (forceTarget) {
            var target = forceTarget.target || [0, 0, 0];
            var life = forceTarget.curve.getValue(time / lifetime);
            var dl = 1 - life;
            ret.x = ret.x * dl + target[0] * life;
            ret.y = ret.y * dl + target[1] * life;
            ret.z = ret.z * dl + target[2] * life;
        }
        return ret;
    };
    ParticleSystem.prototype.onEnd = function (particle) {
    };
    ParticleSystem.prototype.onIterate = function (particle) {
    };
    ParticleSystem.prototype.initPoint = function (data) {
        var options = this.options;
        var lifetime = this.lifetime;
        var shape = this.shape;
        var speed = options.startSpeed.getValue(lifetime);
        var matrix4 = options.particleFollowParent ? this.transform.getMatrix() : this.transform.getWorldMatrix();
        // 粒子的位置受发射器的位置影响，自身的旋转和缩放不受影响
        var position = matrix4.transformPoint(data.position, new Vector3());
        var transform = new Transform({
            position: position,
            valid: true,
        });
        var direction = data.direction;
        direction = matrix4.transformNormal(direction, tempDir).normalize();
        if (options.startTurbulence && options.turbulence) {
            for (var i = 0; i < 3; i++) {
                tempVec3.setElement(i, options.turbulence[i].getValue(lifetime));
            }
            tempEuler.setFromVector3(tempVec3.negate());
            var mat4 = tempMat4.setFromEuler(tempEuler);
            mat4.transformNormal(direction).normalize();
        }
        var dirX = tmpDirX;
        var dirY = tmpDirY;
        if (shape.alignSpeedDirection) {
            dirY.copyFrom(direction);
            if (!this.upDirectionWorld) {
                if (shape.upDirection) {
                    this.upDirectionWorld = shape.upDirection.clone();
                }
                else {
                    this.upDirectionWorld = Vector3.Z.clone();
                }
                matrix4.transformNormal(this.upDirectionWorld);
            }
            dirX.crossVectors(dirY, this.upDirectionWorld).normalize();
            // FIXME: 原先因为有精度问题，这里dirX不是0向量
            if (dirX.isZero()) {
                dirX.set(1, 0, 0);
            }
        }
        else {
            dirX.set(1, 0, 0);
            dirY.set(0, 1, 0);
        }
        var sprite;
        var tsa = this.textureSheetAnimation;
        if (tsa && tsa.animate) {
            sprite = tempSprite;
            sprite[0] = tsa.animationDelay.getValue(lifetime);
            sprite[1] = tsa.animationDuration.getValue(lifetime);
            sprite[2] = tsa.cycles.getValue(lifetime);
        }
        var rot = tempRot;
        if (options.start3DRotation) {
            // @ts-expect-error
            rot.set(options.startRotationX.getValue(lifetime), options.startRotationY.getValue(lifetime), options.startRotationZ.getValue(lifetime));
        }
        else if (options.startRotation) {
            rot.set(0, 0, options.startRotation.getValue(lifetime));
        }
        else {
            rot.set(0, 0, 0);
        }
        transform.setRotation(rot.x, rot.y, rot.z);
        var color = options.startColor.getValue(lifetime);
        if (color.length === 3) {
            color[3] = 1;
        }
        var size = tempSize;
        if (options.start3DSize) {
            size.x = options.startSizeX.getValue(lifetime);
            size.y = options.startSizeY.getValue(lifetime);
        }
        else {
            var n = options.startSize.getValue(lifetime);
            var aspect = options.sizeAspect.getValue(lifetime);
            size.x = n;
            // 兼容aspect为0的情况
            size.y = aspect === 0 ? 0 : n / aspect;
            // size[1] = n / aspect;
        }
        var vel = direction.clone();
        vel.multiply(speed);
        // 粒子的大小受发射器父节点的影响
        if (!options.particleFollowParent) {
            var tempScale = new Vector3();
            this.transform.assignWorldTRS(undefined, undefined, tempScale);
            size.x *= tempScale.x;
            size.y *= tempScale.y;
        }
        transform.setScale(size.x, size.y, 1);
        return {
            size: size,
            vel: vel,
            color: color,
            delay: options.startDelay.getValue(lifetime),
            lifetime: options.startLifetime.getValue(lifetime),
            uv: randomArrItem(this.uvs, true),
            gravity: options.gravity,
            sprite: sprite,
            dirY: dirY,
            dirX: dirX,
            transform: transform,
        };
    };
    ParticleSystem.prototype.addBurst = function (burst, offsets) {
        var willAdd = false;
        if (!this.emission.bursts.includes(burst)) {
            this.emission.bursts.push(burst);
            willAdd = true;
        }
        if (willAdd && offsets instanceof Array) {
            var index = this.emission.bursts.indexOf(burst);
            this.emission.burstOffsets[index] = offsets;
            return index;
        }
        return -1;
    };
    ParticleSystem.prototype.removeBurst = function (index) {
        if (index < this.emission.bursts.length) {
            this.emission.burstOffsets[index] = null;
            this.emission.bursts.splice(index, 1);
        }
    };
    ParticleSystem.prototype.createPoint = function (lifetime) {
        var generator = {
            total: this.emission.rateOverTime.getValue(lifetime),
            index: this.generatedCount,
            burstIndex: 0,
            burstCount: 0,
        };
        this.generatedCount++;
        return this.initPoint(this.shape.generate(generator));
    };
    return ParticleSystem;
}());
// array performance better for small memory than Float32Array
var tempDir = new Vector3();
var tempSize = new Vector2();
var tempRot = new Euler();
var tmpDirX = new Vector3();
var tmpDirY = new Vector3();
var tempVec3 = new Vector3();
var tempEuler = new Euler();
var tempSprite = [0, 0, 0];
var tempMat4 = new Matrix4$1();
function getBurstOffsets(burstOffsets) {
    var ret = {};
    if (Array.isArray(burstOffsets)) {
        burstOffsets.forEach(function (arr) {
            var isArr = arr instanceof Array;
            var index = isArr ? arr[0] : arr.index;
            var offsets = ret[index];
            if (!offsets) {
                offsets = ret[index] = [];
            }
            if (isArr) {
                offsets.push(arr.slice(1, 4));
            }
            else {
                offsets.push([+arr.x, +arr.y, +arr.z]);
            }
        });
    }
    return ret;
}
function randomArrItem(arr, keepArr) {
    var index = Math.floor(Math.random() * arr.length);
    var item = arr[index];
    if (!keepArr) {
        arr.splice(index, 1);
    }
    return item;
}

var ParticleVFXItem = /** @class */ (function (_super) {
    __extends(ParticleVFXItem, _super);
    function ParticleVFXItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.destroyed = false;
        return _this;
    }
    Object.defineProperty(ParticleVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.particle;
        },
        enumerable: false,
        configurable: true
    });
    ParticleVFXItem.prototype.onConstructed = function (props) {
        this.particle = props.content;
        if (this.composition) {
            this._content = new ParticleSystem(this.particle, this.composition.getRendererOptions(), this);
        }
    };
    ParticleVFXItem.prototype.onLifetimeBegin = function (composition, particleSystem) {
        var _this = this;
        if (particleSystem) {
            particleSystem.name = this.name;
            particleSystem.start();
            particleSystem.onDestroy = function () {
                _this.destroyed = true;
            };
        }
        return particleSystem;
    };
    ParticleVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        if (this.content) {
            var hide = !this.visible;
            var parentItem = this.parentId && ((_a = this.composition) === null || _a === void 0 ? void 0 : _a.getItemByID(this.parentId));
            if (!hide && parentItem) {
                var parentData = parentItem.getRenderData();
                if (parentData) {
                    if (!parentData.visible) {
                        hide = false;
                    }
                }
            }
            if (hide) {
                this.content.setVisible(false);
            }
            else {
                this.content.setVisible(true);
                this.content.onUpdate(dt);
            }
        }
    };
    ParticleVFXItem.prototype.onItemRemoved = function (composition, content) {
        if (content) {
            composition.destroyTextures(content.getTextures());
            content.meshes.forEach(function (mesh) { return mesh.dispose({ material: { textures: exports.DestroyOptions.keep } }); });
        }
    };
    /**
     * @internal
     */
    ParticleVFXItem.prototype.setColor = function (r, g, b, a) {
        this.content.setColor(r, g, b, a);
    };
    ParticleVFXItem.prototype.setOpacity = function (opacity) {
        this.content.setOpacity(opacity);
    };
    ParticleVFXItem.prototype.stopParticleEmission = function () {
        if (this.content) {
            this.content.emissionStopped = true;
        }
    };
    ParticleVFXItem.prototype.resumeParticleEmission = function () {
        if (this.content) {
            this.content.emissionStopped = false;
        }
    };
    ParticleVFXItem.prototype.doCreateContent = function (composition) {
        if (!this.content) {
            return new ParticleSystem(this.particle, composition.getRendererOptions(), this);
        }
        else {
            return this.content;
        }
    };
    ParticleVFXItem.prototype.isEnded = function (now) {
        return _super.prototype.isEnded.call(this, now) && this.destroyed;
    };
    ParticleVFXItem.prototype.getBoundingBox = function () {
        var pt = this.content;
        if (!pt) {
            return;
        }
        else {
            var area = pt.getParticleBoxes();
            return {
                type: exports.HitTestType.sphere,
                area: area,
            };
        }
    };
    ParticleVFXItem.prototype.getHitTestParams = function (force) {
        var _this = this;
        var _a;
        var interactParams = (_a = this.content) === null || _a === void 0 ? void 0 : _a.interaction;
        if (force || interactParams) {
            return {
                type: exports.HitTestType.custom,
                collect: function (ray) {
                    var _a;
                    return (_a = _this.content) === null || _a === void 0 ? void 0 : _a.raycast({
                        radius: (interactParams === null || interactParams === void 0 ? void 0 : interactParams.radius) || 0.4,
                        multiple: !!(interactParams === null || interactParams === void 0 ? void 0 : interactParams.multiple),
                        removeParticle: (interactParams === null || interactParams === void 0 ? void 0 : interactParams.behavior) === ParticleInteractionBehavior$1.removeParticle,
                        ray: ray,
                    });
                },
            };
        }
    };
    return ParticleVFXItem;
}(VFXItem));
var particleUniformTypeMap = {
    'uSprite': 'vec4',
    'uParams': 'vec4',
    'uAcceleration': 'vec4',
    'uGravityModifierValue': 'vec4',
    'uOpacityOverLifetimeValue': 'vec4',
    'uRXByLifeTimeValue': 'vec4',
    'uRYByLifeTimeValue': 'vec4',
    'uRZByLifeTimeValue': 'vec4',
    'uLinearXByLifetimeValue': 'vec4',
    'uLinearYByLifetimeValue': 'vec4',
    'uLinearZByLifetimeValue': 'vec4',
    'uSpeedLifetimeValue': 'vec4',
    'uOrbXByLifetimeValue': 'vec4',
    'uOrbYByLifetimeValue': 'vec4',
    'uOrbZByLifetimeValue': 'vec4',
    'uSizeByLifetimeValue': 'vec4',
    'uSizeYByLifetimeValue': 'vec4',
    'uColorParams': 'vec4',
    'uFSprite': 'vec4',
    'uPreviewColor': 'vec4',
    'uVCurveValues': 'vec4Array',
    'uFCurveValues': 'vec4',
    'uFinalTarget': 'vec3',
    'uForceCurve': 'vec4',
    'uOrbCenter': 'vec3',
    'uTexOffset': 'vec2',
    'uPeriodValue': 'vec4',
    'uMovementValue': 'vec4',
    'uStrengthValue': 'vec4',
    'uWaveParams': 'vec4',
};

var ParticleMesh = /** @class */ (function () {
    function ParticleMesh(props, rendererOptions) {
        var _a, _b, _c, _d;
        this.particleCount = 0;
        var engine = rendererOptions.composition.getEngine();
        var env = ((_a = engine.renderer) !== null && _a !== void 0 ? _a : {}).env;
        var speedOverLifetime = props.speedOverLifetime, colorOverLifetime = props.colorOverLifetime, linearVelOverLifetime = props.linearVelOverLifetime, orbitalVelOverLifetime = props.orbitalVelOverLifetime, sizeOverLifetime = props.sizeOverLifetime, rotationOverLifetime = props.rotationOverLifetime, sprite = props.sprite, gravityModifier = props.gravityModifier, maxCount = props.maxCount, duration = props.duration, textureFlip = props.textureFlip, useSprite = props.useSprite, name = props.name, filter = props.filter, gravity = props.gravity, forceTarget = props.forceTarget, side = props.side, occlusion = props.occlusion, anchor = props.anchor, blending = props.blending, maskMode = props.maskMode, mask = props.mask, transparentOcclusion = props.transparentOcclusion, listIndex = props.listIndex, meshSlots = props.meshSlots, _e = props.renderMode, renderMode = _e === void 0 ? 0 : _e, _f = props.diffuse, diffuse = _f === void 0 ? Texture.createWithData(engine) : _f;
        var detail = engine.gpuCapability.detail;
        var halfFloatTexture = detail.halfFloatTexture, maxVertexUniforms = detail.maxVertexUniforms;
        var marcos = [
            ['RENDER_MODE', +renderMode],
            ['PRE_MULTIPLY_ALPHA', false],
            ['ENV_EDITOR', env === PLAYER_OPTIONS_ENV_EDITOR],
        ];
        var level = engine.gpuCapability.level;
        var vertexKeyFrameMeta = createKeyFrameMeta();
        var fragmentKeyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = maxVertexUniforms > 0;
        var uniformValues = {};
        var vertex_lookup_texture = 0;
        var shaderCacheId = 0;
        var particleDefine;
        var useOrbitalVel;
        this.useSprite = useSprite;
        if (enableVertexTexture) {
            marcos.push(['ENABLE_VERTEX_TEXTURE', true]);
        }
        if (speedOverLifetime) {
            marcos.push(['SPEED_OVER_LIFETIME', true]);
            shaderCacheId |= 1 << 1;
            uniformValues.uSpeedLifetimeValue = speedOverLifetime.toUniform(vertexKeyFrameMeta);
        }
        if (sprite === null || sprite === void 0 ? void 0 : sprite.animate) {
            marcos.push(['USE_SPRITE', true]);
            shaderCacheId |= 1 << 2;
            uniformValues.uFSprite = uniformValues.uSprite = new Float32Array([sprite.col, sprite.row, sprite.total, sprite.blend ? 1 : 0]);
            this.useSprite = true;
        }
        if (filter && filter.name !== FILTER_NAME_NONE) {
            marcos.push(['USE_FILTER', true]);
            shaderCacheId |= 1 << 3;
            var filterDefine = createFilter(filter, rendererOptions.composition);
            if (!filterDefine.particle) {
                throw new Error("particle filter ".concat(filter.name, " not implement"));
            }
            particleDefine = filterDefine.particle;
            Object.keys((_b = particleDefine.uniforms) !== null && _b !== void 0 ? _b : {}).forEach(function (uName) {
                var _a;
                var getter = (_a = particleDefine.uniforms) === null || _a === void 0 ? void 0 : _a[uName];
                if (uniformValues[uName]) {
                    throw new Error('conflict uniform name:' + uName);
                }
                uniformValues[uName] = getter === null || getter === void 0 ? void 0 : getter.toUniform(vertexKeyFrameMeta);
            });
            Object.keys((_c = particleDefine.uniformValues) !== null && _c !== void 0 ? _c : {}).forEach(function (uName) {
                var _a;
                var val = (_a = particleDefine.uniformValues) === null || _a === void 0 ? void 0 : _a[uName];
                if (uniformValues[uName]) {
                    throw new Error('conflict uniform name:' + uName);
                }
                uniformValues[uName] = val;
            });
        }
        if (colorOverLifetime === null || colorOverLifetime === void 0 ? void 0 : colorOverLifetime.color) {
            marcos.push(['COLOR_OVER_LIFETIME', true]);
            shaderCacheId |= 1 << 4;
            uniformValues.uColorOverLifetime = colorOverLifetime.color instanceof Texture ? colorOverLifetime.color : Texture.createWithData(engine, imageDataFromGradient(colorOverLifetime.color));
        }
        if (colorOverLifetime === null || colorOverLifetime === void 0 ? void 0 : colorOverLifetime.opacity) {
            uniformValues.uOpacityOverLifetimeValue = colorOverLifetime.opacity.toUniform(vertexKeyFrameMeta);
        }
        else {
            uniformValues.uOpacityOverLifetimeValue = createValueGetter(1).toUniform(vertexKeyFrameMeta);
        }
        ['x', 'y', 'z'].forEach(function (pro, i) {
            var defL = 0;
            var defO = 0;
            if (linearVelOverLifetime === null || linearVelOverLifetime === void 0 ? void 0 : linearVelOverLifetime[pro]) {
                uniformValues["uLinear".concat(pro.toUpperCase(), "ByLifetimeValue")] = linearVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defL = 1;
                shaderCacheId |= 1 << (7 + i);
                linearVelOverLifetime.enabled = true;
            }
            marcos.push(["LINEAR_VEL_".concat(pro.toUpperCase()), defL]);
            if (orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime[pro]) {
                uniformValues["uOrb".concat(pro.toUpperCase(), "ByLifetimeValue")] = orbitalVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defO = 1;
                shaderCacheId |= 1 << (10 + i);
                useOrbitalVel = true;
                orbitalVelOverLifetime.enabled = true;
            }
            marcos.push(["ORB_VEL_".concat(pro.toUpperCase()), defO]);
        });
        if (linearVelOverLifetime === null || linearVelOverLifetime === void 0 ? void 0 : linearVelOverLifetime.asMovement) {
            marcos.push(['AS_LINEAR_MOVEMENT', true]);
            shaderCacheId |= 1 << 5;
        }
        if (useOrbitalVel) {
            if (orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime.asRotation) {
                marcos.push(['AS_ORBITAL_MOVEMENT', true]);
                shaderCacheId |= 1 << 6;
            }
            uniformValues.uOrbCenter = new Float32Array((orbitalVelOverLifetime === null || orbitalVelOverLifetime === void 0 ? void 0 : orbitalVelOverLifetime.center) || [0, 0, 0]);
        }
        uniformValues.uSizeByLifetimeValue = sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.x.toUniform(vertexKeyFrameMeta);
        if (sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.separateAxes) {
            marcos.push(['SIZE_Y_BY_LIFE', 1]);
            shaderCacheId |= 1 << 14;
            uniformValues.uSizeYByLifetimeValue = (_d = sizeOverLifetime === null || sizeOverLifetime === void 0 ? void 0 : sizeOverLifetime.y) === null || _d === void 0 ? void 0 : _d.toUniform(vertexKeyFrameMeta);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.z) {
            uniformValues.uRZByLifeTimeValue = rotationOverLifetime.z.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 15;
            marcos.push(['ROT_Z_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.x) {
            uniformValues.uRXByLifeTimeValue = rotationOverLifetime.x.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 16;
            marcos.push(['ROT_X_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.y) {
            uniformValues.uRYByLifeTimeValue = rotationOverLifetime.y.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 17;
            marcos.push(['ROT_Y_LIFETIME', 1]);
        }
        if (rotationOverLifetime === null || rotationOverLifetime === void 0 ? void 0 : rotationOverLifetime.asRotation) {
            marcos.push(['ROT_LIFETIME_AS_MOVEMENT', 1]);
            shaderCacheId |= 1 << 18;
        }
        uniformValues.uGravityModifierValue = gravityModifier.toUniform(vertexKeyFrameMeta);
        if (forceTarget) {
            marcos.push(['FINAL_TARGET', true]);
            shaderCacheId |= 1 << 19;
            uniformValues.uFinalTarget = new Float32Array(forceTarget.target || [0, 0, 0]);
            uniformValues.uForceCurve = forceTarget.curve.toUniform(vertexKeyFrameMeta);
        }
        if (halfFloatTexture && fragmentKeyFrameMeta.max) {
            shaderCacheId |= 1 << 20;
            uniformValues.uFCurveValueTexture = generateHalfFloatTexture(engine, ValueGetter.getAllData(fragmentKeyFrameMeta, true), fragmentKeyFrameMeta.index, 1);
        }
        else {
            uniformValues.uFCurveValues = ValueGetter.getAllData(fragmentKeyFrameMeta);
        }
        var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
        // if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        //   vertexCurveTexture = true;
        // }
        if (level === 2) {
            vertexKeyFrameMeta.max = -1;
            vertexKeyFrameMeta.index = meshSlots ? meshSlots[0] : getSlot(vertexKeyFrameMeta.index);
            if (fragmentKeyFrameMeta.index > 0) {
                fragmentKeyFrameMeta.max = -1;
                fragmentKeyFrameMeta.index = meshSlots ? meshSlots[1] : getSlot(fragmentKeyFrameMeta.index);
            }
        }
        if (vertexCurveTexture && halfFloatTexture && enableVertexTexture) {
            var tex = generateHalfFloatTexture(engine, ValueGetter.getAllData(vertexKeyFrameMeta, true), vertexKeyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
            vertex_lookup_texture = 1;
        }
        else {
            uniformValues.uVCurveValues = ValueGetter.getAllData(vertexKeyFrameMeta);
        }
        var shaderCache = ['-p:', renderMode, shaderCacheId, vertexKeyFrameMeta.index, vertexKeyFrameMeta.max, fragmentKeyFrameMeta.index, fragmentKeyFrameMeta.max].join('+');
        marcos.push(['VERT_CURVE_VALUE_COUNT', vertexKeyFrameMeta.index], ['FRAG_CURVE_VALUE_COUNT', fragmentKeyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', vertexKeyFrameMeta.max], ['FRAG_MAX_KEY_FRAME_COUNT', fragmentKeyFrameMeta.max]);
        var fragment = filter ? particleFrag.replace(/#pragma\s+FILTER_FRAG/, particleDefine.fragment) : particleFrag;
        var originalVertex = "#define LOOKUP_TEXTURE_CURVE ".concat(vertex_lookup_texture, "\n").concat(particleVert);
        var vertex = filter ? originalVertex.replace(/#pragma\s+FILTER_VERT/, particleDefine.vertex || 'void filterMain(float t){}\n') : originalVertex;
        var shader = {
            fragment: createShaderWithMarcos(marcos, fragment, exports.ShaderType.fragment, level),
            vertex: createShaderWithMarcos(marcos, vertex, exports.ShaderType.vertex, level),
            glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
            shared: true,
            cacheId: shaderCache,
            marcos: marcos,
            name: "particle#".concat(name),
        };
        if (filter) {
            shader.cacheId += filter.name;
        }
        var mtlOptions = {
            shader: shader,
            uniformSemantics: {
                effects_MatrixV: 'VIEW',
                effects_MatrixVP: 'VIEWPROJECTION',
                uEditorTransform: 'EDITOR_TRANSFORM',
                effects_ObjectToWorld: 'MODEL',
            },
        };
        var preMulAlpha = getPreMultiAlpha(blending);
        uniformValues.uTexOffset = new Float32Array(diffuse ? [1 / diffuse.getWidth(), 1 / diffuse.getHeight()] : [0, 0]);
        uniformValues.uMaskTex = diffuse;
        uniformValues.uColorParams = new Float32Array([diffuse ? 1 : 0, +preMulAlpha, 0, +(!!occlusion && !transparentOcclusion)]);
        uniformValues.uParams = [0, duration, 0, 0];
        uniformValues.uAcceleration = [(gravity === null || gravity === void 0 ? void 0 : gravity[0]) || 0, (gravity === null || gravity === void 0 ? void 0 : gravity[1]) || 0, (gravity === null || gravity === void 0 ? void 0 : gravity[2]) || 0, 0];
        // mtlOptions.uniformValues = uniformValues;
        var material = Material.create(engine, mtlOptions);
        material.blending = true;
        material.depthTest = true;
        material.depthMask = !!(occlusion);
        material.stencilRef = mask ? [mask, mask] : undefined;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        setSideMode(material, side);
        Object.keys(uniformValues).map(function (name) {
            var value = uniformValues[name];
            if (value instanceof Texture) {
                material.setTexture(name, value);
                return;
            }
            var res = [];
            switch (particleUniformTypeMap[name]) {
                case 'vec4':
                    material.setVector4(name, Vector4$1.fromArray(value));
                    break;
                case 'vec3':
                    material.setVector3(name, Vector3.fromArray(value));
                    break;
                case 'vec2':
                    material.setVector2(name, Vector2.fromArray(value));
                    break;
                case 'vec4Array':
                    for (var i = 0; i < value.length; i = i + 4) {
                        var v = new Vector4$1(value[i], value[i + 1], value[i + 2], value[i + 3]);
                        res.push(v);
                    }
                    material.setVector4Array(name, res);
                    res.length = 0;
                    break;
                default:
                    console.warn("uniform ".concat(name, "'s type not in typeMap"));
            }
        });
        material.setVector3('emissionColor', new Vector3(0, 0, 0));
        material.setFloat('emissionIntensity', 0.0);
        var geometry = Geometry.create(engine, generateGeometryProps(maxCount * 4, this.useSprite, "particle#".concat(name)));
        var mesh = Mesh.create(engine, {
            name: "MParticle_".concat(name),
            priority: listIndex,
            material: material,
            geometry: geometry,
        });
        this.anchor = anchor;
        this.mesh = mesh;
        this.geometry = mesh.firstGeometry();
        this.forceTarget = forceTarget;
        this.sizeOverLifetime = sizeOverLifetime;
        this.speedOverLifetime = speedOverLifetime;
        this.linearVelOverLifetime = linearVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.gravityModifier = gravityModifier;
        this.maxCount = maxCount;
        this.duration = duration;
        this.textureOffsets = textureFlip ? [0, 0, 1, 0, 0, 1, 1, 1] : [0, 1, 0, 0, 1, 1, 1, 0];
    }
    Object.defineProperty(ParticleMesh.prototype, "time", {
        get: function () {
            var value = this.mesh.material.getVector4('uParams');
            return value.x;
        },
        set: function (v) {
            this.mesh.material.setVector4('uParams', new Vector4$1(+v, this.duration, 0, 0));
        },
        enumerable: false,
        configurable: true
    });
    ParticleMesh.prototype.getPointColor = function (index) {
        var data = this.geometry.getAttributeData('aRot');
        var i = index * 32 + 4;
        return [data[i], data[i + 1], data[i + 2], data[i + 3]];
    };
    /**
     * 待废弃
     * @deprecated - 使用 `particle-system.getPointPosition` 替代
     */
    ParticleMesh.prototype.getPointPosition = function (index) {
        var geo = this.geometry;
        var posIndex = index * 48;
        var posData = geo.getAttributeData('aPos');
        var offsetData = geo.getAttributeData('aOffset');
        var time = this.time - offsetData[index * 16 + 2];
        var pointDur = offsetData[index * 16 + 3];
        var mtl = this.mesh.material;
        var acc = mtl.getVector4('uAcceleration').toVector3();
        var pos = Vector3.fromArray(posData, posIndex);
        var vel = Vector3.fromArray(posData, posIndex + 3);
        var ret = calculateTranslation(new Vector3(), this, acc, time, pointDur, pos, vel);
        if (this.forceTarget) {
            var target = mtl.getVector3('uFinalTarget');
            var life = this.forceTarget.curve.getValue(time / pointDur);
            var dl = 1 - life;
            ret.x = ret.x * dl + target.x * life;
            ret.y = ret.y * dl + target.y * life;
            ret.z = ret.z * dl + target.z * life;
        }
        return ret;
    };
    ParticleMesh.prototype.clearPoints = function () {
        this.resetGeometryData(this.geometry);
        this.particleCount = 0;
        this.geometry.setDrawCount(0);
        this.maxParticleBufferCount = 0;
    };
    ParticleMesh.prototype.resetGeometryData = function (geometry) {
        var names = geometry.getAttributeNames();
        var index = geometry.getIndexData();
        for (var i = 0; i < names.length; i++) {
            var name_1 = names[i];
            var data = geometry.getAttributeData(name_1);
            if (data) {
                // @ts-expect-error
                geometry.setAttributeData(name_1, new data.constructor(0));
            }
        }
        // @ts-expect-error
        geometry.setIndexData(new index.constructor(0));
    };
    ParticleMesh.prototype.minusTime = function (time) {
        var data = this.geometry.getAttributeData('aOffset');
        for (var i = 0; i < data.length; i += 4) {
            data[i + 2] -= time;
        }
        this.geometry.setAttributeData('aOffset', data);
        this.time -= time;
    };
    ParticleMesh.prototype.removePoint = function (index) {
        if (index < this.particleCount) {
            this.geometry.setAttributeSubData('aOffset', index * 16, new Float32Array(16));
        }
    };
    ParticleMesh.prototype.setPoint = function (point, index) {
        var maxCount = this.maxCount;
        if (index < maxCount) {
            var particleCount = index + 1;
            var vertexCount_1 = particleCount * 4;
            var geometry_1 = this.geometry;
            var increaseBuffer_1 = particleCount > this.maxParticleBufferCount;
            var inc_1 = 1;
            if (this.particleCount > 300) {
                inc_1 = (this.particleCount + 100) / this.particleCount;
            }
            else if (this.particleCount > 100) {
                inc_1 = 1.4;
            }
            else if (this.particleCount > 0) {
                inc_1 = 2;
            }
            var pointData_1 = {
                aPos: new Float32Array(48),
                aRot: new Float32Array(32),
                aOffset: new Float32Array(16),
            };
            var useSprite = this.useSprite;
            if (useSprite) {
                pointData_1.aSprite = new Float32Array(12);
            }
            var tempPos = new Vector3();
            var tempQuat = new Quaternion();
            var scale = new Vector3(1, 1, 1);
            point.transform.assignWorldTRS(tempPos, tempQuat, scale);
            var tempEuler = Transform.getRotation(tempQuat, new Euler());
            var position = tempPos.toArray();
            var rotation = tempEuler.toArray();
            var offsets = this.textureOffsets;
            var off = [0, 0, point.delay, point.lifetime];
            var wholeUV = [0, 0, 1, 1];
            var vel = point.vel;
            var color = point.color;
            var sizeOffsets = [-.5, .5, -.5, -.5, .5, .5, .5, -.5];
            var seed = Math.random();
            var sprite = void 0;
            if (useSprite) {
                sprite = point.sprite;
            }
            for (var j = 0; j < 4; j++) {
                var offset = j * 2;
                var j3 = j * 3;
                var j4 = j * 4;
                var j12 = j * 12;
                var j8 = j * 8;
                pointData_1.aPos.set(position, j12);
                vel.fill(pointData_1.aPos, j12 + 3);
                pointData_1.aRot.set(rotation, j8);
                pointData_1.aRot[j8 + 3] = seed;
                pointData_1.aRot.set(color, j8 + 4);
                if (useSprite) {
                    // @ts-expect-error
                    pointData_1.aSprite.set(sprite, j3);
                }
                var uv = point.uv || wholeUV;
                if (uv) {
                    var uvy = useSprite ? (1 - offsets[offset + 1]) : offsets[offset + 1];
                    off[0] = uv[0] + offsets[offset] * uv[2];
                    off[1] = uv[1] + uvy * uv[3];
                }
                pointData_1.aOffset.set(off, j4);
                var ji = (j + j);
                var sx = (sizeOffsets[ji] - this.anchor.x) * scale.x;
                var sy = (sizeOffsets[ji + 1] - this.anchor.y) * scale.y;
                for (var k = 0; k < 3; k++) {
                    pointData_1.aPos[j12 + 6 + k] = point.dirX.getElement(k) * sx;
                    pointData_1.aPos[j12 + 9 + k] = point.dirY.getElement(k) * sy;
                }
            }
            var indexData = new Uint16Array([0, 1, 2, 2, 1, 3].map(function (x) { return x + index * 4; }));
            if (increaseBuffer_1) {
                var baseIndexData = geometry_1.getIndexData();
                var idx = enlargeBuffer(baseIndexData, particleCount * 6, inc_1, maxCount * 6);
                idx.set(indexData, index * 6);
                geometry_1.setIndexData(idx);
                this.maxParticleBufferCount = idx.length / 6;
            }
            else {
                geometry_1.setIndexSubData(index * 6, indexData);
            }
            Object.keys(pointData_1).forEach(function (name) {
                var data = pointData_1[name];
                var attrSize = geometry_1.getAttributeStride(name) / Float32Array.BYTES_PER_ELEMENT;
                if (increaseBuffer_1) {
                    var baseData = geometry_1.getAttributeData(name);
                    var geoData = enlargeBuffer(baseData, vertexCount_1 * attrSize, inc_1, maxCount * 4 * attrSize);
                    geoData.set(data, data.length * index);
                    geometry_1.setAttributeData(name, geoData);
                }
                else {
                    geometry_1.setAttributeSubData(name, data.length * index, data);
                }
            });
            this.particleCount = Math.max(particleCount, this.particleCount);
            geometry_1.setDrawCount(this.particleCount * 6);
        }
    };
    return ParticleMesh;
}());
var gl2UniformSlots = [10, 32, 64, 160];
function getSlot(count) {
    for (var w = 0; w < gl2UniformSlots.length; w++) {
        var slot = gl2UniformSlots[w];
        if (slot > count) {
            return slot;
        }
    }
    return count || gl2UniformSlots[0];
}
function generateGeometryProps(maxVertex, useSprite, name) {
    var bpe = Float32Array.BYTES_PER_ELEMENT;
    var j12 = bpe * 12;
    var attributes = {
        aPos: { size: 3, offset: 0, stride: j12, data: new Float32Array(0) },
        aVel: { size: 3, offset: 3 * bpe, stride: j12, dataSource: 'aPos' },
        aDirX: { size: 3, offset: 6 * bpe, stride: j12, dataSource: 'aPos' },
        aDirY: { size: 3, offset: 9 * bpe, stride: j12, dataSource: 'aPos' },
        //
        aRot: { size: 3, offset: 0, stride: 8 * bpe, data: new Float32Array(0) },
        aSeed: { size: 1, offset: 3 * bpe, stride: 8 * bpe, dataSource: 'aRot' },
        aColor: { size: 4, offset: 4 * bpe, stride: 8 * bpe, dataSource: 'aRot' },
        //
        aOffset: { size: 4, stride: 4 * bpe, data: new Float32Array(0) },
    };
    if (useSprite) {
        attributes['aSprite'] = { size: 3, data: new Float32Array(0) };
    }
    return { attributes: attributes, indices: { data: new Uint16Array(0) }, name: name, maxVertex: maxVertex };
}
function getParticleMeshShader(item, env, gpuCapability) {
    var _a, _b, _c, _d, _e;
    if (env === void 0) { env = ''; }
    var props = item.content;
    var renderMode = +(((_a = props.renderer) === null || _a === void 0 ? void 0 : _a.renderMode) || 0);
    var marcos = [
        ['RENDER_MODE', renderMode],
        ['PRE_MULTIPLY_ALPHA', false],
        ['ENV_EDITOR', env === PLAYER_OPTIONS_ENV_EDITOR],
    ];
    var level = gpuCapability.level, detail = gpuCapability.detail;
    var vertexKeyFrameMeta = createKeyFrameMeta();
    var fragmentKeyFrameMeta = createKeyFrameMeta();
    var enableVertexTexture = detail.maxVertexUniforms > 0;
    var speedOverLifetime = ((_b = props.positionOverLifetime) !== null && _b !== void 0 ? _b : {}).speedOverLifetime;
    var vertex_lookup_texture = 0;
    var shaderCacheId = 0;
    if (enableVertexTexture) {
        marcos.push(['ENABLE_VERTEX_TEXTURE', true]);
    }
    if (speedOverLifetime) {
        marcos.push(['SPEED_OVER_LIFETIME', true]);
        shaderCacheId |= 1 << 1;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, speedOverLifetime);
    }
    var sprite = props.textureSheetAnimation;
    if (sprite && sprite.animate) {
        marcos.push(['USE_SPRITE', true]);
        shaderCacheId |= 1 << 2;
    }
    var filter = undefined;
    if (props.filter && props.filter.name !== FILTER_NAME_NONE) {
        marcos.push(['USE_FILTER', true]);
        shaderCacheId |= 1 << 3;
        var f = createFilterShaders(props.filter).find(function (f) { return f.isParticle; });
        if (!f) {
            throw Error("particle filter ".concat(props.filter.name, " not implement"));
        }
        filter = f;
        (_c = f.uniforms) === null || _c === void 0 ? void 0 : _c.forEach(function (val) { return getKeyFrameMetaByRawValue(vertexKeyFrameMeta, val); });
        // filter = processFilter(props.filter, fragmentKeyFrameMeta, vertexKeyFrameMeta, options);
    }
    var colorOverLifetime = props.colorOverLifetime;
    if (colorOverLifetime && colorOverLifetime.color) {
        marcos.push(['COLOR_OVER_LIFETIME', true]);
        shaderCacheId |= 1 << 4;
    }
    var opacity = colorOverLifetime && colorOverLifetime.opacity;
    if (opacity) {
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, opacity);
    }
    var positionOverLifetime = props.positionOverLifetime;
    var useOrbitalVel;
    ['x', 'y', 'z'].forEach(function (pro, i) {
        var defL = 0;
        var linearPro = 'linear' + pro.toUpperCase();
        var orbitalPro = 'orbital' + pro.toUpperCase();
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime[linearPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[linearPro]);
            defL = 1;
            shaderCacheId |= 1 << (7 + i);
        }
        marcos.push(["LINEAR_VEL_".concat(pro.toUpperCase()), defL]);
        var defO = 0;
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime[orbitalPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[orbitalPro]);
            defO = 1;
            shaderCacheId |= 1 << (10 + i);
            useOrbitalVel = true;
        }
        marcos.push(["ORB_VEL_".concat(pro.toUpperCase()), defO]);
    });
    if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.asMovement) {
        marcos.push(['AS_LINEAR_MOVEMENT', true]);
        shaderCacheId |= 1 << 5;
    }
    if (useOrbitalVel) {
        if (positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.asRotation) {
            marcos.push(['AS_ORBITAL_MOVEMENT', true]);
            shaderCacheId |= 1 << 6;
        }
    }
    if (props.sizeOverLifetime) {
        var sizeOverLifetime = props.sizeOverLifetime;
        var separateAxes = sizeOverLifetime.separateAxes;
        if (separateAxes) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.x);
            marcos.push(['SIZE_Y_BY_LIFE', 1]);
            shaderCacheId |= 1 << 14;
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.y);
        }
        else {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.size);
        }
    }
    if (props.rotationOverLifetime) {
        var rot = props.rotationOverLifetime;
        if (rot.z) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot === null || rot === void 0 ? void 0 : rot.z);
            shaderCacheId |= 1 << 15;
            marcos.push(['ROT_Z_LIFETIME', 1]);
        }
        if (rot.separateAxes) {
            if (rot.x) {
                getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.x);
                shaderCacheId |= 1 << 16;
                marcos.push(['ROT_X_LIFETIME', 1]);
            }
            if (rot.y) {
                getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.y);
                shaderCacheId |= 1 << 17;
                marcos.push(['ROT_Y_LIFETIME', 1]);
            }
        }
        if (rot === null || rot === void 0 ? void 0 : rot.asRotation) {
            marcos.push(['ROT_LIFETIME_AS_MOVEMENT', 1]);
            shaderCacheId |= 1 << 18;
        }
    }
    getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.gravityOverLifetime);
    var forceOpt = positionOverLifetime === null || positionOverLifetime === void 0 ? void 0 : positionOverLifetime.forceTarget;
    if (forceOpt) {
        marcos.push(['FINAL_TARGET', true]);
        shaderCacheId |= 1 << 19;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime.forceCurve);
    }
    var HALF_FLOAT = detail.halfFloatTexture;
    if (HALF_FLOAT && fragmentKeyFrameMeta.max) {
        shaderCacheId |= 1 << 20;
    }
    var maxVertexUniforms = detail.maxVertexUniforms;
    var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
    if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        vertexCurveTexture = true;
    }
    if (level === 2) {
        vertexKeyFrameMeta.max = -1;
        // vertexKeyFrameMeta.index = getSlot(vertexKeyFrameMeta.index);
        if (fragmentKeyFrameMeta.index > 0) {
            fragmentKeyFrameMeta.max = -1;
            // fragmentKeyFrameMeta.index = getSlot(fragmentKeyFrameMeta.index);
        }
    }
    if (vertexCurveTexture && HALF_FLOAT && enableVertexTexture) {
        vertex_lookup_texture = 1;
    }
    var shaderCache = ['-p:', renderMode, shaderCacheId, vertexKeyFrameMeta.index, vertexKeyFrameMeta.max, fragmentKeyFrameMeta.index, fragmentKeyFrameMeta.max].join('+');
    var shader = {
        fragment: particleFrag,
        vertex: "#define LOOKUP_TEXTURE_CURVE ".concat(vertex_lookup_texture, "\n").concat(particleVert),
        shared: true,
        cacheId: shaderCache,
        marcos: marcos,
        name: "particle#".concat(item.name),
    };
    if (filter) {
        shader.fragment = shader.fragment.replace(/#pragma\s+FILTER_FRAG/, (_d = filter.fragment) !== null && _d !== void 0 ? _d : '');
        shader.vertex = shader.vertex.replace(/#pragma\s+FILTER_VERT/, filter.vertex || 'void filterMain(float t){}\n');
        shader.cacheId += '+' + ((_e = props.filter) === null || _e === void 0 ? void 0 : _e.name);
    }
    marcos.push(['VERT_CURVE_VALUE_COUNT', vertexKeyFrameMeta.index], ['FRAG_CURVE_VALUE_COUNT', fragmentKeyFrameMeta.index], ['VERT_MAX_KEY_FRAME_COUNT', vertexKeyFrameMeta.max], ['FRAG_MAX_KEY_FRAME_COUNT', fragmentKeyFrameMeta.max]);
    return { shader: shader, vertex: vertexKeyFrameMeta.index, fragment: fragmentKeyFrameMeta.index };
}
function modifyMaxKeyframeShader(shader, maxVertex, maxFrag) {
    var _a;
    var shaderIds = (_a = shader.cacheId) === null || _a === void 0 ? void 0 : _a.split('+');
    shaderIds[3] = maxVertex;
    shaderIds[5] = maxFrag;
    shader.cacheId = shaderIds.join('+');
    if (!shader.marcos) {
        return;
    }
    for (var i = 0; i < shader.marcos.length; i++) {
        var marco = shader.marcos[i];
        if (marco[0] === 'VERT_CURVE_VALUE_COUNT') {
            marco[1] = maxVertex;
        }
        else if (marco[0] === 'FRAG_CURVE_VALUE_COUNT') {
            marco[1] = maxFrag;
            break;
        }
    }
}

var ParticleLoader = /** @class */ (function (_super) {
    __extends(ParticleLoader, _super);
    function ParticleLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.meshes = [];
        return _this;
    }
    ParticleLoader.precompile = function (compositions, renderer, options) {
        var gpuCapability = renderer.engine.gpuCapability;
        var level = gpuCapability.level;
        var env = (options !== null && options !== void 0 ? options : {}).env;
        var shaderLibrary = renderer.getShaderLibrary();
        var items = [];
        var shaders = [];
        var maxFragmentCount = 0;
        var maxVertexCount = 0;
        // 增加预合成中的粒子处理
        compositions.forEach(function (comp) {
            comp.items.forEach(function (item) {
                if (exports.Item.isParticle(item)) {
                    items.push(item);
                }
            });
        });
        items.forEach(function (item) {
            var _a, _b;
            var _c = getParticleMeshShader(item, env, gpuCapability), shader = _c.shader, fragment = _c.fragment, vertex = _c.vertex;
            shaders.push(shader);
            maxFragmentCount = Math.max(maxFragmentCount, fragment);
            maxVertexCount = Math.max(maxVertexCount, vertex);
            // TODO 此处add是否有意义？shader变量似乎没有加到this.shaders数组。
            if (item.content.trails) {
                var shader_1 = getTrailMeshShader(item.content.trails, item.content.options.maxCount, item.name, env, gpuCapability);
                shader_1.vertex = createShaderWithMarcos((_a = shader_1.marcos) !== null && _a !== void 0 ? _a : [], shader_1.vertex, exports.ShaderType.vertex, level);
                shader_1.fragment = createShaderWithMarcos((_b = shader_1.marcos) !== null && _b !== void 0 ? _b : [], shader_1.fragment, exports.ShaderType.fragment, level);
                shader_1.glslVersion = level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1;
                shaderLibrary.addShader(shader_1);
            }
        });
        shaders.forEach(function (shader) {
            var _a, _b;
            if (level === 2) {
                modifyMaxKeyframeShader(shader, maxVertexCount, maxFragmentCount);
                shader.glslVersion = exports.GLSLVersion.GLSL3;
            }
            else {
                shader.glslVersion = exports.GLSLVersion.GLSL1;
            }
            shader.vertex = createShaderWithMarcos((_a = shader.marcos) !== null && _a !== void 0 ? _a : [], shader.vertex, exports.ShaderType.vertex, level);
            shader.fragment = createShaderWithMarcos((_b = shader.marcos) !== null && _b !== void 0 ? _b : [], shader.fragment, exports.ShaderType.fragment, level);
            shaderLibrary.addShader(shader);
        });
        if (level === 2) {
            items.forEach(function (item) {
                // @ts-expect-error
                item.content.options.meshSlots = [maxVertexCount, maxFragmentCount];
            });
        }
        return Promise.resolve();
    };
    ParticleLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        if (item instanceof ParticleVFXItem) {
            this.add(item.content);
        }
    };
    ParticleLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        if (item instanceof ParticleVFXItem) {
            if (item.content) {
                this.remove(item.content, composition.renderFrame);
            }
        }
    };
    ParticleLoader.prototype.prepareRenderFrame = function (composition, pipeline) {
        this.meshes.forEach(function (mesh) { return pipeline.addMeshToDefaultRenderPass(mesh); });
        this.meshes.length = 0;
        return false;
    };
    ParticleLoader.prototype.add = function (particle) {
        var _this = this;
        particle.meshes.forEach(function (mesh) { return addItem(_this.meshes, mesh); });
    };
    ParticleLoader.prototype.remove = function (particle, frame) {
        var _this = this;
        particle.meshes.forEach(function (mesh) {
            removeItem(_this.meshes, mesh);
            frame.removeMeshFromDefaultRenderPass(mesh);
        });
    };
    return ParticleLoader;
}(AbstractPlugin));

var CalculateLoader = /** @class */ (function (_super) {
    __extends(CalculateLoader, _super);
    function CalculateLoader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CalculateLoader;
}(AbstractPlugin));

var CalculateVFXItem = /** @class */ (function (_super) {
    __extends(CalculateVFXItem, _super);
    function CalculateVFXItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._v_priority = 1;
        _this.childrenVisible = true;
        return _this;
    }
    Object.defineProperty(CalculateVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.null;
        },
        enumerable: false,
        configurable: true
    });
    CalculateVFXItem.prototype.onConstructed = function (props) {
        this.cal = props.content;
        this.relative = props.relative;
    };
    CalculateVFXItem.prototype.onLifetimeBegin = function (composition, content) {
        content.active = true;
    };
    CalculateVFXItem.prototype.onItemRemoved = function (composition, content) {
    };
    CalculateVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        if (this.content) {
            this.content.updateTime(this.time);
            this.renderData = this.content.getRenderData(this.content.time);
            /* 要过包含父节点颜色/透明度变化的动画的帧对比 打开这段兼容代码 */
            // if (this.parentId) {
            //   const parent = this.composition?.getItemByID(this.parentId);
            //
            //   if ((parent as CalculateVFXItem).renderData) {
            //     const color = parent?.getRenderData().color;
            //
            //     if (color && !this.renderData.color) {
            //       this.renderData.color = [1, 1, 1, 1];
            //     }
            //     vecMulCombine(this.renderData.color as spec.vec4, this.renderData.color, color);
            //
            //   }
            // }
            // this.renderData.visible = this.visible;
            /********************/
        }
    };
    CalculateVFXItem.prototype.setScale = function (x, y, z) {
        this.content.startSize = new Vector3(x, y, z);
    };
    CalculateVFXItem.prototype.scale = function (x, y, z) {
        var startSize = this.content.startSize.clone();
        this.content.startSize = new Vector3(x * startSize.x, y * startSize.y, z * startSize.z);
    };
    CalculateVFXItem.prototype.getHitTestParams = function (force) {
    };
    CalculateVFXItem.prototype.getRenderData = function () {
        return this.renderData;
    };
    // hide its children when visible is fasle
    CalculateVFXItem.prototype.getChildrenVisible = function () {
        return this.childrenVisible;
    };
    CalculateVFXItem.prototype.setChildrenVisible = function (visible) {
        if (this.childrenVisible !== visible) {
            this.childrenVisible = !!visible;
            this.handleVisibleChanged(this.visible);
        }
    };
    CalculateVFXItem.prototype.doCreateContent = function (composition) {
        var content = new CalculateItem(this.cal, this);
        content.renderData = content.getRenderData(0, true);
        return content;
    };
    CalculateVFXItem.prototype.handleVisibleChanged = function (visible) {
        if (this.content) {
            this.content.visible = visible || this.childrenVisible;
        }
    };
    return CalculateVFXItem;
}(VFXItem));

var TextMesh = /** @class */ (function (_super) {
    __extends(TextMesh, _super);
    function TextMesh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @override
     * @param item
     * @param aIndex
     * @returns
     */
    TextMesh.prototype.getItemGeometryData = function (item, aIndex) {
        var _a = item, splits = _a.splits, renderer = _a.renderer, textureSheetAnimation = _a.textureSheetAnimation, startSize = _a.startSize; _a.textLayout;
        var sx = startSize.x, sy = startSize.y;
        if (renderer.shape) {
            var _b = renderer.shape, index_1 = _b.index, aPoint_1 = _b.aPoint;
            var point = new Float32Array(aPoint_1);
            for (var i = 0; i < point.length; i += 6) {
                point[i] *= sx;
                point[i + 1] *= sy;
            }
            return {
                index: index_1,
                aPoint: Array.from(point),
            };
        }
        var x = 0.5; // textLayout.meshSize[0] / 2;
        var y = 0.5; // textLayout.meshSize[1] / 2;
        var originData = [-x, y, -x, -y, x, y, x, -y];
        var aPoint = [];
        var index = [];
        var col = 2;
        var row = 2;
        if (splits.length === 1) {
            col = 1;
            row = 1;
        }
        for (var x_1 = 0; x_1 < col; x_1++) {
            for (var y_1 = 0; y_1 < row; y_1++) {
                var base = (y_1 * 2 + x_1) * 4;
                // @ts-expect-error
                var split = textureSheetAnimation ? [0, 0, 1, 1, splits[0][4]] : splits[y_1 * 2 + x_1];
                var texOffset = split[4] ? [0, 0, 1, 0, 0, 1, 1, 1] : [0, 1, 0, 0, 1, 1, 1, 0];
                var dw = ((x_1 + x_1 + 1) / col - 1) / 2;
                var dh = ((y_1 + y_1 + 1) / row - 1) / 2;
                var tox = split[0];
                var toy = split[1];
                var tsx = split[4] ? split[3] : split[2];
                var tsy = split[4] ? split[2] : split[3];
                var origin_1 = [
                    originData[0] / col + dw,
                    originData[1] / row + dh,
                    originData[2] / col + dw,
                    originData[3] / row + dh,
                    originData[4] / col + dw,
                    originData[5] / row + dh,
                    originData[6] / col + dw,
                    originData[7] / row + dh,
                ];
                aPoint.push((origin_1[0]) * sx, (origin_1[1]) * sy, texOffset[0] * tsx + tox, texOffset[1] * tsy + toy, aIndex, 0, (origin_1[2]) * sx, (origin_1[3]) * sy, texOffset[2] * tsx + tox, texOffset[3] * tsy + toy, aIndex, 0, (origin_1[4]) * sx, (origin_1[5]) * sy, texOffset[4] * tsx + tox, texOffset[5] * tsy + toy, aIndex, 0, (origin_1[6]) * sx, (origin_1[7]) * sy, texOffset[6] * tsx + tox, texOffset[7] * tsy + toy, aIndex, 0);
                if (this.lineMode) {
                    index.push(base, 1 + base, 1 + base, 3 + base, 3 + base, 2 + base, 2 + base, base);
                }
                else {
                    index.push(base, 1 + base, 2 + base, 2 + base, 1 + base, 3 + base);
                }
            }
        }
        return { index: index, aPoint: aPoint };
    };
    return TextMesh;
}(SpriteMesh));

var TextStyle = /** @class */ (function () {
    function TextStyle(options) {
        var _a, _b, _c, _d, _e, _f;
        /**
         * 是否有下划线（暂时无效）
         */
        this.isUnderline = false; // ttf
        /**
         * 下划线高度（暂时无效）
         */
        this.underlineHeight = 1; // ttf
        /**
         * 是否有外描边
         */
        this.isOutlined = false; // both // ttf & char
        /**
         * 外描边宽度
         */
        this.outlineWidth = 0; // both // ttf & char
        /**
         * 是否有阴影
         */
        this.hasShadow = false; // ttf
        this.fontDesc = ''; // both
        /**
         * 字体倍数
         */
        this.fontScale = 2;
        this.fontOffset = 0;
        var _g = options.textColor, textColor = _g === void 0 ? [1, 1, 1, 1] : _g, _h = options.fontSize, fontSize = _h === void 0 ? 40 : _h, outline = options.outline, shadow = options.shadow, _j = options.fontWeight, fontWeight = _j === void 0 ? 'normal' : _j, _k = options.fontStyle, fontStyle = _k === void 0 ? 'normal' : _k, _l = options.fontFamily, fontFamily = _l === void 0 ? 'sans-serif' : _l;
        this.textColor = textColor;
        this.textWeight = fontWeight;
        this.fontStyle = fontStyle;
        this.fontFamily = fontFamily;
        this.fontSize = fontSize; // 暂时取消字号限制 Math.min(fontSize, this.maxFontSize);
        if (outline) {
            this.isOutlined = true;
            this.outlineColor = (_a = outline.outlineColor) !== null && _a !== void 0 ? _a : [1, 1, 1, 1];
            this.outlineWidth = (_b = outline.outlineWidth) !== null && _b !== void 0 ? _b : 1;
            this.fontOffset += this.outlineWidth;
        }
        if (shadow) {
            this.hasShadow = true;
            this.shadowBlur = (_c = shadow.shadowBlur) !== null && _c !== void 0 ? _c : 2;
            this.shadowColor = (_d = shadow.shadowColor) !== null && _d !== void 0 ? _d : [0, 0, 0, 1];
            this.shadowOffsetX = (_e = shadow.shadowOffsetX) !== null && _e !== void 0 ? _e : 0;
            this.shadowOffsetY = (_f = shadow.shadowOffsetY) !== null && _f !== void 0 ? _f : 0;
        }
        if (this.fontStyle !== FontStyle$1.normal) {
            // 0.0174532925 = 3.141592653 / 180
            this.fontOffset += this.fontSize * Math.tan(12 * 0.0174532925);
        }
    }
    return TextStyle;
}());

var TextMetrics = /** @class */ (function () {
    function TextMetrics() {
    }
    TextMetrics.measureFont = function (font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
        };
        var canvas = TextMetrics._canvas;
        var context = canvas.getContext('2d', { willReadFrequently: true });
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    };
    Object.defineProperty(TextMetrics, "_canvas", {
        get: function () {
            var canvas;
            if (getConfig(TEMPLATE_USE_OFFSCREEN_CANVAS)) {
                // @ts-expect-error
                canvas = alipay.window._createOffscreenCanvas(10, 10);
                TextMetrics.__canvas = canvas;
            }
            else if (!TextMetrics.__canvas) {
                canvas = alipay.document.createElement('canvas');
                canvas.width = canvas.height = 10;
                TextMetrics.__canvas = canvas;
            }
            return TextMetrics.__canvas;
        },
        enumerable: false,
        configurable: true
    });
    TextMetrics._fonts = {};
    TextMetrics.METRICS_STRING = '|ÉqÅ';
    TextMetrics.BASELINE_SYMBOL = 'M';
    TextMetrics.BASELINE_MULTIPLIER = 1.4;
    TextMetrics.HEIGHT_MULTIPLIER = 2.0;
    return TextMetrics;
}());

var genericFontFamilies = [
    'serif',
    'sans-serif',
    'monospace',
    'cursive',
    'fantasy',
    'system-ui',
];
exports.QTextWrapMode = void 0;
(function (QTextWrapMode) {
    QTextWrapMode[QTextWrapMode["Default"] = 0] = "Default";
    QTextWrapMode[QTextWrapMode["Clip"] = 1] = "Clip";
    QTextWrapMode[QTextWrapMode["Ellipsis"] = 2] = "Ellipsis";
})(exports.QTextWrapMode || (exports.QTextWrapMode = {}));
var QText = /** @class */ (function () {
    function QText(text, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // 文本框在canvas中位置
        this.left = 0;
        this.top = 0;
        this.fontSize = 48;
        this.fontFamily = 'Arial';
        this.color = 'black';
        this.letterSpacing = 0;
        // 文本最大宽度
        this.maxLineWidth = 0;
        this.wrap = exports.QTextWrapMode.Clip;
        // 文字缩放系数
        this.scaleX = 1;
        this.scaleY = 1;
        // 文字旋转角度
        this.angle = 0;
        this.active = true;
        this.padding = 0;
        this.borderColor = '#ffffffff';
        this.borderWidth = 1;
        this.fontProperties = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
        };
        this.fontVariant = 'normal';
        // 锚点位置
        this.originX = 'left';
        this.originY = 'top';
        this.ellipsis = '…';
        this.text = text;
        this.left = (_a = options.left) !== null && _a !== void 0 ? _a : 0;
        this.top = (_b = options.top) !== null && _b !== void 0 ? _b : 0;
        this.maxLineWidth = (_c = options.maxWidth) !== null && _c !== void 0 ? _c : 0;
        this.letterSpacing = (_d = options.letterSpacing) !== null && _d !== void 0 ? _d : 0;
        this.originX = 'left';
        this.originY = 'top';
        this.color = (_e = options.color) !== null && _e !== void 0 ? _e : 'black';
        this.fontFamily = (_f = options.fontFamily) !== null && _f !== void 0 ? _f : 'Arial';
        this.fontSize = (_g = options.fontSize) !== null && _g !== void 0 ? _g : 48;
        this.wrap = (_h = options.wrap) !== null && _h !== void 0 ? _h : exports.QTextWrapMode.Clip;
        // @ts-expect-error
        this.fontStyle = (_j = options.fontStyle) !== null && _j !== void 0 ? _j : 'normal';
        this.textAlign = 'left';
        this.textBaseline = 'alphabetic';
        this.fontWeight = 'normal';
        this.angle = (_k = options.angle) !== null && _k !== void 0 ? _k : 0;
        this.name = options.name || '';
    }
    QText.prototype.update = function () {
        this.updateDimension();
    };
    QText.prototype.render = function () {
        if (this.viewer === undefined) {
            return;
        }
        var ctx = this.viewer.renderContext;
        if (ctx === undefined) {
            return;
        }
        ctx.save();
        // 设置绘制文本时的坐标变换
        this.setRenderTransform(ctx);
        this.renderText(ctx);
        if (this.active) {
            this.drawBorders(ctx);
        }
        ctx.restore();
    };
    QText.prototype.init = function (viewer) {
        this.viewer = viewer;
        this.updateDimension();
    };
    QText.prototype.getLayout = function () {
        var scaleX = this.viewer.scaleX;
        var scaleY = this.viewer.scaleY;
        return {
            x: this.left * scaleX,
            y: this.top * scaleY,
            // @ts-expect-error
            width: this.width * scaleX,
            // @ts-expect-error
            height: this.height * scaleY,
        };
    };
    QText.prototype.updateDimension = function () {
        var viewer = this.viewer;
        var ctx = viewer.renderContext;
        this.configTextStyle(ctx);
        this.configTextLayout(ctx);
        var font = this.getFontDesc();
        this.fontProperties = TextMetrics.measureFont(font);
        if (this.fontProperties.fontSize === 0) {
            this.fontProperties.fontSize = this.fontSize;
            this.fontProperties.ascent = this.fontSize;
        }
        var qChars = this.createCharsFromText(ctx, this.text);
        var textWithLetterSpaceWidth = 0;
        if (qChars.length > 0) {
            var lastChar = qChars[qChars.length - 1];
            textWithLetterSpaceWidth = lastChar.left + lastChar.width;
        }
        this.chars = qChars;
        // 文本加字间距宽度
        this.maxLineWidth = textWithLetterSpaceWidth;
        // 文本框宽高度自适应文本高度
        if (this.height === undefined) {
            // this.height = this.fontSize;
            this.height = this.fontProperties.fontSize;
        }
        if (this.width === undefined) {
            this.width = this.maxLineWidth;
        }
    };
    QText.prototype.configTextStyle = function (ctx) {
        ctx.font = this.getFontDesc();
        ctx.fillStyle = this.color; // 字体颜色
    };
    QText.prototype.getFontDesc = function () {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = typeof this.fontSize === 'number' ? "".concat(this.fontSize, "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = (this.fontFamily).split(',');
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (
            // eslint-disable-next-line no-useless-escape
            !/([\"\'])[^\'\"]+\1/.test(fontFamily) &&
                !genericFontFamilies.includes(fontFamily)) {
                fontFamily = "\"".concat(fontFamily, "\"");
            }
            fontFamilies[i] = fontFamily;
        }
        fontFamilies.push('Arial, Helvetica, sans-serif');
        return "".concat(this.fontStyle, " ").concat(this.fontVariant, " ").concat(this.fontWeight, " ").concat(fontSizeString, " ").concat((fontFamilies).join(','));
    };
    QText.prototype.configTextLayout = function (ctx) {
        ctx.textBaseline = this.textBaseline;
        ctx.textAlign = this.textAlign;
    };
    QText.prototype.setRenderTransform = function (ctx) {
        ctx.scale(this.scaleX, this.scaleY);
        ctx.translate(this.left, this.top);
        // ctx.rotate(this.angle);
    };
    QText.prototype.renderText = function (ctx) {
        // 绘制起点偏移
        var x = 0;
        var y = 0;
        this.drawCharsInTextBox(ctx, {
            min: [x, y],
            // @ts-expect-error
            max: [x + this.width, y + this.height],
        });
    };
    QText.prototype.drawCharsInTextBox = function (ctx, textBox) {
        var qChars = this.chars;
        var textWithLetterSpaceWidth = 0;
        if (qChars.length > 0) {
            var lastChar = qChars[qChars.length - 1];
            textWithLetterSpaceWidth = lastChar.left + lastChar.width;
        }
        var textBoxWidth = textBox.max[0] - textBox.min[0];
        var charOffset = 0;
        if ('left' === this.textAlign) {
            charOffset = 0;
        }
        else if ('center' === this.textAlign) {
            charOffset = 0.5 * (textBoxWidth - textWithLetterSpaceWidth);
        }
        else if ('right' === this.textAlign) {
            charOffset = textBoxWidth - textWithLetterSpaceWidth;
        }
        this.addOffsetToChars(qChars, charOffset);
        var charsInTextBox = this.cloneChars(this.clipCharsWithTextBox(qChars, textBox));
        var needDrawChars = charsInTextBox;
        if (this.wrap === exports.QTextWrapMode.Ellipsis) {
            needDrawChars = this.replaceCharWithEllipsis(ctx, charsInTextBox, textBox);
            if (needDrawChars.length === 0 && qChars.length !== 0) {
                this.addEllipsisToChars(ctx, needDrawChars, textBox);
            }
        }
        this.drawCharsFromLeft(ctx, needDrawChars);
    };
    QText.prototype.addEllipsisToChars = function (ctx, needDrawChars, textBox) {
        var _a, _b, _c;
        var ellipsisWidth = ctx.measureText(this.ellipsis).width;
        if (this.textAlign === 'left') {
            needDrawChars.push({
                char: this.ellipsis,
                left: textBox.min[0],
                top: 0,
                width: ellipsisWidth,
                heigh: (_a = this.height) !== null && _a !== void 0 ? _a : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
        else if (this.textAlign === 'right') {
            needDrawChars.push({
                char: this.ellipsis,
                left: textBox.max[0] - ellipsisWidth,
                top: 0,
                width: ellipsisWidth,
                heigh: (_b = this.height) !== null && _b !== void 0 ? _b : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
        else {
            var x = (textBox.max[0] + textBox.min[0]) * 0.5;
            needDrawChars.push({
                char: this.ellipsis,
                left: x - ellipsisWidth * 0.5,
                top: 0,
                width: ellipsisWidth,
                heigh: (_c = this.height) !== null && _c !== void 0 ? _c : 0,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: true,
                scale: 1,
                index: 0,
            });
        }
    };
    QText.prototype.createCharsFromText = function (ctx, text) {
        var chars = text.split('');
        var x = 0;
        var y = 0;
        if (this.textBaseline === 'top') {
            y = 0;
        }
        else if (this.textBaseline === 'middle') {
            y += this.fontProperties.ascent * 0.5;
        }
        else if (this.textBaseline === 'alphabetic') {
            y += this.fontProperties.ascent;
        }
        var qChars = [];
        for (var i = 0; i < chars.length; ++i) {
            var char = chars[i];
            // in safari width maybe float number
            var charWidth = Math.floor(ctx.measureText(char).width);
            var charHeight = this.fontSize;
            var qChar = {
                left: x,
                top: y,
                width: charWidth,
                heigh: charHeight,
                char: char,
                font: this.fontFamily,
                fontSize: this.fontSize,
                isEllipsis: false,
                scale: 1,
                index: i,
            };
            qChars.push(qChar);
            x += charWidth + this.letterSpacing;
        }
        return qChars;
    };
    QText.prototype.addOffsetToChars = function (chars, offset) {
        chars.forEach(function (qChar) {
            qChar.left += offset;
        });
        return chars;
    };
    QText.prototype.clipCharsWithTextBox = function (chars, textBox) {
        var charsInTextBox = [];
        var error = 0.5;
        for (var i = 0; i < chars.length; ++i) {
            var qChar = chars[i];
            if (qChar.left >= textBox.min[0] &&
                qChar.left + qChar.width < textBox.max[0] + error) {
                charsInTextBox.push(qChar);
            }
        }
        return charsInTextBox;
    };
    QText.prototype.cloneChars = function (chars) {
        return chars.map(function (qChar) {
            return __assign$1({}, qChar);
        });
    };
    QText.prototype.replaceCharWithEllipsis = function (ctx, qCharsInTextBox, textBox) {
        var ellipsisWidth = ctx.measureText(this.ellipsis).width;
        if (qCharsInTextBox.length > 0) {
            if (qCharsInTextBox[0].index !== 0) {
                var ellipsisChar = __assign$1({}, qCharsInTextBox[0]);
                ellipsisChar.char = this.ellipsis;
                ellipsisChar.isEllipsis = true;
                ellipsisChar.width = ellipsisWidth;
                qCharsInTextBox = this.findEllipsisPositionAndReplaceCharsFromLeft(qCharsInTextBox, ellipsisChar, textBox);
            }
            var qCharsInTextBoxLastIndex = qCharsInTextBox.length - 1;
            var qCharsLength = this.chars.length;
            if (qCharsInTextBox[qCharsInTextBoxLastIndex].index !==
                qCharsLength - 1) {
                var ellipsisChar = __assign$1({}, qCharsInTextBox[0]);
                ellipsisChar.char = this.ellipsis;
                ellipsisChar.isEllipsis = true;
                ellipsisChar.width = ellipsisWidth;
                qCharsInTextBox = this.findEllipsisPositionAndReplaceCharsFromRight(qCharsInTextBox, ellipsisChar, textBox);
            }
        }
        return qCharsInTextBox;
    };
    QText.prototype.findEllipsisPositionAndReplaceCharsFromLeft = function (qCharsInTextBox, ellipsis, textBox) {
        var replaceIndex = 0;
        for (var i = 0; i < qCharsInTextBox.length; ++i) {
            var qChar = qCharsInTextBox[i];
            var qCharRight = qChar.left + qChar.width;
            replaceIndex = i;
            if (qCharRight - ellipsis.width >= textBox.min[0]) {
                break;
            }
        }
        var replacedChar = qCharsInTextBox[replaceIndex];
        ellipsis.left = replacedChar.left + replacedChar.width - ellipsis.width;
        for (var i = 0; i < replaceIndex + 1; ++i) {
            qCharsInTextBox.shift();
        }
        return [ellipsis].concat(qCharsInTextBox);
    };
    QText.prototype.findEllipsisPositionAndReplaceCharsFromRight = function (qCharsInTextBox, ellipsis, textBox) {
        var replaceIndex = qCharsInTextBox.length - 1;
        for (var i = replaceIndex; i >= 0; --i) {
            var qChar = qCharsInTextBox[i];
            var ellipsisCharRight = qChar.left + ellipsis.width;
            replaceIndex = i;
            if (ellipsisCharRight <= textBox.max[0]) {
                break;
            }
        }
        ellipsis.left = qCharsInTextBox[replaceIndex].left;
        var qCharsLength = qCharsInTextBox.length;
        for (var i = qCharsLength - 1; i >= replaceIndex; --i) {
            qCharsInTextBox.pop();
        }
        return qCharsInTextBox.concat([ellipsis]);
    };
    QText.prototype.drawCharsFromLeft = function (ctx, chars) {
        var align = ctx.textAlign || 'left';
        ctx.textAlign = 'left';
        for (var i = 0; i < chars.length; ++i) {
            var qChar = chars[i];
            ctx.fillText(qChar.char, qChar.left, qChar.top);
        }
        ctx.textAlign = align;
    };
    QText.prototype.drawBorders = function (ctx) {
        this.padding;
        var strokeWidth = this.borderWidth;
        ctx.strokeStyle = this.borderColor;
        ctx.lineWidth = strokeWidth;
        var w = this.width;
        var h = this.height;
        var x = 0;
        var y = 0;
        if (this.originX === 'center') {
            // @ts-expect-error
            x -= this.width / 2;
        }
        else if (this.originX === 'right') {
            // @ts-expect-error
            x -= this.width;
        }
        if (this.originY === 'center') {
            // @ts-expect-error
            y -= this.height / 2;
        }
        else if (this.originY === 'bottom') {
            // @ts-expect-error
            y -= this.height;
        }
        ctx.strokeRect(x + strokeWidth / 2, y + strokeWidth / 2, 
        // @ts-expect-error
        w - strokeWidth, 
        // @ts-expect-error
        h - strokeWidth);
    };
    return QText;
}());

var QCanvasViewer = /** @class */ (function () {
    function QCanvasViewer(canvas, width, height, scaleX, scaleY, flipY) {
        this.textList = [];
        var renderCanvas;
        if (typeof canvas === 'string') {
            renderCanvas = alipay.document.getElementById(canvas);
        }
        else {
            renderCanvas = canvas;
        }
        // canvas缩放比例
        this.scaleX = scaleX !== null && scaleX !== void 0 ? scaleX : 1.0;
        this.scaleY = scaleY !== null && scaleY !== void 0 ? scaleY : 1.0;
        this.flipY = flipY !== null && flipY !== void 0 ? flipY : false;
        // 保存传入canvas宽度和高度信息
        this.width = width;
        this.height = height;
        // canvas的css尺寸
        renderCanvas.style.width = "".concat(width * this.scaleX, "px");
        renderCanvas.style.height = "".concat(height * this.scaleY, "px");
        // canvas的画布尺寸
        // const devicePixelRatio = window.devicePixelRatio ?? 1.0;
        var devicePixelRatio = 1;
        this.devicePixelRatio = devicePixelRatio;
        renderCanvas.width = devicePixelRatio * width * this.scaleX;
        renderCanvas.height = devicePixelRatio * height * this.scaleY;
        renderCanvas.className = 'lower-canvas';
        // renderCanvas.style.position = 'absolute';
        this.renderCanvas = renderCanvas;
        this.renderContext = this.renderCanvas.getContext('2d');
        // 画布坐标系需要进行比缩放（）
        this.renderContext.scale(devicePixelRatio * this.scaleX, devicePixelRatio * this.scaleY);
    }
    QCanvasViewer.prototype.initDimension = function (width, height, scaleX, scaleY) {
        this.width = width;
        this.height = height;
        this.scaleX = scaleX !== null && scaleX !== void 0 ? scaleX : 1.0;
        this.scaleY = scaleY !== null && scaleY !== void 0 ? scaleY : 1.0;
        this.renderCanvas.style.width = "".concat(width * this.scaleX, "px");
        this.renderCanvas.style.height = "".concat(height * this.scaleY, "px");
        // 改变canvas的尺寸会导致重置画布的所有状态
        var devicePixelRatio = this.devicePixelRatio;
        this.renderCanvas.width = devicePixelRatio * width * this.scaleX;
        this.renderCanvas.height = devicePixelRatio * height * this.scaleY;
        if (this.flipY) {
            this.renderContext.translate(0, this.height);
            this.renderContext.scale(1, -1);
        }
        this.renderContext.scale(devicePixelRatio * this.scaleX, devicePixelRatio * this.scaleY);
    };
    QCanvasViewer.prototype.clearText = function () {
        this.textList = [];
    };
    QCanvasViewer.prototype.clearCanvasWithContext = function (ctx) {
        ctx.clearRect(0, 0, this.width, this.height);
    };
    QCanvasViewer.prototype.clearCanvas = function () {
        this.clearCanvasWithContext(this.renderContext);
    };
    QCanvasViewer.prototype.addObject = function (text) {
        text.init(this);
        this.textList.push(text);
    };
    QCanvasViewer.prototype.render = function () {
        // 清空画布
        this.clearCanvasWithContext(this.renderContext);
        this.renderContext.fillStyle = 'rgba(255, 255, 255, 0.0039)';
        this.renderContext.fillRect(0, 0, this.width, this.height);
        var image = this.background;
        if (image && image.width !== undefined && image.height !== undefined) {
            this.renderContext.drawImage(image, 0, 0, image.width, image.height, 0, 0, this.width, this.height);
        }
        for (var i = 0; i < this.textList.length; ++i) {
            this.renderContext.save();
            var text = this.textList[i];
            text.update();
            text.render();
            this.renderContext.restore();
        }
    };
    return QCanvasViewer;
}());

function requestAsync(url, opt) {
    opt = opt || {};
    return new Promise(function (resolve, reject) {
        var xhr = new alipay.XMLHttpRequest();
        xhr.responseType = (opt === null || opt === void 0 ? void 0 : opt.responseType) || 'json';
        xhr.addEventListener('load', function () { return resolve(xhr.response); });
        xhr.addEventListener('error', function () { return reject(Error("load ".concat(url, " fail"))); });
        xhr.open((opt === null || opt === void 0 ? void 0 : opt.method) || 'get', url);
        xhr.send(opt === null || opt === void 0 ? void 0 : opt.data);
    });
}
/**
 *
 * @param url
 * @param template
 * @param variables
 * @param opts
 * @param flipY
 * @returns
 */
function combineImageTemplate1(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        var replacedVariables, pendings, name_1, replaceURL, onImage, imageScale, bg, content, fg, canvas;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    replacedVariables = {};
                    pendings = [];
                    opts = opts || {};
                    variables = variables || {};
                    if (template.asImage) {
                        name_1 = template.content.replace(/\$/g, '');
                        replaceURL = variables[name_1] || template.variables[name_1];
                        onImage = function (image) {
                            var canvas = (opts === null || opts === void 0 ? void 0 : opts.canvas) || alipay.document.createElement('canvas');
                            var width = canvas.width = template.backgroundWidth;
                            var height = canvas.height = template.backgroundHeight;
                            var ctx = canvas.getContext('2d');
                            ctx === null || ctx === void 0 ? void 0 : ctx.clearRect(0, 0, width, height);
                            if (flipY) {
                                ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, height);
                                ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);
                            }
                            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
                            return canvas;
                        };
                        if (replaceURL) {
                            return [2 /*return*/, loadImage(replaceURL).then(onImage)];
                        }
                        return [2 /*return*/, loadURL(url).then(onImage)];
                    }
                    imageScale = opts.templateScale || 1;
                    Object.keys(template.variables).forEach(function (name) {
                        var val = template.variables[name];
                        // eslint-disable-next-line no-prototype-builtins
                        if (variables.hasOwnProperty(name)) {
                            // @ts-expect-error
                            val = variables[name];
                        }
                        if (/^image_/.test(name)) {
                            var isArr = val instanceof Array;
                            // @ts-expect-error
                            var first = isArr ? val[0] : val;
                            // @ts-expect-error
                            pendings.push(requestImageBase64(first, isArr && val[1]).then(function (dataURL) { return replacedVariables[name] = dataURL; }));
                        }
                        else {
                            replacedVariables[name] = val;
                        }
                    });
                    return [4 /*yield*/, Promise.all(pendings)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, loadImage(url)];
                case 2:
                    bg = _a.sent();
                    content = template.content
                        .replace(/\$([\w_]+)\$/g, function (str, name) { return replacedVariables[name]; })
                        .replace("width=\"".concat(template.width, "px\""), "width=\"".concat(template.width * imageScale, "px\""))
                        .replace("height=\"".concat(template.height, "px\""), "height=\"".concat(template.height * imageScale, "px\""));
                    return [4 /*yield*/, loadImage("data:image/svg+xml,".concat(encodeURIComponent(content)))];
                case 3:
                    fg = _a.sent();
                    canvas = (opts === null || opts === void 0 ? void 0 : opts.canvas) || alipay.document.createElement('canvas');
                    canvas.width = bg.width * imageScale;
                    canvas.height = bg.height * imageScale;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            // FIXME: 先注释掉setTimeout
                            // fix ios 14 bug, image may not be drawn
                            // setTimeout(() => {
                            var ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            if (flipY) {
                                ctx.translate(0, canvas.height);
                                ctx.scale(1, -1);
                            }
                            ctx.drawImage(bg, 0, 0, bg.width, bg.height, 0, 0, canvas.width, canvas.height);
                            ctx.drawImage(fg, 0, 0, fg.width, fg.height, (template.x || 0) * imageScale, (template.y || 0) * imageScale, template.width * imageScale / template.backgroundWidth * bg.width, template.height * imageScale / template.backgroundHeight * bg.height);
                            resolve(canvas);
                            //}, 0);
                        })];
            }
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate1` instead
 */
function combineImageTemplate1Async(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplate1Async function is deprecated. Use combineImageTemplate1 instead.');
            return [2 /*return*/, combineImageTemplate1(url, template, variables, opts, flipY)];
        });
    });
}
function loadURL(url) {
    return isString(url) ? loadImage(url) : Promise.resolve(url);
}
function requestImageBase64(first, alt) {
    return req(first, function (ex) {
        return alt ? req(alt, function () { return first; }) : first;
    });
    function req(val, onError) {
        if (/^(https?:)?\/\//.test(val)) {
            // @ts-expect-error
            return requestAsync(val, { responseType: 'blob' }).then(blobToBase64, onError);
        }
        return Promise.resolve(val);
    }
}
function blobToBase64(blob) {
    return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onload = function () {
            resolve(reader.result);
        };
        reader.onerror = reject;
    });
}

var DEFAULT_FONTS = [
    'serif',
    'sans-serif',
    'monospace',
    'courier',
];
var defaultWidth = 800;
var defaultHeight = 600;
var viewerCanvasMap = new Map();
var CanvasPool = /** @class */ (function () {
    function CanvasPool() {
        this.elements = [];
    }
    CanvasPool.prototype.dispose = function () {
        this.elements.forEach(function (e) { return e.remove(); });
        // @ts-expect-error
        this.elements = [];
    };
    CanvasPool.prototype.getCanvas = function () {
        if (this.elements.length) {
            // @ts-expect-error
            return this.elements.shift();
        }
        if (getConfig(TEMPLATE_USE_OFFSCREEN_CANVAS)) {
            // @ts-expect-error
            return alipay.window._createOffscreenCanvas(10, 10);
        }
        else {
            // in hongmeng system,create too many canvas will case render error
            var defCanvas = alipay.document.createElement('canvas');
            defCanvas.getContext('2d', { willReadFrequently: true });
            return defCanvas;
        }
    };
    CanvasPool.prototype.saveCanvas = function (cvs) {
        cvs.width = cvs.height = 1;
        if (this.elements.length < 3) {
            addItem(this.elements, cvs);
        }
        else {
            cvs.remove();
        }
    };
    return CanvasPool;
}());
var canvasPool = new CanvasPool();
function getDefaultTemplateCanvasPool() {
    return canvasPool;
}
function getCanvasViewer(width, height, opt) {
    var viewer;
    var scale = (opt === null || opt === void 0 ? void 0 : opt.templateScale) || 1.0;
    var flipY = (opt === null || opt === void 0 ? void 0 : opt.flipY) || false;
    if (opt === null || opt === void 0 ? void 0 : opt.canvas) {
        viewer = viewerCanvasMap.get(opt.canvas);
        if (!viewer) {
            var newViewer = new QCanvasViewer(opt.canvas, width, height, scale, scale, flipY);
            viewerCanvasMap.set(opt.canvas, newViewer);
            viewer = newViewer;
        }
    }
    else {
        var canvas = canvasPool.getCanvas();
        viewer = new QCanvasViewer(canvas, defaultWidth, defaultHeight, scale, scale, flipY);
    }
    return viewer;
}
function convert2QTextList(stringTemplateContent, variables, opt) {
    // 创建文本绘制对象
    var fonts = stringTemplateContent.fonts;
    var qTextList = [];
    stringTemplateContent.texts.forEach(function (text) {
        var _a;
        var textString = text.t;
        var left = text.x;
        var top = text.y;
        // 字体属性
        var font = {
            weight: 400,
            family: 'serif',
            size: 48,
            style: FontStyle$1.normal,
        };
        if (text.f !== undefined) {
            font = fonts[text.f];
        }
        // 文字替换
        var name = text.n;
        // eslint-disable-next-line no-prototype-builtins
        if (name && variables && variables.hasOwnProperty(name)) {
            textString = "".concat(variables[name]);
        }
        // 创建文字对象
        var qtext = new QText(textString, {
            left: left,
            top: top,
            fontSize: font.size,
            fontFamily: font.family,
            fontWeight: "".concat(font.weight),
            fontStyle: 'normal',
            name: name,
        });
        // @ts-expect-error
        if (text.r !== undefined) {
            // @ts-expect-error
            qtext.angle = (text.r * Math.PI / 180);
        }
        qtext.active = (_a = opt === null || opt === void 0 ? void 0 : opt.debug) !== null && _a !== void 0 ? _a : false;
        //文字最大宽度
        if (text.w !== undefined) {
            qtext.width = text.w;
        }
        // 字间距
        if (font.letterSpace !== undefined) {
            qtext.letterSpacing = font.letterSpace;
        }
        // 超过最大宽度行为
        if (text.of === TextOverflow$1.display) {
            qtext.wrap = exports.QTextWrapMode.Default;
        }
        else if (text.of === TextOverflow$1.clip) {
            qtext.wrap = exports.QTextWrapMode.Clip;
        }
        else if (text.of === TextOverflow$1.ellipsis) {
            qtext.wrap = exports.QTextWrapMode.Ellipsis;
        }
        // 文字颜色
        if (text.c !== undefined) {
            var textColor = stringTemplateContent.colors[text.c][1];
            var alpha = 1.0;
            if (textColor[3] !== undefined) {
                alpha = textColor[3] / 255;
            }
            qtext.color = "rgba(".concat(textColor[0], ", ").concat(textColor[1], ", ").concat(textColor[2], ", ").concat(alpha, ")");
        }
        // 文字对齐方式
        if (text.a === TextAlignment$1.left) {
            qtext.textAlign = 'left';
        }
        else if (text.a === TextAlignment$1.middle) {
            qtext.textAlign = 'center';
        }
        else if (text.a === TextAlignment$1.right) {
            qtext.textAlign = 'right';
        }
        // 文字style
        if (font.style === FontStyle$1.normal) {
            qtext.fontStyle = 'normal';
        }
        else if (font.style === FontStyle$1.italic) {
            qtext.fontStyle = 'italic';
        }
        else if (font.style === FontStyle$1.oblique) {
            qtext.fontStyle = 'oblique';
        }
        // 文字weight
        if (font.weight !== undefined) {
            qtext.fontWeight = String(font.weight);
        }
        // 边框颜色
        if (opt === null || opt === void 0 ? void 0 : opt.borderColor) {
            qtext.borderColor = opt.borderColor;
        }
        if ((opt === null || opt === void 0 ? void 0 : opt.borderWidth) !== undefined) {
            qtext.borderWidth = opt.borderWidth;
        }
        qTextList.push(qtext);
    });
    return qTextList;
}
function getBackgroundImage(template, variables) {
    var _a, _b;
    var templateBackground;
    if ((_a = template === null || template === void 0 ? void 0 : template.background) === null || _a === void 0 ? void 0 : _a.name) {
        var name_1 = template.background.name;
        if (variables && variables[name_1]) {
            templateBackground = variables[name_1];
        }
        else if ((_b = template.background) === null || _b === void 0 ? void 0 : _b.url) {
            templateBackground = template.background.url;
        }
    }
    return templateBackground;
}
function loadMedia(url, loadFn) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!Array.isArray(url)) return [3 /*break*/, 5];
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 5]);
                    return [4 /*yield*/, loadFn(url[0])];
                case 2: return [2 /*return*/, _a.sent()];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, loadFn(url[1])];
                case 4: return [2 /*return*/, _a.sent()];
                case 5: return [2 /*return*/, loadFn(url)];
            }
        });
    });
}
function drawImageAndTemplate(viewer, image, template, variables, opt) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var templateScale, scaleX, scaleY, drawImage, width, height, templateBackground, _b, stringTemplateContent, qTextList, textLayouts;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!image) {
                        throw Error('image not provided');
                    }
                    templateScale = (opt === null || opt === void 0 ? void 0 : opt.templateScale) || 1;
                    scaleX = templateScale;
                    scaleY = templateScale;
                    drawImage = image;
                    width = image.width;
                    height = image.height;
                    if (!template) return [3 /*break*/, 5];
                    width = template.width;
                    height = template.height;
                    if (image.width !== width || image.height !== height) {
                        //in webgl1 image will resize to pot
                        //so scale template to image size
                        scaleX *= (image.width / template.width);
                        scaleY *= (image.height / template.height);
                    }
                    templateBackground = getBackgroundImage(template, variables);
                    if (!(templateBackground && templateBackground !== image.src)) return [3 /*break*/, 4];
                    if (!isString(templateBackground)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadImage(templateBackground)];
                case 1:
                    _b = _c.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _b = templateBackground;
                    _c.label = 3;
                case 3:
                    // @ts-expect-error
                    drawImage = _b;
                    _c.label = 4;
                case 4:
                    stringTemplateContent = template.content;
                    if (stringTemplateContent) {
                        qTextList = convert2QTextList(stringTemplateContent, variables, __assign$1(__assign$1({}, opt), { scaleX: scaleX, scaleY: scaleY }));
                        qTextList.forEach(function (qText) {
                            viewer.addObject(qText);
                        });
                    }
                    _c.label = 5;
                case 5:
                    viewer.flipY = (_a = opt === null || opt === void 0 ? void 0 : opt.flipY) !== null && _a !== void 0 ? _a : false;
                    viewer.initDimension(width, height, scaleX, scaleY);
                    // 设置背景图
                    viewer.background = drawImage;
                    // 将文本绘制到canvas上
                    viewer.render();
                    textLayouts = opt === null || opt === void 0 ? void 0 : opt.textLayouts;
                    if (textLayouts) {
                        // 清空数组
                        textLayouts.length = 0;
                        // 返回文本的布局对象
                        viewer.textList.forEach(function (qText) {
                            var layout = qText.getLayout();
                            var textLayout = {
                                x: layout.x,
                                y: layout.y,
                                width: layout.width,
                                height: layout.height,
                            };
                            textLayouts.push(textLayout);
                        });
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function prepareFontResources(template) {
    return __awaiter(this, void 0, void 0, function () {
        var fontDescList, _loop_1, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(template.content && template.content.fonts)) return [3 /*break*/, 4];
                    fontDescList = template.content.fonts;
                    _loop_1 = function (i) {
                        var name_2, url, hasFontAdd, source, fontFace;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    name_2 = fontDescList[i].family;
                                    url = fontDescList[i].url;
                                    hasFontAdd = false;
                                    if (DEFAULT_FONTS.includes(name_2)) {
                                        hasFontAdd = true;
                                    }
                                    else {
                                        if (alipay.document.fonts !== undefined) {
                                            alipay.document.fonts.forEach(function (fontFace) {
                                                if (fontFace.family === name_2) {
                                                    hasFontAdd = true;
                                                }
                                            });
                                        }
                                    }
                                    if (!(!hasFontAdd && url !== undefined && url !== '')) return [3 /*break*/, 2];
                                    source = "url(".concat(url, ")");
                                    if (!(alipay.document.fonts !== undefined)) return [3 /*break*/, 2];
                                    fontFace = new FontFace("".concat(name_2), source);
                                    return [4 /*yield*/, fontFace.load()];
                                case 1:
                                    _b.sent();
                                    // @ts-expect-error
                                    alipay.document.fonts.add(fontFace);
                                    _b.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    };
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < fontDescList.length)) return [3 /*break*/, 4];
                    return [5 /*yield**/, _loop_1(i)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
}
/**
 * @param {string|HTMLImageElement} url
 * @param {TemplateContentV2} [template]
 * @param {Record<string, number | string>} [variables]
 * @param {TemplateOptions} [opts]
 * @param {boolean} [flipY]
 * @returns
 */
function combineImageTemplate2(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        var templateOption, viewer, image;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    templateOption = __assign$1(__assign$1({}, opts), { flipY: flipY });
                    viewer = getCanvasViewer(defaultWidth, defaultWidth, templateOption);
                    if (!(template !== undefined)) return [3 /*break*/, 2];
                    return [4 /*yield*/, prepareFontResources(template)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    // 清空文本
                    viewer.clearText();
                    if (!(typeof url === 'string')) return [3 /*break*/, 5];
                    return [4 /*yield*/, loadImage(url)];
                case 3:
                    image = _a.sent();
                    return [4 /*yield*/, drawImageAndTemplate(viewer, image, template, variables, templateOption)];
                case 4:
                    _a.sent();
                    return [2 /*return*/, viewer.renderCanvas];
                case 5: return [4 /*yield*/, drawImageAndTemplate(viewer, url, template, variables, templateOption)];
                case 6:
                    _a.sent();
                    return [2 /*return*/, viewer.renderCanvas];
            }
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate2` instead
 */
function combineImageTemplate2Async(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplate2Async function is deprecated. Use combineImageTemplate2 instead.');
            return [2 /*return*/, combineImageTemplate2(url, template, variables, opts, flipY)];
        });
    });
}
/**
 * @param url
 * @param template
 * @param variables
 * @param opts
 * @param flipY
 * @returns
 */
function combineImageTemplate(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (template.v === 2) {
                return [2 /*return*/, combineImageTemplate2(url, template, variables, {
                        templateScale: opts === null || opts === void 0 ? void 0 : opts.templateScale,
                        toData: true,
                    }, flipY)];
            }
            return [2 /*return*/, combineImageTemplate1(url, template, variables, opts, flipY)];
        });
    });
}
/**
 * @internal
 * @deprecated since 2.0.0 - use `combineImageTemplate` instead
 */
function combineImageTemplateAsync(url, template, variables, opts, flipY) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            console.warn('The combineImageTemplateAsync function is deprecated. Use combineImageTemplate instead.');
            return [2 /*return*/, combineImageTemplate(url, template, variables, opts, flipY)];
        });
    });
}

var TextLayout = /** @class */ (function () {
    function TextLayout(options) {
        this.width = 0;
        this.height = 0;
        var _a = options.textHeight, textHeight = _a === void 0 ? 100 : _a, _b = options.textWidth, textWidth = _b === void 0 ? 100 : _b, _c = options.textOverflow, textOverflow = _c === void 0 ? TextOverflow$1.display : _c, _d = options.textBaseline, textBaseline = _d === void 0 ? TextBaseline$1.top : _d, _e = options.textAlign, textAlign = _e === void 0 ? TextAlignment$1.left : _e, text = options.text, _f = options.letterSpace, letterSpace = _f === void 0 ? 0 : _f, _g = options.autoWidth, autoWidth = _g === void 0 ? false : _g, fontSize = options.fontSize, _h = options.lineHeight, lineHeight = _h === void 0 ? fontSize : _h;
        var tempWidth = fontSize + letterSpace;
        this.autoWidth = autoWidth;
        this.maxTextWidth = text.length * tempWidth;
        // if (autoWidth) {
        //   this.width = this.maxTextWidth + this.lineWidth;
        //   this.height = fontSize + this.lineHeight;
        // } else {
        //   if (textWidth) {
        //     this.maxCharCount = Math.floor((textWidth - this.lineWidth) / (tempWidth));
        //     this.width = textWidth;
        //   } else {
        //     this.width = basicScale[0] * 100;
        //   }
        //   this.height = basicScale[1] * 100;
        // }
        this.width = textWidth;
        this.height = textHeight;
        this.letterSpace = letterSpace;
        this.overFlow = textOverflow;
        this.textBaseline = textBaseline;
        this.textAlign = textAlign;
        this.lineHeight = lineHeight;
    }
    TextLayout.prototype.getOffsetY = function (style, lineCount, lineHeight) {
        var offsetResult = 0;
        var fontSize = style.fontSize, outlineWidth = style.outlineWidth, fontScale = style.fontScale;
        // 计算基础偏移量
        var baseOffset = (fontSize + outlineWidth) * fontScale;
        // /3 计算Y轴偏移量，以匹配编辑器行为
        var offsetY = (lineHeight - fontSize) / 3;
        var commonCalculation = lineHeight * (lineCount - 1);
        switch (this.textBaseline) {
            case TextBaseline$1.top:
                offsetResult = baseOffset + offsetY;
                break;
            case TextBaseline$1.middle:
                offsetResult = (this.height * fontScale - commonCalculation + baseOffset) / 2;
                break;
            case TextBaseline$1.bottom:
                offsetResult = (this.height * fontScale - commonCalculation) - offsetY;
                break;
        }
        return offsetResult;
    };
    TextLayout.prototype.getOffsetX = function (style, maxWidth) {
        var offsetX = 0;
        switch (this.textAlign) {
            case TextAlignment$1.left:
                offsetX = style.outlineWidth * style.fontScale;
                break;
            case TextAlignment$1.middle:
                offsetX = (this.width * style.fontScale - maxWidth) / 2;
                break;
            case TextAlignment$1.right:
                offsetX = (this.width * style.fontScale - maxWidth);
                break;
        }
        return offsetX;
    };
    /**
     * 设置文本框的宽度和高度
     * @param width 文本框宽度
     * @param height 文本框高度
     */
    TextLayout.prototype.setSize = function (width, height) {
        this.width = width;
        this.height = height;
    };
    return TextLayout;
}());

var TextItem = /** @class */ (function (_super) {
    __extends(TextItem, _super);
    function TextItem(props, opts, vfxItem) {
        var _this = _super.call(this, props, opts, vfxItem) || this;
        _this.isDirty = true;
        /**
         * 文本行数
         */
        _this.lineCount = 0;
        var options = props.options;
        _this.canvas = canvasPool.getCanvas();
        canvasPool.saveCanvas(_this.canvas);
        _this.context = _this.canvas.getContext('2d', { willReadFrequently: true });
        _this.engine = vfxItem.composition.getEngine();
        _this.textStyle = new TextStyle(options);
        _this.textLayout = new TextLayout(options);
        _this.text = options.text;
        _this.lineCount = _this.getLineCount(options.text, true);
        // Text
        _this.mesh = new TextMesh(_this.engine, _this.renderInfo, vfxItem.composition);
        return _this;
    }
    TextItem.prototype.getLineCount = function (text, init) {
        var _a, _b;
        var context = this.context;
        var letterSpace = this.textLayout.letterSpace;
        var fontScale = init ? this.textStyle.fontSize / 10 : 1 / this.textStyle.fontScale;
        var width = (this.textLayout.width + this.textStyle.fontOffset);
        var lineCount = 1;
        var x = 0;
        for (var i = 0; i < text.length; i++) {
            var str = text[i];
            var textMetrics = ((_b = (_a = context === null || context === void 0 ? void 0 : context.measureText(str)) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0) * fontScale;
            // 和浏览器行为保持一致
            x += letterSpace;
            if (((x + textMetrics) > width && i > 0) || str === '\n') {
                lineCount++;
                x = 0;
            }
            if (str !== '\n') {
                x += textMetrics;
            }
        }
        return lineCount;
    };
    /**
     * 设置字号大小
     * @param value - 字号
     * @returns
     */
    TextItem.prototype.setFontSize = function (value) {
        if (this.textStyle.fontSize === value) {
            return;
        }
        // 保证字号变化后位置正常
        var diff = this.textStyle.fontSize - value;
        this.textLayout.lineHeight += diff;
        this.textStyle.fontSize = value;
        this.isDirty = true;
    };
    /**
     * 设置字重
     * @param value - 字重类型
     * @returns
     */
    TextItem.prototype.setFontWeight = function (value) {
        if (this.textStyle.textWeight === value) {
            return;
        }
        this.textStyle.textWeight = value;
        this.isDirty = true;
    };
    /**
     * 设置字体类型
     * @param value 字体类型
     * @returns
     */
    TextItem.prototype.setFontStyle = function (value) {
        if (this.textStyle.fontStyle === value) {
            return;
        }
        this.textStyle.fontStyle = value;
        this.isDirty = true;
    };
    /**
     * 设置文本
     * @param value - 文本内容
     * @returns
     */
    TextItem.prototype.setText = function (value) {
        if (this.text === value) {
            return;
        }
        this.text = value;
        this.lineCount = this.getLineCount(value, false);
        this.isDirty = true;
    };
    /**
     * 设置文本水平布局
     * @param value - 布局选项
     * @returns
     */
    TextItem.prototype.setTextAlign = function (value) {
        if (this.textLayout.textAlign === value) {
            return;
        }
        this.textLayout.textAlign = value;
        this.isDirty = true;
    };
    /**
     * 设置文本垂直布局
     * @param value - 布局选项
     * @returns
     */
    TextItem.prototype.setTextBaseline = function (value) {
        if (this.textLayout.textBaseline === value) {
            return;
        }
        this.textLayout.textBaseline = value;
        this.isDirty = true;
    };
    /**
     * 设置文本颜色
     * @param value - 颜色内容
     * @returns
     */
    TextItem.prototype.setTextColor = function (value) {
        if (this.textStyle.textColor === value) {
            return;
        }
        this.textStyle.textColor = value;
        this.isDirty = true;
    };
    /**
     * 设置文本字体
     * @param value - 文本字体
     * @returns
     */
    TextItem.prototype.setFontFamily = function (value) {
        if (this.textStyle.fontFamily === value && !isValidFontFamily(value)) {
            console.warn('The font is either the current font or an risky font family.');
            return;
        }
        this.textStyle.fontFamily = value;
        this.isDirty = true;
    };
    /**
     * 设置外描边文本颜色
     * @param value - 颜色内容
     * @returns
     */
    TextItem.prototype.setOutlineColor = function (value) {
        if (this.textStyle.outlineColor === value) {
            return;
        }
        this.textStyle.outlineColor = value;
        this.isDirty = true;
    };
    /**
     * 设置外描边文本宽度
     * @param value - 外描边宽度
     * @returns
     */
    TextItem.prototype.setOutlineWidth = function (value) {
        if (this.textStyle.outlineWidth === value) {
            return;
        }
        this.textStyle.outlineWidth = value;
        this.isDirty = true;
    };
    /**
     * 设置阴影模糊
     * @param value - 阴影模糊强度
     * @returns
     */
    TextItem.prototype.setShadowBlur = function (value) {
        if (this.textStyle.shadowBlur === value) {
            return;
        }
        this.textStyle.shadowBlur = value;
        this.isDirty = true;
    };
    /**
     * 设置阴影颜色
     * @param value - 阴影颜色
     * @returns
     */
    TextItem.prototype.setShadowColor = function (value) {
        if (this.textStyle.shadowColor === value) {
            return;
        }
        this.textStyle.shadowColor = value;
        this.isDirty = true;
    };
    /**
     * 设置阴影水平偏移距离
     * @param value - 水平偏移距离
     * @returns
     */
    TextItem.prototype.setShadowOffsetX = function (value) {
        if (this.textStyle.shadowOffsetX === value) {
            return;
        }
        this.textStyle.shadowOffsetX = value;
        this.isDirty = true;
    };
    /**
     * 设置阴影水平偏移距离
     * @param value - 水平偏移距离
     * @returns
     */
    TextItem.prototype.setShadowOffsetY = function (value) {
        if (this.textStyle.shadowOffsetY === value) {
            return;
        }
        this.textStyle.shadowOffsetY = value;
        this.isDirty = true;
    };
    /**
     * 设置字体清晰度
     * @param value - 字体清晰度
     * @returns
     */
    TextItem.prototype.setFontScale = function (value) {
        if (this.textStyle.fontScale === value) {
            return;
        }
        this.textStyle.fontScale = value;
        this.isDirty = true;
    };
    /**
     * 更新文本
     * @returns
     */
    TextItem.prototype.updateTexture = function () {
        var _a;
        if (!this.isDirty || !this.context || !this.canvas) {
            return;
        }
        var context = this.context;
        var style = this.textStyle;
        var layout = this.textLayout;
        var fontScale = style.fontScale;
        var width = (layout.width + style.fontOffset) * fontScale;
        var height = layout.height * fontScale;
        style.fontSize * fontScale;
        var lineHeight = layout.lineHeight * fontScale;
        this.char = (this.text || '').split('');
        this.canvas.width = width;
        this.canvas.height = height;
        context.clearRect(0, 0, width, this.canvas.height);
        // fix bug 1/255
        context.fillStyle = 'rgba(255, 255, 255, 0.0039)';
        context.fillRect(0, 0, width, this.canvas.height);
        style.fontDesc = this.getFontDesc();
        context.font = style.fontDesc;
        if (style.hasShadow) {
            this.setupShadow();
        }
        if (style.isOutlined) {
            this.setupOutline();
        }
        // 文本颜色
        context.fillStyle = "rgba(".concat(style.textColor[0], ", ").concat(style.textColor[1], ", ").concat(style.textColor[2], ", ").concat(style.textColor[3], ")");
        var charsInfo = [];
        var x = 0;
        var y = layout.getOffsetY(style, this.lineCount, lineHeight);
        var charsArray = [];
        var charOffsetX = [];
        for (var i = 0; i < this.char.length; i++) {
            var str = this.char[i];
            var textMetrics = context.measureText(str);
            // 和浏览器行为保持一致
            x += layout.letterSpace * fontScale;
            if (((x + textMetrics.width) > width && i > 0) || str === '\n') {
                charsInfo.push({
                    y: y,
                    width: x,
                    chars: charsArray,
                    charOffsetX: charOffsetX,
                });
                x = 0;
                y += lineHeight;
                charsArray = [];
                charOffsetX = [];
            }
            if (str !== '\n') {
                charsArray.push(str);
                charOffsetX.push(x);
                x += textMetrics.width;
            }
        }
        charsInfo.push({
            y: y,
            width: x,
            chars: charsArray,
            charOffsetX: charOffsetX,
        });
        charsInfo.forEach(function (charInfo) {
            var x = layout.getOffsetX(style, charInfo.width);
            charInfo.chars.forEach(function (str, i) {
                if (style.isOutlined) {
                    context.strokeText(str, x + charInfo.charOffsetX[i], charInfo.y);
                }
                context.fillText(str, x + charInfo.charOffsetX[i], charInfo.y);
            });
        });
        if (style.hasShadow) {
            context.shadowColor = 'transparent';
        }
        //与 toDataURL() 两种方式都需要像素读取操作
        var imageData = context.getImageData(0, 0, this.canvas.width, this.canvas.height);
        (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.mesh.material.setTexture('uSampler0', Texture.createWithData(this.engine, {
            data: new Uint8Array(imageData.data),
            width: imageData.width,
            height: imageData.height,
        }, {
            flipY: true,
            magFilter: glContext.LINEAR,
            minFilter: glContext.LINEAR,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
        }));
        this.isDirty = false;
    };
    TextItem.prototype.getFontDesc = function () {
        var textStyle = this.textStyle;
        var fontDesc = "".concat((textStyle.fontSize * textStyle.fontScale).toString(), "px ");
        if (!DEFAULT_FONTS.includes(textStyle.fontFamily)) {
            fontDesc += "\"".concat(textStyle.fontFamily, "\"");
        }
        else {
            fontDesc += textStyle.fontFamily;
        }
        if (textStyle.textWeight !== TextWeight$1.normal) {
            fontDesc = "".concat(textStyle.textWeight, " ").concat(fontDesc);
        }
        if (textStyle.fontStyle !== FontStyle$1.normal) {
            fontDesc = "".concat(textStyle.fontStyle, " ").concat(fontDesc);
        }
        return fontDesc;
    };
    TextItem.prototype.setupOutline = function () {
        var context = this.context;
        var style = this.textStyle;
        context.strokeStyle = "rgba(".concat(style.outlineColor[0] * 255, ", ").concat(style.outlineColor[1] * 255, ", ").concat(style.outlineColor[2] * 255, ", ").concat(style.outlineColor[3], ")");
        context.lineWidth = style.outlineWidth * 2;
    };
    TextItem.prototype.setupShadow = function () {
        var context = this.context;
        var style = this.textStyle;
        context.shadowColor = "rgba(".concat(style.shadowColor[0] * 255, ", ").concat(style.shadowColor[1] * 255, ", ").concat(style.shadowColor[2] * 255, ", ").concat(style.shadowColor[3], ")");
        context.shadowBlur = style.shadowBlur;
        context.shadowOffsetX = style.shadowOffsetX;
        context.shadowOffsetY = -style.shadowOffsetY;
    };
    return TextItem;
}(SpriteItem));

var TextVFXItem = /** @class */ (function (_super) {
    __extends(TextVFXItem, _super);
    function TextVFXItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TextVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.text;
        },
        enumerable: false,
        configurable: true
    });
    TextVFXItem.prototype.onConstructed = function (props) {
        this.textContext = props.content;
    };
    TextVFXItem.prototype.onLifetimeBegin = function (composition, content) {
        var _a, _b;
        content.active = true;
        (_b = (_a = this.content) === null || _a === void 0 ? void 0 : _a.mesh) === null || _b === void 0 ? void 0 : _b.setItems([this.content]);
        this.content.updateTexture();
    };
    TextVFXItem.prototype.onItemRemoved = function (composition, content) {
        if (content) {
            delete content.mesh;
            composition.destroyTextures(content.getTextures());
        }
    };
    TextVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _a;
        if (!this.content) {
            return;
        }
        (_a = this.content) === null || _a === void 0 ? void 0 : _a.updateTime(this.time);
    };
    TextVFXItem.prototype.getCurrentPosition = function () {
        var pos = new Vector3();
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    /**
     * 获取图层包围盒的类型和世界坐标
     * @returns
     */
    TextVFXItem.prototype.getBoundingBox = function () {
        var item = this.content;
        if (!item || !this.transform) {
            return;
        }
        var worldMatrix = this.transform.getWorldMatrix();
        var size = item.startSize;
        var triangles = trianglesFromRect(Vector3.ZERO, size.x / 2, size.y / 2);
        triangles.forEach(function (triangle) {
            worldMatrix.transformPoint(triangle.p0);
            worldMatrix.transformPoint(triangle.p1);
            worldMatrix.transformPoint(triangle.p2);
        });
        return {
            type: exports.HitTestType.triangle,
            area: triangles,
        };
    };
    TextVFXItem.prototype.getHitTestParams = function (force) {
        var _a, _b;
        var item = this.content;
        var ui = item && item.interaction;
        if ((force || ui) && ((_a = item.mesh) === null || _a === void 0 ? void 0 : _a.mesh) && item) {
            var area = this.getBoundingBox();
            if (area) {
                return {
                    behavior: ((_b = item.interaction) === null || _b === void 0 ? void 0 : _b.behavior) || 0,
                    type: area.type,
                    triangles: area.area,
                    backfaceCulling: item.renderer.side === SideMode$1.FRONT,
                };
            }
        }
    };
    TextVFXItem.prototype.getRenderData = function () {
        return this.content.getRenderData(this.content.time);
    };
    TextVFXItem.prototype.doCreateContent = function (composition) {
        var emptyTexture = composition.getRendererOptions().emptyTexture;
        return new TextItem(this.textContext, { emptyTexture: emptyTexture }, this);
    };
    TextVFXItem.prototype.createWireframeMesh = function (item, color) {
        var spMesh = new TextMesh(this.composition.getEngine(), __assign$1({ wireframe: true }, item.renderInfo), this.composition);
        spMesh.mesh.setVisible(true);
        spMesh.setItems([item]);
        spMesh.mesh.material.setVector3('uFrameColor', Vector3.fromArray(color));
        spMesh.mesh.priority = 999;
        return spMesh;
    };
    return TextVFXItem;
}(VFXItem));

var TextLoader = /** @class */ (function (_super) {
    __extends(TextLoader, _super);
    function TextLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'text';
        _this.addItems = [];
        _this.removeItems = [];
        _this.meshes = [];
        return _this;
    }
    TextLoader.prototype.onCompositionDestroyed = function (composition) {
        if (composition.reusable) {
            this.addItems.forEach(function (vfxitem) {
                var _a;
                (_a = vfxitem.content.mesh) === null || _a === void 0 ? void 0 : _a.mesh.dispose({ material: { textures: exports.DestroyOptions.keep } });
            });
        }
        else {
            this.addItems.forEach(function (vfxitem) {
                var _a;
                (_a = vfxitem.content.mesh) === null || _a === void 0 ? void 0 : _a.mesh.dispose();
            });
        }
    };
    TextLoader.prototype.onCompositionUpdate = function (composition, dt) {
        this.addItems.forEach(function (item) {
            var _a, _b, _c;
            if (!item.contentVisible) {
                (_a = item.content.mesh) === null || _a === void 0 ? void 0 : _a.mesh.setVisible(false);
                return;
            }
            else {
                (_b = item.content.mesh) === null || _b === void 0 ? void 0 : _b.mesh.setVisible(true);
            }
            item.content.updateTexture();
            if (!item.content.ended && item.content.mesh) {
                item.content.mesh.updateItem(item.content);
                (_c = item.content.mesh) === null || _c === void 0 ? void 0 : _c.applyChange();
            }
        });
    };
    TextLoader.prototype.onCompositionItemLifeBegin = function (composition, item) {
        var _a;
        if (item instanceof TextVFXItem && item.content) {
            if (!this.addItems.includes(item)) {
                addItem(this.addItems, item);
                if (!item.content.ended && item.content.mesh) {
                    item.content.mesh.updateItem(item.content);
                }
                (_a = item.content.mesh) === null || _a === void 0 ? void 0 : _a.applyChange();
            }
        }
    };
    TextLoader.prototype.onCompositionReset = function (composition, pipeline) {
    };
    TextLoader.prototype.onCompositionItemRemoved = function (composition, item) {
        var _a;
        // FIXME: 此处判断有问题，item 应该先判断
        if (item instanceof TextVFXItem && item) {
            addItem(this.removeItems, item);
            if (this.addItems.includes(item)) {
                if ((_a = item.content) === null || _a === void 0 ? void 0 : _a.mesh) {
                    removeItem(this.addItems, item);
                    item.content.mesh.mesh.dispose({ material: { textures: exports.DestroyOptions.keep } });
                    item.dispose();
                }
            }
        }
    };
    TextLoader.prototype.prepareRenderFrame = function (composition, renderFrame) {
        var _this = this;
        this.removeItems.map(function (item) {
            var _a, _b;
            if ((_a = item.content) === null || _a === void 0 ? void 0 : _a.mesh) {
                renderFrame.removeMeshFromDefaultRenderPass((_b = item.content.mesh) === null || _b === void 0 ? void 0 : _b.mesh);
                removeItem(_this.addItems, item);
                item.content.mesh.mesh.dispose({ material: { textures: exports.DestroyOptions.keep } });
                item.dispose();
            }
        });
        this.addItems.forEach(function (item) {
            var _a;
            if (item.content.mesh) {
                renderFrame.addMeshToDefaultRenderPass((_a = item.content.mesh) === null || _a === void 0 ? void 0 : _a.mesh);
            }
        });
        this.removeItems.length = 0;
        return false;
    };
    return TextLoader;
}(AbstractPlugin));

function cloneMeshWithShader(engine, mesh, shader) {
    var mtlOptions = __assign$1(__assign$1({}, mesh.material.props), { shader: shader });
    var material = mesh.material.clone(mtlOptions);
    material.blending = false;
    material.depthTest = false;
    material.culling = false;
    var ret = Mesh.create(engine, {
        geometry: mesh.geometry,
        material: material,
    });
    return ret;
}
function cloneSpriteMesh(engine, spriteMesh, options) {
    var shader = spriteMeshShaderFromFilter(engine.gpuCapability.level, { fragment: options.fragment }, { ignoreBlend: true });
    return cloneMeshWithShader(engine, spriteMesh, shader);
}

/****************************************************************************************/
/** 高斯滤镜，分3个 pass 组成，分别是高斯 H、高斯 V 和最终合并两个 pass 结果的 copyPass **********/
/****************************************************************************************/
var GaussianPass = /** @class */ (function (_super) {
    __extends(GaussianPass, _super);
    function GaussianPass(renderer, type, uTexStep, pluginSystem, fragShader, option) {
        var _this = _super.call(this, renderer, option) || this;
        _this.uTexStep = uTexStep;
        _this.pluginSystem = pluginSystem;
        _this.fragShader = fragShader;
        _this.type = type;
        return _this;
    }
    GaussianPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0] ? renderer.getFrameBuffer().getColorTextures()[0] : renderer.renderingData.currentFrame.transparentTexture;
        if (this.type === 'H') {
            this.preDefaultPassAttachment.texture = this.prePassTexture;
        }
        this.preDefaultPassTexture = this.preDefaultPassAttachment.texture;
        if (!this.mframeBuffer) {
            var attachment = Texture.create(renderer.engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                minFilter: glContext.LINEAR,
                magFilter: glContext.LINEAR,
                name: this.type,
                internalFormat: glContext.RGBA,
                format: glContext.RGBA,
                type: glContext.UNSIGNED_BYTE,
            });
            this.mframeBuffer = FrameBuffer.create({
                name: this.type,
                storeAction: {},
                viewport: this.viewport,
                viewportScale: 1,
                isCustomViewport: true,
                attachments: [attachment],
                depthStencilAttachment: { storageType: exports.RenderPassAttachmentStorageType.none },
            }, renderer);
        }
        renderer.setFrameBuffer(this.mframeBuffer);
    };
    GaussianPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassTexture));
        this.meshes[1].material.setVector2('uTexStep', this.uTexStep);
        this.meshes[1].material.setTexture('uBlurSource', this.uBlurSource ? this.uBlurSource : this.prePassTexture);
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], cloneSpriteMesh(renderer.engine, this.meshes[1], { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    GaussianPass.prototype.dispose = function (options) {
        _super.prototype.dispose.call(this, options);
        var mframeBuffer = this.mframeBuffer;
        if (mframeBuffer) {
            mframeBuffer.dispose(options);
        }
    };
    return GaussianPass;
}(RenderPass));
/**
 * 滤镜元素的最终渲染 Pass
 */
var CopyPass = /** @class */ (function (_super) {
    __extends(CopyPass, _super);
    function CopyPass(renderer, options, preDefaultPassAttachment) {
        var _this = _super.call(this, renderer, options) || this;
        if (preDefaultPassAttachment) {
            _this.preDefaultPassAttachment = preDefaultPassAttachment;
        }
        return _this;
    }
    CopyPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        if (!this.preDefaultPassAttachment) {
            this.preDefaultPassAttachment = new RenderTargetHandle(renderer.engine, {});
            this.preDefaultPassAttachment.texture = this.prePassTexture;
        }
        renderer.setFrameBuffer(this.frameBuffer);
    };
    CopyPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassAttachment.texture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassAttachment.texture));
        this.meshes[1].material.setTexture('uFrameSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return CopyPass;
}(RenderPass));
function createGaussianShader(filter) {
    var radius = filter.radius;
    var f = gaussianFilter({ radius: radius });
    return [
        {
            fragment: copyFrag,
            shaderCacheId: "gaussian-".concat(f.step),
        },
        {
            fragment: f.shader,
            ignoreBlend: true,
        },
    ];
}
function registerGaussianFilter(filter, composition) {
    var radius = filter.radius;
    var level = composition.getEngine().gpuCapability.level;
    var engine = composition.renderer.engine;
    var renderer = composition.renderer;
    var _a = gaussianFilter({ radius: radius }), downSample = _a.downSample, step = _a.step, shader = _a.shader;
    var texWidth = Math.round(composition.width / downSample);
    var texHeight = Math.round(composition.height / downSample);
    if (level === 1) {
        texHeight = nearestPowerOfTwo(texHeight);
        texWidth = nearestPowerOfTwo(texWidth);
    }
    var viewport = [0, 0, texWidth, texHeight];
    var gaussianTextureV = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        minFilter: glContext.LINEAR,
        magFilter: glContext.LINEAR,
        name: 'gaussianV',
        width: texWidth,
        height: texHeight,
    });
    var gaussianTextureH = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        minFilter: glContext.LINEAR,
        magFilter: glContext.LINEAR,
        name: 'gaussianH',
        width: texWidth,
        height: texHeight,
    });
    // 使用一个attachment对象保存滤镜前的pass渲染结果，传递到后续滤镜pass使用
    var preDefaultPassColorAttachment = new RenderTargetHandle(engine, {});
    var gaussianHPass = new GaussianPass(renderer, 'H', new Vector2(0, step), composition.pluginSystem, shader, {
        name: 'gaussianH',
        viewport: viewport,
        attachments: [{ texture: gaussianTextureH }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    gaussianHPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianVPass = new GaussianPass(renderer, 'V', new Vector2(step, 0), composition.pluginSystem, shader, {
        name: 'gaussianV',
        viewport: viewport,
        attachments: [{ texture: gaussianTextureV }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    gaussianVPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var texturefilter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var copyPass = new CopyPass(renderer, {
        name: 'gaussianCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: texturefilter, magFilter: texturefilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, preDefaultPassColorAttachment);
    copyPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    return {
        mesh: {
            fragment: copyFrag,
            shaderCacheId: "gaussian-".concat(step),
            uniformValues: {
                uTexSize: [texWidth, texHeight],
            },
            materialStates: {
                blending: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [gaussianHPass, gaussianVPass, copyPass],
        },
    };
}
function gaussianFilter(opts) {
    var downSample = opts.radius <= 3 ? 1 : 2;
    var radius = opts.radius / downSample;
    var maxStep = opts.maxStep || 4;
    while (radius > 10 && downSample < maxStep) {
        downSample *= 2;
        radius = opts.radius / downSample;
    }
    var step = 1 + (opts.radius % downSample) / downSample / downSample;
    radius = Math.floor(radius);
    var floats = getGaussianParams(radius);
    var steps = [];
    for (var i = -radius; i <= radius; i++) {
        var weight = floats[i + radius];
        steps.push("color += texture2D(uBlurSource,getTexCoord(".concat(i.toFixed(1), ")) * ").concat(weight, ";"));
    }
    var ret = {
        shader: "\n  uniform sampler2D uBlurSource;\n  uniform vec2 uTexSize;\n  uniform vec2 uTexStep;\n  #define getTexCoord(i) coord + uTexStep/uTexSize * i\n  vec4 filterMain(vec2 coord,sampler2D tex){\n    vec4 color = vec4(0.);\n    vec2 texCoord;\n    ".concat(steps.join('\n'), "\n\n    return color;\n  }\n  "),
        step: step,
        downSample: downSample,
        radius: radius,
    };
    return ret;
}
function calculateSigma(x, sig) {
    return Math.exp(-(x * x) / (2 * sig * sig)) / Math.sqrt(2 * Math.PI) / sig;
}
function getGaussianParams(radius) {
    var sigma = (radius + 1) / 3.329;
    var nums = [];
    for (var i = -radius; i <= radius; i++) {
        nums.push(calculateSigma(i, sigma));
    }
    return nums;
}

function createDistortionShader(filter) {
    var _a = filter, period = _a.period, waveMovement = _a.waveMovement, strength = _a.strength;
    return [
        {
            fragment: distortionFrag,
            shaderCacheId: 'distortion',
        },
        {
            fragment: distortionFrag,
            vertex: distortionVert,
            isParticle: true,
            uniforms: [period, waveMovement, strength],
        },
    ];
}
function registerDistortionFilter(filter, composition) {
    var _a = filter, _b = _a.center, center = _b === void 0 ? [0.5, 0.5] : _b, _c = _a.direction, direction = _c === void 0 ? [1, 0] : _c, period = _a.period, waveMovement = _a.waveMovement, strength = _a.strength;
    var dir = vecNormalize(direction);
    var uWaveParams = [center[0], center[1], dir[0], dir[1]];
    var uPeriodValue = createValueGetter(period);
    var uMovementValue = createValueGetter(waveMovement);
    var uStrengthValue = createValueGetter(strength);
    var PI2 = Math.PI * 2;
    var renderer = composition.renderer;
    var textureFilter = renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var distortionPass = new CopyPass(renderer, {
        name: 'distortionCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        particle: {
            fragment: distortionFrag,
            vertex: distortionVert,
            uniforms: {
                uPeriodValue: uPeriodValue,
                uMovementValue: uMovementValue,
                uStrengthValue: uStrengthValue,
            },
            uniformValues: {
                uWaveParams: uWaveParams,
            },
        },
        mesh: {
            shaderCacheId: 'distortion',
            fragment: distortionFrag,
            materialStates: {
                blending: false,
                culling: false,
            },
            variables: {
                vWaveParams: function (life) {
                    return [
                        uPeriodValue.getValue(life) * PI2,
                        uMovementValue.getValue(life) * PI2,
                        uStrengthValue.getValue(life),
                        0,
                    ];
                },
            },
            uniformValues: {
                uWaveParams: uWaveParams,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [distortionPass],
        },
    };
}

/******************************************************************************************/
/** Bloom 滤镜，分4个 pass 组成，分别是阈值 Pass、高斯 H、高斯 V 和最终合并 pass 结果的 copyPass ***/
/******************************************************************************************/
function createBloomShader(filter) {
    var _a = filter.radius, radius = _a === void 0 ? 30 : _a;
    var gaussian = gaussianFilter({ radius: radius });
    return [
        {
            fragment: bloomMixVert,
            shaderCacheId: "bloom-".concat(gaussian.step),
        },
        { fragment: bloomThresholdVert, ignoreBlend: true },
        { fragment: gaussian.shader, ignoreBlend: true },
    ];
}
function registerBloomFilter(filter, composition) {
    var _a = filter, _b = _a.radius, radius = _b === void 0 ? 30 : _b, _c = _a.bloomAddon, bloomAddon = _c === void 0 ? 0.4 : _c, _d = _a.colorAddon, colorAddon = _d === void 0 ? 1 : _d, _e = _a.colorThreshold, colorThreshold = _e === void 0 ? [255, 255, 255] : _e;
    var level = composition.getEngine().gpuCapability.level;
    var gaussian = gaussianFilter({ radius: radius });
    var engine = composition.renderer.engine;
    var renderer = composition.renderer;
    var width = Math.round(composition.width / gaussian.downSample);
    var height = Math.round(composition.width / gaussian.downSample);
    if (level === 1) {
        width = nearestPowerOfTwo(width);
        height = nearestPowerOfTwo(height);
    }
    var viewport = [0, 0, width, height];
    // TODO 这里设置的width和height没用，会被viewport覆盖
    var blurTarget = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        format: glContext.RGBA,
        magFilter: glContext.LINEAR,
        minFilter: glContext.LINEAR,
        name: 'gaussianV',
        width: width,
        height: height,
    });
    var blurInterMedia = composition.renderFrame.passTextureCache.requestColorAttachmentTexture({
        format: glContext.RGBA,
        magFilter: glContext.LINEAR,
        minFilter: glContext.LINEAR,
        name: 'gaussianH',
        width: width,
        height: height,
    });
    var bloomAddOnGetter = createValueGetter(bloomAddon);
    var colorAddOnGetter = createValueGetter(colorAddon);
    var preDefaultPassColorAttachment = new RenderTargetHandle(engine);
    var thresholdPass = new ThresholdPass(renderer, {
        name: 'threshold',
        attachments: [{ texture: blurTarget }],
        viewport: viewport,
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    thresholdPass.pluginSystem = composition.pluginSystem;
    thresholdPass.fragShader = bloomThresholdVert;
    thresholdPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianHPass = new BloomGaussianPass(renderer, 'H', new Vector2(gaussian.step, 0), composition.pluginSystem, gaussian.shader, {
        name: 'gaussianH',
        viewport: viewport,
        attachments: [{ texture: blurInterMedia }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, blurTarget);
    gaussianHPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var gaussianVPass = new BloomGaussianPass(renderer, 'V', new Vector2(0, gaussian.step), composition.pluginSystem, gaussian.shader, {
        name: 'gaussianV',
        viewport: viewport,
        attachments: [{ texture: blurTarget }],
    }, blurInterMedia);
    gaussianVPass.preDefaultPassAttachment = preDefaultPassColorAttachment;
    var textureFilter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var copyPass = new BloomCopyPass(renderer, {
        name: 'bloomCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    }, preDefaultPassColorAttachment);
    return {
        mesh: {
            name: "bloom-".concat(gaussian.step),
            fragment: bloomMixVert,
            shaderCacheId: "bloom-".concat(gaussian.step),
            variables: {
                uBloomParams: function (life) { return [
                    bloomAddOnGetter.getValue(life),
                    colorAddOnGetter.getValue(life),
                    0,
                    1,
                ]; },
            },
            uniformValues: {
                uColorThreshold: [(colorThreshold[0] / 255) || 1.1, (colorThreshold[1] / 255) || 1.1, (colorThreshold[2] / 255) || 1.1, 0],
                uBloomBlur: blurTarget,
            },
            materialStates: {
                blending: false,
                culling: false,
            },
        },
        onItemRemoved: function () {
            blurTarget.dispose();
            blurInterMedia.dispose();
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [thresholdPass, gaussianHPass, gaussianVPass, copyPass],
        },
    };
}
var ThresholdPass = /** @class */ (function (_super) {
    __extends(ThresholdPass, _super);
    function ThresholdPass(renderer, option) {
        return _super.call(this, renderer, option) || this;
    }
    ThresholdPass.prototype.configure = function (renderer) {
        var currentFrameBuffer = renderer.getFrameBuffer();
        // 第一个Pass，可能前一个pass没有FBO需要判断一下。
        this.preDefaultPassAttachment.texture = currentFrameBuffer ? currentFrameBuffer.getColorTextures()[0] : renderer.renderingData.currentFrame.transparentTexture;
        renderer.setFrameBuffer(this.frameBuffer);
    };
    ThresholdPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.preDefaultPassAttachment.texture));
        var renderQueue = [cloneSpriteMesh(renderer.engine, this.meshes[1], { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    return ThresholdPass;
}(RenderPass));
var BloomGaussianPass = /** @class */ (function (_super) {
    __extends(BloomGaussianPass, _super);
    function BloomGaussianPass(renderer, type, uTexStep, pluginSystem, fragShader, option, uBlurSource) {
        var _this = _super.call(this, renderer, option) || this;
        _this.uTexStep = uTexStep;
        _this.pluginSystem = pluginSystem;
        _this.fragShader = fragShader;
        _this.type = type;
        if (uBlurSource) {
            _this.uBlurSource = uBlurSource;
        }
        return _this;
    }
    BloomGaussianPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        this.preDefaultPassTexture = this.preDefaultPassAttachment.texture;
        renderer.setFrameBuffer(this.frameBuffer);
        if (!this.uBlurSource) {
            this.uBlurSource = this.prePassTexture;
        }
    };
    BloomGaussianPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[1].material.setVector2('uTexStep', this.uTexStep);
        this.meshes[1].material.setTexture('uBlurSource', this.uBlurSource);
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.uBlurSource));
        var renderQueue = [cloneSpriteMesh(renderer.engine, this.meshes[1], { fragment: this.fragShader })];
        renderer.renderMeshes(renderQueue);
    };
    return BloomGaussianPass;
}(RenderPass));
/**
 * Bloom 滤镜元素的最终渲染 Pass
 */
var BloomCopyPass = /** @class */ (function (_super) {
    __extends(BloomCopyPass, _super);
    function BloomCopyPass(renderer, options, preDefaultPassAttachment) {
        var _this = _super.call(this, renderer, options) || this;
        _this.preDefaultPassAttachment = preDefaultPassAttachment;
        return _this;
    }
    BloomCopyPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    BloomCopyPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.preDefaultPassAttachment.texture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.preDefaultPassAttachment.texture));
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.preDefaultPassAttachment.texture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setVector2('uTexSize', getTextureSize(this.preDefaultPassAttachment.texture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return BloomCopyPass;
}(RenderPass));

var DelayPass = /** @class */ (function (_super) {
    __extends(DelayPass, _super);
    function DelayPass(renderer, options) {
        return _super.call(this, renderer, options) || this;
    }
    DelayPass.prototype.configure = function (renderer) {
        this.prePassTexture = renderer.getFrameBuffer().getColorTextures()[0];
        renderer.setFrameBuffer(this.frameBuffer);
    };
    DelayPass.prototype.execute = function (renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[0].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        this.meshes[1].material.setTexture('uFilterSource', this.prePassTexture);
        this.meshes[1].material.setTexture('uSamplerPre', this.prePassTexture);
        this.meshes[1].material.setVector2('uFilterSourceSize', getTextureSize(this.prePassTexture));
        var renderQueue = [this.meshes[0], this.meshes[1]];
        renderer.renderMeshes(renderQueue);
    };
    return DelayPass;
}(RenderPass));
function createDelayShader() {
    return [{
            fragment: delayFrag,
            shaderCacheId: 'delay',
        }];
}
function registerDelayFilter(filter, composition) {
    // FIXME: renderer 在 Composition 下
    var renderer = composition.renderer;
    var tex = Texture.create(renderer.engine, {
        sourceType: exports.TextureSourceType.framebuffer,
    });
    var filterParams = [0, 0.96, 0, 0];
    var textureFilter = renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var delayPass = new DelayPass(renderer, {
        name: 'delayCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: delayFrag,
            shaderCacheId: 'delay',
            uniformValues: {
                uLastSource: tex,
            },
            variables: {
                uParams: function () { return filterParams; },
            },
            materialStates: {
                blending: true,
                blendFunction: [glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA, glContext.SRC_ALPHA, glContext.ONE_MINUS_SRC_ALPHA],
                depthTest: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [delayPass],
        },
        onItemRemoved: function () {
            tex.dispose();
        },
        renderPassDelegate: {
            didEndRenderPass: function (pass) {
                // @ts-expect-error
                renderer.extension.copyTexture(pass.attachments[0].texture, tex);
                filterParams[0] = 2;
            },
        },
    };
}

function createAlphaFrameShader() {
    return [
        { fragment: alphaFrameFrag, shaderCacheId: 'alpha-frame' },
        { fragment: alphaFrameFrag, isParticle: true },
    ];
}
function registerAlphaFrameFilter(filter, composition) {
    var _a = filter, _b = _a.colorRange, colorRange = _b === void 0 ? [0.5, 1] : _b, _c = _a.alphaRange, alphaRange = _c === void 0 ? [0, 0.5] : _c;
    var uTexRange = [alphaRange[0], alphaRange[1] - alphaRange[0], colorRange[0], colorRange[1] - colorRange[0]];
    var renderer = composition.renderer;
    var textureFilter = renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var alphaFramePass = new CopyPass(renderer, {
        name: 'alphaFrameCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        particle: {
            fragment: alphaFrameFrag,
            uniformValues: {
                uTexRange: uTexRange,
            },
        },
        mesh: {
            fragment: alphaFrameFrag,
            shaderCacheId: 'alpha-frame',
            materialStates: {
                blending: false,
            },
            uniformValues: {
                uTexRange: uTexRange,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [alphaFramePass],
        },
    };
}

function createAlphaMaskShader() {
    return [{
            fragment: alphaMaskFrag,
            shaderCacheId: 'alpha-mask',
        }];
}
function registerAlphaMaskFilter(filter, composition) {
    var _a = filter, xOpacity = _a.xOpacity, yOpacity = _a.yOpacity;
    var engine = composition.renderer.engine;
    var renderer = composition.renderer;
    var uAlphaXSample = createSampler(engine, xOpacity);
    var uAlphaYSample = createSampler(engine, yOpacity, true);
    var textureFilter = engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var alphaMaskPass = new CopyPass(renderer, {
        name: 'alphaMaskCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: alphaMaskFrag,
            shaderCacheId: 'alpha-mask',
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
            uniformValues: {
                uAlphaXSample: uAlphaXSample,
                uAlphaYSample: uAlphaYSample,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [alphaMaskPass],
        },
    };
}
function createSampler(engine, value, reverse) {
    var exp = createValueGetter(value || 1);
    var width = value ? 256 : 1;
    var data = new Uint8Array(width);
    for (var i = 0; i < width; i++) {
        var p = i / (width - 1);
        data[i] = Math.round(exp.getValue((reverse ? 1 - p : p)) * 255);
    }
    return Texture.createWithData(engine, { width: width, height: 1, data: data }, { format: glContext.LUMINANCE });
}

var tmpScale = new Vector3(1, 1, 1);
/**
 * 合成的相机对象，采用透视投影
 */
var Camera = /** @class */ (function () {
    /**
     *
     * @param name - 相机名称
     * @param options
     */
    function Camera(name, options) {
        if (options === void 0) { options = {}; }
        this.name = name;
        this.viewMatrix = Matrix4$1.fromIdentity();
        this.projectionMatrix = Matrix4$1.fromIdentity();
        this.viewProjectionMatrix = Matrix4$1.fromIdentity();
        this.inverseViewMatrix = Matrix4$1.fromIdentity();
        this.dirty = true;
        var _a = options.near, near = _a === void 0 ? 0.1 : _a, _b = options.far, far = _b === void 0 ? 20 : _b, _c = options.fov, fov = _c === void 0 ? 60 : _c, _d = options.aspect, aspect = _d === void 0 ? 1 : _d, _e = options.clipMode, clipMode = _e === void 0 ? CameraClipMode$1.portrait : _e, _f = options.position, position = _f === void 0 ? [0, 0, 8] : _f, _g = options.rotation, rotation = _g === void 0 ? [0, 0, 0] : _g;
        this.options = {
            near: near,
            far: far,
            fov: fov,
            aspect: aspect,
            clipMode: clipMode,
            position: Vector3.fromArray(position),
            rotation: Euler.fromArray(rotation),
        };
        this.dirty = true;
        this.updateMatrix();
    }
    Object.defineProperty(Camera.prototype, "near", {
        get: function () {
            return this.options.near;
        },
        /**
         * 设置相机近平面
         * @param near
         */
        set: function (near) {
            if (this.options.near !== near) {
                this.options.near = near;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "far", {
        get: function () {
            return this.options.far;
        },
        /**
         * 设置相机远平面
         * @param far
         */
        set: function (far) {
            if (this.options.far !== far) {
                this.options.far = far;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "fov", {
        get: function () {
            return this.options.fov;
        },
        /**
         * 设置相机视锥体垂直视野角度
         * @param fov
         */
        set: function (fov) {
            if (this.options.fov !== fov) {
                this.options.fov = fov;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "aspect", {
        get: function () {
            return this.options.aspect;
        },
        /**
         * 设置相机视锥体的长宽比
         * @param aspect
         */
        set: function (aspect) {
            if (this.options.aspect !== aspect) {
                this.options.aspect = aspect;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "clipMode", {
        get: function () {
            return this.options.clipMode;
        },
        /**
         * 相机的裁剪模式
         * @param clipMode
         */
        set: function (clipMode) {
            if (clipMode !== undefined && this.options.clipMode !== clipMode) {
                this.options.clipMode = clipMode;
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "position", {
        get: function () {
            return this.options.position.clone();
        },
        /**
         * 设置相机的位置
         * @param value
         */
        set: function (value) {
            if (!this.options.position.equals(value)) {
                this.options.position.copyFrom(value);
                this.dirty = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "rotation", {
        get: function () {
            return this.options.rotation.clone();
        },
        /**
         * 设置相机的旋转角度
         * @param value
         */
        set: function (value) {
            if (!this.options.rotation.equals(value)) {
                this.options.rotation.copyFrom(value);
                this.dirty = true;
                this.options.quat = undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取相机的视图变换矩阵
     * @return
     */
    Camera.prototype.getViewMatrix = function () {
        this.updateMatrix();
        return this.viewMatrix.clone();
    };
    /**
     * 获取视图变换的逆矩阵
     */
    Camera.prototype.getInverseViewMatrix = function () {
        this.updateMatrix();
        return this.inverseViewMatrix.clone();
    };
    /**
     * 获取相机的投影矩阵
     * @return
     */
    Camera.prototype.getProjectionMatrix = function () {
        this.updateMatrix();
        return this.projectionMatrix.clone();
    };
    /**
     * 获取相机投影矩阵的逆矩阵
     * @return
     */
    Camera.prototype.getInverseProjectionMatrix = function () {
        var _a;
        this.updateMatrix();
        return (_a = this.inverseProjectionMatrix) === null || _a === void 0 ? void 0 : _a.clone();
    };
    /**
     * 获取相机的 VP 矩阵
     * @return
     */
    Camera.prototype.getViewProjectionMatrix = function () {
        this.updateMatrix();
        return this.viewProjectionMatrix.clone();
    };
    /**
     * 获取相机 VP 矩阵的逆矩阵
     * @return
     */
    Camera.prototype.getInverseViewProjectionMatrix = function () {
        this.updateMatrix();
        if (!this.inverseViewProjectionMatrix) {
            this.inverseViewProjectionMatrix = this.viewProjectionMatrix.clone();
            this.inverseViewProjectionMatrix.invert();
        }
        return this.inverseViewProjectionMatrix.clone();
    };
    /**
     * 根据相机的视图投影矩阵对指定模型矩阵做变换
     * @param out - 结果矩阵
     * @param model - 模型变换矩阵
     */
    Camera.prototype.getModelViewProjection = function (out, model) {
        return out.multiplyMatrices(this.viewProjectionMatrix, model);
    };
    /**
     * 获取归一化坐标和 3D 世界坐标的换算比例
     * @param z - 当前的位置 z
     */
    Camera.prototype.getInverseVPRatio = function (z) {
        var pos = new Vector3(0, 0, z);
        var mat = this.getViewProjectionMatrix();
        var inverseVP = this.getInverseViewProjectionMatrix();
        var nz = mat.projectPoint(pos).z;
        return inverseVP.projectPoint(new Vector3(1, 1, nz));
    };
    /**
     * 设置相机的旋转四元数
     * @param value - 旋转四元数
     */
    Camera.prototype.setQuat = function (value) {
        if (this.options.quat === undefined) {
            this.options.quat = value.clone();
            this.dirty = true;
        }
        else {
            if (!this.options.quat.equals(value)) {
                this.options.quat.copyFrom(value);
                this.dirty = true;
            }
        }
        if (this.dirty) {
            this.setRotationByQuat(value);
        }
    };
    /**
     * 获取相机旋转对应的四元数
     * @returns
     */
    Camera.prototype.getQuat = function () {
        var quat = this.options.quat;
        if (quat === undefined) {
            quat = new Quaternion();
            var rotation = this.options.rotation;
            if (rotation) {
                quat.setFromEuler(rotation);
            }
            this.options.quat = quat;
        }
        return quat;
    };
    /**
     * 获取相机内部的 options
     * @returns 相机 options
     */
    Camera.prototype.getOptions = function () {
        return this.options;
    };
    /**
     * 复制指定相机元素的属性到当前相机
     * @param camera
     */
    Camera.prototype.copy = function (camera) {
        var near = camera.near, far = camera.far, fov = camera.fov, clipMode = camera.clipMode, aspect = camera.aspect, position = camera.position, rotation = camera.rotation;
        this.near = near;
        this.far = far;
        this.fov = fov;
        this.clipMode = clipMode;
        this.aspect = aspect;
        this.position = position;
        this.rotation = rotation;
        this.updateMatrix();
    };
    /**
     * 更新相机相关的矩阵，获取矩阵前会自动调用
     */
    Camera.prototype.updateMatrix = function () {
        if (this.dirty) {
            var _a = this.options, fov = _a.fov, aspect = _a.aspect, near = _a.near, far = _a.far, clipMode = _a.clipMode, position = _a.position;
            this.projectionMatrix.perspective(fov * DEG2RAD, aspect, near, far, clipMode === CameraClipMode$1.portrait);
            this.inverseViewMatrix.compose(position, this.getQuat(), tmpScale);
            this.viewMatrix.copyFrom(this.inverseViewMatrix).invert();
            this.viewProjectionMatrix.multiplyMatrices(this.projectionMatrix, this.viewMatrix);
            this.inverseViewProjectionMatrix = null;
            this.dirty = false;
        }
    };
    Camera.prototype.setRotationByQuat = function (quat) {
        Transform.getRotation(quat, this.options.rotation);
    };
    return Camera;
}());

function createCameraMoveShader() {
    return [
        {
            vertex: cameraMoveVert,
            fragment: copyFrag,
            shaderCacheId: 'camera-move',
        },
    ];
}
function registerCameraMoveFilter(filter, composition) {
    var _a = filter.position, position = _a === void 0 ? [0, 0, 0] : _a;
    var params = position;
    if (Number.isFinite(position[0]) && Number.isFinite(position[1])) {
        params = [ValueType$1.CONSTANT_VEC3, position];
    }
    var pos = createValueGetter(params);
    var camera = new Camera('camera_move');
    var cameraPos = new Vector3();
    var renderer = composition.renderer;
    var textureFilter = renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var cameraPass = new CopyPass(renderer, {
        name: 'cameraCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: textureFilter, magFilter: textureFilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            vertex: cameraMoveVert,
            fragment: copyFrag,
            shaderCacheId: 'camera-move',
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
            variables: {
                uMoveCameraViewPro: function (p) {
                    camera.copy(composition.camera);
                    var trans = pos.getValue(p);
                    cameraPos.addVectors(composition.camera.position, new Vector3(-trans[0], -trans[1], -trans[2]));
                    camera.position = cameraPos;
                    return camera.getViewProjectionMatrix().toArray();
                },
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
            prePasses: [cameraPass],
        },
    };
}

function createLumShader() {
    return [{ fragment: copyFrag }];
}
function registerLumFilter(filter, composition) {
    var renderer = composition.renderer;
    var texturefilter = renderer.engine.gpuCapability.level === 2 ? glContext.LINEAR : glContext.NEAREST;
    var lumCopyPass = new CopyPass(renderer, {
        name: 'lumCopyPass',
        attachments: [{ texture: { format: glContext.RGBA, minFilter: texturefilter, magFilter: texturefilter } }],
        clearAction: {
            colorAction: exports.TextureLoadAction.clear,
        },
    });
    return {
        mesh: {
            fragment: copyFrag,
            uniformValues: {
                uFilterParams: [1, 0, 0, 0],
            },
            materialStates: {
                blending: false,
                depthTest: false,
                culling: false,
            },
        },
        passSplitOptions: {
            attachments: [{ texture: { format: glContext.RGBA } }],
        },
        prePasses: [lumCopyPass],
        renderPassDelegate: {},
    };
}

var filters = {
    lum: [registerLumFilter, createLumShader],
    // 透明视频
    alphaFrame: [registerAlphaFrameFilter, createAlphaFrameShader],
    // 移动镜头
    cameraMove: [registerCameraMoveFilter, createCameraMoveShader],
    // 渐变滤镜
    alphaMask: [registerAlphaMaskFilter, createAlphaMaskShader],
    // 扭曲滤镜
    distortion: [registerDistortionFilter, createDistortionShader],
    // 发光
    bloom: [registerBloomFilter, createBloomShader],
    // 高斯模糊
    gaussian: [registerGaussianFilter, createGaussianShader],
    // 动作延迟
    delay: [registerDelayFilter, createDelayShader],
};

/*!
 * Name: @galacean/effects-specification
 * Description: Galacean Effects JSON Specification
 * Author: Ant Group CO., Ltd.
 * Version: v1.3.0
 */

/*********************************************/
/*               元素属性参数类型               */
/*********************************************/
/**
 * 渲染等级
 */
var RenderLevel;
(function (RenderLevel) {
    RenderLevel["S"] = "S";
    RenderLevel["APlus"] = "A+";
    RenderLevel["A"] = "A";
    RenderLevel["BPlus"] = "B+";
    RenderLevel["B"] = "B";
})(RenderLevel || (RenderLevel = {}));
/**
 * 混合模式
 */
var BlendingMode;
(function (BlendingMode) {
    /**
     * 普通混合模式
     */
    BlendingMode[BlendingMode["ALPHA"] = 0] = "ALPHA";
    /**
     * 叠加混合模式
     */
    BlendingMode[BlendingMode["ADD"] = 1] = "ADD";
    /**
     * 相乘混合模式
     */
    BlendingMode[BlendingMode["MULTIPLY"] = 2] = "MULTIPLY";
    /**
     * 亮度混合模式
     */
    BlendingMode[BlendingMode["BRIGHTNESS"] = 3] = "BRIGHTNESS";
    /**
     * 减色混合模式
     */
    BlendingMode[BlendingMode["SUBTRACTION"] = 4] = "SUBTRACTION";
    /**
     * 强光混合模式
     */
    BlendingMode[BlendingMode["STRONG_LIGHT"] = 5] = "STRONG_LIGHT";
    /**
     * 弱光混合模式
     */
    BlendingMode[BlendingMode["WEAK_LIGHT"] = 6] = "WEAK_LIGHT";
    /**
     * 亮度叠加混合模式
     */
    BlendingMode[BlendingMode["SUPERPOSITION"] = 7] = "SUPERPOSITION";
})(BlendingMode || (BlendingMode = {}));
/**
 * 单双面模式
 */
var SideMode;
(function (SideMode) {
    /**
     * 双面模式
     */
    SideMode[SideMode["DOUBLE"] = 1032] = "DOUBLE";
    /**
     * 正面模式
     */
    SideMode[SideMode["FRONT"] = 1028] = "FRONT";
    /**
     * 背面模式
     */
    SideMode[SideMode["BACK"] = 1029] = "BACK";
})(SideMode || (SideMode = {}));
/**
 * 蒙版模式
 */
var MaskMode;
(function (MaskMode) {
    /**
     * 无蒙版
     */
    MaskMode[MaskMode["NONE"] = 0] = "NONE";
    /**
     * 蒙版
     */
    MaskMode[MaskMode["MASK"] = 1] = "MASK";
    /**
     * 被遮挡
     */
    MaskMode[MaskMode["OBSCURED"] = 2] = "OBSCURED";
    /**
     * 被反向遮挡
     */
    MaskMode[MaskMode["REVERSE_OBSCURED"] = 3] = "REVERSE_OBSCURED";
})(MaskMode || (MaskMode = {}));
/**
 * 发射器形状
 */
var ShapeType;
(function (ShapeType) {
    /**
     * 没有类型
     */
    ShapeType[ShapeType["NONE"] = 0] = "NONE";
    /**
     * 圆球
     */
    ShapeType[ShapeType["SPHERE"] = 1] = "SPHERE";
    /**
     * 圆锥
     */
    ShapeType[ShapeType["CONE"] = 2] = "CONE";
    /**
     * 半球
     */
    ShapeType[ShapeType["HEMISPHERE"] = 3] = "HEMISPHERE";
    /**
     * 圆
     */
    ShapeType[ShapeType["CIRCLE"] = 4] = "CIRCLE";
    /**
     * 圆环
     */
    ShapeType[ShapeType["DONUT"] = 5] = "DONUT";
    /**
     * 矩形
     */
    ShapeType[ShapeType["RECTANGLE"] = 6] = "RECTANGLE";
    /**
     * 矩形框
     */
    ShapeType[ShapeType["RECTANGLE_EDGE"] = 7] = "RECTANGLE_EDGE";
    /**
     * 直线
     */
    ShapeType[ShapeType["EDGE"] = 8] = "EDGE";
    /**
     * 贴图
     */
    ShapeType[ShapeType["TEXTURE"] = 9] = "TEXTURE";
})(ShapeType || (ShapeType = {}));
/**
 * 插件类型
 */
var PluginType;
(function (PluginType) {
    /**
     * 陀螺仪
     */
    PluginType[PluginType["GYROSCOPE"] = 0] = "GYROSCOPE";
    /**
     * Spine
     */
    PluginType[PluginType["SPINE"] = 1] = "SPINE";
})(PluginType || (PluginType = {}));
/**
 * 交互类型
 */
var InteractType;
(function (InteractType) {
    /**
     * 点击
     */
    InteractType[InteractType["CLICK"] = 0] = "CLICK";
    /**
     * 消息
     * 前端收到 onMessageItem 回调
     */
    InteractType[InteractType["MESSAGE"] = 1] = "MESSAGE";
    /**
     * 拖拽
     */
    InteractType[InteractType["DRAG"] = 2] = "DRAG";
})(InteractType || (InteractType = {}));
/**
 * 交互行为
 */
var InteractBehavior;
(function (InteractBehavior) {
    /**
     * 无
     */
    InteractBehavior[InteractBehavior["NONE"] = 0] = "NONE";
    /**
     * 通知
     */
    InteractBehavior[InteractBehavior["NOTIFY"] = 1] = "NOTIFY";
    /**
     * 重置播放器
     */
    InteractBehavior[InteractBehavior["RESUME_PLAYER"] = 2] = "RESUME_PLAYER";
    /**
     * 清除元素
     */
    InteractBehavior[InteractBehavior["REMOVE"] = 3] = "REMOVE";
    /**
     * 暂停播放器
     */
    InteractBehavior[InteractBehavior["PAUSE"] = 4] = "PAUSE";
})(InteractBehavior || (InteractBehavior = {}));
/**
 * 元素类型
 */
var ItemType;
(function (ItemType) {
    /**
     * 错误元素
     */
    ItemType["base"] = "0";
    /**
     * 图层元素
     */
    ItemType["sprite"] = "1";
    /**
     * 粒子元素
     */
    ItemType["particle"] = "2";
    /**
     * 空节点元素
     */
    ItemType["null"] = "3";
    /**
     * 交互元素
     */
    ItemType["interact"] = "4";
    /**
     * 插件元素
     */
    ItemType["plugin"] = "5";
    /**
     * 相机元素
     */
    ItemType["camera"] = "6";
    /**
     * 预合成元素
     */
    ItemType["composition"] = "7";
    /**
     * 滤镜图层
     */
    ItemType["filter"] = "8";
    /**
     * Spine 元素
     */
    ItemType["spine"] = "spine";
    /**
     * Mesh 元素
     */
    ItemType["mesh"] = "mesh";
    /**
     * 节点树元素
     */
    ItemType["tree"] = "tree";
    /**
     * 文本元素
     */
    ItemType["text"] = "text";
    /**
     * 灯光元素
     */
    ItemType["light"] = "light";
    /**
     * 天空盒元素
     */
    ItemType["skybox"] = "skybox";
})(ItemType || (ItemType = {}));
/**
 * 渲染模式
 */
var RenderMode;
(function (RenderMode) {
    /**
     * 广告牌模式
     */
    RenderMode[RenderMode["BILLBOARD"] = 0] = "BILLBOARD";
    /**
     * 网格模式
     */
    RenderMode[RenderMode["MESH"] = 1] = "MESH";
    /**
     * 垂直广告牌模式
     */
    RenderMode[RenderMode["VERTICAL_BILLBOARD"] = 2] = "VERTICAL_BILLBOARD";
    /**
     * 水平广告牌模式
     */
    RenderMode[RenderMode["HORIZONTAL_BILLBOARD"] = 3] = "HORIZONTAL_BILLBOARD";
})(RenderMode || (RenderMode = {}));
/**
 * 变换中心
 */
var ParticleOrigin;
(function (ParticleOrigin) {
    /**
     * 水平和垂直中点
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER"] = 0] = "PARTICLE_ORIGIN_CENTER";
    /**
     * 水平左侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_TOP"] = 1] = "PARTICLE_ORIGIN_LEFT_TOP";
    /**
     * 水平左侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_CENTER"] = 2] = "PARTICLE_ORIGIN_LEFT_CENTER";
    /**
     * 水平左侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_BOTTOM"] = 3] = "PARTICLE_ORIGIN_LEFT_BOTTOM";
    /**
     * 水平中间 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_TOP"] = 4] = "PARTICLE_ORIGIN_CENTER_TOP";
    /**
     * 水平中间 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_BOTTOM"] = 5] = "PARTICLE_ORIGIN_CENTER_BOTTOM";
    /**
     * 水平右侧 垂直顶部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_TOP"] = 6] = "PARTICLE_ORIGIN_RIGHT_TOP";
    /**
     * 水平右侧 垂直中间
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_CENTER"] = 7] = "PARTICLE_ORIGIN_RIGHT_CENTER";
    /**
     * 水平右侧 垂直底部
     */
    ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_BOTTOM"] = 8] = "PARTICLE_ORIGIN_RIGHT_BOTTOM";
})(ParticleOrigin || (ParticleOrigin = {}));

var END_BEHAVIOR_DESTROY = 0;
var END_BEHAVIOR_PAUSE = 1;
var END_BEHAVIOR_FORWARD = 2;
var END_BEHAVIOR_PAUSE_AND_DESTROY = 3;
var END_BEHAVIOR_FREEZE = 4;
var END_BEHAVIOR_RESTART = 5;
var END_BEHAVIOR_DESTROY_CHILDREN = 6;
var CAMERA_CLIP_MODE_VERTICAL = 1;
var CAMERA_CLIP_MODE_NORMAL = 0;

var CameraClipMode;
(function (CameraClipMode) {
    /**
     * 剪裁上下
     */
    CameraClipMode[CameraClipMode["portrait"] = CAMERA_CLIP_MODE_VERTICAL] = "portrait";
    /**
     * 剪裁左右
     */
    CameraClipMode[CameraClipMode["landscape"] = CAMERA_CLIP_MODE_NORMAL] = "landscape";
})(CameraClipMode || (CameraClipMode = {}));
/**
 * 结束行为
 */
var CompositionEndBehavior;
(function (CompositionEndBehavior) {
    /**
     * 销毁
     */
    CompositionEndBehavior[CompositionEndBehavior["destroy"] = END_BEHAVIOR_DESTROY] = "destroy";
    /**
     * 暂停
     */
    CompositionEndBehavior[CompositionEndBehavior["pause"] = END_BEHAVIOR_PAUSE] = "pause";
    /**
     * 重播
     */
    CompositionEndBehavior[CompositionEndBehavior["restart"] = END_BEHAVIOR_RESTART] = "restart";
    /**
     * 无限播放
     */
    CompositionEndBehavior[CompositionEndBehavior["forward"] = END_BEHAVIOR_FORWARD] = "forward";
    /**
     * 销毁并保留最后一帧
     */
    CompositionEndBehavior[CompositionEndBehavior["pause_destroy"] = END_BEHAVIOR_PAUSE_AND_DESTROY] = "pause_destroy";
})(CompositionEndBehavior || (CompositionEndBehavior = {}));

/**
 * 动态换图类型
 * @since 1.3.0
 */
var BackgroundType;
(function (BackgroundType) {
    BackgroundType["video"] = "video";
    BackgroundType["image"] = "image";
})(BackgroundType || (BackgroundType = {}));

/*********************************************/
/*               基本数值属性参数              */
/*********************************************/
var ValueType;
(function (ValueType) {
    /**
     * 常数
     */
    ValueType[ValueType["CONSTANT"] = 0] = "CONSTANT";
    /**
     * 二维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC2"] = 1] = "CONSTANT_VEC2";
    /**
     * 三维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC3"] = 2] = "CONSTANT_VEC3";
    /**
     * 四维常数向量
     */
    ValueType[ValueType["CONSTANT_VEC4"] = 3] = "CONSTANT_VEC4";
    /**
     * 随机数
     */
    ValueType[ValueType["RANDOM"] = 4] = "RANDOM";
    /**
     * 直线
     */
    ValueType[ValueType["LINE"] = 5] = "LINE";
    /**
     * 曲线
     */
    ValueType[ValueType["CURVE"] = 6] = "CURVE";
    /**
     * 贝塞尔路径
     */
    ValueType[ValueType["BEZIER_PATH"] = 7] = "BEZIER_PATH";
    /**
     * 颜色
     */
    ValueType[ValueType["RGBA_COLOR"] = 8] = "RGBA_COLOR";
    /**
     * 渐变色
     */
    ValueType[ValueType["GRADIENT_COLOR"] = 9] = "GRADIENT_COLOR";
    /**
     * 蒙版形状点集
     */
    ValueType[ValueType["SHAPE_POINTS"] = 10] = "SHAPE_POINTS";
    /**
     * 蒙版形状切分
     */
    ValueType[ValueType["SHAPE_SPLITS"] = 11] = "SHAPE_SPLITS";
    /**
     *直线路径
     */
    ValueType[ValueType["LINEAR_PATH"] = 12] = "LINEAR_PATH";
    /**
     * 多色
     */
    ValueType[ValueType["COLORS"] = 13] = "COLORS";
    /**
     * 二进制指针
     */
    ValueType[ValueType["BINARY"] = 20] = "BINARY";
    /**
     * 贝塞尔曲线
     */
    ValueType[ValueType["BEZIER_CURVE"] = 21] = "BEZIER_CURVE";
    /**
     * 贝塞尔曲线路径
     */
    ValueType[ValueType["BEZIER_CURVE_PATH"] = 22] = "BEZIER_CURVE_PATH";
})(ValueType || (ValueType = {}));
/**
 * 关键帧类型
 */
var BezierKeyframeType;
(function (BezierKeyframeType) {
    BezierKeyframeType[BezierKeyframeType["AUTO"] = 0] = "AUTO";
    BezierKeyframeType[BezierKeyframeType["EASE"] = 1] = "EASE";
    BezierKeyframeType[BezierKeyframeType["EASE_IN"] = 2] = "EASE_IN";
    BezierKeyframeType[BezierKeyframeType["EASE_OUT"] = 3] = "EASE_OUT";
    BezierKeyframeType[BezierKeyframeType["LINE"] = 4] = "LINE";
    BezierKeyframeType[BezierKeyframeType["HOLD"] = 5] = "HOLD";
    BezierKeyframeType[BezierKeyframeType["LINE_OUT"] = 6] = "LINE_OUT";
})(BezierKeyframeType || (BezierKeyframeType = {}));

var ItemEndBehavior;
(function (ItemEndBehavior) {
    ItemEndBehavior[ItemEndBehavior["destroy"] = END_BEHAVIOR_DESTROY] = "destroy";
    ItemEndBehavior[ItemEndBehavior["loop"] = END_BEHAVIOR_RESTART] = "loop";
    ItemEndBehavior[ItemEndBehavior["freeze"] = END_BEHAVIOR_FREEZE] = "freeze";
})(ItemEndBehavior || (ItemEndBehavior = {}));
var ParentItemEndBehavior;
(function (ParentItemEndBehavior) {
    ParentItemEndBehavior[ParentItemEndBehavior["destroyChildren"] = END_BEHAVIOR_DESTROY_CHILDREN] = "destroyChildren";
})(ParentItemEndBehavior || (ParentItemEndBehavior = {}));

/**
 * 粒子交互行为
 */
var ParticleInteractionBehavior;
(function (ParticleInteractionBehavior) {
    /**
     * 无
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["none"] = 0] = "none";
    /**
     * 移出粒子
     */
    ParticleInteractionBehavior[ParticleInteractionBehavior["removeParticle"] = 1] = "removeParticle";
})(ParticleInteractionBehavior || (ParticleInteractionBehavior = {}));

var ShapeArcMode;
(function (ShapeArcMode) {
    /**
     * 随机
     */
    ShapeArcMode[ShapeArcMode["RANDOM"] = 0] = "RANDOM";
    /**
     * 单向循环
     */
    ShapeArcMode[ShapeArcMode["UNIDIRECTIONAL_CYCLE"] = 1] = "UNIDIRECTIONAL_CYCLE";
    /**
     * 双向循环
     */
    ShapeArcMode[ShapeArcMode["BIDIRECTIONAL_CYCLE"] = 2] = "BIDIRECTIONAL_CYCLE";
    /**
     * 均匀爆发
     */
    ShapeArcMode[ShapeArcMode["UNIFORM_BURST"] = 3] = "UNIFORM_BURST";
})(ShapeArcMode || (ShapeArcMode = {}));

var ModelBoundingType;
(function (ModelBoundingType) {
    ModelBoundingType[ModelBoundingType["box"] = 2] = "box";
    ModelBoundingType[ModelBoundingType["sphere"] = 3] = "sphere";
})(ModelBoundingType || (ModelBoundingType = {}));

// 材质类型
var MaterialType;
(function (MaterialType) {
    MaterialType["unlit"] = "unlit";
    MaterialType["pbr"] = "pbr";
    // 头发材质，在 pbr 材质基础上扩展
    MaterialType["hair"] = "hair";
})(MaterialType || (MaterialType = {}));
// 混合模式
var MaterialBlending;
(function (MaterialBlending) {
    MaterialBlending[MaterialBlending["opaque"] = 100] = "opaque";
    MaterialBlending[MaterialBlending["masked"] = 101] = "masked";
    MaterialBlending[MaterialBlending["translucent"] = 102] = "translucent";
    MaterialBlending[MaterialBlending["additive"] = 103] = "additive";
})(MaterialBlending || (MaterialBlending = {}));

/**
 * 3D渲染模式：将渲染过程中的中间结果输出，主要用于排查渲染效果问题，支持 pbr 和 unlit 材质
 */
var RenderMode3D;
(function (RenderMode3D) {
    /**
     * 正常渲染
     */
    RenderMode3D["none"] = "none";
    /**
     * 纹理坐标
     */
    RenderMode3D["uv"] = "uv";
    /**
     * 世界坐标法线
     */
    RenderMode3D["normal"] = "normal";
    /**
     * 基础颜色
     */
    RenderMode3D["basecolor"] = "basecolor";
    /**
     * 基础颜色 Alpha
     */
    RenderMode3D["alpha"] = "alpha";
    /**
     * 金属度
     */
    RenderMode3D["metallic"] = "metallic";
    /**
     * 粗超度
     */
    RenderMode3D["roughness"] = "roughness";
    /**
     * 环境遮蔽
     */
    RenderMode3D["ao"] = "ao";
    /**
     * 自发光
     */
    RenderMode3D["emissive"] = "emissive";
})(RenderMode3D || (RenderMode3D = {}));

var TextOverflow;
(function (TextOverflow) {
    /**
     * display 模式下，会显示所有文本，存在文本超过边界框的情况。
     */
    TextOverflow[TextOverflow["display"] = 0] = "display";
    /**
     * clip 模式下，当文本内容超出边界框时，多余的会被截断。
     */
    TextOverflow[TextOverflow["clip"] = 1] = "clip";
    /**
     * ellipsis 模式下，会使用（...）来代替超出边界框的内容。
     */
    TextOverflow[TextOverflow["ellipsis"] = 2] = "ellipsis";
})(TextOverflow || (TextOverflow = {}));
var TextBaseline;
(function (TextBaseline) {
    /**
     * 文本顶对齐。
     */
    TextBaseline[TextBaseline["top"] = 0] = "top";
    /**
     * 文本垂直居中对齐。
     */
    TextBaseline[TextBaseline["middle"] = 1] = "middle";
    /**
     * 文本底对齐。
     */
    TextBaseline[TextBaseline["bottom"] = 2] = "bottom";
})(TextBaseline || (TextBaseline = {}));
var TextAlignment;
(function (TextAlignment) {
    /**
     * text alignment starts from（x,y) to right direction
     * 从(x,y)开始第一个字符，向右边延伸
     */
    TextAlignment[TextAlignment["left"] = 0] = "left";
    /**
     * (x,y) is middle position of text, where (left + right)/2 =(x,y)
     * (x,y) 为文字中间位置，（最左位置 + 最右位置)/2 = (x,y)
     */
    TextAlignment[TextAlignment["middle"] = 1] = "middle";
    /**
     * text alignment ends with（x,y) from left direction
     * 从(x,y)结束最后一个字符，向左边延伸
     */
    TextAlignment[TextAlignment["right"] = 2] = "right";
})(TextAlignment || (TextAlignment = {}));
/**
 * 文本字重
 */
var TextWeight;
(function (TextWeight) {
    /**
     * 正常
     */
    TextWeight["normal"] = "normal";
    /**
     * 粗体
     */
    TextWeight["bold"] = "bold";
    /**
     * 瘦体
     */
    TextWeight["lighter"] = "lighter";
})(TextWeight || (TextWeight = {}));
/**
 * 文本样式
 */
var FontStyle;
(function (FontStyle) {
    /**
     * 正常
     */
    FontStyle["normal"] = "normal";
    /**
     * 斜体
     */
    FontStyle["italic"] = "italic";
    /**
     * 倾斜体
     */
    FontStyle["oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function arrAdd(arr, item) {
    if (!arr.includes(item)) {
        arr.push(item);
        return true;
    }
}
/**
 * @deprecated 请直接使用 Array.prototype.forEach 或 for...of
 * @param object
 * @param callback
 * @returns the mutated input object
 */
function forEach(object, callback, thisObj) {
    if (object) {
        for (var name_1 in object) {
            if (Object.hasOwnProperty.call(object, name_1)) {
                callback.call(thisObj, object[name_1], name_1);
            }
        }
    }
    return object;
}
function ensureFixedNumber(a) {
    if (Number.isFinite(a)) {
        return [ValueType.CONSTANT, a];
    }
    if (a) {
        var valueType = a[0];
        var valueData = a[1];
        if (Array.isArray(valueType)) {
            // 没有数据类型的数据
            return;
        }
        if (valueType === 'static' || valueType === ValueType.CONSTANT) {
            return [ValueType.CONSTANT, a[1]];
        }
        if (valueType === 'lines') {
            return [ValueType.LINE, a[1]];
        }
        if (valueType === ValueType.LINE) {
            // @ts-expect-error
            var keyframes = valueData.map(function (data) { return [BezierKeyframeType.LINE, data]; });
            return [ValueType.BEZIER_CURVE, keyframes];
        }
        if (valueType === 'curve' || valueType === ValueType.CURVE) {
            return [ValueType.BEZIER_CURVE, getBezierCurveFromHermiteInGE(valueData)];
        }
        return a;
    }
}
function ensureFixedNumberWithRandom(a, p) {
    if (Array.isArray(a) && a[0] === 'random') {
        return [ValueType.CONSTANT, a[1][p]];
    }
    return ensureFixedNumber(a);
}
function ensureRGBAValue(a) {
    if (a && a[0] === 'color') {
        return colorToArr(a[1], true);
    }
    return [1, 1, 1, 1];
}
function ensureColorExpression(a, normalized) {
    if (a) {
        if (a[0] === 'colors') {
            return [ValueType.COLORS, a[1].map(function (color) { return colorToArr(color, normalized); })];
        }
        else if (a[0] === 'gradient') {
            return ensureGradient(a[1], normalized);
        }
        else if (a[0] === 'color') {
            return [ValueType.RGBA_COLOR, colorToArr(a[1], normalized)];
        }
        return a;
    }
}
function ensureNumberExpression(a) {
    if (a && a[0] === 'random') {
        return [ValueType.RANDOM, a[1]];
    }
    return ensureFixedNumber(a);
}
function ensureValueGetter(a) {
    if (Array.isArray(a) && typeof a[0] === 'string') {
        return ensureNumberExpression(a) || ensureFixedVec3(a) || ensureColorExpression(a) || a;
    }
    return a;
}
function ensureGradient(a, normalized) {
    if (a) {
        var stops_1 = [];
        Object.getOwnPropertyNames(a).forEach(function (p) {
            var stop = parsePercent(p);
            var color = colorToArr(a[p], normalized);
            stops_1.push([stop, color[0], color[1], color[2], color[3]]);
        });
        stops_1 = stops_1.sort(function (a, b) { return a[0] - b[0]; });
        return [ValueType.GRADIENT_COLOR, stops_1];
    }
}
function colorToArr(hex, normalized) {
    var ret;
    if (typeof hex === 'string') {
        hex = hex.replace(/[\s\t\r\n]/g, '');
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [+m[1], +m[2], +m[3], isNaN(a) ? 255 : Math.round(a * 255)];
        }
        else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [parseInt(hex[1] + hex[1], 16), parseInt(hex[2] + hex[2], 16), parseInt(hex[3] + hex[3], 16), 255];
            // eslint-disable-next-line no-cond-assign
        }
        else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [parseInt(m[1], 16), parseInt(m[2], 16), parseInt(m[3], 16), 255] || [0, 0, 0, 255];
        }
    }
    else if (hex instanceof Array) {
        ret = [hex[0], hex[1], hex[2], isNaN(hex[3]) ? 255 : Math.round(hex[3] * 255)];
    }
    if (normalized) {
        // @ts-expect-error
        ret = normalizeColor(ret);
    }
    // @ts-expect-error
    return ret;
}
function normalizeColor(a) {
    if (Array.isArray(a)) {
        return a.map(function (i) { return Number.isFinite(i / 255) ? Number((i / 255).toFixed(6)) : 0; });
    }
}
function parsePercent(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}
function getGradientColor(color, normalized) {
    if (Array.isArray(color)) {
        if (color[0] === ValueType.GRADIENT_COLOR) {
            return color;
        }
        // @ts-expect-error
        return (color[0] === 'gradient' || color[0] === 'color') && ensureGradient(color[1], normalized);
    }
    else {
        return ensureGradient(color, normalized);
    }
}
function ensureFixedVec3(a) {
    if (a) {
        if (a.length === 3) {
            return [ValueType.CONSTANT_VEC3, a];
        }
        var valueType = a[0];
        if (valueType === 'path' ||
            valueType === 'bezier' ||
            valueType === ValueType.BEZIER_PATH ||
            valueType === ValueType.LINEAR_PATH) {
            var valueData = a[1];
            var easing = valueData[0];
            var points = valueData[1];
            var controlPoints = valueData[2];
            var bezierEasing = getBezierCurveFromHermiteInGE(easing);
            // linear path没有controlPoints
            if (!controlPoints) {
                controlPoints = [];
                for (var keyframeIndex = 0; keyframeIndex < points.length; keyframeIndex++) {
                    var point = points[keyframeIndex].slice();
                    if (keyframeIndex === 0) {
                        controlPoints.push(point);
                    }
                    else if (keyframeIndex < points.length - 1) {
                        controlPoints.push(point);
                        controlPoints.push(point);
                    }
                    else {
                        controlPoints.push(point);
                    }
                }
            }
            return [ValueType.BEZIER_CURVE_PATH, [bezierEasing, points, controlPoints]];
        }
        return a;
    }
}
function objectValueToNumber(o) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(o)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            o[key] = Number(o[key]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return o;
}
function deleteEmptyValue(o) {
    var e_2, _a;
    try {
        for (var _b = __values(Object.keys(o)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (o[key] === undefined) {
                delete o[key];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return o;
}
var cos = Math.cos;
var sin = Math.sin;
var d2r = Math.PI / 180;
var r2d = 180 / Math.PI;
function quatFromXYZRotation(out, x, y, z) {
    var c1 = cos((x * d2r) / 2);
    var c2 = cos((y * d2r) / 2);
    var c3 = cos((z * d2r) / 2);
    var s1 = sin((x * d2r) / 2);
    var s2 = sin((y * d2r) / 2);
    var s3 = sin((z * d2r) / 2);
    out[0] = s1 * c2 * c3 + c1 * s2 * s3;
    out[1] = c1 * s2 * c3 - s1 * c2 * s3;
    out[2] = c1 * c2 * s3 + s1 * s2 * c3;
    out[3] = c1 * c2 * c3 - s1 * s2 * s3;
    return out;
}
function clamp(v, min, max) {
    return v > max ? max : (v < min ? min : v);
}
function rotationZYXFromQuat(out, quat) {
    var x = quat[0];
    var y = quat[1];
    var z = quat[2];
    var w = quat[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var m11 = 1 - yy - zz, m12 = yx - wz;
    var m21 = yx + wz, m22 = 1 - xx - zz;
    var m31 = zx - wy, m32 = zy + wx, m33 = 1 - xx - yy;
    out[1] = Math.asin(clamp(-m31, -1, 1)) * r2d;
    if (Math.abs(m31) < 0.9999999) {
        out[0] = Math.atan2(m32, m33) * r2d;
        out[2] = Math.atan2(m21, m11) * r2d;
    }
    else {
        out[0] = 0;
        out[2] = Math.atan2(-m12, m22) * r2d;
    }
    return out;
}
function getBezierCurveFromHermite(m0, m1, p0, p3) {
    var xStart = p0[0];
    var yStart = p0[1];
    var xEnd = p3[0];
    var yEnd = p3[1];
    var dt = xEnd - xStart;
    m0 = m0 * dt;
    m1 = m1 * dt;
    var bezierControlPoints = [[xStart + (xEnd - xStart) / 3, yStart + m0 / 3], [xEnd - (xEnd - xStart) / 3, yEnd - m1 / 3]];
    return bezierControlPoints;
}
function getBezierCurveFromHermiteInGE(geHermiteCurves) {
    var ymax = -1000000;
    var ymin = 1000000;
    for (var i = 0; i < geHermiteCurves.length; i++) {
        ymax = Math.max(ymax, geHermiteCurves[i][1]);
        ymin = Math.min(ymin, geHermiteCurves[i][1]);
    }
    var geBezierCurves = [[geHermiteCurves[0][0], geHermiteCurves[0][1]]];
    for (var i = 0; i < geHermiteCurves.length - 1; i++) {
        var m0 = geHermiteCurves[i][3] * (ymax - ymin);
        var m1 = geHermiteCurves[i + 1][2] * (ymax - ymin);
        var p0 = [geHermiteCurves[i][0], geHermiteCurves[i][1]];
        var p3 = [geHermiteCurves[i + 1][0], geHermiteCurves[i + 1][1]];
        if (p0[0] != p3[0]) {
            var bezierControlPoints = getBezierCurveFromHermite(m0, m1, p0, p3);
            var p1 = bezierControlPoints[0];
            var p2 = bezierControlPoints[1];
            geBezierCurves[geBezierCurves.length - 1].push(p1[0]);
            geBezierCurves[geBezierCurves.length - 1].push(p1[1]);
            geBezierCurves.push([p2[0], p2[1], p3[0], p3[1]]);
        }
        else {
            geBezierCurves[geBezierCurves.length - 1].push(p3[0]);
            geBezierCurves[geBezierCurves.length - 1].push(p3[1]);
        }
    }
    // 添加关键帧类型
    return geBezierCurves.map(function (curve, index) {
        return index === 0 ? [BezierKeyframeType.EASE_OUT, curve]
            : index === geBezierCurves.length - 1 ? [BezierKeyframeType.EASE_IN, curve]
                : [BezierKeyframeType.EASE, curve];
    });
}

function getStandardParticleContent(particle) {
    var _a;
    var options = particle.options;
    var transform = particle.transform;
    var shape = {
        type: ShapeType.NONE,
    };
    if (particle.shape) {
        var shapeType = (_a = particle.shape.shape) === null || _a === void 0 ? void 0 : _a.replace(/([A-Z])/g, '_$1').toUpperCase().replace(/^_/, '');
        shape = __assign(__assign({}, particle.shape), { type: ShapeType[shapeType] });
        if (particle.shape.upDirection) {
            var _b = __read(particle.shape.upDirection, 3), x = _b[0], y = _b[1], z = _b[2];
            if (x === 0 && y === 0 && z === 0) {
                delete shape.upDirection;
            }
        }
    }
    if (options.startTurbulence) {
        shape.turbulenceX = ensureNumberExpression(options.turbulenceX);
        shape.turbulenceY = ensureNumberExpression(options.turbulenceY);
        shape.turbulenceZ = ensureNumberExpression(options.turbulenceZ);
    }
    var emission = particle.emission;
    if (emission.bursts && emission.bursts.length > 0) {
        emission.bursts = emission.bursts.map(function (b) { return objectValueToNumber(b); });
    }
    if (emission.burstOffsets && emission.burstOffsets.length > 0) {
        emission.burstOffsets = emission.burstOffsets.map(function (b) { return objectValueToNumber(b); });
    }
    if (emission.rateOverTime) {
        emission.rateOverTime = ensureNumberExpression(emission.rateOverTime);
    }
    var ret = {
        renderer: particle.renderer,
        shape: shape,
        splits: particle.splits,
        emission: emission,
        options: {
            startLifetime: ensureNumberExpression(options.startLifetime),
            start3DSize: !!options.start3DSize,
            startSize: ensureNumberExpression(options.startSize),
            startSizeX: ensureNumberExpression(options.startSizeX),
            startSizeY: ensureNumberExpression(options.startSizeY),
            sizeAspect: ensureNumberExpression(options.sizeAspect),
            maxCount: options.maxCount,
            startDelay: ensureNumberExpression(options.startDelay),
            startColor: ensureColorExpression(options.startColor, true),
            startRotationZ: ensureNumberExpression(options.startRotation || options.startRotationZ),
            particleFollowParent: options.particleFollowParent,
        },
    };
    if (options.start3DRotation) {
        ret.options.startRotationX = ensureNumberExpression(options.startRotationX);
        ret.options.startRotationY = ensureNumberExpression(options.startRotationY);
    }
    if (particle.filter) {
        var filter_1 = {};
        forEach(particle.filter, function (val, key) {
            // @ts-expect-error
            filter_1[key] = ensureValueGetter(val);
        });
        ret.filter = filter_1;
    }
    if (transform && transform.path) {
        ret.emitterTransform = {
            path: ensureFixedVec3(transform.path),
        };
    }
    var sizeOverLifetime = particle.sizeOverLifetime;
    if (sizeOverLifetime) {
        if (sizeOverLifetime.separateAxes) {
            ret.sizeOverLifetime = {
                separateAxes: true,
                x: ensureNumberExpression(sizeOverLifetime.x),
                y: ensureNumberExpression(sizeOverLifetime.y),
            };
        }
        else {
            ret.sizeOverLifetime = {
                size: ensureNumberExpression(sizeOverLifetime.size),
            };
        }
    }
    var velocityOverLifetime = particle.velocityOverLifetime || {};
    var sol = velocityOverLifetime.speedOverLifetime;
    if (sol) {
        sol = ensureFixedNumber(sol);
    }
    else {
        sol = undefined;
    }
    ret.positionOverLifetime = {
        gravity: options.gravity,
        gravityOverLifetime: ensureFixedNumber(options.gravityModifier),
        startSpeed: ensureNumberExpression(options.startSpeed),
        speedOverLifetime: sol,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureNumberExpression(velocityOverLifetime.linearX),
        linearY: ensureNumberExpression(velocityOverLifetime.linearY),
        linearZ: ensureNumberExpression(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureNumberExpression(velocityOverLifetime.orbitalX),
        orbitalY: ensureNumberExpression(velocityOverLifetime.orbitalY),
        orbitalZ: ensureNumberExpression(velocityOverLifetime.orbitalZ),
        forceTarget: velocityOverLifetime.forceTarget,
        target: velocityOverLifetime.target,
        forceCurve: ensureFixedNumber(velocityOverLifetime.forceCurve),
    };
    deleteEmptyValue(ret.positionOverLifetime);
    var rotationOverLifetime = particle.rotationOverLifetime;
    if (rotationOverLifetime) {
        ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation,
            z: ensureNumberExpression(rotationOverLifetime.separateAxes ? rotationOverLifetime.z : rotationOverLifetime.angularVelocity),
        };
        if (rotationOverLifetime.separateAxes) {
            ret.rotationOverLifetime.y = ensureFixedNumber(rotationOverLifetime.y);
            ret.rotationOverLifetime.x = ensureFixedNumber(rotationOverLifetime.x);
        }
    }
    var colorOverLifetime = particle.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity),
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var textureSheetAnimation = particle.textureSheetAnimation;
    if (textureSheetAnimation) {
        ret.textureSheetAnimation = {
            row: textureSheetAnimation.row,
            col: textureSheetAnimation.col,
            total: textureSheetAnimation.total,
            animate: textureSheetAnimation.animate,
            cycles: ensureFixedNumber(textureSheetAnimation.cycles),
            animationDelay: ensureFixedNumberWithRandom(textureSheetAnimation.animationDelay, 0),
            animationDuration: ensureFixedNumberWithRandom(textureSheetAnimation.animationDuration, 0),
        };
    }
    var trials = particle.trails;
    if (trials) {
        ret.trails = {
            lifetime: ensureNumberExpression(trials.lifetime),
            dieWithParticles: trials.dieWithParticles,
            maxPointPerTrail: trials.maxPointPerTrail,
            minimumVertexDistance: trials.minimumVertexDistance,
            widthOverTrail: ensureFixedNumber(trials.widthOverTrail),
            colorOverTrail: trials.colorOverTrail && getGradientColor(trials.colorOverTrail, false),
            blending: trials.blending,
            colorOverLifetime: trials.colorOverLifetime && getGradientColor(trials.colorOverLifetime, false),
            inheritParticleColor: trials.inheritParticleColor,
            occlusion: trials.occlusion,
            transparentOcclusion: trials.transparentOcclusion,
            orderOffset: trials.orderOffset,
            sizeAffectsLifetime: trials.sizeAffectsLifetime,
            sizeAffectsWidth: trials.sizeAffectsWidth,
            texture: trials.texture,
            parentAffectsPosition: trials.parentAffectsPosition,
            opacityOverLifetime: ensureNumberExpression(trials.opacityOverLifetime),
        };
    }
    ret.trails && deleteEmptyValue(ret.trails);
    var interaction = particle.interaction;
    if (interaction) {
        ret.interaction = {
            behavior: interaction.behavior,
            radius: interaction.radius,
            multiple: interaction.multiple,
        };
    }
    return ret;
}

function getStandardNullContent(sprite, transform) {
    var _a;
    var opt = sprite.options;
    var velocityOverLifetime = sprite.velocityOverLifetime || {};
    var positionOverLifetime = {
        path: ensureFixedVec3((_a = sprite.transform) === null || _a === void 0 ? void 0 : _a.path),
        gravity: opt.gravity,
        gravityOverLifetime: ensureFixedNumber(opt.gravityModifier),
        direction: opt.direction,
        startSpeed: opt.startSpeed,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureFixedNumber(velocityOverLifetime.linearX),
        linearY: ensureFixedNumber(velocityOverLifetime.linearY),
        linearZ: ensureFixedNumber(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureFixedNumber(velocityOverLifetime.orbitalX),
        orbitalY: ensureFixedNumber(velocityOverLifetime.orbitalY),
        orbitalZ: ensureFixedNumber(velocityOverLifetime.orbitalZ),
        speedOverLifetime: ensureFixedNumber(velocityOverLifetime.speedOverLifetime),
    };
    deleteEmptyValue(positionOverLifetime);
    var ret = {
        options: {
            startColor: ensureRGBAValue(opt.startColor),
        },
        positionOverLifetime: positionOverLifetime,
    };
    if (opt.startSize) {
        transform.scale = [opt.startSize, opt.startSize / (opt.sizeAspect || 1), 1];
    }
    if (opt.startRotation) {
        if (!transform.rotation) {
            transform.rotation = [0, 0, opt.startRotation];
        }
        else {
            transform.rotation[2] += opt.startRotation;
        }
    }
    var rotationOverLifetime = sprite.rotationOverLifetime;
    if (rotationOverLifetime) {
        var rot = ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation,
        };
        if (rot.separateAxes) {
            rot.x = ensureFixedNumber(rotationOverLifetime.x);
            rot.y = ensureFixedNumber(rotationOverLifetime.y);
            rot.z = ensureFixedNumber(rotationOverLifetime.z);
        }
        else {
            rot.z = ensureFixedNumber(rotationOverLifetime.angularVelocity);
        }
    }
    var colorOverLifetime = sprite.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity),
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var sizeOverLifetime = sprite.sizeOverLifetime;
    if (sizeOverLifetime) {
        ret.sizeOverLifetime = {
            separateAxes: sizeOverLifetime.separateAxes,
            size: ensureFixedNumber(sizeOverLifetime.size),
            x: ensureFixedNumber(sizeOverLifetime.x),
            y: ensureFixedNumber(sizeOverLifetime.y),
            z: ensureFixedNumber(sizeOverLifetime.z),
        };
    }
    return ret;
}
function getStandardSpriteContent(sprite, transform) {
    var ret = getStandardNullContent(sprite, transform);
    var texAni = sprite.textureSheetAnimation;
    if (texAni) {
        ret.textureSheetAnimation = {
            row: texAni.row,
            col: texAni.col,
            total: texAni.total || undefined,
            animate: texAni.animate,
        };
    }
    ret.renderer = sprite.renderer;
    if (sprite.splits) {
        ret.splits = sprite.splits;
    }
    if (sprite.interaction) {
        ret.interaction = sprite.interaction;
    }
    return ret;
}

function getStandardInteractContent(ui) {
    var options = ui.options;
    var option;
    switch (options.type) {
        case 'click': {
            option = {
                type: InteractType.CLICK,
                showPreview: options.showPreview,
                previewColor: options.previewColor && ensureRGBAValue(options.previewColor),
                behavior: options.behavior || InteractBehavior.NOTIFY,
            };
            break;
        }
        case 'drag': {
            option = {
                type: InteractType.DRAG,
                enableInEditor: !!options.enableInEditor,
                dxRange: options.dxRange,
                dyRange: options.dyRange,
                target: options.target,
            };
            break;
        }
        case 'message': {
            option = {
                type: InteractType.MESSAGE,
            };
            break;
        }
    }
    var ret = {
        // @ts-expect-error
        options: option,
    };
    return ret;
}

function getStandardCameraContent(model) {
    var _a, _b;
    var opt = model.options;
    var ret = {
        options: {
            fov: opt.fov,
            far: opt.far,
            near: opt.near,
            clipMode: opt.clipMode,
        },
    };
    var velocityOverLifetime = model.velocityOverLifetime;
    if (velocityOverLifetime || ((_a = model.transform) === null || _a === void 0 ? void 0 : _a.path)) {
        var positionOverLifetime = {
            path: ensureFixedVec3((_b = model.transform) === null || _b === void 0 ? void 0 : _b.path),
            linearX: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateX),
            linearY: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateY),
            linearZ: ensureFixedNumber(velocityOverLifetime === null || velocityOverLifetime === void 0 ? void 0 : velocityOverLifetime.translateZ),
        };
        deleteEmptyValue(positionOverLifetime);
        ret.positionOverLifetime = positionOverLifetime;
    }
    var rol = model.rotationOverLifetime;
    if (rol) {
        var rotationOverLifetime = {
            separateAxes: rol.separateAxes,
            x: ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateX),
            y: ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateY),
            z: rol.separateAxes ? ensureFixedNumber(rol === null || rol === void 0 ? void 0 : rol.rotateZ) : ensureFixedNumber(rol.rotation),
        };
        deleteEmptyValue(rotationOverLifetime);
        ret.rotationOverLifetime = rotationOverLifetime;
    }
    return ret;
}

var convertParams = [
    'strength',
    'bloomAddon',
    'colorAddon',
    'period',
    'waveMovement',
    'colorThreshold',
    'xOpacity',
    'yOpacity',
    'feather',
];
var pathParams = [
    'path', 'position',
];
function getStandardFilterContent(filter) {
    var ret = {};
    forEach(filter, function (val, key) {
        if (convertParams.includes(key)) {
            ret[key] = ensureFixedNumber(val);
        }
        else if (pathParams.includes(key)) {
            ret[key] = ensureFixedVec3(val);
        }
        else {
            ret[key] = val;
        }
    });
    return ret;
}

/**
 * 2.1 以下版本数据适配（mars-player@2.4.0 及以上版本支持 2.1 以下数据的适配）
 */
function version21Migration(json) {
    json.compositions.forEach(function (composition) {
        composition.items.forEach(function (item) {
            if (item.type === ItemType.null) {
                if (item.endBehavior === ItemEndBehavior.destroy) {
                    item.endBehavior = ItemEndBehavior.freeze;
                }
            }
        });
    });
    json.version = '2.1';
    return json;
}
/**
 * 2.2 以下版本数据适配（mars-player@2.5.0 及以上版本支持 2.2 以下数据的适配）
 */
function version22Migration(json) {
    var _a;
    var singleVersion = (_a = json.version) === null || _a === void 0 ? void 0 : _a.split('.');
    if (!singleVersion || Number(singleVersion[0]) > 2 || (Number(singleVersion[0]) === 2 && Number(singleVersion[1]) >= 2)) {
        return json;
    }
    json.compositions.forEach(function (composition) {
        composition.items.forEach(function (item) {
            if (item.type === ItemType.mesh || item.type === ItemType.light) {
                item.endBehavior = item.endBehavior === 1 ? ItemEndBehavior.destroy : item.endBehavior;
            }
        });
    });
    return json;
}
/**
 * 2.5 以下版本 赫尔米特数据转换成贝塞尔数据
 */
function version24Migration(json) {
    // 曲线转换成贝塞尔
    json.compositions.map(function (comp) {
        var e_1, _a;
        try {
            for (var _b = __values(comp.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                convertParam(item.content);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
    return json;
}
function convertParam(content) {
    var e_2, _a;
    if (!content) {
        return;
    }
    try {
        for (var _b = __values(Object.keys(content)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var value = content[key];
            var isArray = Array.isArray(value);
            if (isArray && value.length === 2 && Array.isArray(value[1])) {
                if (key === 'path') {
                    content[key] = ensureFixedVec3(value);
                }
                else {
                    content[key] = ensureFixedNumber(value);
                }
            }
            else if (!isArray && typeof value === 'object') {
                convertParam(value);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}

var v0 = /^(\d+)\.(\d+)\.(\d+)(-(\w+)\.\d+)?$/;
var standardVersion = /^(\d+)\.(\d+)$/;
var reverseParticle = false;
function getStandardJSON(json) {
    var _a;
    if (!json || typeof json !== 'object') {
        throw Error('expect a json object');
    }
    // 修正老版本数据中，meshItem以及lightItem结束行为错误问题
    version22Migration(json);
    if (v0.test(json.version)) {
        reverseParticle = ((_a = (/^(\d+)/).exec(json.version)) === null || _a === void 0 ? void 0 : _a[0]) === '0';
        return version21Migration(getStandardJSONFromV0(json));
    }
    var vs = standardVersion.exec(json.version) || [];
    var mainVersion = Number(vs[1]);
    var minorVersion = Number(vs[2]);
    if (mainVersion) {
        if (mainVersion < 2 || (mainVersion === 2 && minorVersion < 4)) {
            version24Migration(json);
        }
        if (mainVersion < 2) {
            return version21Migration(json);
        }
        return json;
    }
    throw Error('invalid json version ' + json.version);
}
var currentVersion = '1.0';
function getStandardJSONFromV0(json) {
    var _a, _b;
    currentVersion = '1.0';
    var plugins = json.plugins || [];
    if ((_a = json.bins) === null || _a === void 0 ? void 0 : _a.length) {
        currentVersion = '1.3';
    }
    var requires = (json.requires || []).slice();
    var images = json.images.map(function (img, index) { return getStandardImage(img, index, json.imageTags || []); });
    var textures = json.textures || images.map(function (img, i) { return ({ source: i, flipY: true }); });
    var ret = {
        plugins: plugins,
        shapes: json.shapes || [],
        type: 'ge',
        version: currentVersion,
        playerVersion: (_b = json.playerVersion) !== null && _b !== void 0 ? _b : {
            web: '',
            native: '',
        },
        compositionId: json.compositionId + '',
        compositions: json.compositions.map(function (comp) { return getStandardComposition(comp, { plugins: plugins, requires: requires }); }),
        images: images,
        imgUsage: json._imgs,
        binUsage: json.binUsage,
        spines: json.spines,
        requires: json.requires,
        textures: textures,
        bins: (json.bins || []).slice(),
    };
    if (json._textures) {
        ret._textures = json._textures;
    }
    return ret;
}
function getStandardImage(image, index, imageTags) {
    var renderLevel = imageTags[index];
    var oriY = image.oriY;
    if (typeof image === 'string') {
        return {
            renderLevel: renderLevel,
            url: image,
            oriY: oriY,
        };
    }
    else if (image.template) {
        return {
            url: image.url,
            template: image.template,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY,
        };
    }
    else if (image.compressed) {
        return {
            url: image.url,
            oriY: oriY,
            compressed: {
                astc: image.compressed.android,
                pvrtc: image.compressed.iOS,
            },
            webp: image.webp,
            renderLevel: renderLevel,
        };
    }
    else if (image.url) {
        return {
            url: image.url,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY,
        };
    }
    else if (image && image.sourceType) {
        return image;
    }
    throw Error('invalid image type');
}
function getStandardComposition(composition, opt) {
    var _a;
    if (opt === void 0) { opt = {}; }
    var ret = {
        id: composition.id + '',
        camera: Object.assign({ clipMode: CAMERA_CLIP_MODE_NORMAL }, composition.camera),
        duration: composition.duration,
        endBehavior: composition.endBehavior,
        items: composition.items.map(function (item) { return getStandardItem(item, opt); }),
        name: composition.name,
    };
    var startTime = composition.startTime || composition.st;
    if (startTime) {
        ret.startTime = startTime;
    }
    var previewSize = (_a = composition.meta) === null || _a === void 0 ? void 0 : _a.previewSize;
    if (previewSize && previewSize[0] === previewSize[1] && previewSize[0] === 0) {
        previewSize = undefined;
    }
    if (previewSize) {
        ret.previewSize = previewSize;
    }
    return ret;
}
var tempQuat = [0, 0, 0, 1];
var stdAnchor = 0.5;
function getStandardItem(item, opt) {
    var _a, _b, _c;
    if (opt === void 0) { opt = {}; }
    var type = ItemType.base;
    var transform;
    var originContent;
    var content;
    var endBehavior = item.endBehavior;
    var renderLevel;
    var pluginName;
    var duration = NaN;
    var pn;
    if (item.content) {
        type = item.type || ItemType.plugin;
        pn = item.pn;
        pluginName = item.pluginName;
        content = item.content;
        originContent = item.content;
        if (isNaN(pn) && !pluginName) {
            pluginName = content.options.type;
        }
        if (item.duration) {
            duration = item.duration;
        }
        transform = item.transform || getTransform(originContent.transform);
        if (type === ItemType.filter) {
            if (currentVersion < '1.1') {
                currentVersion = '1.1';
            }
            content = getStandardSpriteContent(originContent, transform);
            // @ts-expect-error
            content.filter = getStandardFilterContent(originContent.filter);
        }
    }
    else if (item.particle) {
        type = ItemType.particle;
        originContent = item.particle;
        transform = getTransform(originContent.transform, reverseParticle, true);
        content = getStandardParticleContent(originContent);
    }
    else if (item.sprite) {
        type = ItemType.sprite;
        originContent = item.sprite;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardSpriteContent(originContent, transform);
    }
    else if (item.cal) {
        type = ItemType.null;
        originContent = item.cal;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardNullContent(originContent, transform);
    }
    else if (item.ui) {
        type = ItemType.interact;
        originContent = item.ui;
        transform = getTransform(originContent.transform);
        content = getStandardInteractContent(originContent);
        transform.scale = [originContent.options.width || 1, originContent.options.height || 1, 1];
    }
    else if (item.model) {
        originContent = item.model;
        if (item.model.options.type === 1) {
            type = ItemType.camera;
            transform = getTransform(originContent.transform);
            content = getStandardCameraContent(originContent);
        }
    }
    if ((_a = content.renderer) === null || _a === void 0 ? void 0 : _a.anchor) {
        var anchor = new Float32Array(content.renderer.anchor);
        if (anchor[0] == stdAnchor && anchor[1] == stdAnchor) {
            delete content.renderer.anchor;
        }
        else if (opt.requires) {
            arrAdd(opt.requires, 'anchor');
        }
    }
    if (originContent) {
        var looping = (_b = originContent.options) === null || _b === void 0 ? void 0 : _b.looping;
        if (looping) {
            if (Array.isArray(looping)) {
                endBehavior = looping[1] ? ItemEndBehavior.loop : ItemEndBehavior.destroy;
            }
            else {
                endBehavior = ItemEndBehavior.loop;
            }
        }
        else {
            endBehavior = endBehavior || ((_c = originContent === null || originContent === void 0 ? void 0 : originContent.options) === null || _c === void 0 ? void 0 : _c.endBehavior) || ItemEndBehavior.destroy;
        }
        if (originContent.options.renderLevel) {
            renderLevel = originContent.options.renderLevel;
        }
        if (isNaN(duration)) {
            duration = originContent.options.duration;
        }
    }
    var ret = {
        type: type,
        name: item.name,
        delay: item.delay,
        duration: duration,
        id: item.id + '',
        // @ts-expect-error
        transform: transform,
        endBehavior: endBehavior,
        // @ts-expect-error
        renderLevel: renderLevel,
        content: content,
    };
    // @ts-expect-error
    if (pluginName) {
        if (opt.plugins) {
            arrAdd(opt.plugins, pluginName);
            ret.pn = opt.plugins.indexOf(pluginName);
        }
        else {
            ret.pluginName = pluginName;
        }
        // @ts-expect-error
    }
    else if (Number.isInteger(pn)) {
        // @ts-expect-error
        ret.pn = pn;
    }
    if (item.parentId) {
        ret.parentId = item.parentId + '';
    }
    return ret;
    function getTransform(originTransform, inverseRotation, changeOrder) {
        if (originTransform) {
            var transform_1 = {};
            var rotation = originTransform.rotation;
            if (rotation) {
                if (inverseRotation) {
                    transform_1.rotation = [-rotation[0], -rotation[1], -rotation[2]];
                }
                else {
                    transform_1.rotation = [rotation[0], rotation[1], rotation[2]];
                }
                if (changeOrder) {
                    var q = quatFromXYZRotation(tempQuat, transform_1.rotation[0], transform_1.rotation[1], transform_1.rotation[2]);
                    transform_1.rotation = rotationZYXFromQuat([], q);
                }
            }
            var position = originTransform.position;
            if (position) {
                transform_1.position = originTransform.position;
            }
            if (Array.isArray(originTransform.scale)) {
                transform_1.scale = [originTransform.scale[0] || 1, originTransform.scale[1] || 1, originTransform.scale[2] || 1];
            }
            return transform_1;
        }
        return {};
    }
}

var _a$4;
var renderLevelPassSet = (_a$4 = {},
    _a$4[RenderLevel$1.S] = [RenderLevel$1.S, RenderLevel$1.BPlus, RenderLevel$1.APlus],
    _a$4[RenderLevel$1.A] = [RenderLevel$1.A, RenderLevel$1.BPlus, RenderLevel$1.APlus],
    _a$4[RenderLevel$1.B] = [RenderLevel$1.B, RenderLevel$1.BPlus],
    _a$4);
function passRenderLevel(l, renderLevel) {
    if (!l || !renderLevel) {
        return true;
    }
    var arr = renderLevelPassSet[renderLevel];
    if (arr) {
        return arr.includes(l);
    }
    return false;
}

var listOrder = 0;
/**
 * 合成资源管理
 */
var CompositionSourceManager = /** @class */ (function () {
    function CompositionSourceManager(scene, engine) {
        var e_1, _a;
        this.refCompositions = new Map();
        this.refCompositionProps = new Map();
        this.mask = 0;
        // 资源
        var jsonScene = scene.jsonScene, renderLevel = scene.renderLevel, textureOptions = scene.textureOptions, pluginSystem = scene.pluginSystem, totalTime = scene.totalTime;
        var compositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage, compositionId = jsonScene.compositionId;
        if (!textureOptions) {
            throw new Error('scene.textures expected');
        }
        var cachedTextures = textureOptions.map(function (option) { return option && (option instanceof Texture ? option : Texture.create(engine, option)); });
        // 缓存创建的Texture对象
        scene.textureOptions = cachedTextures;
        cachedTextures === null || cachedTextures === void 0 ? void 0 : cachedTextures.forEach(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.initialize(); });
        try {
            for (var compositions_1 = __values$1(compositions), compositions_1_1 = compositions_1.next(); !compositions_1_1.done; compositions_1_1 = compositions_1.next()) {
                var comp = compositions_1_1.value;
                if (comp.id === compositionId) {
                    this.composition = comp;
                }
                else {
                    this.refCompositions.set(comp.id, comp);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (compositions_1_1 && !compositions_1_1.done && (_a = compositions_1.return)) _a.call(compositions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!this.composition) {
            throw new Error('Invalid composition id: ' + compositionId);
        }
        this.jsonScene = jsonScene;
        this.renderLevel = renderLevel;
        this.pluginSystem = pluginSystem;
        this.totalTime = totalTime !== null && totalTime !== void 0 ? totalTime : 0;
        this.imgUsage = imgUsage !== null && imgUsage !== void 0 ? imgUsage : {};
        this.textures = cachedTextures;
        listOrder = 0;
        this.textureOptions = textureOptions;
        this.sourceContent = this.getContent(this.composition);
    }
    CompositionSourceManager.prototype.getContent = function (composition) {
        // TODO: specification 中补充 globalVolume 类型
        // @ts-expect-error
        var id = composition.id, duration = composition.duration, name = composition.name, endBehavior = composition.endBehavior, camera = composition.camera, globalVolume = composition.globalVolume, _a = composition.startTime, startTime = _a === void 0 ? 0 : _a;
        var items = this.assembleItems(composition);
        return {
            id: id,
            duration: duration,
            name: name,
            endBehavior: isNaN(endBehavior) ? END_BEHAVIOR_PAUSE$1 : endBehavior,
            // looping,
            items: items,
            camera: camera,
            startTime: startTime,
            globalVolume: globalVolume,
        };
    };
    CompositionSourceManager.prototype.assembleItems = function (composition) {
        var _this = this;
        var items = [];
        composition.items.forEach(function (item) {
            var _a;
            var option = {};
            var visible = item.visible, itemRenderLevel = item.renderLevel, type = item.type;
            if (visible === false) {
                return;
            }
            var content = __assign$1({}, item.content);
            if (content) {
                option.content = __assign$1({}, content);
                if (passRenderLevel(itemRenderLevel, _this.renderLevel)) {
                    var renderContent = option.content;
                    option.type = type;
                    if (renderContent.renderer) {
                        renderContent.renderer = _this.changeTex(renderContent.renderer);
                        _this.processMask(renderContent.renderer);
                        var split = renderContent.splits && !renderContent.textureSheetAnimation && renderContent.splits[0];
                        if (Number.isInteger(renderContent.renderer.shape)) {
                            // TODO: scene.shapes 类型问题？
                            renderContent.renderer.shape = getGeometryByShape((_a = _this.jsonScene) === null || _a === void 0 ? void 0 : _a.shapes[renderContent.renderer.shape], split);
                        }
                        else if (renderContent.renderer.shape && isObject(renderContent.renderer.shape)) {
                            renderContent.renderer.shape = getGeometryByShape(renderContent.renderer.shape, split);
                        }
                    }
                    else {
                        option.content.renderer = { order: 0 };
                    }
                    if (renderContent.trails) {
                        renderContent.trails = _this.changeTex(renderContent.trails);
                    }
                    if (renderContent.filter) {
                        renderContent.filter = __assign$1({}, renderContent.filter);
                    }
                    var name_1 = item.name, _b = item.delay, delay = _b === void 0 ? 0 : _b, id = item.id, parentId = item.parentId, duration = item.duration, endBehavior = item.endBehavior, pluginName = item.pluginName, pn = item.pn, transform = item.transform;
                    // FIXME: specification 下定义的 Item 不存在 refCount 类型定义
                    // @ts-expect-error
                    var refCount = item.refCount;
                    var _c = _this.jsonScene.plugins, plugins = _c === void 0 ? [] : _c;
                    option.name = name_1;
                    option.delay = delay;
                    option.id = id;
                    if (parentId) {
                        option.parentId = parentId;
                    }
                    option.refCount = refCount;
                    option.duration = duration;
                    option.listIndex = listOrder++;
                    option.endBehavior = endBehavior;
                    if (pluginName) {
                        option.pluginName = pluginName;
                    }
                    else if (pn !== undefined && Number.isInteger(pn)) {
                        option.pluginName = plugins[pn];
                    }
                    if (transform) {
                        option.transform = transform;
                    }
                    // 处理预合成的渲染顺序
                    if (option.type === ItemType$1.composition) {
                        _this.mask++;
                        var refId = item.content.options.refId;
                        if (!_this.refCompositions.get(refId)) {
                            throw new Error('Invalid Ref Composition id: ' + refId);
                        }
                        var ref = _this.getContent(_this.refCompositions.get(refId));
                        if (!_this.refCompositionProps.has(refId)) {
                            _this.refCompositionProps.set(refId, ref);
                        }
                        ref.items.forEach(function (item) {
                            _this.processMask(item.content);
                        });
                        option.items = ref.items;
                    }
                    items.push(option);
                }
            }
        });
        return items;
    };
    CompositionSourceManager.prototype.changeTex = function (renderer) {
        var texIdx = renderer.texture;
        var ret = __assign$1({}, renderer);
        if (texIdx !== undefined) {
            // ret._texture = ret.texture;
            ret.texture = this.addTextureUsage(texIdx) || texIdx;
        }
        return ret;
    };
    CompositionSourceManager.prototype.addTextureUsage = function (texIdx) {
        var _a, _b;
        if (Number.isInteger(texIdx)) {
            var tex = (_a = this.textures) === null || _a === void 0 ? void 0 : _a[texIdx];
            var texId = tex === null || tex === void 0 ? void 0 : tex.id;
            // FIXME: imageUsage 取自 scene.imgUsage，类型为 Record<string, number[]>，这里给的 number，类型对不上
            var imageUsage = (_b = this.imgUsage) !== null && _b !== void 0 ? _b : {};
            if (texId && imageUsage) {
                // eslint-disable-next-line no-prototype-builtins
                if (!imageUsage.hasOwnProperty(texId)) {
                    imageUsage[texId] = 0;
                }
                imageUsage[texId]++;
                return tex;
            }
        }
    };
    /**
     * 处理蒙版和遮挡关系写入 stencil 的 ref 值
     */
    CompositionSourceManager.prototype.processMask = function (renderer) {
        if (renderer.maskMode === MaskMode$1.NONE) {
            return;
        }
        if (!renderer.mask) {
            var maskMode = renderer.maskMode;
            if (maskMode === MaskMode$1.MASK) {
                renderer.mask = ++this.mask;
            }
            else if (maskMode === MaskMode$1.OBSCURED || maskMode === MaskMode$1.REVERSE_OBSCURED) {
                renderer.mask = this.mask;
            }
        }
    };
    CompositionSourceManager.prototype.dispose = function () {
        this.textureOptions = [];
        this.textures = [];
        this.composition = undefined;
        this.jsonScene = undefined;
        this.totalTime = 0;
        this.pluginSystem = undefined;
        this.sourceContent = undefined;
        this.refCompositions.clear();
        this.refCompositionProps.clear();
    };
    return CompositionSourceManager;
}());

function isScene(scene) {
    // TODO: 判断不太优雅，后期试情况优化
    return isObject(scene) && 'jsonScene' in scene;
}

var seed$5 = 1;
/**
 * 资源管理器
 * 用于加载和动效中所有的资源文件，包括图片、插件、图层粒子数据等
 */
var AssetManager = /** @class */ (function () {
    /**
     * 构造函数
     * @param options - 场景加载参数
     * @param downloader - 资源下载对象
     */
    function AssetManager(options, downloader) {
        if (options === void 0) { options = {}; }
        if (downloader === void 0) { downloader = new Downloader(); }
        this.options = options;
        this.downloader = downloader;
        /**
         * 图像资源，用于创建和释放GPU纹理资源
         */
        this.assets = {};
        this.id = seed$5++;
        /**
         * 场景加载的超时定时器
         */
        this.timers = [];
        this.updateOptions(options);
    }
    AssetManager.prototype.updateOptions = function (options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        if (!options.pluginData) {
            options.pluginData = {};
        }
        var _a = options.timeout, timeout = _a === void 0 ? 10 : _a;
        this.timeout = timeout;
    };
    /**
     * 根据用户传入的参数修改场景数据
     */
    AssetManager.prototype.updateSceneData = function (compositions) {
        var variables = this.options.variables;
        if (!variables || Object.keys(variables).length <= 0) {
            return compositions;
        }
        compositions.forEach(function (composition) {
            composition.items.forEach(function (item) {
                if (item.type === ItemType$1.text) {
                    var textVariable = variables[item.name];
                    if (textVariable) {
                        item.content.options.text = textVariable;
                    }
                }
            });
        });
        return compositions;
    };
    /**
     * 场景创建，通过 json 创建出场景对象，并进行提前编译等工作
     * @param url - json 的 URL 链接或者 json 对象
     * @param renderer - renderer 对象，用于获取管理、编译 shader 及 GPU 上下文的参数
     * @param options - 扩展参数
     * @returns
     */
    AssetManager.prototype.loadScene = function (url, renderer, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var rawJSON, assetUrl, startTime, timeInfoMessages, gpuInstance, asyncShaderCompile, compressedTexture, timeInfos, loadTimer, cancelLoading, waitPromise, hookTimeInfo, loadResourcePromise;
            var _this = this;
            return __generator(this, function (_d) {
                assetUrl = isString(url) ? url : this.id;
                startTime = alipay.performance.now();
                timeInfoMessages = [];
                gpuInstance = renderer === null || renderer === void 0 ? void 0 : renderer.engine.gpuCapability;
                asyncShaderCompile = (_b = (_a = gpuInstance === null || gpuInstance === void 0 ? void 0 : gpuInstance.detail) === null || _a === void 0 ? void 0 : _a.asyncShaderCompile) !== null && _b !== void 0 ? _b : false;
                compressedTexture = (_c = gpuInstance === null || gpuInstance === void 0 ? void 0 : gpuInstance.detail.compressedTexture) !== null && _c !== void 0 ? _c : 0;
                timeInfos = {};
                cancelLoading = false;
                waitPromise = new Promise(function (resolve, reject) {
                    loadTimer = alipay.window.setTimeout(function () {
                        cancelLoading = true;
                        _this.removeTimer(loadTimer);
                        var totalTime = alipay.performance.now() - startTime;
                        reject("Load time out: totalTime: ".concat(totalTime.toFixed(4), "ms ").concat(timeInfoMessages.join(' '), ", url: ").concat(assetUrl));
                    }, _this.timeout * 1000);
                    _this.timers.push(loadTimer);
                });
                hookTimeInfo = function (label, func) { return __awaiter(_this, void 0, void 0, function () {
                    var st, result, time, e_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!!cancelLoading) return [3 /*break*/, 4];
                                st = alipay.performance.now();
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, func()];
                            case 2:
                                result = _a.sent();
                                time = alipay.performance.now() - st;
                                timeInfoMessages.push("[".concat(label, ": ").concat(time.toFixed(2), "]"));
                                timeInfos[label] = time;
                                return [2 /*return*/, result];
                            case 3:
                                e_1 = _a.sent();
                                throw new Error("load error in ".concat(label, ", ").concat(e_1));
                            case 4: throw new Error('load canceled.');
                        }
                    });
                }); };
                loadResourcePromise = function () { return __awaiter(_this, void 0, void 0, function () {
                    var scene, rawImages, images_1, i, _a, i, _b, usedImages_1, jsonScene_1, pluginSystem_1, _c, bins_1, images_2, compositions_1, fonts_1, _d, loadedBins_1, loadedImages_1, loadedTextures, totalTime;
                    var _this = this;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                if (!isObject(url)) return [3 /*break*/, 1];
                                // TODO: 原 JSONLoader contructor 判断是否兼容
                                rawJSON = url;
                                this.baseUrl = alipay.location.href;
                                return [3 /*break*/, 3];
                            case 1:
                                // 兼容相对路径
                                url = new alipay.URL(url, alipay.location.href).href;
                                this.baseUrl = url;
                                return [4 /*yield*/, hookTimeInfo('loadJSON', function () { return _this.loadJSON(url); })];
                            case 2:
                                rawJSON = _e.sent();
                                _e.label = 3;
                            case 3:
                                if (!isScene(rawJSON)) return [3 /*break*/, 6];
                                // 已经加载过的 可能需要更新数据模板
                                scene = __assign$1({}, rawJSON);
                                if (!(this.options && this.options.variables && Object.keys(this.options.variables).length !== 0)) return [3 /*break*/, 5];
                                rawImages = rawJSON.jsonScene.images;
                                images_1 = scene.images;
                                for (i = 0; i < rawImages.length; i++) {
                                    // 仅重新加载数据模板对应的图片
                                    if (images_1[i] instanceof alipay.HTMLCanvasElement) {
                                        images_1[i] = rawImages[i];
                                    }
                                }
                                _a = scene;
                                return [4 /*yield*/, hookTimeInfo('processImages', function () { return _this.processImages(images_1, scene.usedImages, compressedTexture); })];
                            case 4:
                                _a.images = _e.sent();
                                // 更新 TextureOptions 中的 image 指向
                                for (i = 0; i < scene.images.length; i++) {
                                    scene.textureOptions[i].image = scene.images[i];
                                }
                                scene.jsonScene.compositions = this.updateSceneData(scene.jsonScene.compositions);
                                _e.label = 5;
                            case 5: return [3 /*break*/, 12];
                            case 6: return [4 /*yield*/, hookTimeInfo('processJSON', function () { return _this.processJSON(rawJSON); })];
                            case 7:
                                _b = _e.sent(), usedImages_1 = _b.usedImages, jsonScene_1 = _b.jsonScene, pluginSystem_1 = _b.pluginSystem;
                                _c = jsonScene_1.bins, bins_1 = _c === void 0 ? [] : _c, images_2 = jsonScene_1.images, compositions_1 = jsonScene_1.compositions, fonts_1 = jsonScene_1.fonts;
                                return [4 /*yield*/, Promise.all([
                                        hookTimeInfo('processBins', function () { return _this.processBins(bins_1); }),
                                        hookTimeInfo('processImages', function () { return _this.processImages(images_2, usedImages_1, compressedTexture); }),
                                        hookTimeInfo("".concat(asyncShaderCompile ? 'async' : 'sync', "Compile"), function () { return _this.precompile(compositions_1, pluginSystem_1, renderer, options); }),
                                    ])];
                            case 8:
                                _d = __read$3.apply(void 0, [_e.sent(), 2]), loadedBins_1 = _d[0], loadedImages_1 = _d[1];
                                return [4 /*yield*/, hookTimeInfo('processFontURL', function () { return _this.processFontURL(fonts_1); })];
                            case 9:
                                _e.sent();
                                return [4 /*yield*/, hookTimeInfo('processTextures', function () { return _this.processTextures(loadedImages_1, loadedBins_1, jsonScene_1); })];
                            case 10:
                                loadedTextures = _e.sent();
                                jsonScene_1.compositions = this.updateSceneData(jsonScene_1.compositions);
                                scene = {
                                    timeInfos: timeInfos,
                                    url: url,
                                    renderLevel: this.options.renderLevel,
                                    storage: {},
                                    pluginSystem: pluginSystem_1,
                                    jsonScene: jsonScene_1,
                                    usedImages: usedImages_1,
                                    images: loadedImages_1,
                                    textureOptions: loadedTextures,
                                    bins: loadedBins_1,
                                };
                                // 触发插件系统 pluginSystem 的回调 prepareResource
                                return [4 /*yield*/, hookTimeInfo('processPlugins', function () { return pluginSystem_1.loadResources(scene, _this.options); })];
                            case 11:
                                // 触发插件系统 pluginSystem 的回调 prepareResource
                                _e.sent();
                                _e.label = 12;
                            case 12:
                                totalTime = alipay.performance.now() - startTime;
                                logger.info("Load asset: totalTime: ".concat(totalTime.toFixed(4), "ms ").concat(timeInfoMessages.join(' '), ", url: ").concat(assetUrl));
                                alipay.window.clearTimeout(loadTimer);
                                this.removeTimer(loadTimer);
                                scene.totalTime = totalTime;
                                scene.startTime = startTime;
                                // 各部分分段时长
                                scene.timeInfos = timeInfos;
                                return [2 /*return*/, scene];
                        }
                    });
                }); };
                return [2 /*return*/, Promise.race([waitPromise, loadResourcePromise()])];
            });
        });
    };
    AssetManager.prototype.precompile = function (compositions, pluginSystem, renderer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var shaderLibrary;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!renderer || !renderer.getShaderLibrary()) {
                            return [2 /*return*/];
                        }
                        shaderLibrary = renderer === null || renderer === void 0 ? void 0 : renderer.getShaderLibrary();
                        return [4 /*yield*/, (pluginSystem === null || pluginSystem === void 0 ? void 0 : pluginSystem.precompile(compositions, renderer, options))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, new Promise(function (resolve) {
                                shaderLibrary.compileAllShaders(function () {
                                    resolve(null);
                                });
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    AssetManager.prototype.processJSON = function (json) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonScene, _a, plugins, sceneCompositions, imgUsage, images, pluginSystem, renderLevel, usedImages;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        jsonScene = getStandardJSON(json);
                        // FIXME: hack globalVolume，specification 更新后需移除
                        // @ts-expect-error
                        json.compositions.forEach(function (composition, i) {
                            if (composition.globalVolume) {
                                // @ts-expect-error
                                jsonScene.compositions[i].globalVolume = composition.globalVolume;
                            }
                        });
                        _a = jsonScene.plugins, plugins = _a === void 0 ? [] : _a, sceneCompositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage, images = jsonScene.images;
                        pluginSystem = new PluginSystem(plugins);
                        return [4 /*yield*/, pluginSystem.processRawJSON(jsonScene, this.options)];
                    case 1:
                        _b.sent();
                        renderLevel = this.options.renderLevel;
                        usedImages = {};
                        if (imgUsage) {
                            // TODO: 考虑放到独立的 fix 文件
                            fixOldImageUsage(usedImages, sceneCompositions, imgUsage, images, renderLevel);
                        }
                        else {
                            images === null || images === void 0 ? void 0 : images.forEach(function (_, i) {
                                usedImages[i] = true;
                            });
                        }
                        return [2 /*return*/, {
                                usedImages: usedImages,
                                jsonScene: jsonScene,
                                pluginSystem: pluginSystem,
                            }];
                }
            });
        });
    };
    AssetManager.prototype.processBins = function (bins) {
        return __awaiter(this, void 0, void 0, function () {
            var renderLevel, baseUrl, jobs;
            var _this = this;
            return __generator(this, function (_a) {
                renderLevel = this.options.renderLevel;
                baseUrl = this.baseUrl;
                jobs = bins.map(function (bin) {
                    if (bin instanceof ArrayBuffer) {
                        return bin;
                    }
                    if (passRenderLevel(bin.renderLevel, renderLevel)) {
                        return _this.loadBins(new alipay.URL(bin.url, baseUrl).href);
                    }
                    throw new Error("Invalid bins source: ".concat(JSON.stringify(bins)));
                });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.processFontURL = function (fonts) {
        return __awaiter(this, void 0, void 0, function () {
            var jobs;
            var _this = this;
            return __generator(this, function (_a) {
                // 对老数据的兼容
                if (!fonts) {
                    return [2 /*return*/];
                }
                jobs = fonts.map(function (font) { return __awaiter(_this, void 0, void 0, function () {
                    var url, fontFace;
                    var _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!(font.fontURL && !AssetManager.fonts.has(font.fontFamily))) return [3 /*break*/, 4];
                                if (!isValidFontFamily(font.fontFamily)) {
                                    // 在所有设备上提醒开发者
                                    console.warn("Risky font family: ".concat(font.fontFamily));
                                }
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 3, , 4]);
                                url = new alipay.URL(font.fontURL, this.baseUrl).href;
                                fontFace = new FontFace((_a = font.fontFamily) !== null && _a !== void 0 ? _a : '', 'url(' + url + ')');
                                return [4 /*yield*/, fontFace.load()];
                            case 2:
                                _b.sent();
                                //@ts-expect-error
                                alipay.document.fonts.add(fontFace);
                                AssetManager.fonts.add(font.fontFamily);
                                return [3 /*break*/, 4];
                            case 3:
                                _b.sent();
                                logger.warn("Invalid font family or font source: ".concat(JSON.stringify(font.fontURL)));
                                return [3 /*break*/, 4];
                            case 4: return [2 /*return*/];
                        }
                    });
                }); });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.processImages = function (images, usage, compressedTexture) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, useCompressedTexture, variables, baseUrl, jobs;
            var _this = this;
            return __generator(this, function (_b) {
                _a = this.options, useCompressedTexture = _a.useCompressedTexture, variables = _a.variables;
                baseUrl = this.baseUrl;
                jobs = images.map(function (img, idx) { return __awaiter(_this, void 0, void 0, function () {
                    var png, webp, imageURL, webpURL, template, isTemplateV2, background, url_1, isVideo, loadFn, resultImage, e_3, resultImage, compressed, src, bufferURL, _a, url, image;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!usage[idx]) {
                                    return [2 /*return*/, undefined];
                                }
                                png = img.url, webp = img.webp;
                                imageURL = new alipay.URL(png, baseUrl).href;
                                webpURL = webp && new alipay.URL(webp, baseUrl).href;
                                if (!('template' in img)) return [3 /*break*/, 13];
                                template = img.template;
                                isTemplateV2 = 'v' in template && template.v === 2 && template.background;
                                background = isTemplateV2 ? template.background : undefined;
                                if (!(isTemplateV2 && background)) return [3 /*break*/, 8];
                                url_1 = getBackgroundImage(template, variables);
                                isVideo = background.type === BackgroundType$1.video;
                                loadFn = background && isVideo ? loadVideo : loadImage;
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 6, , 7]);
                                return [4 /*yield*/, loadMedia(url_1, loadFn)];
                            case 2:
                                resultImage = _b.sent();
                                if (!(resultImage instanceof alipay.HTMLVideoElement)) return [3 /*break*/, 3];
                                return [2 /*return*/, resultImage];
                            case 3:
                                // 如果是加载图片且是数组，设置变量，视频情况下不需要
                                if (background && Array.isArray(url_1) && variables) {
                                    variables[background.name] = resultImage.src;
                                }
                                return [4 /*yield*/, combineImageTemplate(resultImage, template, variables, this.options, img.oriY === -1)];
                            case 4: return [2 /*return*/, _b.sent()];
                            case 5: return [3 /*break*/, 7];
                            case 6:
                                e_3 = _b.sent();
                                throw new Error("Failed to load. Check the template or if the URL is ".concat(isVideo ? 'video' : 'image', " type, URL: ").concat(url_1, ", Error: ").concat(e_3.message));
                            case 7: return [3 /*break*/, 12];
                            case 8:
                                _b.trys.push([8, 11, , 12]);
                                return [4 /*yield*/, loadWebPOptional(imageURL, webpURL)];
                            case 9:
                                resultImage = _b.sent();
                                return [4 /*yield*/, combineImageTemplate(resultImage.image, template, variables, this.options, img.oriY === -1)];
                            case 10: return [2 /*return*/, _b.sent()];
                            case 11:
                                _b.sent();
                                throw new Error("Failed to load. Check the template, URL: ".concat(imageURL, "."));
                            case 12: return [3 /*break*/, 14];
                            case 13:
                                if ('type' in img && img.type === 'video') {
                                    // 视频
                                    // TODO: 2024.03.28 后面考虑下掉非推荐的视频元素使用方式
                                    console.warn('The video element is deprecated. Use template BackgroundType.video instead.');
                                    return [2 /*return*/, loadVideo(img.url)];
                                }
                                else if ('compressed' in img && useCompressedTexture && compressedTexture) {
                                    compressed = img.compressed;
                                    src = void 0;
                                    if (compressedTexture === COMPRESSED_TEXTURE.ASTC) {
                                        src = compressed.astc;
                                    }
                                    else if (compressedTexture === COMPRESSED_TEXTURE.PVRTC) {
                                        src = compressed.pvrtc;
                                    }
                                    if (src) {
                                        bufferURL = new alipay.URL(src, baseUrl).href;
                                        this.assets[idx] = { url: bufferURL, type: exports.TextureSourceType.compressed };
                                        return [2 /*return*/, this.loadBins(bufferURL)];
                                    }
                                }
                                else if ('sourceType' in img) {
                                    return [2 /*return*/, img];
                                }
                                else if (img instanceof alipay.HTMLImageElement ||
                                    img instanceof alipay.HTMLCanvasElement ||
                                    img instanceof alipay.HTMLVideoElement ||
                                    img instanceof Texture) {
                                    return [2 /*return*/, img];
                                }
                                _b.label = 14;
                            case 14: return [4 /*yield*/, loadWebPOptional(imageURL, webpURL)];
                            case 15:
                                _a = _b.sent(), url = _a.url, image = _a.image;
                                this.assets[idx] = { url: url, type: exports.TextureSourceType.image };
                                return [2 /*return*/, image];
                        }
                    });
                }); });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.processTextures = function (images, bins, jsonScene) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var textures, jobs;
            var _this = this;
            return __generator(this, function (_b) {
                textures = (_a = jsonScene.textures) !== null && _a !== void 0 ? _a : images.map(function (img, source) { return ({ source: source }); });
                jobs = textures.map(function (texOpts, idx) {
                    if (texOpts instanceof Texture) {
                        return texOpts;
                    }
                    if ('mipmaps' in texOpts) {
                        try {
                            return deserializeMipmapTexture(texOpts, bins, jsonScene.bins);
                        }
                        catch (e) {
                            throw new Error("load texture ".concat(idx, " fails, error message: ").concat(e));
                        }
                    }
                    var source = texOpts.source;
                    var image = images[source];
                    if (image) {
                        var tex = createTextureOptionsBySource(image, _this.assets[idx]);
                        return tex.sourceType === exports.TextureSourceType.compressed ? tex : __assign$1(__assign$1({}, tex), texOpts);
                    }
                    throw new Error("Invalid texture source: ".concat(source));
                });
                return [2 /*return*/, Promise.all(jobs)];
            });
        });
    };
    AssetManager.prototype.loadJSON = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.downloader.downloadJSON(url, resolve, function (status, responseText) {
                            reject("Couldn't load JSON ".concat(JSON.stringify(url), ": status ").concat(status, ", ").concat(responseText));
                        });
                    })];
            });
        });
    };
    AssetManager.prototype.loadBins = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.downloader.downloadBinary(url, resolve, function (status, responseText) {
                            reject("Couldn't load bins ".concat(JSON.stringify(url), ": status ").concat(status, ", ").concat(responseText));
                        });
                    })];
            });
        });
    };
    AssetManager.prototype.removeTimer = function (id) {
        var index = this.timers.indexOf(id);
        if (index !== -1) {
            this.timers.splice(index, 1);
        }
    };
    /**
     * 销毁方法
     */
    AssetManager.prototype.dispose = function () {
        var _a;
        if (this.timers.length) {
            this.timers.map(function (id) { return alipay.window.clearTimeout(id); });
        }
        for (var key in this.assets) {
            var asset = this.assets[key];
            (_a = asset === null || asset === void 0 ? void 0 : asset.dispose) === null || _a === void 0 ? void 0 : _a.call(asset);
        }
        this.assets = {};
        this.timers = [];
    };
    /**
     * 自定义文本缓存，随页面销毁而销毁
     */
    AssetManager.fonts = new Set();
    return AssetManager;
}());
function fixOldImageUsage(usedImages, compositions, imgUsage, images, renderLevel) {
    for (var i = 0; i < compositions.length; i++) {
        var id = compositions[i].id;
        var ids = imgUsage[id];
        if (ids) {
            for (var j = 0; j < ids.length; j++) {
                var id_1 = ids[j];
                var tag = images[id_1].renderLevel;
                if (passRenderLevel(tag, renderLevel)) {
                    usedImages[id_1] = true;
                }
            }
        }
    }
}
function createTextureOptionsBySource(image, sourceFrom) {
    if (image instanceof Texture) {
        return image.source;
    }
    else if (image instanceof alipay.HTMLImageElement ||
        isCanvas(image)) {
        return {
            image: image,
            sourceType: exports.TextureSourceType.image,
            sourceFrom: sourceFrom,
            keepImageSource: true,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
        };
    }
    else if (image instanceof alipay.HTMLVideoElement) {
        // 视频
        return {
            sourceType: exports.TextureSourceType.video,
            video: image,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR,
        };
    }
    else if (image instanceof ArrayBuffer) {
        // 压缩纹理
        return __assign$1(__assign$1({}, getKTXTextureOptions(image)), { sourceFrom: sourceFrom });
    }
    else if ('width' in image &&
        'height' in image &&
        'data' in image) {
        return {
            sourceType: exports.TextureSourceType.data,
            data: image,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST,
        };
    }
    throw new Error('Invalid texture options');
}
function isCanvas(canvas) {
    var _a;
    // 小程序 Canvas 无法使用 instanceof HTMLCanvasElement 判断
    return typeof canvas === 'object' && canvas !== null && ((_a = canvas.tagName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'CANVAS';
}

var CompVFXItem = /** @class */ (function (_super) {
    __extends(CompVFXItem, _super);
    function CompVFXItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 创建好的元素数组
         */
        _this.items = [];
        /**
         * 根据父子关系构建的元素树
         */
        _this.itemTree = [];
        /**
         * id和元素的映射关系Map，方便查找
         */
        _this.itemCacheMap = new Map();
        _this.itemsToRemove = [];
        _this.tempQueue = [];
        return _this;
    }
    Object.defineProperty(CompVFXItem.prototype, "type", {
        get: function () {
            return ItemType$1.composition;
        },
        enumerable: false,
        configurable: true
    });
    CompVFXItem.prototype.onConstructed = function (props) {
        var _a = props.items, items = _a === void 0 ? [] : _a, _b = props.startTime, startTime = _b === void 0 ? 0 : _b, content = props.content, refId = props.refId;
        this.refId = refId;
        this.itemProps = items;
        this.contentProps = content;
        var endBehavior = this.endBehavior;
        if (endBehavior === END_BEHAVIOR_RESTART$1 ||
            endBehavior === END_BEHAVIOR_PAUSE$1 ||
            endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1) {
            this.freezeOnEnd = true;
        }
        this.startTime = startTime;
        this.startTimeInms = Math.round((this.startTime) * 1000);
    };
    CompVFXItem.prototype.createContent = function () {
        /**
         * 创建前需要判断下是否存在，createContent会执行两次
         */
        if (!this.items.length && this.composition) {
            for (var i = 0; i < this.itemProps.length; i++) {
                var item = void 0;
                var itemProps = this.itemProps[i];
                // 设置预合成作为元素时的时长、结束行为和渲染延时
                if (exports.Item.isComposition(itemProps)) {
                    var refId = itemProps.content.options.refId;
                    item = new CompVFXItem(__assign$1({ refId: refId }, itemProps), this.composition);
                    item.contentProps = itemProps.content;
                    item.transform.parentTransform = this.transform;
                    this.composition.refContent.push(item);
                    if (item.endBehavior === END_BEHAVIOR_RESTART$1) {
                        this.composition.autoRefTex = false;
                    }
                    item.createContent();
                }
                else {
                    item = createVFXItem(this.itemProps[i], this.composition);
                    // 相机不跟随合成移动
                    item.transform.parentTransform = VFXItem.isCamera(item) ? new Transform() : this.transform;
                }
                if (VFXItem.isExtraCamera(item)) {
                    this.extraCamera = item;
                }
                this.items.push(item);
                this.tempQueue.push(item);
            }
        }
        // TODO: 处理k帧数据, ECS后改成 TimelineComponent
        if (!this.content && this.contentProps) {
            this._content = this.doCreateContent();
        }
    };
    CompVFXItem.prototype.doCreateContent = function () {
        var content = new CalculateItem(this.contentProps, this);
        content.renderData = content.getRenderData(0, true);
        return content;
    };
    CompVFXItem.prototype.onLifetimeBegin = function () {
        var _a;
        (_a = this.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
            item.start();
            item.createContent();
        });
        this.buildItemTree();
    };
    CompVFXItem.prototype.doStop = function () {
        if (this.items) {
            this.items.forEach(function (item) { return item.stop(); });
        }
    };
    CompVFXItem.prototype.onItemUpdate = function (dt, lifetime) {
        var _this = this;
        var _a, _b;
        if (this.content) {
            this.content.updateTime(this.time);
            this.content.getRenderData(this.content.time);
        }
        if (!this.items) {
            return;
        }
        // 更新 model-tree-plugin
        (_a = this.composition) === null || _a === void 0 ? void 0 : _a.updatePluginLoaders(dt);
        var queue = [];
        /**
         * 元素销毁时，重新设置其子元素的父元素
         */
        if (this.itemsToRemove.length) {
            this.itemsToRemove.forEach(function (item) {
                var _a, _b;
                var itemNode = _this.itemCacheMap.get(item.id);
                if (!itemNode) {
                    return;
                }
                var children = itemNode.children;
                // 如果有父元素，设置当前元素的子元素的父元素为父元素，以便继承变换
                if (itemNode.parentId) {
                    var parentNode_1 = _this.itemCacheMap.get(itemNode.parentId);
                    if (parentNode_1) {
                        parentNode_1.children.splice(parentNode_1.children.indexOf(itemNode), 1);
                        children.forEach(function (child) { return _this.setItemParent(child.item, parentNode_1.item); });
                    }
                    else {
                        children.forEach(function (child) { return _this.setItemParent(child.item, undefined); });
                        (_a = _this.itemTree).push.apply(_a, __spreadArray$2([], __read$3(children), false));
                    }
                    // 否则直接设置当前元素的子元素的父元素为合成
                }
                else {
                    (_b = _this.itemTree).splice.apply(_b, __spreadArray$2([_this.itemTree.indexOf(itemNode), 1], __read$3(children), false));
                    children.forEach(function (child) { return _this.setItemParent(child.item, undefined); });
                }
                _this.itemCacheMap.delete(item.id);
                _this.items.splice(_this.items.indexOf(item), 1);
            });
            this.itemsToRemove.length = 0;
        }
        /**
         * 避免 slice 操作，先遍历第一层
         */
        for (var i = 0; i < this.itemTree.length; i++) {
            var itemNode = this.itemTree[i];
            if (itemNode && itemNode.item) {
                var item = itemNode.item;
                if (VFXItem.isComposition(item) &&
                    item.ended &&
                    item.endBehavior === END_BEHAVIOR_RESTART$1) {
                    item.restart();
                }
                else {
                    item.onUpdate(dt);
                }
                queue.push.apply(queue, __spreadArray$2([], __read$3(itemNode.children), false));
            }
        }
        while (queue.length) {
            var itemNode = queue.shift();
            if (itemNode && itemNode.item) {
                var item = itemNode.item;
                item.onUpdate(dt);
                queue.push.apply(queue, __spreadArray$2([], __read$3(itemNode.children), false));
                if (!item.composition) {
                    addItem(this.itemsToRemove, item);
                }
            }
        }
        (_b = this.extraCamera) === null || _b === void 0 ? void 0 : _b.onUpdate(dt);
    };
    CompVFXItem.prototype.onItemRemoved = function (composition) {
        if (this.items) {
            this.items.forEach(function (item) { return item.dispose(); });
            this.items.length = 0;
            this.itemTree.length = 0;
            this.itemCacheMap.clear();
        }
    };
    CompVFXItem.prototype.reset = function () {
        _super.prototype.reset.call(this);
        this.itemTree = [];
        this.itemCacheMap.clear();
        this.tempQueue.length = 0;
        this.itemsToRemove.length = 0;
    };
    CompVFXItem.prototype.handleVisibleChanged = function (visible) {
        this.items.forEach(function (item) { return item.setVisible(visible); });
    };
    CompVFXItem.prototype.setScale = function (x, y, z) {
        if (this.content) {
            this.content.startSize = new Vector3(x, y, z);
        }
    };
    CompVFXItem.prototype.scale = function (x, y, z) {
        if (this.content) {
            var startSize = this.content.startSize.clone();
            this.content.startSize = new Vector3(x * startSize.x, y * startSize.y, z * startSize.z);
        }
    };
    CompVFXItem.prototype.getUpdateTime = function (t) {
        var startTime = this.startTimeInms;
        var now = this.timeInms;
        if (t < 0 && (now + t) < startTime) {
            return startTime - now;
        }
        if (this.freezeOnEnd) {
            var remain = this.durInms - now;
            if (remain < t) {
                return remain;
            }
        }
        return t;
    };
    CompVFXItem.prototype.removeItem = function (item) {
        var _this = this;
        var _a;
        var itemIndex = this.items.indexOf(item);
        if (itemIndex > -1) {
            addItem(this.itemsToRemove, item);
            if (VFXItem.isTree(item) || VFXItem.isNull(item)) {
                var willRemove_1 = item.endBehavior === END_BEHAVIOR_DESTROY_CHILDREN$1;
                var keepParent_1 = VFXItem.isNull(item) && !!this.itemCacheMap.get(item.id);
                var children = ((_a = this.itemCacheMap.get(item.id)) === null || _a === void 0 ? void 0 : _a.children) || [];
                children.forEach(function (cit) {
                    if (!keepParent_1) {
                        _this.setItemParent(cit.item, undefined);
                    }
                    willRemove_1 && _this.removeItem(cit.item);
                });
            }
            return true;
        }
        this.items.forEach(function (it) {
            if (VFXItem.isComposition(it)) {
                var itemIndex_1 = it.items.indexOf(item);
                if (itemIndex_1 > -1) {
                    it.removeItem(item);
                    return true;
                }
            }
        });
        return false;
    };
    /**
     * 设置指定元素的父元素
     * @param item
     * @param parentItem - 为 undefined 时表示设置父变换为合成的变换
     */
    CompVFXItem.prototype.setItemParent = function (item, parentItem) {
        var itemNode = this.itemCacheMap.get(item.id);
        if (!itemNode) {
            console.error('item has been remove, please set item\'s parent in valid lifetime');
            return;
        }
        else {
            if (!parentItem) {
                itemNode.parentId = undefined;
                item.parent = undefined;
                item.transform.parentTransform = VFXItem.isExtraCamera(item) ? new Transform() : this.transform;
            }
            else {
                var parentNode = this.itemCacheMap.get(parentItem.id);
                if (itemNode.parentId) {
                    var originalParent = this.itemCacheMap.get(itemNode.parentId);
                    originalParent.children.splice(originalParent.children.indexOf(itemNode), 1);
                }
                item.parent = parentItem;
                itemNode.parentId = parentItem.id;
                parentNode.children.push(itemNode);
                item.transform.parentTransform = parentItem.transform;
            }
        }
    };
    /**
     * 获取指定元素当前时刻真正起作用的父元素, 需要在元素生命周期内获取
     * @internal
     * @param item - 指定元素
     * @return 当父元素生命周期结束时，返回空
     */
    CompVFXItem.prototype.getItemCurrentParent = function (item) {
        var id = item.id;
        var itemNode = this.itemCacheMap.get(id);
        if (!itemNode) {
            return;
        }
        var parentId = itemNode.parentId;
        if (!parentId) {
            return;
        }
        var parentNode = this.itemCacheMap.get(parentId);
        if (parentId && parentNode) {
            return parentNode.item;
        }
    };
    CompVFXItem.prototype.getItemByName = function (name) {
        var e_1, _a;
        var res = [];
        try {
            for (var _b = __values$1(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.name === name) {
                    res.push(item);
                }
                else if (VFXItem.isComposition(item)) {
                    res.push.apply(res, __spreadArray$2([], __read$3(item.getItemByName(name)), false));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return res;
    };
    CompVFXItem.prototype.hitTest = function (ray, x, y, regions, force, options) {
        var hitPositions = [];
        var stop = (options === null || options === void 0 ? void 0 : options.stop) || noop;
        var skip = (options === null || options === void 0 ? void 0 : options.skip) || noop;
        var maxCount = (options === null || options === void 0 ? void 0 : options.maxCount) || this.items.length;
        for (var i = 0; i < this.items.length && regions.length < maxCount; i++) {
            var item = this.items[i];
            if (item.lifetime >= 0 && item.lifetime <= 1 && !VFXItem.isComposition(item) && !skip(item)) {
                var hitParams = item.getHitTestParams(force);
                if (hitParams) {
                    var success = false;
                    var intersectPoint = new Vector3();
                    if (hitParams.type === exports.HitTestType.triangle) {
                        var triangles = hitParams.triangles, backfaceCulling = hitParams.backfaceCulling;
                        for (var j = 0; j < triangles.length; j++) {
                            var triangle = triangles[j];
                            if (ray.intersectTriangle(triangle, intersectPoint, backfaceCulling)) {
                                success = true;
                                hitPositions.push(intersectPoint);
                                break;
                            }
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.box) {
                        var center = hitParams.center, size = hitParams.size;
                        var boxMin = center.clone().addScaledVector(size, 0.5);
                        var boxMax = center.clone().addScaledVector(size, -0.5);
                        if (ray.intersectBox({ min: boxMin, max: boxMax }, intersectPoint)) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.sphere) {
                        var center = hitParams.center, radius = hitParams.radius;
                        if (ray.intersectSphere({ center: center, radius: radius }, intersectPoint)) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    }
                    else if (hitParams.type === exports.HitTestType.custom) {
                        var tempPosition = hitParams.collect(ray, new Vector2(x, y));
                        if (tempPosition && tempPosition.length > 0) {
                            tempPosition.forEach(function (pos) {
                                hitPositions.push(pos);
                            });
                            success = true;
                        }
                    }
                    if (success) {
                        var region = {
                            compContent: this,
                            id: item.id,
                            name: item.name,
                            position: hitPositions[hitPositions.length - 1],
                            parentId: item.parentId,
                            hitPositions: hitPositions,
                            behavior: hitParams.behavior,
                        };
                        regions.push(region);
                        if (stop(region)) {
                            return regions;
                        }
                    }
                }
            }
        }
        return regions;
    };
    CompVFXItem.prototype.isEnded = function (now) {
        return now >= this.durInms;
    };
    /**
     * 构建父子树，同时保存到 itemCacheMap 中便于查找
     */
    CompVFXItem.prototype.buildItemTree = function () {
        if (!this.itemTree.length && this.composition) {
            this.itemTree = [];
            var itemMap = this.itemCacheMap;
            var queue = this.tempQueue;
            var _loop_1 = function () {
                var item = queue.shift();
                if (item.parentId === undefined) {
                    var itemNode = {
                        id: item.id,
                        item: item,
                        children: [],
                    };
                    this_1.itemTree.push(itemNode);
                    itemMap.set(item.id, itemNode);
                }
                else {
                    // 兼容 treeItem 子元素的 parentId 带 '^'
                    var parentId_1 = this_1.getParentIdWithoutSuffix(item.parentId);
                    var parent_1 = itemMap.get(parentId_1);
                    if (parent_1) {
                        var itemNode = {
                            id: item.id,
                            parentId: parentId_1,
                            item: item,
                            children: [],
                        };
                        item.parent = parent_1.item;
                        item.transform.parentTransform = parent_1.item.getNodeTransform(item.parentId);
                        parent_1.children.push(itemNode);
                        itemMap.set(item.id, itemNode);
                    }
                    else {
                        if (this_1.items.findIndex(function (item) { return item.id === parentId_1; }) === -1) {
                            throw Error('元素引用了不存在的元素，请检查数据');
                        }
                        queue.push(item);
                    }
                }
            };
            var this_1 = this;
            while (queue.length) {
                _loop_1();
            }
        }
    };
    CompVFXItem.prototype.getParentIdWithoutSuffix = function (id) {
        var idx = id.lastIndexOf('^');
        return idx > -1 ? id.substring(0, idx) : id;
    };
    CompVFXItem.prototype.restart = function () {
        this.reset();
        this.createContent();
        this.start();
    };
    return CompVFXItem;
}(VFXItem));

var seed$4 = 1;
/**
 * 合成抽象类：核心对象，通常一个场景只包含一个合成，可能会有多个合成。
 * 合成中包含了相关的 Item 元素，支持对 Item 元素的创建、更新和销毁。
 * 也负责 Item 相关的动画播放控制，和持有渲染帧数据。
 */
var Composition = /** @class */ (function () {
    /**
     * Composition 构造函数
     * @param props - composition 的创建参数
     */
    function Composition(props, scene) {
        var _a, _b;
        /**
         * 动画播放速度
         */
        this.speed = 1;
        /**
         * 用于保存与当前合成相关的插件数据
         */
        this.loaderData = {};
        /**
         * 预合成数组
         */
        this.refContent = [];
        /**
         * 预合成的合成属性，在 content 中会被其元素属性覆盖
         */
        this.refCompositionProps = new Map();
        // TODO: 待优化
        this.assigned = false;
        /**
         * 销毁状态位
         */
        this.destroyed = false;
        /**
         * 合成暂停/播放 标识
         */
        this.paused = false;
        this.lastVideoUpdateTime = 0;
        this.postLoaders = [];
        var _c = props.reusable, reusable = _c === void 0 ? false : _c, _d = props.speed, speed = _d === void 0 ? 1 : _d, _e = props.baseRenderOrder, baseRenderOrder = _e === void 0 ? 0 : _e, renderer = props.renderer, onPlayerPause = props.onPlayerPause, onMessageItem = props.onMessageItem, onEnd = props.onEnd, event = props.event, width = props.width, height = props.height;
        this.compositionSourceManager = new CompositionSourceManager(scene, renderer.engine);
        scene.jsonScene.imgUsage = undefined;
        if (reusable) {
            this.keepResource = true;
            scene.textures = undefined;
            scene.consumed = true;
        }
        var _f = this.compositionSourceManager, sourceContent = _f.sourceContent, pluginSystem = _f.pluginSystem, imgUsage = _f.imgUsage, totalTime = _f.totalTime, renderLevel = _f.renderLevel, refCompositionProps = _f.refCompositionProps;
        assertExist(sourceContent);
        this.refCompositionProps = refCompositionProps;
        var vfxItem = new CompVFXItem(sourceContent, this);
        var imageUsage = (!reusable && imgUsage);
        this.transform = new Transform({
            name: this.name,
        });
        vfxItem.transform = this.transform;
        this.globalVolume = sourceContent.globalVolume;
        this.width = width;
        this.height = height;
        this.renderOrder = baseRenderOrder;
        this.id = seed$4++;
        this.renderer = renderer;
        this.texInfo = imageUsage !== null && imageUsage !== void 0 ? imageUsage : {};
        this.event = event;
        this.statistic = { loadTime: totalTime !== null && totalTime !== void 0 ? totalTime : 0, loadStart: (_a = scene.startTime) !== null && _a !== void 0 ? _a : 0, firstFrameTime: 0, precompileTime: (_b = scene.timeInfos['asyncCompile']) !== null && _b !== void 0 ? _b : scene.timeInfos['syncCompile'] };
        this.reusable = reusable;
        this.speed = speed;
        this.renderLevel = renderLevel;
        this.autoRefTex = !this.keepResource && imageUsage && vfxItem.endBehavior !== END_BEHAVIOR_RESTART$1;
        this.content = vfxItem;
        this.name = vfxItem.name;
        this.pluginSystem = pluginSystem;
        this.pluginSystem.initializeComposition(this, scene);
        this.camera = new Camera(this.name, __assign$1(__assign$1({}, sourceContent === null || sourceContent === void 0 ? void 0 : sourceContent.camera), { aspect: width / height }));
        this.url = scene.url;
        this.assigned = true;
        this.interactive = true;
        this.onPlayerPause = onPlayerPause;
        this.onMessageItem = onMessageItem;
        this.onEnd = onEnd;
        this.createRenderFrame();
        this.reset();
    }
    Object.defineProperty(Composition.prototype, "handleEnd", {
        /**
         * 合成结束回调
         * @param {(composition: Composition) => void} func
         * @deprecated since 2.0 - use `onEnd` instead
         */
        set: function (func) {
            console.warn('The handleEnd property is deprecated. Use onEnd instead.');
            this.onEnd = func;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "textures", {
        /**
         * 获取场景中的纹理数组
         */
        get: function () {
            return this.compositionSourceManager.textures;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "items", {
        /**
         * 获取合成中所有元素
         */
        get: function () {
            return this.content.items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "startTime", {
        /**
         * 获取合成开始渲染的时间
         */
        get: function () {
            var _a;
            return (_a = this.content.startTime) !== null && _a !== void 0 ? _a : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "time", {
        /**
         * 获取合成当前时间
         */
        get: function () {
            return this.content.timeInms / 1000;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Composition.prototype, "isDestroyed", {
        /**
         * 获取销毁状态
         */
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取合成的时长
     */
    Composition.prototype.getDuration = function () {
        return this.content.duration;
    };
    /**
     * 重新开始合成
     */
    Composition.prototype.restart = function () {
        this.content.reset();
        this.prepareRender();
        this.reset();
        this.transform.setValid(true);
        this.content.start();
        this.forwardTime(this.startTime);
        this.content.onUpdate(0);
        this.loaderData.spriteGroup.onUpdate(0);
    };
    /**
     * 设置当前合成的渲染顺序
     * @param index - 序号，大的后绘制
     */
    Composition.prototype.setIndex = function (index) {
        this.renderOrder = index;
    };
    /**
     * 获取当前合成的渲染顺序
     * @returns
     */
    Composition.prototype.getIndex = function () {
        return this.renderOrder;
    };
    /**
     * 设置合成的动画速度
     * @param speed - 速度
     */
    Composition.prototype.setSpeed = function (speed) {
        this.speed = speed;
    };
    /**
     * 获取合成的动画速度
     * @returns
     */
    Composition.prototype.getSpeed = function () {
        return this.speed;
    };
    Composition.prototype.play = function () {
        if (this.content.ended && this.reusable) {
            this.restart();
        }
        if (this.content.started) {
            this.gotoAndPlay(this.time - this.startTime);
        }
        else {
            this.gotoAndPlay(0);
        }
    };
    /**
     * 暂停合成的播放
     */
    Composition.prototype.pause = function () {
        this.paused = true;
    };
    /**
     * 恢复合成的播放
     */
    Composition.prototype.resume = function () {
        this.paused = false;
    };
    /**
     * 跳转合成到指定时间播放
     * @param time - 相对 startTime 的时间
     */
    Composition.prototype.gotoAndPlay = function (time) {
        this.resume();
        if (!this.content.started) {
            this.content.start();
        }
        this.forwardTime(time + this.startTime);
    };
    /**
     * 跳转合成到指定时间并暂停
     * @param time - 相对 startTime 的时间
     */
    Composition.prototype.gotoAndStop = function (time) {
        this.gotoAndPlay(time);
        this.pause();
    };
    /**
     *
     */
    Composition.prototype.createRenderFrame = function () {
        this.renderFrame = new RenderFrame({
            camera: this.camera,
            renderer: this.renderer,
            keepColorBuffer: this.keepColorBuffer,
            globalVolume: this.globalVolume,
        });
        // TODO 考虑放到构造函数
        this.renderFrame.cachedTextures = this.textures;
    };
    /**
     * 跳到指定时间点（不做任何播放行为）
     * @param time - 相对 startTime 的时间
     */
    Composition.prototype.setTime = function (time) {
        var pause = this.paused;
        if (pause) {
            this.resume();
        }
        if (!this.content.started) {
            this.content.start();
        }
        this.forwardTime(time + this.startTime, true);
        if (pause) {
            this.pause();
        }
    };
    /**
     * 前进合成到指定时间
     * @param time - 相对0时刻的时间
     * @param skipRender - 是否跳过渲染
     */
    Composition.prototype.forwardTime = function (time, skipRender) {
        if (skipRender === void 0) { skipRender = false; }
        var deltaTime = time * 1000 - this.content.timeInms;
        var reverse = deltaTime < 0;
        var step = 15;
        var t = Math.abs(deltaTime);
        var ss = reverse ? -step : step;
        for (t; t > step; t -= step) {
            this.update(ss, skipRender);
        }
        this.update(reverse ? -t : t, skipRender);
    };
    /**
     * 重置状态函数
     */
    Composition.prototype.reset = function () {
        var _this = this;
        this.rendererOptions = null;
        this.pluginSystem.plugins.forEach(function (p) { return p.onCompositionWillReset(_this, _this.renderFrame); });
        this.content.createContent();
        this.content.onEnd = function () {
            alipay.window.setTimeout(function () {
                var _a;
                (_a = _this.onEnd) === null || _a === void 0 ? void 0 : _a.call(_this, _this);
            }, 0);
        };
        this.pluginSystem.resetComposition(this, this.renderFrame);
    };
    Composition.prototype.prepareRender = function () {
        var _this = this;
        var frame = this.renderFrame;
        this.postLoaders.length = 0;
        this.pluginSystem.plugins.forEach(function (loader) {
            if (loader.prepareRenderFrame(_this, frame)) {
                _this.postLoaders.push(loader);
            }
        });
        this.postLoaders.forEach(function (loader) { return loader.postProcessFrame(_this, frame); });
    };
    /**
     * 是否合成需要重新播放
     * @returns 重新播放合成标志位
     */
    Composition.prototype.shouldRestart = function () {
        var _a = this.content, ended = _a.ended, endBehavior = _a.endBehavior;
        return ended && endBehavior === END_BEHAVIOR_RESTART$1;
    };
    /**
     * 是否合成需要销毁
     * @returns 销毁合成标志位
     */
    Composition.prototype.shouldDispose = function () {
        if (this.reusable) {
            return false;
        }
        var _a = this.content, ended = _a.ended, endBehavior = _a.endBehavior;
        return ended && (!endBehavior || endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY$1);
    };
    /**
     * 合成更新，针对所有 item 的更新
     * @param deltaTime - 更新的时间步长
     * @param skipRender - 是否需要渲染
     */
    Composition.prototype.update = function (deltaTime, skipRender) {
        if (skipRender === void 0) { skipRender = false; }
        if (!this.assigned || this.paused) {
            return;
        }
        if (this.shouldRestart()) {
            this.restart();
            // restart then tick to avoid flicker
        }
        var time = this.content.getUpdateTime(deltaTime * this.speed);
        this.updateVideo();
        this.content.onUpdate(time);
        this.loaderData.spriteGroup.onUpdate(time);
        this.updateCamera();
        if (this.shouldDispose()) {
            this.dispose();
        }
        else {
            if (!skipRender) {
                this.prepareRender();
            }
        }
    };
    /**
     * 更新视频数据到纹理
     * @override
     */
    Composition.prototype.updateVideo = function () {
        var _a;
        var now = alipay.performance.now();
        // 视频固定30帧更新
        if (now - this.lastVideoUpdateTime > 33) {
            ((_a = this.textures) !== null && _a !== void 0 ? _a : []).forEach(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.uploadCurrentVideoFrame(); });
            this.lastVideoUpdateTime = now;
        }
    };
    /**
     * 更新相机
     * @override
     */
    Composition.prototype.updateCamera = function () {
        this.camera.updateMatrix();
    };
    /**
     * 插件更新，来自 CompVFXItem 的更新调用
     * @param deltaTime - 更新的时间步长
     */
    Composition.prototype.updatePluginLoaders = function (deltaTime) {
        var _this = this;
        this.pluginSystem.plugins.forEach(function (loader) { return loader.onCompositionUpdate(_this, deltaTime); });
    };
    /**
     * 通过名称获取元素
     * @param name - 元素名称
     * @param type - 元素类型
     * @returns 元素对象
     */
    Composition.prototype.getItemByName = function (name, type) {
        if (this.content && this.content.items) {
            return this.content.getItemByName(name)[0];
        }
    };
    /**
     * 通过 id 获取元素
     * @param id - 元素 id
     * @return
     */
    Composition.prototype.getItemByID = function (id) {
        var items = this.content && this.content.items;
        if (items && this.content.itemCacheMap.has(id)) {
            return this.content.itemCacheMap.get(id).item;
        }
        return null;
    };
    /**
     * 获取指定元素当前时刻真正起作用的父元素, 需要在元素生命周期内获取
     * @internal
     * @param item - 指定元素
     * @return 当父元素生命周期结束时，返回空
     */
    Composition.prototype.getItemCurrentParent = function (item) {
        return this.content.getItemCurrentParent(item);
    };
    /**
     * Item 的起始和结束事件
     * @internal
     * @param item - 合成元素
     * @param start - 是起始事件
     */
    Composition.prototype.itemLifetimeEvent = function (item, start) {
        var _this = this;
        var func = start ?
            function (p) { return p.onCompositionItemLifeBegin(_this, item); } :
            function (p) { return p.onCompositionItemLifeEnd(_this, item); };
        this.pluginSystem.plugins.forEach(func);
    };
    /**
     * 获取指定位置和相机连成的射线
     * @param x
     * @param y
     * @returns
     */
    Composition.prototype.getHitTestRay = function (x, y) {
        var _a = this.renderFrame.editorTransform, a = _a.x, b = _a.y, c = _a.z, d = _a.w;
        return setRayFromCamera((x - c) / a, (y - d) / b, this.camera);
    };
    /**
     * 获取 engine 对象
     * @returns
     */
    Composition.prototype.getEngine = function () {
        var _a;
        return (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.engine;
    };
    /**
     * Item 求交测试，返回求交结果列表，x 和 y 是归一化到[-1, 1]区间的值，原点在左上角
     * @param x - 鼠标或触点的 x，已经归一化到[-1, 1]
     * @param y - 鼠标或触点的 y，已经归一化到[-1, 1]
     * @param force - 是否强制求交，没有交互信息的 Item 也要进行求交测试
     * @param options - 最大求交数和求交时的回调
     */
    Composition.prototype.hitTest = function (x, y, force, options) {
        if (this.isDestroyed || !this.interactive) {
            return [];
        }
        var regions = [];
        var ray = this.getHitTestRay(x, y);
        this.content.hitTest(ray, x, y, regions, force, options);
        this.refContent.forEach(function (ref) {
            ref.hitTest(ray, x, y, regions, force, options);
        });
        return regions;
    };
    /**
     * InteractItem 生命周期开始时的调用
     * @param item - 交互元素
     * @param type - 交互类型
     */
    Composition.prototype.addInteractiveItem = function (item, type) {
        var _a;
        if (type === InteractType$1.MESSAGE) {
            (_a = this.onMessageItem) === null || _a === void 0 ? void 0 : _a.call(this, {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_BEGIN,
                id: item.id,
                compositionId: this.id,
            });
            return item.id;
        }
    };
    /**
     * InteractItem 生命周期结束时的调用
     * @param item - 交互元素
     * @param type - 交互类型
     */
    Composition.prototype.removeInteractiveItem = function (item, type) {
        var _a;
        // MESSAGE ITEM的结束行为
        if (type === InteractType$1.MESSAGE) {
            (_a = this.onMessageItem) === null || _a === void 0 ? void 0 : _a.call(this, {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_END,
                id: item.id,
                compositionId: this.id,
            });
        }
    };
    /**
     * 销毁插件 Item 中保存的纹理数组
     * @internal
     * @param textures - 需要销毁的数组
     */
    Composition.prototype.destroyTextures = function (textures) {
        var _a;
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[i];
            if (!texture) {
                continue;
            }
            if (texture.sourceType === exports.TextureSourceType.data && !(this.texInfo[texture.id])) {
                if (texture !== ((_a = this.rendererOptions) === null || _a === void 0 ? void 0 : _a.emptyTexture) &&
                    texture !== this.renderFrame.transparentTexture) {
                    texture.dispose();
                }
                continue;
            }
            if (this.autoRefTex) {
                // texInfo的类型有点不明确，改成<string, number>不会提前删除texture
                var c = --this.texInfo[texture.id];
                if (!c) {
                    texture.dispose();
                }
            }
        }
    };
    /**
     * 销毁 Item
     * @internal
     * @param item - 需要销毁的 item
     */
    Composition.prototype.destroyItem = function (item) {
        var _this = this;
        // 预合成元素销毁时销毁其中的item
        if (item.type == ItemType$1.composition) {
            if (item.endBehavior !== END_BEHAVIOR_FREEZE$1) {
                item.items.forEach(function (it) { return _this.pluginSystem.plugins.forEach(function (loader) { return loader.onCompositionItemRemoved(_this, it); }); });
            }
        }
        else {
            this.content.removeItem(item);
            // 预合成中的元素移除
            this.refContent.forEach(function (content) { return content.removeItem(item); });
            this.pluginSystem.plugins.forEach(function (loader) { return loader.onCompositionItemRemoved(_this, item); });
        }
    };
    Composition.prototype.lost = function (e) {
        this.videoState = this.textures.map(function (tex) {
            if ('video' in tex.source) {
                tex.source.video.pause();
                return tex.source.video.currentTime;
            }
        });
        this.textures.map(function (tex) { return tex.dispose(); });
        this.dispose();
    };
    /**
     * 合成对象销毁
     */
    Composition.prototype.dispose = function () {
        var _this = this;
        var _a, _b;
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var textureDisposes = {};
        var textures = this.textures;
        if (textures) {
            if (this.keepResource) {
                textures.forEach(function (tex) {
                    if (tex === null || tex === void 0 ? void 0 : tex.dispose) {
                        textureDisposes[tex.id] = tex.dispose;
                        tex.dispose = noop;
                    }
                });
            }
            else {
                textures.forEach(function (tex) { return tex && tex.dispose(); });
            }
        }
        this.content.dispose();
        // FIXME: 注意这里增加了renderFrame销毁
        this.renderFrame.dispose();
        (_a = this.rendererOptions) === null || _a === void 0 ? void 0 : _a.emptyTexture.dispose();
        (_b = this.pluginSystem) === null || _b === void 0 ? void 0 : _b.destroyComposition(this);
        this.update = function () {
            logger.error("Update disposed composition: ".concat(_this.name, "."));
        };
        this.onPlayerPause = noop;
        this.dispose = noop;
        if (textures && this.keepResource) {
            textures.forEach(function (tex) { return tex.dispose = textureDisposes[tex.id]; });
        }
        this.compositionSourceManager.dispose();
        this.refCompositionProps.clear();
    };
    /**
     * 编辑器使用的 transform 修改方法
     * @internal
     * @param scale - 缩放比例
     * @param dx - x偏移量
     * @param dy - y偏移量
     */
    Composition.prototype.setEditorTransform = function (scale, dx, dy) {
        this.renderFrame.editorTransform.set(scale, scale, dx, dy);
    };
    /**
     * 合成整体在水平方向移动 x 像素，垂直方向移动 y 像素
     */
    Composition.prototype.translateByPixel = function (x, y) {
        if (!this.renderer) {
            console.warn('Can not translate position when container not assigned');
            return;
        }
        this.content.translateByPixel(x, y);
    };
    /**
     * 设置合成在 3D 坐标轴上相对当前的位移
     */
    Composition.prototype.translate = function (x, y, z) {
        this.content.translate(x, y, z);
    };
    /**
     * 设置合成在 3D 坐标轴上相对原点的位移
     */
    Composition.prototype.setPosition = function (x, y, z) {
        this.content.setPosition(x, y, z);
    };
    /**
     * 设置合成在 3D 坐标轴上相对当前的旋转（角度）
     */
    Composition.prototype.rotate = function (x, y, z) {
        this.content.rotate(x, y, z);
    };
    /**
     * 设置合成在 3D 坐标轴上的相对原点的旋转（角度）
     */
    Composition.prototype.setRotation = function (x, y, z) {
        this.content.setRotation(x, y, z);
    };
    /**
     * 设置合成在 3D 坐标轴上相对当前的缩放
     */
    Composition.prototype.scale = function (x, y, z) {
        this.content.scale(x, y, z);
    };
    /**
     * 设置合成在 3D 坐标轴上的缩放
     */
    Composition.prototype.setScale = function (x, y, z) {
        this.content.setScale(x, y, z);
    };
    /**
     * 卸载贴图纹理方法，减少内存
     */
    Composition.prototype.offloadTexture = function () {
        if (!this.textureOffloaded) {
            this.textures.forEach(function (tex) { return tex && tex.offloadData(); });
            this.textureOffloaded = true;
        }
    };
    Composition.prototype.getRendererOptions = function () {
        if (!this.rendererOptions) {
            this.rendererOptions = {
                emptyTexture: this.renderFrame.emptyTexture,
                cachePrefix: '-',
            };
        }
        return this.rendererOptions;
    };
    /**
     * 重新加载纹理
     */
    Composition.prototype.reloadTexture = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.textureOffloaded) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(this.textures.map(function (tex) { return tex === null || tex === void 0 ? void 0 : tex.reloadData(); }))];
                    case 1:
                        _a.sent();
                        this.textureOffloaded = false;
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    return Composition;
}());

/**
 * Engine 基类，负责维护所有 GPU 资源的管理及销毁
 */
var Engine = /** @class */ (function () {
    function Engine() {
        this.destroyed = false;
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
        /**
         * 渲染过程中错误队列
         */
        this.renderErrors = new Set();
    }
    Engine.prototype.addTexture = function (tex) {
        if (this.destroyed) {
            return;
        }
        addItem(this.textures, tex);
    };
    Engine.prototype.removeTexture = function (tex) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.textures, tex);
    };
    Engine.prototype.addMaterial = function (mat) {
        if (this.destroyed) {
            return;
        }
        addItem(this.materials, mat);
    };
    Engine.prototype.removeMaterial = function (mat) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.materials, mat);
    };
    Engine.prototype.addGeometry = function (geo) {
        if (this.destroyed) {
            return;
        }
        addItem(this.geometries, geo);
    };
    Engine.prototype.removeGeometry = function (geo) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.geometries, geo);
    };
    Engine.prototype.addMesh = function (mesh) {
        if (this.destroyed) {
            return;
        }
        addItem(this.meshes, mesh);
    };
    Engine.prototype.removeMesh = function (mesh) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.meshes, mesh);
    };
    Engine.prototype.addRenderPass = function (pass) {
        if (this.destroyed) {
            return;
        }
        addItem(this.renderPasses, pass);
    };
    Engine.prototype.removeRenderPass = function (pass) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.renderPasses, pass);
    };
    Object.defineProperty(Engine.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Engine.prototype.getShaderLibrary = function () {
        return this.renderer.getShaderLibrary();
    };
    /**
     * 销毁所有缓存的资源
     */
    Engine.prototype.dispose = function () {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var info = [];
        if (this.renderPasses.length > 0) {
            info.push("Pass ".concat(this.renderPasses.length));
        }
        if (this.meshes.length > 0) {
            info.push("Mesh ".concat(this.meshes.length));
        }
        if (this.geometries.length > 0) {
            info.push("Geom ".concat(this.geometries.length));
        }
        if (this.textures.length > 0) {
            info.push("Tex ".concat(this.textures.length));
        }
        if (info.length > 0) {
            logger.warn("Release GPU memory: ".concat(info.join(', ')));
        }
        this.renderPasses.forEach(function (pass) {
            pass.dispose();
        });
        this.meshes.forEach(function (mesh) {
            mesh.dispose();
        });
        this.geometries.forEach(function (geo) {
            geo.dispose();
        });
        this.materials.forEach(function (mat) {
            mat.dispose();
        });
        this.textures.forEach(function (tex) {
            tex.dispose();
        });
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
        // @ts-expect-error
        this.renderer = null;
    };
    return Engine;
}());

/**
 * 定时器类
 */
var Ticker = /** @class */ (function () {
    function Ticker(fps) {
        if (fps === void 0) { fps = 60; }
        this.paused = true;
        this.lastTime = 0;
        this.setFPS(fps);
        this.tickers = [];
    }
    /**
     * FPS 帧率设置
     */
    Ticker.prototype.getFPS = function () {
        return this.targetFPS;
    };
    Ticker.prototype.setFPS = function (fps) {
        this.targetFPS = clamp$1(fps, 1, 120);
        // 注意：-2 的原因是保证帧率稳定
        // interval 在 fps 为 60 的时候设成 15 累计误差会很大，设成 14 较稳定
        // requestanimationFrame 在不同的刷新率下时间间隔不一样，120hz 的误差在 8 以内，60hz 的误差在 16 以内
        this.interval = Math.floor(1000 / fps) - 2;
    };
    /**
     * 获取定时器暂停标志位
     * @returns 暂停标志位
     */
    Ticker.prototype.getPaused = function () {
        return this.paused;
    };
    /**
     * 定时器开始方法
     */
    Ticker.prototype.start = function () {
        var _this = this;
        this.paused = false;
        if (!this.intervalId) {
            this.lastTime = alipay.performance.now();
            var raf_1 = alipay.requestAnimationFrame || function (func) {
                return alipay.window.setTimeout(func, 16.7);
            };
            var runLoop_1 = function () {
                _this.intervalId = raf_1(runLoop_1);
                if (!_this.paused) {
                    _this.tick();
                }
            };
            runLoop_1();
        }
    };
    /**
     * 定时器停止方法
     */
    Ticker.prototype.stop = function () {
        (alipay.cancelAnimationFrame || alipay.window.clearTimeout)(this.intervalId);
        this.intervalId = 0;
        this.lastTime = 0;
        this.paused = true;
        this.tickers = [];
    };
    /**
     * 定时器暂停方法
     */
    Ticker.prototype.pause = function () {
        this.paused = true;
    };
    /**
     * 定时器恢复方法
     */
    Ticker.prototype.resume = function () {
        this.paused = false;
    };
    /**
     * 定时器 tick 方法
     */
    Ticker.prototype.tick = function () {
        if (this.paused) {
            return;
        }
        var startTime = alipay.performance.now();
        var deltaTime = startTime - this.lastTime;
        if (deltaTime >= this.interval) {
            this.lastTime = startTime;
            if (this.resetTickers) {
                this.tickers = this.tickers.filter(function (tick) { return tick; });
                this.resetTickers = false;
            }
            for (var i = 0, len = this.tickers.length; i < len; i++) {
                var tick = this.tickers[i];
                tick(deltaTime);
            }
        }
    };
    /**
     * 定时器添加计时方法
     * @param ticker - 定时器类
     */
    Ticker.prototype.add = function (ticker) {
        if (typeof ticker !== 'function') {
            throw new Error('Ticker: The tick object must implement the tick method.');
        }
        this.tickers.push(ticker);
    };
    return Ticker;
}());

registerPlugin('camera', CameraVFXItemLoader, CameraVFXItem, true);
registerPlugin('sprite', SpriteLoader, SpriteVFXItem, true);
registerPlugin('particle', ParticleLoader, ParticleVFXItem, true);
registerPlugin('cal', CalculateLoader, CalculateVFXItem, true);
registerPlugin('interact', InteractLoader, InteractVFXItem, true);
registerPlugin('filter', SpriteLoader, FilterSpriteVFXItem, true);
registerPlugin('text', TextLoader, TextVFXItem, true);
registerFilters(filters);

var _a$3, _b$1;
var FORMAT_HALF_FLOAT = (_a$3 = {},
    _a$3[glContext.RGBA] = 34842,
    _a$3[glContext.RGB] = 34843,
    _a$3[glContext.ALPHA] = 33325,
    _a$3[glContext.RED] = 33325,
    _a$3[glContext.LUMINANCE_ALPHA] = 33327,
    _a$3[glContext.LUMINANCE] = 33325,
    _a$3);
var FORMAT_FLOAT = (_b$1 = {},
    _b$1[glContext.RGBA] = 34836,
    _b$1[glContext.RGB] = 34837,
    _b$1[glContext.ALPHA] = 33326,
    _b$1[glContext.RED] = 33326,
    _b$1[glContext.LUMINANCE_ALPHA] = 33328,
    _b$1[glContext.LUMINANCE] = 33326,
    _b$1);
var GLTexture = /** @class */ (function (_super) {
    __extends(GLTexture, _super);
    function GLTexture(engine, source) {
        var _this = _super.call(this) || this;
        _this.initialized = false;
        var opts = _this.assembleOptions(source);
        var sourceType = opts.sourceType, sourceFrom = opts.sourceFrom, _a = opts.name, name = _a === void 0 ? '' : _a;
        _this.source = opts;
        _this.sourceType = sourceType;
        _this.sourceFrom = sourceFrom;
        _this.name = name;
        _this.engine = engine;
        return _this;
    }
    /** 绑定当前Texture对象。*/
    GLTexture.prototype.bind = function (force) {
        this.pipelineContext.bindTexture(this.target, this.textureBuffer, force);
    };
    /** 初始化Texture的GPU资源。*/
    GLTexture.prototype.initialize = function () {
        if (this.initialized) {
            return;
        }
        var glEngine = this.engine;
        glEngine.addTexture(this);
        var pipelineContext = glEngine.getGLPipelineContext();
        this.pipelineContext = pipelineContext;
        var gl = pipelineContext.gl;
        var _a = this.source, _b = _a.target, target = _b === void 0 ? gl.TEXTURE_2D : _b, name = _a.name;
        this.textureBuffer = gl.createTexture();
        if (this.textureBuffer) {
            assignInspectorName(this.textureBuffer, name);
        }
        this.target = target;
        this.update(this.source);
        this.release();
        this.initialized = true;
    };
    GLTexture.prototype.clone = function () {
        var clonedTexture = new GLTexture(this.engine, this.source);
        clonedTexture.sourceFrom = this.sourceFrom;
        clonedTexture.sourceType = this.sourceType;
        clonedTexture.width = this.width;
        clonedTexture.height = this.height;
        return clonedTexture;
    };
    GLTexture.prototype.release = function () {
        var sourceType = this.source.sourceType;
        switch (sourceType) {
            case exports.TextureSourceType.image:
                // @ts-expect-error
                delete this.source.image;
                // @ts-expect-error
                delete this.source.cube;
                break;
            case exports.TextureSourceType.data:
                // @ts-expect-error
                delete this.source.data;
                break;
            case exports.TextureSourceType.compressed:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
            case exports.TextureSourceType.mipmaps:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
        }
    };
    GLTexture.prototype.update = function (sourceOptions) {
        var _a, _b;
        var _this = this;
        var _c, _d;
        if (!this.pipelineContext || !this.textureBuffer) {
            this.width = 0;
            this.height = 0;
            return;
        }
        var target = this.target;
        var source = this.source;
        var gl = this.pipelineContext.gl;
        var detail = this.engine.gpuCapability.detail;
        var sourceType = source.sourceType;
        var data = source.data;
        var cube = source.cube;
        var image = source.image;
        var video = source.video;
        var mipmaps = source.mipmaps;
        var cubeMipmaps = source.mipmaps;
        var optionsData = sourceOptions.data;
        var optionsCube = sourceOptions.cube;
        var generateMipmap = sourceOptions.generateMipmap;
        var optionsMipmaps = sourceOptions.mipmaps;
        var _e = source, format = _e.format, type = _e.type, internalFormat = _e.internalFormat;
        var width = 0;
        var height = 0;
        // TODO 原GLState的textureUnitDict参数未处理。
        this.bind(sourceType === exports.TextureSourceType.video);
        // 选择 type 和 format
        if (type === glContext.HALF_FLOAT) {
            type = detail.halfFloatTexture;
            if (!type) {
                logger.error('Half float texture is not support.');
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_HALF_FLOAT[format];
            }
            if (!detail.halfFloatLinear) {
                source.minFilter = source.magFilter = gl.NEAREST;
                logger.warn('Half float linear not support, change to NEAREST.');
            }
        }
        else if (type === gl.FLOAT) {
            type = detail.floatTexture;
            if (!type) {
                logger.error('Float texture is not support.');
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_FLOAT[format];
            }
            if (!detail.floatLinear) {
                source.minFilter = gl.NEAREST;
                source.magFilter = gl.NEAREST;
                logger.warn('Float linear not support, change to NEAREST.');
            }
        }
        // 处理是否RGB透明度相乘和Y轴反转, 默认值都为false。
        if (source.premultiplyAlpha === undefined) {
            source.premultiplyAlpha = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, source.premultiplyAlpha);
        if (source.flipY === undefined) {
            source.flipY = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, source.flipY);
        // 根据不同的 TextureSourceType 传输对应贴图数据到GPU。
        if (sourceType === exports.TextureSourceType.framebuffer) {
            if (optionsData) {
                width = (_c = optionsData.width) !== null && _c !== void 0 ? _c : 0;
                height = (_d = optionsData.height) !== null && _d !== void 0 ? _d : 0;
                if (width && height && (this.width !== width || this.height !== height)) {
                    gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, null);
                }
            }
        }
        else if (sourceType === exports.TextureSourceType.data) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                optionsCube.forEach(function (data, key) {
                    var _a = __read$3(_this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, data), 2), x = _a[0], y = _a[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            }
            else {
                _a = __read$3(this.texImage2DData(gl, target, 0, internalFormat, format, type, data), 2), width = _a[0], height = _a[1];
            }
        }
        else if (sourceType === exports.TextureSourceType.image || sourceType === exports.TextureSourceType.video) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                cube.forEach(function (image, key) {
                    var _a = __read$3(_this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, image), 2), x = _a[0], y = _a[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            }
            else if (target === gl.TEXTURE_2D) {
                var imageData = image !== null && image !== void 0 ? image : video;
                _b = __read$3(this.texImage2D(gl, target, 0, internalFormat, format, type, imageData), 2), width = _b[0], height = _b[1];
            }
            if (generateMipmap) {
                if ((isPowerOfTwo(width) && isPowerOfTwo(height)) || isWebGL2(gl)) {
                    gl.generateMipmap(target);
                }
            }
        }
        else if (sourceType === exports.TextureSourceType.mipmaps) {
            var ret_1;
            if (target === gl.TEXTURE_2D) {
                mipmaps.forEach(function (mipmap, level) {
                    var _a;
                    if ('data' in mipmap) {
                        ret_1 = _this.texImage2DData(gl, target, level, internalFormat, format, type, mipmap);
                    }
                    else {
                        ret_1 = _this.texImage2D(gl, target, level, internalFormat, format, type, mipmap);
                    }
                    if (level === 0) {
                        _a = __read$3(ret_1, 2), width = _a[0], height = _a[1];
                    }
                });
            }
            else if (target === gl.TEXTURE_CUBE_MAP) {
                cubeMipmaps.forEach(function (mipmap, level) {
                    mipmap.forEach(function (face, key) {
                        var _a;
                        if ('data' in face) {
                            ret_1 = _this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        }
                        else {
                            ret_1 = _this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        }
                        if (level === 0) {
                            _a = __read$3(ret_1, 2), width = _a[0], height = _a[1];
                        }
                    });
                });
            }
        }
        else if (sourceType === exports.TextureSourceType.compressed) {
            if (optionsMipmaps) {
                width = optionsMipmaps[0].width;
                height = optionsMipmaps[0].height;
                optionsMipmaps.forEach(function (mipmap, idx) {
                    gl.compressedTexImage2D(target, idx, internalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                });
            }
        }
        this.width = width;
        this.height = height;
        this.setTextureFilters(gl, target, source);
    };
    GLTexture.prototype.setTextureFilters = function (gl, target, options) {
        var _a = options.anisotropic, anisotropic = _a === void 0 ? 4 : _a, _b = options.wrapS, wrapS = _b === void 0 ? gl.CLAMP_TO_EDGE : _b, _c = options.wrapT, wrapT = _c === void 0 ? gl.CLAMP_TO_EDGE : _c;
        var gpuCapability = this.engine.gpuCapability;
        if (this.target === gl.TEXTURE_2D) {
            gpuCapability.setTextureAnisotropic(gl, this.target, anisotropic);
        }
        var isPot = isWebGL2(gl) || (isPowerOfTwo(this.width) && isPowerOfTwo(this.height));
        var minFiler = options.minFilter ? options.minFilter : gl.NEAREST;
        var magFilter = options.magFilter ? options.magFilter : gl.NEAREST;
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minFiler);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, isPot ? wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, isPot ? wrapT : gl.CLAMP_TO_EDGE);
    };
    GLTexture.prototype.texImage2D = function (gl, target, level, internalformat, format, type, image) {
        var _this = this;
        var _a;
        var _b = this.source, sourceType = _b.sourceType, minFilter = _b.minFilter, magFilter = _b.magFilter; _b.flipY; var wrapS = _b.wrapS, wrapT = _b.wrapT;
        var maxSize = (_a = this.engine.gpuCapability.detail.maxTextureSize) !== null && _a !== void 0 ? _a : 2048;
        var img = image;
        if (sourceType !== exports.TextureSourceType.video) {
            var shouldResize = minFilter !== gl.NEAREST || magFilter !== gl.NEAREST || wrapS !== gl.CLAMP_TO_EDGE || wrapT !== gl.CLAMP_TO_EDGE;
            shouldResize = shouldResize || image.width > maxSize || image.height > maxSize;
            if (shouldResize) {
                // fix android webgl1 img lost error
                setTimeout(function () {
                    img = _this.resizeImage(image);
                });
            }
        }
        gl.texImage2D(target, level, internalformat, format, type, img);
        var size = [img.width, img.height];
        if (sourceType === exports.TextureSourceType.video) {
            var _c = image, videoWidth = _c.videoWidth, videoHeight = _c.videoHeight;
            return [videoWidth, videoHeight];
        }
        return size;
    };
    GLTexture.prototype.texImage2DData = function (gl, target, level, internalformat, format, type, data) {
        var bufferView = data.data, width = data.width, height = data.height;
        // Uint8ClampedArray is incompatible in android
        var neoBuffer = format === gl.UNSIGNED_BYTE ? new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength / bufferView.BYTES_PER_ELEMENT) : bufferView;
        gl.texImage2D(target, level, internalformat, width, height, 0, format, type, neoBuffer);
        return [width, height];
    };
    GLTexture.prototype.resizeImage = function (image, targetWidth, targetHeight) {
        var _a;
        var detail = this.engine.gpuCapability.detail;
        var maxSize = (_a = detail.maxTextureSize) !== null && _a !== void 0 ? _a : 2048;
        var gl = this.pipelineContext.gl;
        if (isWebGL2(gl) && (image.width < maxSize && image.height < maxSize)) {
            return image;
        }
        var canvas = resizeImageByCanvas(image, maxSize, targetWidth, targetHeight);
        if (canvas) {
            return canvas;
        }
        return image;
    };
    GLTexture.prototype.reloadData = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.offloaded) return [3 /*break*/, 2];
                        return [4 /*yield*/, getDefaultTextureFactory().reload(this)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    GLTexture.prototype.offloadData = function () {
        if (!(this.initialized && getDefaultTextureFactory().canOffloadTexture(this.source.sourceFrom))) {
            return;
        }
        var target = this.target;
        var gl = this.pipelineContext.gl;
        if (gl && this.textureBuffer) {
            var data = new Uint8Array([255]);
            this.bind();
            if (target === gl.TEXTURE_2D) {
                gl.texImage2D(target, 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
            }
            else if (target === gl.TEXTURE_CUBE_MAP) {
                var faces = [
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                ];
                for (var i = 0; i < faces.length; i++) {
                    gl.texImage2D(faces[i], 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
                }
            }
            // rewrite mipmap
            gl.generateMipmap(target);
            this.width = 1;
            this.height = 1;
        }
        this.offloaded = true;
    };
    GLTexture.prototype.uploadCurrentVideoFrame = function () {
        return __awaiter(this, void 0, void 0, function () {
            var video;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.source.sourceType === exports.TextureSourceType.video &&
                            this.source.video &&
                            this.initialized)) return [3 /*break*/, 3];
                        video = this.source.video;
                        if (!video.paused) return [3 /*break*/, 2];
                        return [4 /*yield*/, video.play()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.update({ video: this.source.video });
                        return [2 /*return*/, true];
                    case 3: return [2 /*return*/, false];
                }
            });
        });
    };
    GLTexture.prototype.updateSource = function (opts) {
        // @ts-expect-error
        this.source = this.assembleOptions(__assign$1(__assign$1({}, this.source), opts));
        this.sourceType = this.source.sourceType;
        this.sourceFrom = this.source.sourceFrom;
        this.update(this.source);
    };
    GLTexture.prototype.restore = function () {
        // TODO
    };
    GLTexture.prototype.dispose = function () {
        /**
         * 原先Player是允许多次调用dispose，并且不会报错
         * dispose之后assignRenderer会报错
         */
        if (this.pipelineContext && this.textureBuffer) {
            this.pipelineContext.gl.deleteTexture(this.textureBuffer);
        }
        if (this.source.sourceType === exports.TextureSourceType.video &&
            this.source.video &&
            this.initialized) {
            this.source.video.pause();
            this.source.video.src = '';
            this.source.video.load();
        }
        this.width = 0;
        this.height = 0;
        this.textureBuffer = null;
        this.destroyed = true;
        this.update = function () {
            logger.error('This texture has been destroyed.');
        };
        this.initialize = throwDestroyedError$1;
        if (this.engine !== undefined) {
            this.engine.removeTexture(this);
        }
    };
    return GLTexture;
}(Texture));
function resizeImageByCanvas(image, maxSize, targetWidth, targetHeight) {
    var width = image.width, height = image.height;
    var nw = Math.min(maxSize, targetWidth || nearestPowerOfTwo(width));
    var nh = Math.min(maxSize, targetHeight || nearestPowerOfTwo(height));
    if (nh !== height || nw !== width) {
        var canvas = canvasPool.getCanvas();
        var ctx = canvas.getContext('2d');
        canvas.width = nw;
        canvas.height = nh;
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, width, height, 0, 0, nw, nh);
        logger.warn("Image resize from ".concat(width, "x").concat(height, " to ").concat(nw, "x").concat(nh));
        return canvas;
    }
}
function isPowerOfTwo(value) {
    return (value & (value - 1)) === 0 && value !== 0;
}

var GLVertexArrayObject = /** @class */ (function () {
    function GLVertexArrayObject(engine, name) {
        this.engine = engine;
        this.ready = false;
        this.disposed = false;
        this.gl = engine.getGLPipelineContext().gl;
        this.vaoExt = engine.gpuCapability.vaoExt;
        this.vao = this.createVertexArray(name);
    }
    GLVertexArrayObject.prototype.bind = function () {
        this.bindVertexArray(this.vao);
    };
    GLVertexArrayObject.prototype.unbind = function () {
        this.bindVertexArray(null);
    };
    GLVertexArrayObject.prototype.createVertexArray = function (name) {
        var vao = null;
        if (isWebGL2(this.gl)) {
            vao = this.gl.createVertexArray();
        }
        if (!vao && this.vaoExt) {
            vao = this.vaoExt.createVertexArrayOES();
        }
        if (vao) {
            assignInspectorName(vao, name);
        }
        return vao;
    };
    /**
     * 根据 gpu level 选择对应的绑定函数
     * @param vao
     */
    GLVertexArrayObject.prototype.bindVertexArray = function (vao) {
        var _a;
        if (isWebGL2(this.gl)) {
            this.gl.bindVertexArray(vao);
        }
        else {
            (_a = this.vaoExt) === null || _a === void 0 ? void 0 : _a.bindVertexArrayOES(vao);
        }
    };
    GLVertexArrayObject.prototype.dispose = function () {
        var _a;
        if (isWebGL2(this.gl)) {
            this.gl.deleteVertexArray(this.vao);
        }
        else {
            (_a = this.vaoExt) === null || _a === void 0 ? void 0 : _a.deleteVertexArrayOES(this.vao);
        }
    };
    return GLVertexArrayObject;
}());

var seed$3 = 1;
var GLRendererInternal = /** @class */ (function () {
    function GLRendererInternal(engine) {
        this.engine = engine;
        this.textures = [];
        this.renderBuffers = [];
        this.frameBuffers = [];
        this.destroyed = false;
        var d = { width: 1, height: 1, data: new Uint8Array([255]) };
        var pipelineContext = engine.getGLPipelineContext();
        var gl = pipelineContext.gl;
        this.gl = gl;
        this.pipelineContext = pipelineContext;
        this.emptyTexture2D = new GLTexture(engine, {
            data: d,
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE,
        });
        this.emptyTexture2D.initialize();
        this.emptyTextureCube = new GLTexture(engine, {
            target: gl.TEXTURE_CUBE_MAP,
            cube: [d, d, d, d, d, d],
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE,
        });
        this.emptyTextureCube.initialize();
        this.name = 'GLGPURenderer' + seed$3;
        seed$3++;
    }
    Object.defineProperty(GLRendererInternal.prototype, "height", {
        get: function () {
            var _a;
            return (_a = this.gl) === null || _a === void 0 ? void 0 : _a.drawingBufferHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "width", {
        get: function () {
            var _a;
            return (_a = this.gl) === null || _a === void 0 ? void 0 : _a.drawingBufferWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "canvas", {
        get: function () {
            return this.gl.canvas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRendererInternal.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    GLRendererInternal.prototype.copy2 = function (source, target) {
        var gl = this.gl;
        if (gl) {
            if (!this.sourceFbo) {
                this.sourceFbo = gl.createFramebuffer();
            }
            if (!this.targetFbo) {
                this.targetFbo = gl.createFramebuffer();
            }
            var state = this.pipelineContext;
            var COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
            state.bindFramebuffer(gl.FRAMEBUFFER, this.sourceFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.textureBuffer, 0);
            state.bindFramebuffer(gl.FRAMEBUFFER, this.targetFbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.textureBuffer, 0);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, this.sourceFbo);
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.targetFbo);
            var filter = source.getWidth() === source.getHeight() && target.getWidth() == target.getHeight() ? gl.NEAREST : gl.LINEAR;
            gl.blitFramebuffer(0, 0, source.getWidth(), source.getHeight(), 0, 0, target.getWidth(), target.getHeight(), gl.COLOR_BUFFER_BIT, filter);
            state.bindFramebuffer(gl.FRAMEBUFFER, null);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        }
    };
    GLRendererInternal.prototype.resetColorAttachments = function (rp, colors) {
        rp.bind();
        rp.resetColorTextures(colors);
    };
    GLRendererInternal.prototype.createGLRenderBuffer = function (renderbuffer) {
        var rb = this.gl.createRenderbuffer();
        if (rb) {
            addItem(this.renderBuffers, renderbuffer);
        }
        return rb;
    };
    GLRendererInternal.prototype.resize = function (width, height) {
        var gl = this.gl;
        if (gl && gl.drawingBufferWidth !== width || gl.drawingBufferHeight !== height) {
            gl.canvas.width = width;
            gl.canvas.height = height;
            gl.viewport(0, 0, width, height);
            this.frameBuffers.forEach(function (frameBuffer) {
                var viewport = frameBuffer.viewport;
                if (!frameBuffer.isCustomViewport) {
                    frameBuffer.resize(viewport[0], viewport[1], width * frameBuffer.viewportScale, height * frameBuffer.viewportScale);
                }
            });
        }
    };
    GLRendererInternal.prototype.drawGeometry = function (geometry, material) {
        if (!this.gl) {
            console.warn('GLGPURenderer没有绑定gl对象, 无法绘制geometry');
            return;
        }
        var glGeometry = geometry;
        var glMaterial = material;
        var program = glMaterial.shader.program;
        if (!program) {
            return;
        }
        var vao = program.setupAttributes(glGeometry);
        var gl = this.gl;
        var indicesBuffer = glGeometry.indicesBuffer;
        var offset = glGeometry.drawStart;
        var mode = glGeometry.mode;
        var count = glGeometry.drawCount;
        if (indicesBuffer) {
            var type = indicesBuffer.type, elementCount = indicesBuffer.elementCount;
            count = isNaN(count) ? elementCount : count;
            if (count > 0) {
                gl.drawElements(mode, count, type, offset !== null && offset !== void 0 ? offset : 0);
            }
        }
        else if (count > 0) {
            gl.drawArrays(mode, offset, count);
        }
        vao === null || vao === void 0 ? void 0 : vao.unbind();
    };
    GLRendererInternal.prototype.createGLFrameBuffer = function (frameBuffer, name) {
        var fbo = this.gl.createFramebuffer();
        if (fbo) {
            addItem(this.frameBuffers, frameBuffer);
            assignInspectorName(fbo, name, name);
        }
        return fbo;
    };
    /**创建包裹VAO对象。 */
    GLRendererInternal.prototype.createVAO = function (name) {
        var ret = new GLVertexArrayObject(this.engine, name);
        return ret;
    };
    GLRendererInternal.prototype.deleteGLTexture = function (texture) {
        if (texture.textureBuffer && !this.destroyed) {
            this.gl.deleteTexture(texture.textureBuffer);
            removeItem(this.textures, texture);
            // @ts-expect-error
            delete texture.textureBuffer;
        }
    };
    GLRendererInternal.prototype.deleteGPUBuffer = function (buffer) {
        if (buffer && !this.destroyed) {
            this.gl.deleteBuffer(buffer.glBuffer);
            // @ts-expect-error
            delete buffer.glBuffer;
        }
    };
    GLRendererInternal.prototype.deleteGLFrameBuffer = function (frameBuffer) {
        if (frameBuffer && !this.destroyed) {
            this.gl.deleteFramebuffer(frameBuffer.fbo);
            removeItem(this.frameBuffers, frameBuffer);
            delete frameBuffer.fbo;
        }
    };
    GLRendererInternal.prototype.deleteGLRenderBuffer = function (renderbuffer) {
        if (renderbuffer && !this.destroyed) {
            this.gl.deleteRenderbuffer(renderbuffer.buffer);
            removeItem(this.renderBuffers, renderbuffer);
            // @ts-expect-error
            delete renderbuffer.buffer;
        }
    };
    GLRendererInternal.prototype.deleteResource = function () {
        var _this = this;
        var gl = this.gl;
        if (gl) {
            gl.deleteFramebuffer(this.sourceFbo);
            gl.deleteFramebuffer(this.targetFbo);
            this.emptyTexture2D.dispose();
            this.emptyTextureCube.dispose();
            this.frameBuffers.forEach(function (fb) { return _this.deleteGLFrameBuffer(fb); });
            this.frameBuffers.length = 0;
            this.renderBuffers.forEach(function (rb) { return _this.deleteGLRenderBuffer(rb); });
            this.renderBuffers.length = 0;
            this.textures.forEach(function (tex) { return _this.deleteGLTexture(tex); });
            this.textures.length = 0;
        }
    };
    GLRendererInternal.prototype.lost = function (e) {
        logger.error('gl lost, destroy glRenderer by default', e.target);
        this.deleteResource();
    };
    GLRendererInternal.prototype.dispose = function () {
        this.deleteResource();
        // @ts-expect-error safe to assign
        this.emptyTexture2D = this.emptyTextureCube = this.pipelineContext = this.gpu = this.gl = null;
        this.destroyed = true;
    };
    return GLRendererInternal;
}());
function assignInspectorName(obj, name, id) {
    if (name === undefined) {
        return;
    }
    obj.__SPECTOR_Metadata = { name: name };
    if (obj.__SPECTOR_Object_TAG) {
        obj.__SPECTOR_Object_TAG.displayText = name;
        if (id) {
            obj.__SPECTOR_Object_TAG.id = id;
        }
    }
    else {
        obj.__SPECTOR_Object_TAG = {
            displayText: name,
            id: '',
        };
    }
}

var _a$2;
var GLGPUBuffer = /** @class */ (function () {
    function GLGPUBuffer(pipelineContext, props) {
        this.pipelineContext = pipelineContext;
        this.byteLength = 0;
        this.destroyed = false;
        var _a = props.target, target = _a === void 0 ? glContext.ARRAY_BUFFER : _a, _b = props.type, type = _b === void 0 ? glContext.FLOAT : _b, name = props.name, _c = props.usage, usage = _c === void 0 ? glContext.STATIC_DRAW : _c, data = props.data, elementCount = props.elementCount;
        var bytesPerElement = getBytesPerElementByGLType(type);
        this.target = target;
        this.type = type;
        this.usage = usage;
        this.glBuffer = this.createGLBuffer(name);
        this.bytesPerElement = bytesPerElement;
        if (data) {
            this.bufferData(data);
        }
        else if (elementCount) {
            this.bufferData(bytesPerElement * elementCount);
        }
    }
    Object.defineProperty(GLGPUBuffer.prototype, "elementCount", {
        get: function () {
            return this.byteLength / this.bytesPerElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLGPUBuffer.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    GLGPUBuffer.prototype.createGLBuffer = function (name) {
        var buffer = this.pipelineContext.gl.createBuffer();
        if (buffer) {
            assignInspectorName(buffer, name);
        }
        return buffer;
    };
    GLGPUBuffer.prototype.bind = function () {
        this.pipelineContext.gl.bindBuffer(this.target, this.glBuffer);
    };
    GLGPUBuffer.prototype.bufferData = function (data) {
        var byteLength = typeof data === 'number' ? data : data.byteLength;
        if (this.pipelineContext) {
            this.byteLength = byteLength;
            var gl = this.pipelineContext.gl;
            var target = this.target;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength === 0) {
                // ios 12 13 cause error when byteLength == 0
                gl.bufferData(target, 1, this.usage);
            }
            else {
                gl.bufferData(target, byteLength, this.usage);
                if (typeof data !== 'number') {
                    gl.bufferSubData(target, 0, data);
                }
            }
        }
        else {
            this.byteLength = 0;
        }
    };
    GLGPUBuffer.prototype.bufferSubData = function (elementOffset, data) {
        if (this.pipelineContext) {
            var gl = this.pipelineContext.gl;
            var target = this.target;
            var byteOffset = elementOffset * this.bytesPerElement;
            var byteLength = byteOffset + data.byteLength;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength > this.byteLength) {
                this.byteLength = byteLength;
                gl.bufferData(target, byteLength, this.usage);
            }
            gl.bufferSubData(target, byteOffset, data);
        }
        else {
            this.byteLength = 0;
        }
    };
    GLGPUBuffer.prototype.dispose = function () {
        this.pipelineContext.gl.deleteBuffer(this.glBuffer);
        // @ts-expect-error safe to assign
        this.glBuffer = null;
        this.destroyed = true;
    };
    // for test
    GLGPUBuffer.prototype.readSubData = function (elementOffset, dstBuffer) {
        if (isWebGL2(this.pipelineContext.gl)) {
            this.pipelineContext.gl.getBufferSubData(this.target, elementOffset * this.bytesPerElement, dstBuffer);
            return true;
        }
        return false;
    };
    return GLGPUBuffer;
}());
var map = (_a$2 = {},
    _a$2[glContext.INT] = Int32Array,
    _a$2[glContext.FLOAT] = Float32Array,
    _a$2[glContext.SHORT] = Int16Array,
    _a$2[glContext.BYTE] = Int8Array,
    _a$2[glContext.UNSIGNED_BYTE] = Uint8Array,
    _a$2[glContext.UNSIGNED_INT] = Uint32Array,
    _a$2[glContext.UNSIGNED_SHORT] = Uint16Array,
    _a$2);
function getBytesPerElementByGLType(type) {
    var _a, _b;
    return (_b = (_a = map[type]) === null || _a === void 0 ? void 0 : _a.BYTES_PER_ELEMENT) !== null && _b !== void 0 ? _b : 0;
}

var _a$1;
var INDEX_TYPE_MAP = (_a$1 = {},
    _a$1[Uint8Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_BYTE,
    _a$1[Uint16Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_SHORT,
    _a$1[Uint32Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_INT,
    _a$1);
var seed$2 = 1;
/**
 * 应用层 Geometry 对象，本身不直接保存 GPU 资源而是通过 geometryInternal 成员保存 GPU 资源
 */
var GLGeometry = /** @class */ (function (_super) {
    __extends(GLGeometry, _super);
    // TODO: 参数必传的用 props，可选的用 options，如果 props里面还有 options，则 options 需要修改名字（如renderOptions）
    function GLGeometry(engine, props) {
        var _this = this;
        var _a = props.drawStart, drawStart = _a === void 0 ? 0 : _a, drawCount = props.drawCount, mode = props.mode, indices = props.indices, _b = props.name, name = _b === void 0 ? "effectsGeometry:".concat(seed$2++) : _b, _c = props.bufferUsage, bufferUsage = _c === void 0 ? glContext.STATIC_DRAW : _c;
        _this = _super.call(this, name) || this;
        /**
         * 记录了顶点属性与 GPUBuffer 对应关系
         */
        _this.buffers = {};
        _this.vaos = {};
        _this.initialized = false;
        _this.indicesReleasable = false;
        _this.attributesName = [];
        _this.destroyed = false;
        _this.engine = engine;
        // 记录顶点属性，需要与 Shader 中 attribute 进行关联
        var bufferProps = {};
        var attributesName = [];
        var attributes = {};
        // key为buffer的名字
        var dirtyFlags = {};
        var attributesReleasable = {};
        var usage = bufferUsage;
        _this.drawStart = drawStart;
        _this.drawCount = isNaN(+drawCount) ? NaN : drawCount;
        _this.mode = (isNaN(mode) ? glContext.TRIANGLES : mode);
        Object.keys(props.attributes).forEach(function (name) {
            var attr = props.attributes[name];
            var size = attr.size, stride = attr.stride, offset = attr.offset, normalize = attr.normalize;
            var _a = attr, _b = _a.type, type = _b === void 0 ? glContext.FLOAT : _b, releasable = _a.releasable;
            var data = attr.data;
            if (type && !('dataSource' in attr) && !data) {
                data = generateEmptyTypedArray(type);
            }
            if (data) {
                var glType = data instanceof Float32Array ? glContext.FLOAT : glContext.INT;
                // 使用 AttributeWithData 构造的 attribute
                bufferProps[name] = {
                    data: data,
                    usage: usage,
                    target: glContext.ARRAY_BUFFER,
                    name: name,
                };
                attributes[name] = {
                    size: size,
                    stride: stride,
                    offset: offset,
                    type: type !== null && type !== void 0 ? type : glType,
                    normalize: !!normalize,
                    dataSource: name,
                };
                attributesReleasable[name] = releasable !== null && releasable !== void 0 ? releasable : false;
                dirtyFlags[name] = {
                    dirty: true,
                    discard: true,
                    start: Number.POSITIVE_INFINITY,
                    end: 0,
                };
            }
            else {
                // 使用 AttributeWithType 构造的 attribute
                var dataSource = attr.dataSource;
                if (dataSource) {
                    // 属性共享 buffer
                    attributes[name] = {
                        size: size,
                        stride: stride,
                        offset: offset,
                        type: type,
                        dataSource: dataSource,
                        normalize: !!normalize,
                    };
                }
            }
            attributesName.push(name);
        });
        dirtyFlags.index = {
            dirty: true,
            discard: true,
            start: Number.POSITIVE_INFINITY,
            end: 0,
        };
        // 顶点索引
        _this.indices = indices === null || indices === void 0 ? void 0 : indices.data;
        _this.indicesReleasable = (indices === null || indices === void 0 ? void 0 : indices.releasable) === true;
        _this.bufferProps = bufferProps;
        _this.attributes = attributes;
        _this.attributesName = attributesName;
        _this.attributesReleasable = attributesReleasable;
        _this.dirtyFlags = dirtyFlags;
        _this.options = props;
        return _this;
    }
    Object.defineProperty(GLGeometry.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLGeometry.prototype, "isInitialized", {
        get: function () {
            return this.initialized;
        },
        enumerable: false,
        configurable: true
    });
    GLGeometry.prototype.getOptions = function () {
        return __assign$1({}, this.options);
    };
    /**
     * Geometry 的 GPU 资源初始化方法，在绘制前调用
     */
    GLGeometry.prototype.initialize = function () {
        var _this = this;
        if (this.initialized) {
            return;
        }
        var engine = this.engine;
        assertExist(engine);
        engine.addGeometry(this);
        var pipelineContext = this.engine.getGLPipelineContext();
        // 创建vbo
        Object.keys(this.bufferProps).forEach(function (name) {
            _this.buffers[name] = new GLGPUBuffer(pipelineContext, _this.bufferProps[name]);
        });
        // 创建ibo
        if (this.indices) {
            this.indicesBuffer = this.createIndicesBuffer(pipelineContext, this.indices);
        }
        this.initialized = true;
        // 向 GPU 传输顶点数据
        this.flush();
        this.options = undefined;
    };
    GLGeometry.prototype.getAttributeBuffer = function (name) {
        if (!this.initialized) {
            return undefined;
        }
        var key = this.attributes[name].dataSource;
        return this.buffers[key];
    };
    GLGeometry.prototype.setAttributeData = function (name, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        var key = this.attributes[name].dataSource;
        if (bufferOption) {
            var usage = bufferOption.usage, target = bufferOption.target;
            this.bufferProps[key] = {
                data: data,
                usage: usage,
                target: target,
                elementCount: data.length,
            };
            this.dirtyFlags[key].discard = true;
            this.dirtyFlags[key].dirty = true;
        }
    };
    GLGeometry.prototype.getAttributeData = function (name) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        return bufferOption ? bufferOption.data : undefined;
    };
    GLGeometry.prototype.setAttributeSubData = function (name, offset, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var attribute = this.getAttributeBufferOption(name);
        if (attribute && attribute.data != undefined) {
            var start = offset;
            var length_1 = offset + data.length;
            if (attribute.data.length < length_1) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(length_1);
                newData.set(attribute.data);
                attribute.data = newData;
                this.dirtyFlags[name].discard = true;
            }
            else if (!this.dirtyFlags[name].discard) {
                var dirtyFlag = this.dirtyFlags[name];
                dirtyFlag.start = Math.min(dirtyFlag.start, start);
                dirtyFlag.end = Math.max(dirtyFlag.end, length_1 - 1);
            }
            attribute.data.set(data, start);
            this.dirtyFlags[name].dirty = true;
        }
    };
    GLGeometry.prototype.getIndexData = function () {
        return this.indices;
    };
    GLGeometry.prototype.setIndexData = function (data) {
        if (data instanceof Uint8Array ||
            data instanceof Uint16Array ||
            data instanceof Uint32Array) {
            this.indices = data;
            this.dirtyFlags['index'].discard = true;
            this.dirtyFlags['index'].dirty = true;
        }
    };
    GLGeometry.prototype.setIndexSubData = function (offset, data) {
        var _a;
        if (this.indices) {
            var start = offset;
            var length_2 = offset + data.length;
            if (this.indices.length < length_2) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(end);
                newData.set(this.indices);
                this.indices = newData;
                this.dirtyFlags['index'].discard = true;
            }
            else if (!this.dirtyFlags['index'].discard) {
                var dirtyFlag = this.dirtyFlags['index'];
                dirtyFlag.start = Math.min(dirtyFlag.start, start);
                dirtyFlag.end = Math.max(dirtyFlag.end, length_2 - 1);
            }
            (_a = this.indices) === null || _a === void 0 ? void 0 : _a.set(data, start);
            this.dirtyFlags['index'].dirty = true;
        }
    };
    GLGeometry.prototype.getAttributeStride = function (name) {
        var attr = this.attributes[name];
        var stride = attr.stride, size = attr.size, type = attr.type;
        return stride ? stride : size * BYTES_TYPE_MAP[type];
    };
    GLGeometry.prototype.getAttributeNames = function () {
        return this.attributesName;
    };
    GLGeometry.prototype.setDrawStart = function (count) {
        this.drawStart = count;
    };
    GLGeometry.prototype.getDrawStart = function () {
        return this.drawStart;
    };
    GLGeometry.prototype.setDrawCount = function (count) {
        this.drawCount = count;
    };
    GLGeometry.prototype.getDrawCount = function () {
        return this.drawCount;
    };
    // 根据 attribute 的 datasource 获取 js 端 buffer
    GLGeometry.prototype.getAttributeBufferOption = function (name) {
        var attribute = this.attributes[name];
        return attribute ? this.bufferProps[attribute.dataSource] : undefined;
    };
    GLGeometry.prototype.createIndicesBuffer = function (pipelineContext, data) {
        var type = INDEX_TYPE_MAP[data.BYTES_PER_ELEMENT];
        var indexProps = {
            data: data,
            target: glContext.ELEMENT_ARRAY_BUFFER,
            type: type,
            name: "".concat(this.name, "##index"),
        };
        return new GLGPUBuffer(pipelineContext, indexProps);
    };
    GLGeometry.prototype.flush = function () {
        var _this = this;
        if (!this.initialized) {
            return;
        }
        var attributes = this.attributes;
        var bufferProps = this.bufferProps;
        var indices = this.indices;
        Object.keys(this.dirtyFlags).forEach(function (name) {
            var flag = _this.dirtyFlags[name];
            var buffer;
            var data;
            if (name == 'index') {
                buffer = _this.indicesBuffer;
                data = indices;
            }
            else {
                var bufferName = attributes[name].dataSource;
                buffer = _this.buffers[bufferName];
                data = bufferProps[bufferName].data;
            }
            if ((flag.dirty || flag.discard) && buffer && data) {
                if (flag.discard) {
                    buffer.bufferData(data);
                }
                else {
                    var offset = flag.start * data.BYTES_PER_ELEMENT + data.byteOffset;
                    var length_3 = flag.end - flag.start + 1;
                    // @ts-expect-error safe to use
                    var subData = new data.constructor(data.buffer, offset, length_3);
                    buffer.bufferSubData(flag.start, subData);
                }
                flag.start = Number.POSITIVE_INFINITY;
                flag.end = 0;
                flag.dirty = flag.discard = false;
            }
        });
        // 需要释放的 attributes 数据
        Object.keys(this.attributesReleasable).forEach(function (name) {
            var releasable = _this.attributesReleasable[name];
            var bufferName = attributes[name].dataSource;
            if (bufferProps[bufferName] && releasable) {
                bufferProps[bufferName].data = undefined;
            }
        });
        // 释放 indices buffer
        if (this.indicesReleasable) ;
    };
    GLGeometry.prototype.dispose = function () {
        var _this = this;
        var _a;
        this.drawStart = 0;
        this.drawCount = NaN;
        this.bufferProps = {};
        this.indices = undefined;
        this.attributes = {};
        this.attributesName = [];
        this.options = undefined;
        if (this.initialized) {
            Object.keys(this.buffers).forEach(function (name) {
                _this.buffers[name].dispose();
            });
            this.buffers = {};
            (_a = this.indicesBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
            Object.keys(this.vaos).forEach(function (name) {
                var _a;
                (_a = _this.vaos[name]) === null || _a === void 0 ? void 0 : _a.dispose();
                _this.vaos[name] = undefined;
            });
            this.indicesBuffer = undefined;
            if (this.engine !== undefined) {
                this.engine.removeGeometry(this);
                this.engine = undefined;
            }
        }
        this.destroyed = true;
    };
    return GLGeometry;
}(Geometry));

var GLMaterialState = /** @class */ (function () {
    function GLMaterialState() {
        this.reset();
    }
    GLMaterialState.prototype.setBlendColor = function (color) {
        var _a = __read$3(color, 4), r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        if (this.blendColor[0] === r && this.blendColor[1] === g && this.blendColor[2] === b && this.blendColor[3] === a) {
            return;
        }
        this.blendColor[0] = r;
        this.blendColor[1] = g;
        this.blendColor[2] = b;
        this.blendColor[3] = a;
    };
    GLMaterialState.prototype.setBlending = function (value) {
        if (this.blending !== value) {
            this.blending = value;
        }
    };
    GLMaterialState.prototype.setBlendFunctionParameters = function (value) {
        var _a = __read$3(value, 4), blendSrc = _a[0], blendDst = _a[1], blendSrcAlpha = _a[2], blendDstAlpha = _a[3];
        if (this.blendFunctionParameters[0] === blendSrc &&
            this.blendFunctionParameters[1] === blendDst &&
            this.blendFunctionParameters[2] === blendSrcAlpha &&
            this.blendFunctionParameters[3] === blendDstAlpha) {
            return;
        }
        this.blendFunctionParameters[0] = blendSrc;
        this.blendFunctionParameters[1] = blendDst;
        this.blendFunctionParameters[2] = blendSrcAlpha;
        this.blendFunctionParameters[3] = blendDstAlpha;
    };
    GLMaterialState.prototype.setBlendEquationParameters = function (value) {
        var _a = __read$3(value, 2), rgb = _a[0], alpha = _a[1];
        if (this.blendEquationParameters[0] === rgb && this.blendEquationParameters[1] === alpha) {
            return;
        }
        this.blendEquationParameters[0] = rgb;
        this.blendEquationParameters[1] = alpha;
    };
    GLMaterialState.prototype.setDepthTest = function (value) {
        if (this.depthTest === value) {
            return;
        }
        this.depthTest = value;
    };
    GLMaterialState.prototype.setDepthMask = function (value) {
        if (this.depthMask === value) {
            return;
        }
        this.depthMask = value;
    };
    GLMaterialState.prototype.setDepthRange = function (value) {
        if (this.depthRange[0] === value[0] && this.depthRange[1] === value[1]) {
            return;
        }
        this.depthRange[0] = value[0];
        this.depthRange[1] = value[1];
    };
    GLMaterialState.prototype.setDepthFunc = function (value) {
        if (this.depthFunc === value) {
            return;
        }
        this.depthFunc = value;
    };
    GLMaterialState.prototype.setPolygonOffsetFill = function (value) {
        if (this.polygonOffsetFill === value) {
            return;
        }
        this.polygonOffsetFill = value;
    };
    GLMaterialState.prototype.setPolygonOffset = function (value) {
        if (this.polygonOffset[0] === value[0] && this.polygonOffset[1] === value[1]) {
            return;
        }
        this.polygonOffset[0] = value[0];
        this.polygonOffset[1] = value[1];
    };
    GLMaterialState.prototype.setSampleAlphaToCoverage = function (value) {
        if (this.sampleAlphaToCoverage === value) {
            return;
        }
        this.sampleAlphaToCoverage = value;
    };
    GLMaterialState.prototype.setColorMask = function (color) {
        var _a = __read$3(color, 4), r = _a[0], g = _a[1], b = _a[2], a = _a[3];
        if (this.colorMask[0] === r && this.colorMask[1] === g && this.colorMask[2] === b && this.colorMask[3] === a) {
            return;
        }
        this.colorMask[0] = r;
        this.colorMask[1] = g;
        this.colorMask[2] = b;
        this.colorMask[3] = a;
    };
    GLMaterialState.prototype.setStencilTest = function (value) {
        if (this.stencilTest === value) {
            return;
        }
        this.stencilTest = value;
    };
    GLMaterialState.prototype.setStencilMask = function (value) {
        if (this.stencilMask[0] === value[0] && this.stencilMask[1] === value[1]) {
            return;
        }
        this.stencilMask[0] = value[0];
        this.stencilMask[1] = value[1];
    };
    GLMaterialState.prototype.setStencilRef = function (value) {
        if (this.stencilRef[0] === value[0] && this.stencilRef[1] === value[1]) {
            return;
        }
        this.stencilRef[0] = value[0];
        this.stencilRef[1] = value[1];
    };
    GLMaterialState.prototype.setStencilFunc = function (value) {
        if (this.stencilFunc[0] === value[0] && this.stencilFunc[1] === value[1]) {
            return;
        }
        this.stencilFunc[0] = value[0];
        this.stencilFunc[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpFail = function (value) {
        if (this.stencilOpFail[0] === value[0] && this.stencilOpFail[1] === value[1]) {
            return;
        }
        this.stencilOpFail[0] = value[0];
        this.stencilOpFail[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpZFail = function (value) {
        if (this.stencilOpZFail[0] === value[0] && this.stencilOpZFail[1] === value[1]) {
            return;
        }
        this.stencilOpZFail[0] = value[0];
        this.stencilOpZFail[1] = value[1];
    };
    GLMaterialState.prototype.setStencilOpZPass = function (value) {
        if (this.stencilOpZPass[0] === value[0] && this.stencilOpZPass[1] === value[1]) {
            return;
        }
        this.stencilOpZPass[0] = value[0];
        this.stencilOpZPass[1] = value[1];
    };
    GLMaterialState.prototype.setCulling = function (value) {
        if (this.culling === value) {
            return;
        }
        this.culling = value;
    };
    GLMaterialState.prototype.setFrontFace = function (value) {
        if (this.frontFace === value) {
            return;
        }
        this.frontFace = value;
    };
    GLMaterialState.prototype.setCullFace = function (value) {
        if (this.cullFace === value) {
            return;
        }
        this.cullFace = value;
    };
    GLMaterialState.prototype.reset = function () {
        this.blending = false;
        this.blendColor = [0, 0, 0, 0];
        this.blendFunctionParameters = [glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA, glContext.ONE, glContext.ONE_MINUS_SRC_ALPHA];
        this.blendEquationParameters = [glContext.FUNC_ADD, glContext.FUNC_ADD];
        this.depthTest = false;
        this.depthMask = false;
        this.depthRange = [0, 1];
        this.depthFunc = glContext.LESS;
        this.polygonOffset = [0, 0];
        this.polygonOffsetFill = false;
        this.sampleAlphaToCoverage = false;
        this.colorMask = [true, true, true, true];
        this.stencilTest = false;
        this.stencilMask = [0xFF, 0xFF];
        this.stencilRef = [0, 0];
        this.stencilFunc = [glContext.ALWAYS, glContext.ALWAYS];
        this.stencilOpFail = [glContext.KEEP, glContext.KEEP];
        this.stencilOpZFail = [glContext.KEEP, glContext.KEEP];
        this.stencilOpZPass = [glContext.KEEP, glContext.KEEP];
        this.culling = false;
        this.frontFace = glContext.CW;
        this.cullFace = glContext.FRONT;
    };
    GLMaterialState.prototype.apply = function (pipelineContext) {
        pipelineContext.toggle(glContext.SAMPLE_ALPHA_TO_COVERAGE, this.sampleAlphaToCoverage);
        pipelineContext.toggle(glContext.BLEND, this.blending);
        pipelineContext.toggle(glContext.DEPTH_TEST, this.depthTest);
        pipelineContext.toggle(glContext.STENCIL_TEST, this.stencilTest);
        pipelineContext.toggle(glContext.CULL_FACE, this.culling);
        pipelineContext.toggle(glContext.POLYGON_OFFSET_FILL, this.polygonOffsetFill);
        if (this.stencilTest) {
            //stencil
            pipelineContext.stencilMaskSeparate(glContext.BACK, this.stencilMask[1]);
            pipelineContext.stencilMaskSeparate(glContext.FRONT, this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.BACK, this.stencilFunc[0], this.stencilRef[0], this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.FRONT, this.stencilFunc[1], this.stencilRef[1], this.stencilMask[1]);
            pipelineContext.stencilOpSeparate(glContext.BACK, this.stencilOpFail[0], this.stencilOpZFail[0], this.stencilOpZPass[0]);
            pipelineContext.stencilOpSeparate(glContext.FRONT, this.stencilOpFail[1], this.stencilOpZFail[1], this.stencilOpZPass[1]);
        }
        if (this.blending) {
            var _a = this, blendColor = _a.blendColor, blendEquationParameters = _a.blendEquationParameters, blendFunctionParameters = _a.blendFunctionParameters;
            pipelineContext.blendColor(blendColor[0], blendColor[1], blendColor[2], blendColor[3]);
            pipelineContext.blendEquationSeparate(blendEquationParameters[0], blendEquationParameters[1]);
            pipelineContext.blendFuncSeparate(blendFunctionParameters[0], blendFunctionParameters[1], blendFunctionParameters[2], blendFunctionParameters[3]);
        }
        //color depth
        pipelineContext.colorMask(this.colorMask[0], this.colorMask[1], this.colorMask[2], this.colorMask[3]);
        if (this.depthTest) {
            pipelineContext.depthMask(this.depthMask);
            pipelineContext.depthFunc(this.depthFunc);
            pipelineContext.depthRange(this.depthRange[0], this.depthRange[1]);
        }
        if (this.culling) {
            //face
            pipelineContext.cullFace(this.cullFace);
            pipelineContext.frontFace(this.frontFace);
        }
        if (this.polygonOffsetFill) {
            pipelineContext.polygonOffset(this.polygonOffset[0], this.polygonOffset[1]);
        }
    };
    return GLMaterialState;
}());

var Vector4 = Vector4$1, Matrix4 = Matrix4$1;
var GLMaterial = /** @class */ (function (_super) {
    __extends(GLMaterial, _super);
    function GLMaterial(engine, props) {
        var _this = _super.call(this, props) || this;
        // material存放的uniform数据。
        _this.floats = {};
        _this.ints = {};
        _this.vector2s = {};
        _this.vector3s = {};
        _this.vector4s = {};
        _this.quaternions = {};
        _this.matrices = {};
        _this.matrice3s = {};
        _this.textures = {};
        _this.floatArrays = {};
        _this.vector4Arrays = {};
        _this.matrixArrays = {};
        _this.samplers = []; // material存放的sampler名称。
        _this.uniforms = []; // material存放的uniform名称（不包括sampler）。
        _this.uniformDirtyFlag = true;
        _this.glMaterialState = new GLMaterialState();
        _this.engine = engine;
        return _this;
    }
    Object.defineProperty(GLMaterial.prototype, "blending", {
        get: function () {
            return this.glMaterialState.blending;
        },
        set: function (blending) {
            blending !== undefined && this.glMaterialState.setBlending(blending);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendColor", {
        get: function () {
            return this.glMaterialState.blendColor;
        },
        set: function (color) {
            color && this.glMaterialState.setBlendColor(color);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendFunction", {
        get: function () {
            return this.glMaterialState.blendFunctionParameters;
        },
        set: function (func) {
            func && this.glMaterialState.setBlendFunctionParameters(func);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "blendEquation", {
        get: function () {
            return this.glMaterialState.blendEquationParameters;
        },
        set: function (equation) {
            equation && this.glMaterialState.setBlendEquationParameters(equation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthTest", {
        get: function () {
            return this.glMaterialState.depthTest;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthTest(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthMask", {
        get: function () {
            return this.glMaterialState.depthMask;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthRange", {
        get: function () {
            return this.glMaterialState.depthRange;
        },
        set: function (value) {
            value && this.glMaterialState.setDepthRange(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "depthFunc", {
        get: function () {
            return this.glMaterialState.depthFunc;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setDepthFunc(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "polygonOffsetFill", {
        get: function () {
            return this.glMaterialState.polygonOffsetFill;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setPolygonOffsetFill(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "polygonOffset", {
        get: function () {
            return this.glMaterialState.polygonOffset;
        },
        set: function (value) {
            value && this.glMaterialState.setPolygonOffset(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "sampleAlphaToCoverage", {
        get: function () {
            return this.glMaterialState.sampleAlphaToCoverage;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setSampleAlphaToCoverage(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "colorMask", {
        get: function () {
            return this.glMaterialState.colorMask;
        },
        set: function (value) {
            value && this.glMaterialState.setColorMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilTest", {
        get: function () {
            return this.glMaterialState.stencilTest;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setStencilTest(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilMask", {
        get: function () {
            return this.glMaterialState.stencilMask;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilMask(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilRef", {
        get: function () {
            return this.glMaterialState.stencilRef;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilRef(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilFunc", {
        get: function () {
            return this.glMaterialState.stencilFunc;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilFunc(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpFail", {
        get: function () {
            return this.glMaterialState.stencilOpFail;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpFail(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpZFail", {
        get: function () {
            return this.glMaterialState.stencilOpZFail;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpZFail(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "stencilOpZPass", {
        get: function () {
            return this.glMaterialState.stencilOpZPass;
        },
        set: function (value) {
            value && this.glMaterialState.setStencilOpZPass(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "culling", {
        get: function () {
            return this.glMaterialState.culling;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setCulling(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "frontFace", {
        get: function () {
            return this.glMaterialState.frontFace;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setFrontFace(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLMaterial.prototype, "cullFace", {
        get: function () {
            return this.glMaterialState.cullFace;
        },
        set: function (value) {
            value !== undefined && this.glMaterialState.setCullFace(value);
        },
        enumerable: false,
        configurable: true
    });
    GLMaterial.prototype.enableKeyword = function (keyword) {
        throw new Error('Method not implemented.');
    };
    GLMaterial.prototype.disableKeyword = function (keyword) {
        throw new Error('Method not implemented.');
    };
    GLMaterial.prototype.isKeywordEnabled = function (keyword) {
        throw new Error('Method not implemented.');
    };
    // TODO 待废弃 兼容 model/spine 插件 改造后可移除
    GLMaterial.prototype.createMaterialStates = function (states) {
        this.sampleAlphaToCoverage = !!(states.sampleAlphaToCoverage);
        this.depthTest = states.depthTest;
        this.depthMask = states.depthMask;
        this.depthRange = states.depthRange;
        this.depthFunc = states.depthFunc;
        this.colorMask = states.colorMask;
        this.polygonOffset = states.polygonOffset;
        this.polygonOffsetFill = states.polygonOffsetFill;
        this.blending = states.blending;
        this.blendFunction = states.blendFunction;
        this.stencilTest = states.stencilTest;
    };
    Object.defineProperty(GLMaterial.prototype, "isDestroyed", {
        get: function () {
            return this.destroyed;
        },
        enumerable: false,
        configurable: true
    });
    /**shader和texture的GPU资源初始化。 */
    GLMaterial.prototype.initialize = function () {
        var _this = this;
        if (this.initialized) {
            return;
        }
        var glEngine = this.engine;
        glEngine.addMaterial(this);
        if (!this.shader) {
            var pipelineContext = glEngine.getGLPipelineContext();
            this.shader = pipelineContext.shaderLibrary.createShader(this.shaderSource);
        }
        this.shader.initialize(glEngine);
        Object.keys(this.textures).forEach(function (key) {
            var texture = _this.textures[key];
            if (!isFunction(texture.initialize)) {
                logger.error("".concat(JSON.stringify(texture), " is not valid Texture to initialize"));
                return;
            }
            texture.initialize();
        });
        this.initialized = true;
    };
    GLMaterial.prototype.setupStates = function (pipelineContext) {
        this.glMaterialState.apply(pipelineContext);
    };
    GLMaterial.prototype.use = function (renderer, globalUniforms) {
        var e_1, _a, e_2, _b;
        var _c;
        var engine = renderer.engine;
        var pipelineContext = engine.getGLPipelineContext();
        if (!this.shader.program) {
            (_c = this.engine) === null || _c === void 0 ? void 0 : _c.renderErrors.add(new Error('Shader program is not initialized'));
            return;
        }
        this.shader.program.bind();
        this.setupStates(pipelineContext);
        var name;
        if (globalUniforms) {
            try {
                // 加入全局 uniform 名称
                for (var _d = __values$1(globalUniforms.uniforms), _e = _d.next(); !_e.done; _e = _d.next()) {
                    name = _e.value;
                    this.checkUniform(name);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _f = __values$1(globalUniforms.samplers), _g = _f.next(); !_g.done; _g = _f.next()) {
                    name = _g.value;
                    if (!this.samplers.includes(name)) {
                        this.samplers.push(name);
                        this.uniformDirtyFlag = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        // 更新 cached uniform location
        if (this.uniformDirtyFlag) {
            this.shader.fillShaderInformation(this.uniforms, this.samplers);
            this.uniformDirtyFlag = false;
        }
        if (globalUniforms) {
            // 设置全局 uniform
            for (name in globalUniforms.floats) {
                this.shader.setFloat(name, globalUniforms.floats[name]);
            }
            for (name in globalUniforms.ints) {
                this.shader.setInt(name, globalUniforms.ints[name]);
            }
            for (name in globalUniforms.matrices) {
                this.shader.setMatrix(name, globalUniforms.matrices[name]);
            }
        }
        // 检查贴图数据是否初始化。
        for (name in this.textures) {
            if (!this.textures[name].textureBuffer) {
                this.textures[name].initialize();
            }
        }
        for (name in this.floats) {
            this.shader.setFloat(name, this.floats[name]);
        }
        for (name in this.ints) {
            this.shader.setInt(name, this.ints[name]);
        }
        for (name in this.floatArrays) {
            this.shader.setFloats(name, this.floatArrays[name]);
        }
        for (name in this.textures) {
            this.shader.setTexture(name, this.textures[name]);
        }
        for (name in this.vector2s) {
            this.shader.setVector2(name, this.vector2s[name]);
        }
        for (name in this.vector3s) {
            this.shader.setVector3(name, this.vector3s[name]);
        }
        for (name in this.vector4s) {
            this.shader.setVector4(name, this.vector4s[name]);
        }
        for (name in this.quaternions) {
            this.shader.setQuaternion(name, this.quaternions[name]);
        }
        for (name in this.matrices) {
            this.shader.setMatrix(name, this.matrices[name]);
        }
        for (name in this.matrice3s) {
            this.shader.setMatrix3(name, this.matrice3s[name]);
        }
        for (name in this.vector4Arrays) {
            this.shader.setVector4Array(name, this.vector4Arrays[name]);
        }
        for (name in this.matrixArrays) {
            this.shader.setMatrixArray(name, this.matrixArrays[name]);
        }
    };
    GLMaterial.prototype.getFloat = function (name) {
        return this.floats[name];
    };
    GLMaterial.prototype.setFloat = function (name, value) {
        this.checkUniform(name);
        this.floats[name] = value;
    };
    GLMaterial.prototype.getInt = function (name) {
        return this.ints[name];
    };
    GLMaterial.prototype.setInt = function (name, value) {
        this.checkUniform(name);
        this.ints[name] = value;
    };
    GLMaterial.prototype.getFloats = function (name) {
        return this.floatArrays[name];
    };
    GLMaterial.prototype.setFloats = function (name, value) {
        this.checkUniform(name);
        this.floatArrays[name] = value;
    };
    GLMaterial.prototype.getVector2 = function (name) {
        return this.vector2s[name];
    };
    GLMaterial.prototype.setVector2 = function (name, value) {
        this.checkUniform(name);
        this.vector2s[name] = value;
    };
    GLMaterial.prototype.getVector3 = function (name) {
        return this.vector3s[name];
    };
    GLMaterial.prototype.setVector3 = function (name, value) {
        this.checkUniform(name);
        this.vector3s[name] = value;
    };
    GLMaterial.prototype.getVector4 = function (name) {
        return this.vector4s[name];
    };
    GLMaterial.prototype.setVector4 = function (name, value) {
        this.checkUniform(name);
        this.vector4s[name] = value;
    };
    GLMaterial.prototype.getQuaternion = function (name) {
        return this.quaternions[name];
    };
    GLMaterial.prototype.setQuaternion = function (name, value) {
        this.checkUniform(name);
        this.quaternions[name] = value;
    };
    GLMaterial.prototype.getMatrix = function (name) {
        return this.matrices[name];
    };
    GLMaterial.prototype.setMatrix = function (name, value) {
        this.checkUniform(name);
        this.matrices[name] = value;
    };
    GLMaterial.prototype.setMatrix3 = function (name, value) {
        this.checkUniform(name);
        this.matrice3s[name] = value;
    };
    GLMaterial.prototype.getVector4Array = function (name) {
        return this.vector4Arrays[name];
    };
    GLMaterial.prototype.setVector4Array = function (name, array) {
        var e_3, _a;
        this.checkUniform(name);
        this.vector4Arrays[name] = [];
        try {
            for (var array_1 = __values$1(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var v = array_1_1.value;
                this.vector4Arrays[name].push(v.x, v.y, v.z, v.w);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    GLMaterial.prototype.getMatrixArray = function (name) {
        return this.matrixArrays[name];
    };
    GLMaterial.prototype.setMatrixArray = function (name, array) {
        var e_4, _a;
        this.checkUniform(name);
        this.matrixArrays[name] = [];
        try {
            for (var array_2 = __values$1(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {
                var m = array_2_1.value;
                for (var i = 0; i < 16; i++) {
                    this.matrixArrays[name].push(m.elements[i]);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    GLMaterial.prototype.setMatrixNumberArray = function (name, array) {
        this.checkUniform(name);
        this.matrixArrays[name] = array;
    };
    GLMaterial.prototype.getTexture = function (name) {
        return this.textures[name];
    };
    GLMaterial.prototype.setTexture = function (name, texture) {
        if (!this.samplers.includes(name)) {
            this.samplers.push(name);
            this.uniformDirtyFlag = true;
        }
        this.textures[name] = texture;
    };
    GLMaterial.prototype.hasUniform = function (name) {
        return this.uniforms.includes(name) || this.samplers.includes(name);
    };
    GLMaterial.prototype.clone = function (props) {
        var newProps = props ? props : this.props;
        var engine = this.engine;
        assertExist(engine);
        var clonedMaterial = new GLMaterial(engine, newProps);
        // TODO: 更换 Object.assign，低端设备兼容问题
        clonedMaterial.glMaterialState = Object.assign(new GLMaterialState(), clonedMaterial.glMaterialState);
        clonedMaterial.floats = this.floats;
        clonedMaterial.ints = this.ints;
        clonedMaterial.vector2s = this.vector2s;
        clonedMaterial.vector3s = this.vector3s;
        clonedMaterial.vector4s = this.vector4s;
        clonedMaterial.quaternions = this.quaternions;
        clonedMaterial.matrices = this.matrices;
        clonedMaterial.textures = this.textures;
        clonedMaterial.floatArrays = this.floatArrays;
        clonedMaterial.vector4Arrays = this.vector4Arrays;
        clonedMaterial.matrixArrays = this.matrixArrays;
        clonedMaterial.samplers = this.samplers;
        clonedMaterial.uniforms = this.uniforms;
        clonedMaterial.uniformDirtyFlag = true;
        return clonedMaterial;
    };
    GLMaterial.prototype.cloneUniforms = function (sourceMaterial) {
        var material = sourceMaterial;
        var name;
        for (name in material.floats) {
            this.setFloat(name, material.floats[name]);
        }
        for (name in material.ints) {
            this.setInt(name, material.ints[name]);
        }
        for (name in material.floatArrays) {
            this.setFloats(name, material.floatArrays[name]);
        }
        for (name in material.textures) {
            this.setTexture(name, material.textures[name]);
        }
        for (name in material.vector2s) {
            this.setVector2(name, material.vector2s[name]);
        }
        for (name in material.vector3s) {
            this.setVector3(name, material.vector3s[name]);
        }
        for (name in material.vector4s) {
            this.setVector4(name, material.vector4s[name]);
        }
        for (name in material.quaternions) {
            this.setQuaternion(name, material.quaternions[name]);
        }
        for (name in material.matrices) {
            this.setMatrix(name, material.matrices[name]);
        }
        for (name in material.vector4Arrays) {
            var vec4Array = [];
            for (var i = 0; i < material.vector4Arrays[name].length; i += 4) {
                vec4Array.push(new Vector4(material.vector4Arrays[name][i], material.vector4Arrays[name][i + 1], material.vector4Arrays[name][i + 2], material.vector4Arrays[name][i + 3]));
            }
            this.setVector4Array(name, vec4Array);
        }
        for (name in material.matrixArrays) {
            var mat4Array = [];
            for (var i = 0; i < material.matrixArrays[name].length; i += 16) {
                var matrix = Matrix4.fromIdentity();
                for (var j = 0; j < 16; j++) {
                    matrix.elements[j] = (material.matrixArrays[name][i + j]);
                }
                mat4Array.push(matrix);
            }
            this.setMatrixArray(name, mat4Array);
        }
    };
    GLMaterial.prototype.checkUniform = function (uniformName) {
        if (!this.uniforms.includes(uniformName)) {
            this.uniforms.push(uniformName);
            this.uniformDirtyFlag = true;
        }
    };
    GLMaterial.prototype.dispose = function (options) {
        var _this = this;
        var _a;
        if (this.destroyed) {
            return;
        }
        (_a = this.shader) === null || _a === void 0 ? void 0 : _a.dispose();
        if ((options === null || options === void 0 ? void 0 : options.textures) !== exports.DestroyOptions.keep) {
            Object.keys(this.textures).forEach(function (key) {
                _this.textures[key].dispose();
            });
        }
        // @ts-expect-error
        this.shaderSource = null;
        // @ts-expect-error
        this.uniformSemantics = {};
        this.floats = {};
        this.ints = {};
        this.vector2s = {};
        this.vector3s = {};
        this.vector4s = {};
        this.quaternions = {};
        this.matrices = {};
        this.matrice3s = {};
        this.textures = {};
        this.floatArrays = {};
        this.vector4Arrays = {};
        this.matrixArrays = {};
        this.samplers = [];
        this.uniforms = [];
        this.initialize = throwDestroyedError$1;
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMaterial(this);
            this.engine = undefined;
        }
    };
    return GLMaterial;
}(Material));

var copyShaderId = '$mri-internal-copy';
var ExtWrap = /** @class */ (function () {
    function ExtWrap(renderer) {
        this.renderer = renderer;
        if (renderer.engine.gpuCapability.level === 1) {
            this.copyRenderPass = this.createCopyRenderPass().initialize(renderer);
            var shaderSource = this.copyRenderPass.meshes[0].material.shaderSource;
            renderer.pipelineContext.shaderLibrary.addShader(shaderSource);
        }
    }
    ExtWrap.prototype.resetColorAttachments = function (rp, colorTextures) {
        if (this.renderer) {
            rp.resetColorAttachments(colorTextures);
        }
    };
    ExtWrap.prototype.copyTexture = function (source, tex) {
        if (!this.renderer) {
            return;
        }
        source.initialize();
        tex.initialize();
        tex.updateSource({
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: tex.getWidth() || source.getWidth(),
                height: tex.getHeight() || source.getHeight(),
            },
        });
        if (this.renderer.engine.gpuCapability.level === 2) {
            this.copy2(source, tex);
        }
        else {
            this.copy1(source, tex);
        }
    };
    ExtWrap.prototype.copy2 = function (source, target) {
        var _a;
        // 保存当前的 fbo
        var frameBuffer = this.renderer.getFrameBuffer();
        (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.glRenderer.copy2(source, target);
        // 还原 fbo
        this.renderer.setFrameBuffer(frameBuffer);
    };
    ExtWrap.prototype.copy1 = function (source, target) {
        var rp = this.copyRenderPass;
        if (rp) {
            var renderer = this.renderer;
            if (renderer) {
                var fb = rp.frameBuffer;
                fb.viewport[2] = target.getWidth() || source.getWidth();
                fb.viewport[3] = target.getHeight() || source.getHeight();
                renderer.glRenderer.resetColorAttachments(fb, [target]);
                var mesh = rp.meshes[0];
                mesh.material.setTexture('uTex', source);
                renderer.renderRenderPass(rp);
            }
        }
    };
    ExtWrap.prototype.createCopyRenderPass = function () {
        var name = 'mri-copy-mesh';
        var attachment = { texture: { format: glContext.RGBA } };
        var engine = this.renderer.engine;
        var geometry = new GLGeometry(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                },
            },
            drawCount: 4,
        });
        var vertexShader = "\n        precision highp float;\n      attribute vec2 aPos;\n      varying vec2 vTex;\n      void main(){\n         gl_Position = vec4(aPos,0.,1.0);\n         vTex = (aPos + vec2(1.))/2.;\n       }\n      ";
        var fragmentShader = "\n        precision highp float;\n      varying vec2 vTex;\n      uniform sampler2D uTex;\n      void main(){gl_FragColor = texture2D(uTex,vTex);}\n      ";
        var level = engine.gpuCapability.level;
        var material = new GLMaterial(engine, {
            name: name,
            shader: {
                cacheId: copyShaderId,
                name: name,
                vertex: createShaderWithMarcos([], vertexShader, exports.ShaderType.vertex, level),
                fragment: createShaderWithMarcos([], fragmentShader, exports.ShaderType.fragment, level),
                glslVersion: level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1,
            },
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        var mesh = new Mesh(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0,
        });
        return new CopyTexturePass(this.renderer, {
            name: 'mri-copy-rp',
            clearAction: {
                colorAction: exports.TextureLoadAction.whatever,
            },
            attachments: [attachment],
            meshes: [mesh],
        });
    };
    ExtWrap.prototype.dispose = function () {
        var _a;
        if (this.renderer) {
            (_a = this.copyRenderPass) === null || _a === void 0 ? void 0 : _a.dispose();
            // @ts-expect-error
            this.renderer = undefined;
        }
    };
    return ExtWrap;
}());
var CopyTexturePass = /** @class */ (function (_super) {
    __extends(CopyTexturePass, _super);
    function CopyTexturePass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CopyTexturePass.prototype.configure = function (renderer) {
        this.currentFrameBuffer = renderer.getFrameBuffer();
        renderer.setFrameBuffer(this.frameBuffer);
    };
    CopyTexturePass.prototype.execute = function (renderer) {
        if (this.clearAction) {
            renderer.clear(this.clearAction);
        }
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
        renderer.setFrameBuffer(this.currentFrameBuffer);
    };
    return CopyTexturePass;
}(RenderPass));

var GLContextManager = /** @class */ (function () {
    function GLContextManager(canvas, glType, options) {
        var _this = this;
        if (glType === void 0) { glType = 'webgl'; }
        if (options === void 0) { options = {}; }
        this.canvas = canvas;
        this.glType = glType;
        this.restoreHandlers = [];
        this.lostHandlers = [];
        assertExist(canvas);
        this.gl = createGLContext(canvas, glType, options);
        this.contextLostListener = function (e) {
            var e_1, _a;
            var _b;
            try {
                for (var _c = __values$1(_this.lostHandlers), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var lostHandler = _d.value;
                    lostHandler.lost(e);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_b = _this.canvas) === null || _b === void 0 ? void 0 : _b.removeEventListener('webglcontextlost', _this.contextLostListener);
        };
        this.contextRestoredListener = function (e) {
            var e_2, _a;
            var _b;
            try {
                for (var _c = __values$1(_this.restoreHandlers), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var restorable = _d.value;
                    restorable.restore();
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            (_b = _this.canvas) === null || _b === void 0 ? void 0 : _b.addEventListener('webglcontextlost', _this.contextLostListener);
        };
        canvas.addEventListener('webglcontextlost', this.contextLostListener);
        canvas.addEventListener('webglcontextrestored', this.contextRestoredListener);
    }
    GLContextManager.prototype.dispose = function () {
        if (this.canvas) {
            this.canvas.removeEventListener('webglcontextlost', this.contextLostListener);
            this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredListener);
        }
        this.gl = null;
        this.canvas = null;
    };
    GLContextManager.prototype.addLostHandler = function (lostHandler) {
        this.lostHandlers.push(lostHandler);
    };
    GLContextManager.prototype.removeLostHandler = function (lostHandler) {
        var index = this.lostHandlers.indexOf(lostHandler);
        if (index > -1) {
            this.lostHandlers.splice(index, 1);
        }
    };
    GLContextManager.prototype.addRestoreHandler = function (restoreHandler) {
        this.restoreHandlers.push(restoreHandler);
    };
    GLContextManager.prototype.removeRestoreHandler = function (restorable) {
        var index = this.restoreHandlers.indexOf(restorable);
        if (index > -1) {
            this.restoreHandlers.splice(index, 1);
        }
    };
    return GLContextManager;
}());

var GLEngine = /** @class */ (function (_super) {
    __extends(GLEngine, _super);
    function GLEngine(gl) {
        var _this = _super.call(this) || this;
        _this.gpuCapability = new GPUCapability(gl);
        return _this;
    }
    GLEngine.prototype.dispose = function () {
        if (this.isDestroyed) {
            return;
        }
        _super.prototype.dispose.call(this);
    };
    GLEngine.prototype.getGLRenderer = function () {
        return this.renderer;
    };
    GLEngine.prototype.getGLRendererInternal = function () {
        return this.getGLRenderer().glRenderer;
    };
    GLEngine.prototype.getGLPipelineContext = function () {
        return this.getGLRenderer().pipelineContext;
    };
    return GLEngine;
}(Engine));

var GLRenderBuffer = /** @class */ (function (_super) {
    __extends(GLRenderBuffer, _super);
    function GLRenderBuffer(props, renderer) {
        var _this = _super.call(this, props) || this;
        _this.initialized = false;
        if (renderer !== undefined) {
            _this.initialize(renderer);
        }
        return _this;
    }
    GLRenderBuffer.prototype.initialize = function (renderer) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.renderer = renderer;
        this.buffer = renderer.createGLRenderBuffer(this);
    };
    GLRenderBuffer.prototype.setSize = function (width, height) {
        if (!this.initialized) {
            logger.error('Can\'t set size for uninitialized render buffer');
            return;
        }
        if (width !== this.size[0] || height !== this.size[1]) {
            var _a = this.renderer, gl = _a.gl, state = _a.pipelineContext;
            state.bindRenderBuffer(gl.RENDERBUFFER, this.buffer);
            if (width && height) {
                gl.renderbufferStorage(gl.RENDERBUFFER, this.format, this.size[0] = width, this.size[1] = height);
            }
            else {
                logger.error("Invalid render buffer size: ".concat(width, "x").concat(height));
            }
        }
    };
    GLRenderBuffer.prototype.dispose = function () {
        if (this.renderer) {
            this.renderer.deleteGLRenderBuffer(this);
            this.renderer = null;
            this.buffer = null;
        }
        this.destroyed = true;
        this.initialize = throwDestroyedError$1;
    };
    return GLRenderBuffer;
}(RenderBuffer));

var seed$1 = 1;
var GLFrameBuffer = /** @class */ (function (_super) {
    __extends(GLFrameBuffer, _super);
    function GLFrameBuffer(props, renderer) {
        var _a;
        var _this = _super.call(this) || this;
        _this.attachmentTextures = [];
        _this.renderer = renderer;
        _this.engine = renderer.engine;
        var depthStencilAttachment = props.depthStencilAttachment, viewport = props.viewport, isCustomViewport = props.isCustomViewport, _b = props.viewportScale, viewportScale = _b === void 0 ? 1 : _b, storeAction = props.storeAction, _c = props.name, name = _c === void 0 ? "GLFrameBuffer".concat(seed$1++) : _c;
        _this.depthStencilStorageType = (_a = depthStencilAttachment === null || depthStencilAttachment === void 0 ? void 0 : depthStencilAttachment.storageType) !== null && _a !== void 0 ? _a : exports.RenderPassAttachmentStorageType.none;
        _this.viewport = viewport;
        _this.isCustomViewport = !!isCustomViewport;
        _this.viewportScale = viewportScale;
        _this.name = name;
        _this.storeAction = storeAction;
        _this.updateProps(props);
        return _this;
    }
    Object.defineProperty(GLFrameBuffer.prototype, "stencilStorage", {
        get: function () {
            var storageType = this.depthStencilStorageType;
            if (storageType !== exports.RenderPassAttachmentStorageType.depth_16_opaque) {
                return this.depthStencilRenderBuffer;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLFrameBuffer.prototype, "depthStorage", {
        get: function () {
            if (this.depthStencilStorageType !== exports.RenderPassAttachmentStorageType.stencil_8_opaque) {
                return this.depthStencilRenderBuffer;
            }
        },
        enumerable: false,
        configurable: true
    });
    GLFrameBuffer.prototype.getDepthTexture = function () {
        return this.depthTexture;
    };
    GLFrameBuffer.prototype.getStencilTexture = function () {
        return this.stencilTexture;
    };
    GLFrameBuffer.prototype.getColorTextures = function () {
        return this.colorTextures;
    };
    GLFrameBuffer.prototype.updateAttachmentTextures = function () {
        var _this = this;
        this.attachmentTextures.length = 0;
        this.colorTextures.forEach(function (tex) {
            tex.initialize();
            addItem(_this.attachmentTextures, tex.textureBuffer);
        });
        if (this.stencilTexture) {
            addItem(this.attachmentTextures, this.stencilTexture.textureBuffer);
        }
        if (this.depthTexture) {
            addItem(this.attachmentTextures, this.depthTexture.textureBuffer);
        }
    };
    GLFrameBuffer.prototype.updateProps = function (props) {
        var _a, _b;
        var renderer = this.renderer;
        var gpuCapability = this.engine.gpuCapability;
        var depthStencilAttachment = (_a = props.depthStencilAttachment) !== null && _a !== void 0 ? _a : { storageType: exports.RenderPassAttachmentStorageType.none };
        var willUseFbo = props.attachments.length > 0;
        this.externalStorage = false;
        var separateDepthStencil = true;
        if (props.attachments.length > 1 && !gpuCapability.detail.drawBuffers) {
            throw Error('multiple color attachments not support');
        }
        var optDepthStencilTex = (_b = props.depthStencilAttachment) === null || _b === void 0 ? void 0 : _b.texture;
        var readableDepthStencilTextures = gpuCapability.detail.readableDepthStencilTextures;
        this.colorTextures = props.attachments.slice();
        if (!willUseFbo && depthStencilAttachment.storageType !== exports.RenderPassAttachmentStorageType.none) {
            throw Error('use depth stencil attachment without color attachments');
        }
        if (willUseFbo) {
            this.fbo = renderer.glRenderer.createGLFrameBuffer(this, this.name);
        }
        var storageType = depthStencilAttachment.storageType;
        if (storageType === exports.RenderPassAttachmentStorageType.depth_stencil_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid depth stencil attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    format: glContext.DEPTH_STENCIL,
                    attachment: glContext.DEPTH_STENCIL_ATTACHMENT,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
            separateDepthStencil = false;
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_16_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid depth attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    attachment: glContext.DEPTH_ATTACHMENT,
                    format: glContext.DEPTH_COMPONENT16,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.stencil_8_opaque) {
            if (depthStencilAttachment.storage) {
                if (depthStencilAttachment.storage instanceof GLRenderBuffer) {
                    this.depthStencilRenderBuffer = depthStencilAttachment.storage;
                    this.externalStorage = true;
                }
                else {
                    throw Error('invalid stencil attachment storage');
                }
            }
            else {
                this.depthStencilRenderBuffer = new GLRenderBuffer({
                    attachment: glContext.STENCIL_ATTACHMENT,
                    format: glContext.STENCIL_INDEX8,
                    storageType: storageType,
                }, renderer.glRenderer);
            }
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_16_texture) {
            if (!readableDepthStencilTextures) {
                throw Error('depth texture is not support in framebuffer');
            }
            this.depthTexture = optDepthStencilTex !== null && optDepthStencilTex !== void 0 ? optDepthStencilTex : new GLTexture(this.engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.DEPTH_COMPONENT,
                internalFormat: gpuCapability.internalFormatDepth16,
                type: glContext.UNSIGNED_SHORT,
                name: "".concat(this.name, "##depthTex"),
            });
            this.depthTexture.initialize();
        }
        else if (storageType === exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture) {
            if (!readableDepthStencilTextures) {
                throw Error('depth stencil texture is not support in framebuffer');
            }
            this.depthTexture = this.stencilTexture = optDepthStencilTex !== null && optDepthStencilTex !== void 0 ? optDepthStencilTex : new GLTexture(this.engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.DEPTH_STENCIL,
                internalFormat: gpuCapability.internalFormatDepth24_stencil8,
                type: gpuCapability.UNSIGNED_INT_24_8,
                name: "".concat(this.name, "##dpthStclTex"),
            });
            this.depthTexture.initialize();
            separateDepthStencil = true;
        }
        this.storeInvalidAttachments = this.getStoreAttachments(this.storeAction, separateDepthStencil);
        this.updateAttachmentTextures();
    };
    GLFrameBuffer.prototype.getStoreAttachments = function (storeAction, separateDepthStencil) {
        var gl = this.renderer.glRenderer.gl;
        var colorLen = this.colorTextures.length;
        if (storeAction && isWebGL2(gl) && colorLen > 0) {
            var attachments = [];
            if (storeAction.depthAction === exports.TextureStoreAction.clear && this.depthStorage) {
                addItem(attachments, separateDepthStencil ? gl.DEPTH_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.stencilAction === exports.TextureStoreAction.clear && this.stencilStorage) {
                addItem(attachments, separateDepthStencil ? gl.STENCIL_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.colorAction === exports.TextureStoreAction.clear) {
                for (var i = 0; i < colorLen; i++) {
                    addItem(attachments, gl["COLOR_ATTACHMENT".concat(i)]);
                }
            }
            return attachments;
        }
    };
    GLFrameBuffer.prototype.unbind = function () {
        var att = this.storeInvalidAttachments;
        if (att === null || att === void 0 ? void 0 : att.length) {
            var gl = this.renderer.glRenderer.gl;
            gl.invalidateFramebuffer(gl.FRAMEBUFFER, att);
        }
        this.renderer.pipelineContext.bindSystemFramebuffer();
    };
    GLFrameBuffer.prototype.bind = function () {
        var _this = this;
        var gl = this.renderer.glRenderer.gl;
        var state = this.renderer.pipelineContext;
        if (this.fbo) {
            var FRAMEBUFFER = gl.FRAMEBUFFER;
            var _a = __read$3(this.viewport, 4), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
            state.bindFramebuffer(FRAMEBUFFER, this.fbo);
            // TODO 不在bind中设置viewport
            state.viewport(x, y, width, height);
            var emptyTexture_1 = this.renderer.glRenderer.emptyTexture2D.textureBuffer;
            // in case frame texture loop
            Object.keys(state.textureUnitDict).forEach(function (unit) {
                var texture = state.textureUnitDict[unit];
                if (texture !== emptyTexture_1 &&
                    texture &&
                    _this.attachmentTextures.includes(texture)) {
                    state.activeTexture(+unit);
                    _this.renderer.glRenderer.emptyTexture2D.bind();
                }
            });
            // FIXME: 没有pipeline对象的临时方案
            for (var i = 0; i < 4; i++) {
                state.activeTexture(gl.TEXTURE0 + i);
                this.renderer.glRenderer.emptyTexture2D.bind();
            }
            if (!this.ready) {
                var _b = this, depthStencilRenderBuffer = _b.depthStencilRenderBuffer, depthTexture = _b.depthTexture, stencilTexture = _b.stencilTexture;
                state.activeTexture(gl.TEXTURE0);
                if (depthStencilRenderBuffer) {
                    depthStencilRenderBuffer.setSize(width, height);
                    gl.framebufferRenderbuffer(FRAMEBUFFER, depthStencilRenderBuffer.attachment, gl.RENDERBUFFER, depthStencilRenderBuffer.buffer);
                }
                else if (depthTexture) {
                    // 解决RenderPass在Clone深度贴图时width和height丢失的问题
                    depthTexture.source.data = { width: width, height: height };
                    depthTexture.update({ data: { width: width, height: height, data: new Uint16Array(0) } });
                    var attachment = depthTexture && stencilTexture ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                    gl.framebufferTexture2D(FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthTexture.textureBuffer, 0);
                }
                this.resetColorTextures(this.colorTextures);
                var status_1 = gl.checkFramebufferStatus(FRAMEBUFFER);
                if (status_1 !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error("Framebuffer failed, status: ".concat(status_1, ", error: ").concat(gl.getError()));
                }
                this.ready = true;
            }
        }
    };
    GLFrameBuffer.prototype.resetColorTextures = function (colorTextures) {
        var e_1, _a;
        var colors = colorTextures;
        var gl = this.renderer.glRenderer.gl;
        var gpuCapability = this.engine.gpuCapability;
        var viewport = this.viewport;
        var buffers = [];
        if (colors) {
            try {
                for (var colors_1 = __values$1(colors), colors_1_1 = colors_1.next(); !colors_1_1.done; colors_1_1 = colors_1.next()) {
                    var texture = colors_1_1.value;
                    texture.initialize();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (colors_1_1 && !colors_1_1.done && (_a = colors_1.return)) _a.call(colors_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.colorTextures = colors.slice();
        }
        this.renderer.pipelineContext.activeTexture(gl.TEXTURE0);
        this.colorTextures.forEach(function (tex, index) {
            var width = viewport[2];
            var height = viewport[3];
            var data = { width: width, height: height, data: new Uint8Array(0) };
            tex.update({ data: data });
            gpuCapability.framebufferTexture2D(gl, gl.FRAMEBUFFER, index, gl.TEXTURE_2D, tex.textureBuffer);
            buffers.push(true);
        });
        gpuCapability.drawBuffers(gl, buffers);
        this.updateAttachmentTextures();
    };
    GLFrameBuffer.prototype.resize = function (x, y, width, height) {
        var _a = __read$3(this.viewport, 4), preX = _a[0], preY = _a[1], preWidth = _a[2], preHeight = _a[3];
        if (preX !== x || preY !== y || preWidth !== width || preHeight !== height) {
            this.viewport = [x, y, width, height];
            this.ready = false;
            this.bind();
        }
    };
    GLFrameBuffer.prototype.dispose = function (opt) {
        var _a, _b;
        var renderer = this.renderer;
        if (renderer) {
            renderer.glRenderer.deleteGLFrameBuffer(this);
            delete this.fbo;
            var clearAttachment = (opt === null || opt === void 0 ? void 0 : opt.depthStencilAttachment) ? opt.depthStencilAttachment : exports.RenderPassDestroyAttachmentType.force;
            if (clearAttachment === exports.RenderPassDestroyAttachmentType.force || (clearAttachment === exports.RenderPassDestroyAttachmentType.keepExternal && !this.externalStorage)) {
                (_a = this.depthStencilRenderBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
                (_b = this.depthTexture) === null || _b === void 0 ? void 0 : _b.dispose();
            }
            // @ts-expect-error safe to assign
            this.renderer = this.stencilRenderBuffer = this.depthStencilRenderBuffer = null;
        }
    };
    return GLFrameBuffer;
}(FrameBuffer));

function hash(str) {
  var hash = 5381,
      i    = str.length;

  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }

  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */
  return hash >>> 0;
}

var stringHash = hash;

var _a, _b;
var BlockUniformInfoOffset = 1;
var BlockUniformInfoByteLength = 8;
var BlockUniformInfoType = 0;
var BlockUniformInfoArrayStride = 4;
var BlockUniformInfoArraySize = 2;
var BlockUniformInfoRowStride = 5;
var ItemPerValueMap = (_a = {},
    _a[glContext.FLOAT] = 1,
    _a[glContext.INT] = 1,
    _a[glContext.UNSIGNED_INT] = 1,
    _a[glContext.SHORT] = 1,
    _a[glContext.BOOL] = 1,
    _a[glContext.UNSIGNED_SHORT] = 1,
    _a[glContext.FLOAT_VEC2] = 2,
    _a[glContext.FLOAT_VEC3] = 3,
    _a[glContext.FLOAT_VEC4] = 4,
    _a[glContext.FLOAT_MAT2] = 4,
    _a[glContext.FLOAT_MAT3] = 9,
    _a[glContext.FLOAT_MAT4] = 16,
    _a[glContext.FLOAT_MAT2x3] = 6,
    _a[glContext.FLOAT_MAT2x4] = 8,
    _a[glContext.FLOAT_MAT4x3] = 12,
    _a[glContext.FLOAT_MAT4x2] = 8,
    _a[glContext.FLOAT_MAT3x4] = 12,
    _a[glContext.FLOAT_MAT3x2] = 6,
    _a[glContext.INT_VEC2] = 2,
    _a[glContext.INT_VEC3] = 3,
    _a[glContext.INT_VEC4] = 4,
    _a[glContext.UNSIGNED_INT_VEC2] = 2,
    _a[glContext.UNSIGNED_INT_VEC3] = 3,
    _a[glContext.UNSIGNED_INT_VEC4] = 4,
    _a[glContext.BOOL_VEC2] = 2,
    _a[glContext.BOOL_VEC3] = 3,
    _a[glContext.BOOL_VEC4] = 4,
    _a);
var setFloat32Array = arraySetter(Float32Array);
var setInt32Array = arraySetter(Int32Array);
var setUInt8Array = arraySetter(Uint8Array);
(_b = {},
    _b[glContext.FLOAT] = numberSetter(Float32Array),
    _b[glContext.INT] = numberSetter(Int32Array),
    _b[glContext.UNSIGNED_INT] = numberSetter(Uint32Array),
    _b[glContext.SHORT] = numberSetter(Int16Array),
    _b[glContext.BOOL] = numberSetter(Uint8Array),
    _b[glContext.UNSIGNED_SHORT] = numberSetter(Uint16Array),
    _b[glContext.FLOAT_VEC2] = setFloat32Array,
    _b[glContext.FLOAT_VEC3] = setFloat32Array,
    _b[glContext.FLOAT_VEC4] = setFloat32Array,
    _b[glContext.FLOAT_MAT2] = setFloat32Array,
    _b[glContext.FLOAT_MAT3] = setFloat32Array,
    _b[glContext.FLOAT_MAT4] = setFloat32Array,
    _b[glContext.FLOAT_MAT2x3] = setFloat32Array,
    _b[glContext.FLOAT_MAT2x4] = setFloat32Array,
    _b[glContext.FLOAT_MAT4x3] = setFloat32Array,
    _b[glContext.FLOAT_MAT4x2] = setFloat32Array,
    _b[glContext.FLOAT_MAT3x4] = setFloat32Array,
    _b[glContext.FLOAT_MAT3x2] = setFloat32Array,
    _b[glContext.INT_VEC2] = setInt32Array,
    _b[glContext.INT_VEC3] = setInt32Array,
    _b[glContext.INT_VEC4] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC2] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC3] = setInt32Array,
    _b[glContext.UNSIGNED_INT_VEC4] = setInt32Array,
    _b[glContext.BOOL_VEC2] = setUInt8Array,
    _b[glContext.BOOL_VEC3] = setUInt8Array,
    _b[glContext.BOOL_VEC4] = setUInt8Array);
function numberSetter(typedArray) {
    return function (value, info, name, range) {
        var flag = {
            start: info[BlockUniformInfoOffset],
            dirty: true,
        };
        var arrSize = info[BlockUniformInfoArraySize];
        if (arrSize > 1) {
            var values = value;
            if (values.length) {
                var eleCount = range[1] || values.length;
                var vecLen = info[BlockUniformInfoArrayStride] / typedArray.BYTES_PER_ELEMENT;
                var buffer = flag.buffer = new typedArray(eleCount * vecLen);
                var start = range[0] || 0;
                for (var i = 0; i < eleCount; i++) {
                    buffer[i * vecLen] = values[i + start];
                }
                flag.start += start * vecLen;
            }
        }
        else {
            flag.buffer = new typedArray([value]);
        }
        return flag;
    };
}
function arraySetter(type) {
    return function (value, info, name, range) {
        var blockByteLen = info[BlockUniformInfoByteLength];
        var arrSize = info[BlockUniformInfoArraySize];
        var rowStride = info[BlockUniformInfoRowStride];
        var entryStride = arrSize === 1 ? blockByteLen : info[BlockUniformInfoArrayStride];
        var entryRowCount = rowStride ? entryStride / rowStride : 1;
        var rowNumPadding = entryStride / type.BYTES_PER_ELEMENT / entryRowCount;
        var maxRowCount = blockByteLen / type.BYTES_PER_ELEMENT / rowNumPadding;
        //set array
        var numPerEntry = ItemPerValueMap[info[BlockUniformInfoType]];
        var numPerRow = numPerEntry / entryRowCount;
        var valueStartIndex = (range[0] || 0) * numPerEntry;
        var totalRow = range[1] ? entryRowCount * range[1] : maxRowCount;
        var buffer = new type(rowNumPadding * totalRow);
        var flag = {
            start: info[BlockUniformInfoOffset] + entryStride * (range[0] || 0),
            dirty: true,
            buffer: buffer,
        };
        for (var i = 0, bufferTarget = 0, sourceIndex = valueStartIndex; i < totalRow; i++) {
            for (var j = 0; j < numPerRow; j++) {
                buffer[bufferTarget + j] = value[sourceIndex + j];
            }
            bufferTarget += rowNumPadding;
            sourceIndex += numPerRow;
        }
        return flag;
    };
}
// TODO: 函数名重定义
function createUniformBlockDataFromProgram(gl, program) {
    var blockSpecs = [];
    var blockUniformNames = [];
    var uniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    var _loop_1 = function (idx) {
        var name_1 = gl.getActiveUniformBlockName(program, idx);
        var blockSpec = {
            index: gl.getUniformBlockIndex(program, name_1),
            usedByVertexShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
            usedByFragmentShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
            size: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_DATA_SIZE),
            uniformIndices: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
            used: false,
            uniforms: {},
            name: name_1,
            id: '',
        };
        blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
        blockSpecs[idx] = blockSpec;
        var indices = blockSpec.uniformIndices;
        var uniformNames = [];
        for (var i = 0; i < indices.length; i++) {
            var name_2 = gl.getActiveUniform(program, indices[i]).name.replace('[0]', '');
            blockSpec.uniforms[name_2] = [0, 0, 0, 0, 0, 0, 0, i, 0];
            uniformNames[i] = name_2;
            blockUniformNames.push(name_2);
        }
        [
            gl.UNIFORM_TYPE,
            gl.UNIFORM_OFFSET,
            gl.UNIFORM_SIZE,
            gl.UNIFORM_BLOCK_INDEX,
            gl.UNIFORM_ARRAY_STRIDE,
            gl.UNIFORM_MATRIX_STRIDE,
            gl.UNIFORM_IS_ROW_MAJOR,
        ].forEach(function (param, pi) {
            gl.getActiveUniforms(program, indices, param)
                .forEach(function (value, idx) {
                var name = uniformNames[idx];
                blockSpec.uniforms[name][pi] = +value;
            });
        });
        for (var i = 0; i < uniformNames.length; i++) {
            var uniform = blockSpec.uniforms[uniformNames[i]];
            var nextUniform = blockSpec.uniforms[uniformNames[i + 1]];
            var size = nextUniform ? nextUniform[1] : blockSpec.size;
            uniform[8] = size - uniform[1];
        }
        blockSpec.id = getUboHash(blockSpec) + '';
    };
    for (var idx = 0; idx < uniformBlocks; ++idx) {
        _loop_1(idx);
    }
    return { blockSpecs: blockSpecs, blockUniformNames: blockUniformNames };
}
function getUboHash(spec) {
    var name = spec.name, size = spec.size, uniforms = spec.uniforms, uniformIndices = spec.uniformIndices;
    Object.keys(uniforms)
        .map(function (name) { return "".concat(name, "[").concat(uniforms[name].join(':'), "]"); })
        .join('+');
    return stringHash("".concat(name, "+"), "".concat(size, "+"), "".concat(uniformIndices.length, "+"));
}

var GLProgram = /** @class */ (function () {
    function GLProgram(engine, program, shared, id) {
        var _this = this;
        this.engine = engine;
        this.program = program;
        this.shared = shared;
        this.id = id;
        this.uniformBlockMap = {};
        this.pipelineContext = engine.getGLPipelineContext();
        var gl = this.pipelineContext.gl;
        this.pipelineContext.useProgram(program);
        this.attribInfoMap = this.createAttribMap();
        if (isWebGL2(gl)) {
            var _a = createUniformBlockDataFromProgram(gl, program), blockSpecs = _a.blockSpecs; _a.blockUniformNames;
            blockSpecs.forEach(function (b) { return _this.uniformBlockMap[b.name] = b; });
        }
        this.pipelineContext.useProgram(null);
        //gl.activeTexture(gl.TEXTURE0);
        //pipelineContext.activeTexture(gl.TEXTURE0);
        //emptyTexture2D.bind();
        //this.uniformInfoMap = uniformMap;
    }
    GLProgram.prototype.bind = function () {
        this.pipelineContext.useProgram(this.program);
    };
    /**
     * 绑定 vao 对象并设置顶点属性
     * 如果当前环境不支持 vao，则使用 gl 函数依次设置属性。
     * @param geometry
     * @returns
     */
    GLProgram.prototype.setupAttributes = function (geometry) {
        var _this = this;
        var _a;
        var programId = this.id;
        var gl = this.pipelineContext.gl;
        var vao;
        if (geometry.vaos[programId]) {
            vao = geometry.vaos[programId];
        }
        else {
            vao = new GLVertexArrayObject(this.engine, "".concat(geometry.name, "-").concat(programId));
            if (!vao) {
                console.error('创建vao对象失败');
            }
            geometry.vaos[programId] = vao;
        }
        // 兼容小程序下不支持vao
        if (vao && vao.vao) {
            vao.bind();
            if (vao.ready) {
                return vao;
            }
        }
        Object.keys(this.attribInfoMap).forEach(function (name) {
            var attrInfo = _this.attribInfoMap[name];
            var attribute = geometry.attributes[name];
            if (attribute) {
                var buffer = geometry.buffers[attribute.dataSource];
                if (!buffer) {
                    throw Error("no buffer named ".concat(attribute.dataSource || name));
                }
                buffer.bind();
                gl.enableVertexAttribArray(attrInfo.loc);
                gl.vertexAttribPointer(attrInfo.loc, attribute.size, attribute.type, attribute.normalize, attribute.stride || 0, attribute.offset || 0);
            }
        });
        (_a = geometry.indicesBuffer) === null || _a === void 0 ? void 0 : _a.bind();
        if (vao) {
            vao.ready = true;
        }
        return vao;
    };
    GLProgram.prototype.createAttribMap = function () {
        var gl = this.pipelineContext.gl;
        var program = this.program;
        var attribMap = {};
        var num = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < num; i++) {
            var _a = gl.getActiveAttrib(program, i), name_1 = _a.name, type = _a.type, size = _a.size;
            var loc = gl.getAttribLocation(program, name_1);
            attribMap[name_1] = {
                type: type,
                name: name_1,
                size: size,
                loc: loc,
            };
        }
        return attribMap;
    };
    GLProgram.prototype.dispose = function () {
        if (this.pipelineContext) {
            this.pipelineContext.gl.deleteProgram(this.program);
            // @ts-expect-error safe to assign
            this.pipelineContext = null;
        }
    };
    return GLProgram;
}());

var GLShader = /** @class */ (function (_super) {
    __extends(GLShader, _super);
    function GLShader(source) {
        var _this = _super.call(this, source) || this;
        _this.initialized = false;
        _this.uniformLocations = {};
        _this.samplerChannels = {};
        return _this;
    }
    // shader 的 GPU 资源初始化方法，在绘制前调用
    GLShader.prototype.initialize = function (engine) {
        if (this.initialized) {
            return;
        }
        // 核心初始化都在 compileShader
        // 否则会出现编译了却没有初始化的情况
        var pipelineContext = engine.getGLPipelineContext();
        pipelineContext.shaderLibrary.compileShader(this);
    };
    GLShader.prototype.setFloat = function (name, value) {
        this.pipelineContext.setFloat(this.uniformLocations[name], value);
    };
    GLShader.prototype.setInt = function (name, value) {
        this.pipelineContext.setInt(this.uniformLocations[name], value);
    };
    GLShader.prototype.setFloats = function (name, value) {
        this.pipelineContext.setFloats(this.uniformLocations[name], value);
    };
    GLShader.prototype.setTexture = function (name, texture) {
        this.pipelineContext.setTexture(this.uniformLocations[name], this.samplerChannels[name], texture);
    };
    GLShader.prototype.setVector2 = function (name, value) {
        this.pipelineContext.setVector2(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector3 = function (name, value) {
        this.pipelineContext.setVector3(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector4 = function (name, value) {
        this.pipelineContext.setVector4(this.uniformLocations[name], value);
    };
    GLShader.prototype.setQuaternion = function (name, value) {
        this.pipelineContext.setQuaternion(this.uniformLocations[name], value);
    };
    GLShader.prototype.setMatrix = function (name, value) {
        this.pipelineContext.setMatrix(this.uniformLocations[name], value);
    };
    GLShader.prototype.setMatrix3 = function (name, value) {
        this.pipelineContext.setMatrix3(this.uniformLocations[name], value);
    };
    GLShader.prototype.setVector4Array = function (name, array) {
        this.pipelineContext.setVector4Array(this.uniformLocations[name], array);
    };
    GLShader.prototype.setMatrixArray = function (name, array) {
        this.pipelineContext.setMatrixArray(this.uniformLocations[name], array);
    };
    GLShader.prototype.fillShaderInformation = function (uniformNames, samplers) {
        // 避免修改原数组。
        var samplerList = samplers.slice();
        uniformNames = uniformNames.concat(samplerList);
        var avaliableUniforms = this.pipelineContext.getUniforms(this.program.program, uniformNames);
        for (var i = 0; i < uniformNames.length; i++) {
            this.uniformLocations[uniformNames[i]] = avaliableUniforms[i];
        }
        var index;
        for (index = 0; index < samplerList.length; index++) {
            var sampler = this.uniformLocations[(samplerList[index])];
            if (sampler == null) {
                samplerList.splice(index, 1);
                index--;
            }
        }
        for (index = 0; index < samplerList.length; index++) {
            var samplerName = samplerList[index];
            this.samplerChannels[samplerName] = index;
        }
    };
    GLShader.prototype.dispose = function () {
        var _a;
        if (this.compileResult && this.compileResult.shared) {
            return;
        }
        (_a = this.program) === null || _a === void 0 ? void 0 : _a.dispose();
    };
    return GLShader;
}(Shader));

var shaderSeed = 0;
var GLShaderLibrary = /** @class */ (function () {
    function GLShaderLibrary(engine, pipelineContext) {
        this.engine = engine;
        this.pipelineContext = pipelineContext;
        this.shaderResults = {};
        this.programMap = {};
        this.glVertShaderMap = new Map();
        this.glFragShaderMap = new Map();
        this.shaderAllDone = false;
        this.cachedShaders = {};
        this.glAsyncCompileExt = engine.gpuCapability.glAsyncCompileExt;
    }
    GLShaderLibrary.prototype.compileAllShaders = function (asyncCallback) {
        var e_1, _a;
        var _this = this;
        if (!this.shaderAllDone) {
            var pendings = [];
            try {
                for (var _b = __values$1(Object.keys(this.cachedShaders)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (!this.cachedShaders[key].initialized) {
                        pendings.push(key);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (asyncCallback) {
                if (pendings.length) {
                    Promise.all(pendings.map(function (key) { return new Promise(function (resolve) { return _this.compileShader(_this.cachedShaders[key], resolve); }); }))
                        .then(asyncCallback)
                        .catch(function () { return 0; });
                }
                else {
                    asyncCallback([]);
                }
            }
            else {
                pendings.map(function (key) { return _this.compileShader(_this.cachedShaders[key]); });
            }
            this.shaderAllDone = true;
        }
        else if (asyncCallback) {
            asyncCallback([]);
        }
    };
    // TODO 创建shader的ShaderWithSource和shader的source类型一样，待优化。
    GLShaderLibrary.prototype.addShader = function (shaderSource) {
        var shaderCacheId = this.computeShaderCacheId(shaderSource);
        if (this.cachedShaders[shaderCacheId]) {
            return shaderCacheId;
        }
        this.shaderAllDone = false;
        var header = shaderSource.glslVersion === exports.GLSLVersion.GLSL3 ? '#version 300 es\n' : '';
        var vertex = shaderSource.vertex ? header + shaderSource.vertex : '';
        var fragment = shaderSource.fragment ? header + shaderSource.fragment : '';
        var shared = false;
        if (shaderSource.shared || shaderSource.cacheId) {
            shared = true;
        }
        this.cachedShaders[shaderCacheId] = new GLShader({
            vertex: vertex,
            fragment: fragment,
            name: shaderSource.name || shaderCacheId,
            shared: shared,
        });
        this.cachedShaders[shaderCacheId].id = shaderCacheId;
        return shaderCacheId;
    };
    GLShaderLibrary.prototype.createShader = function (shaderSource) {
        var shaderCacheId = this.addShader(shaderSource);
        return this.cachedShaders[shaderCacheId];
    };
    GLShaderLibrary.prototype.compileShader = function (shader, asyncCallback) {
        var _this = this;
        var shaderSource = shader.source;
        var shared = false;
        if (shaderSource.shared || shaderSource.cacheId) {
            shared = true;
        }
        var shaderData = {
            vertex: shaderSource.vertex,
            fragment: shaderSource.fragment,
            name: shaderSource.name,
            shared: shared,
        };
        var gl = this.pipelineContext.gl;
        var result = { shared: shaderData.shared, status: exports.ShaderCompileResultStatus.compiling };
        var linkProgram = this.createProgram(gl, shaderData.vertex, shaderData.fragment, result);
        var ext = this.glAsyncCompileExt;
        var startTime = alipay.performance.now();
        var setupProgram = function (glProgram) {
            result.status = exports.ShaderCompileResultStatus.success;
            result.compileTime = alipay.performance.now() - startTime;
            shader.program = glProgram;
            shader.initialized = true;
            shader.pipelineContext = _this.pipelineContext;
            if (_this.programMap[shader.id] !== undefined) {
                console.warn('find duplicated shader id', shader.id);
            }
            _this.programMap[shader.id] = glProgram;
        };
        var checkComplete = function () {
            var shouldLink = !asyncCallback || !ext || (ext && gl.getProgramParameter(result.program, ext.COMPLETION_STATUS_KHR) == true);
            var program = shouldLink && linkProgram();
            if (program) {
                if (result.status !== exports.ShaderCompileResultStatus.fail) {
                    assignInspectorName(program, shaderData.name);
                    var glProgram = new GLProgram(_this.engine, program, shared, shader.id);
                    // FIXME: 这个检测不能在这里调用，安卓上会有兼容性问题。要么开发版使用，要么移到Shader首次使用时
                    gl.validateProgram(program);
                    var valid = gl.getProgramParameter(program, gl.VALIDATE_STATUS);
                    if (!valid) {
                        var error = gl.getProgramInfoLog(program);
                        var err0 = 'the same texture';
                        if (error === null || error === void 0 ? void 0 : error.includes(err0)) {
                            // 忽略这类错误
                            setupProgram(glProgram);
                        }
                        else {
                            result.status = exports.ShaderCompileResultStatus.fail;
                            result.error = error;
                            console.error('compileProgramError: ' + error, '\nvertex:\n', shaderData.vertex, '\nfragment:\n', shaderData.fragment);
                            gl.deleteProgram(program);
                        }
                    }
                    else {
                        setupProgram(glProgram);
                    }
                }
                if (asyncCallback) {
                    asyncCallback(result);
                }
            }
            else if (asyncCallback) {
                alipay.requestAnimationFrame(checkComplete);
            }
        };
        shader.compileResult = result;
        checkComplete();
    };
    GLShaderLibrary.prototype.computeShaderCacheId = function (shader) {
        var vertex = shader.vertex ? shader.vertex : '';
        var fragment = shader.fragment ? shader.fragment : '';
        var shaderCacheId;
        if (shader.shared || shader.cacheId) {
            // FIXME: string-hash有冲突，这里先用strHashCode替代
            shaderCacheId = shader.cacheId || "shared_".concat(strHashCode(vertex, fragment));
        }
        else {
            shaderCacheId = 'instanced_' + shaderSeed++;
        }
        return shaderCacheId;
    };
    GLShaderLibrary.prototype.createProgram = function (gl, vs, fs, result) {
        var program = gl.createProgram();
        var vertexShader = this.createGLShader(gl, gl.VERTEX_SHADER, vs);
        var fragShader = this.createGLShader(gl, gl.FRAGMENT_SHADER, fs);
        if (program && vertexShader && fragShader) {
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            result.program = program;
            result.status = exports.ShaderCompileResultStatus.compiling;
            return function () {
                delete result.program;
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                    var vsCheckResult = checkShader(gl, vertexShader, 'vertex', vs);
                    var fsCheckResult = checkShader(gl, fragShader, 'fragment', fs);
                    result.status = exports.ShaderCompileResultStatus.fail;
                    if (vsCheckResult) {
                        result.error = vsCheckResult.error;
                        result.status = vsCheckResult.status;
                    }
                    if (fsCheckResult) {
                        result.error = fsCheckResult.error;
                        result.status = fsCheckResult.status;
                    }
                    return program;
                }
                return program;
            };
        }
        result.status = exports.ShaderCompileResultStatus.fail;
        return function () { return null; };
    };
    GLShaderLibrary.prototype.createGLShader = function (gl, shaderType, code) {
        var map = shaderType === gl.VERTEX_SHADER ? this.glVertShaderMap : this.glFragShaderMap;
        var strHash = stringHash(code !== null && code !== void 0 ? code : '');
        var ret = map.get(strHash);
        if (ret) {
            return ret;
        }
        var shader = gl.createShader(shaderType);
        if (shader) {
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            map.set(strHash, shader);
        }
        return shader;
    };
    GLShaderLibrary.prototype.deleteShader = function (cacheId) {
        var program = this.programMap[cacheId];
        if (program !== undefined) {
            program.dispose();
            delete this.programMap[cacheId];
        }
        var result = this.shaderResults[cacheId];
        if (result !== undefined) {
            delete this.shaderResults[cacheId];
        }
    };
    GLShaderLibrary.prototype.restore = function () {
        // TODO
    };
    GLShaderLibrary.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.programMap).forEach(function (key) {
            var program = _this.programMap[key];
            program.dispose();
        });
        this.programMap = {};
        if (this.pipelineContext) {
            var gl_1 = this.pipelineContext.gl;
            this.glFragShaderMap.forEach(function (shader) {
                gl_1.deleteShader(shader);
            });
            this.glVertShaderMap.forEach(function (shader) {
                gl_1.deleteShader(shader);
            });
            this.glVertShaderMap = new Map();
            this.glFragShaderMap = new Map();
        }
    };
    return GLShaderLibrary;
}());
function checkShader(gl, shader, type, code) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var error = gl.getShaderInfoLog(shader);
        console.error('compile ' + type + ' error: ' + error, (code !== null && code !== void 0 ? code : '')
            .split('\n')
            .map(function (line, index) { return "".concat(index + 1, " ").concat(line); })
            .join('\n'));
        return { error: error, status: exports.ShaderCompileResultStatus.fail };
    }
}
function strHashCode() {
    var strings = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        strings[_i] = arguments[_i];
    }
    var h = 0;
    for (var j = 0; j < arguments.length; j++) {
        var s = strings[j];
        for (var i = 0; i < s.length; i++) {
            h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
        }
    }
    return h;
}

var GLPipelineContext = /** @class */ (function () {
    function GLPipelineContext(engine, gl) {
        this.engine = engine;
        this.gl = gl;
        this.gl = gl;
        this.shaderLibrary = new GLShaderLibrary(engine, this);
        this.maxTextureCount = this.gl.TEXTURE0 + this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS) - 1;
        this.reset();
    }
    GLPipelineContext.prototype.dispose = function () {
        this.shaderLibrary.dispose();
        this.reset();
    };
    GLPipelineContext.prototype.reset = function () {
        this.glCapabilityCache = {};
        this.activeTextureIndex = glContext.TEXTURE0;
        this.textureUnitDict = {};
        this.currentFramebuffer = {};
        this.pixelStorei = {};
        this.currentRenderBuffer = {};
    };
    GLPipelineContext.prototype.toggle = function (capability, enable) {
        if (enable) {
            this.enable(capability);
        }
        else {
            this.disable(capability);
        }
    };
    /**
     * 对于该上下文开启某种特性
     * @param capability
     * example:
     * gl.enable(gl.DITHER);
     */
    GLPipelineContext.prototype.enable = function (capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== true) {
            this.glCapabilityCache[capability] = true;
            this.gl.enable(capability);
        }
    };
    /**
     * 基于某种上下文关闭特性
     * @param capability
     * example:
     * gl.disable(gl.DITHER);
     */
    GLPipelineContext.prototype.disable = function (capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== false) {
            this.glCapabilityCache[capability] = false;
            this.gl.disable(capability);
        }
    };
    /**
     * 绑定framebuffer webgl2新增: gl.DRAW_FRAMEBUFFER 和 gl.READ_FRAMEBUFFER
     * @param target
     * @param framebuffer
     * example:
     * const framebuffer = gl.createFramebuffer();
     * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
     */
    GLPipelineContext.prototype.bindFramebuffer = function (target, framebuffer) {
        if (this.currentFramebuffer[target] !== framebuffer) {
            this.currentFramebuffer[target] = framebuffer;
            this.gl.bindFramebuffer(target, framebuffer);
        }
    };
    GLPipelineContext.prototype.bindRenderBuffer = function (target, renderBuffer) {
        if (this.currentRenderBuffer[target] !== renderBuffer) {
            this.currentRenderBuffer[target] = renderBuffer;
            this.gl.bindRenderbuffer(target, renderBuffer);
        }
    };
    /**
     * 绑定系统 framebuffer
     */
    GLPipelineContext.prototype.bindSystemFramebuffer = function () {
        this.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    };
    /**
     * 将定义好的 WebGLProgram 对象添加到当前的渲染状态中。
     * @param program
     * example:
     * gl.useProgram(program);
     * gl.useProgram(null);
     */
    GLPipelineContext.prototype.useProgram = function (program) {
        this.set1('useProgram', program);
    };
    /**
     * 使用预设值来清空缓冲
     * @param mask
     * example:
     * gl.clear(gl.DEPTH_BUFFER_BIT);
     * gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
     */
    GLPipelineContext.prototype.clear = function (mask) {
        this.gl.clear(mask);
    };
    /*** depth start ***/
    /**
     * 设置深度缓冲区的深度清除值
     * @param depth
     * example:
     * gl.clearDepth(0.5);
     */
    GLPipelineContext.prototype.clearDepth = function (depth) {
        this.set1('clearDepth', depth);
    };
    /**
     * 指定将输入像素深度与当前深度缓冲区值进行比较的函数。
     * @param func
     * example:
     * gl.enable(gl.DEPTH_TEST);
     * gl.depthFunc(gl.NEVER);
     */
    GLPipelineContext.prototype.depthFunc = function (func) {
        this.set1('depthFunc', func);
    };
    /**
     * 设置是否启用写入深度缓冲。
     * @param flag
     * example:
     * gl.depthMask(false);
     */
    GLPipelineContext.prototype.depthMask = function (flag) {
        this.set1('depthMask', flag);
    };
    GLPipelineContext.prototype.polygonOffset = function (factor, unit) {
        this.set2('polygonOffset', factor, unit);
    };
    /**
     * 将 z 值从规范化设备坐标映射到窗口坐标
     * @param zNear
     * @param zFar
     * example:
     * gl.depthRange(0.2, 0.6);
     */
    GLPipelineContext.prototype.depthRange = function (zNear, zFar) {
        this.set2('depthRange', zNear, zFar);
    };
    /*** depth end ***/
    /*** stencil start ***/
    /**
     * 模版测试设置函数和引用值。
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFunc(gl.LESS, 0, 0b1110011);
     */
    GLPipelineContext.prototype.clearStencil = function (s) {
        this.set1('clearStencil', s);
    };
    /**
     * 控制启用和禁用模板平面中单个位的正面和背面写入
     * @param mask
     * example:
     * gl.stencilMask(0xff);
     */
    GLPipelineContext.prototype.stencilMask = function (mask) {
        this.stencilMaskSeparate(this.gl.FRONT, mask);
        this.stencilMaskSeparate(this.gl.BACK, mask);
    };
    /**
     * 模版测试设置函数和引用值。
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFunc(gl.LESS, 0, 0b1110011);
     */
    GLPipelineContext.prototype.stencilFunc = function (func, ref, mask) {
        this.stencilFuncSeparate(this.gl.FRONT, func, ref, mask);
        this.stencilFuncSeparate(this.gl.BACK, func, ref, mask);
    };
    /**
     * 单面模版测试
     * @param face
     * @param func
     * @param ref
     * @param mask
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilFuncSeparate(gl.FRONT, gl.LESS, 0.2, 1110011);
     */
    GLPipelineContext.prototype.stencilFuncSeparate = function (face, func, ref, mask) {
        this.set4('stencilFuncSeparate', face, func, ref, mask);
    };
    /**
     * 单面的mask写入
     * @param face
     * @param mask
     * example:
     * gl.stencilMaskSeparate(gl.FRONT, 110101);
     */
    GLPipelineContext.prototype.stencilMaskSeparate = function (face, mask) {
        this.set2('stencilMaskSeparate', face, mask);
    };
    /**
     * 设置正面和背面模板测试操作
     * @param fail
     * @param zfail
     * @param zpass
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilOp(gl.INCR, gl.DECR, gl.INVERT);
     */
    GLPipelineContext.prototype.stencilOp = function (fail, zfail, zpass) {
        this.stencilOpSeparate(this.gl.FRONT, fail, zfail, zpass);
        this.stencilOpSeparate(this.gl.BACK, fail, zfail, zpass);
    };
    /**
     * 设置正面和/或背面模板测试操作
     * @param face
     * @param fail
     * @param zfail
     * @param zpass
     * example:
     * gl.enable(gl.STENCIL_TEST);
     * gl.stencilOpSeparate(gl.FRONT, gl.INCR, gl.DECR, gl.INVERT);
     */
    GLPipelineContext.prototype.stencilOpSeparate = function (face, fail, zfail, zpass) {
        this.set4('stencilOpSeparate', face, fail, zfail, zpass);
    };
    /*** stencil end ***/
    /*** face start ***/
    /**
     * 剔除方式
     * @param mode
     * example:
     * gl.enable(gl.CULL_FACE);
     * gl.cullFace(gl.FRONT_AND_BACK);
     */
    GLPipelineContext.prototype.cullFace = function (mode) {
        this.set1('cullFace', mode);
    };
    /**
     * 设置卷绕方向
     * @param mode
     * example:
     * gl.frontFace(gl.CW);
     */
    GLPipelineContext.prototype.frontFace = function (mode) {
        this.set1('frontFace', mode);
    };
    /*** face end ***/
    /*** color start ***/
    /**
     * 设置颜色写入
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.colorMask(true, true, true, false);
     */
    GLPipelineContext.prototype.clearColor = function (red, green, blue, alpha) {
        this.set4('clearColor', red, green, blue, alpha);
    };
    /**
     * 设置颜色写入
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.colorMask(true, true, true, false);
     */
    GLPipelineContext.prototype.colorMask = function (red, green, blue, alpha) {
        this.set4('colorMask', red, green, blue, alpha);
    };
    /**
     * 设置源和目标混合因子
     * @param red
     * @param green
     * @param blue
     * @param alpha
     * example:
     * gl.blendColor(0, 0.5, 1, 1);
     */
    GLPipelineContext.prototype.blendColor = function (red, green, blue, alpha) {
        this.set4('blendColor', red, green, blue, alpha);
    };
    /**
     * 用于混合像素算法
     * @param sfactor
     * @param dfactor
     * example:
     * gl.enable(gl.BLEND);
     * gl.blendFunc(gl.SRC_COLOR, gl.DST_COLOR);
     */
    GLPipelineContext.prototype.blendFunc = function (sfactor, dfactor) {
        this.blendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
    };
    /**
     * 分别设置应用在 RGB 和 Alpha 上的 factor
     * @param srcRGB
     * @param dstRGB
     * @param srcAlpha
     * @param dstAlpha
     * example:
     * gl.enable(gl.BLEND);
     * gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);
     */
    GLPipelineContext.prototype.blendFuncSeparate = function (srcRGB, dstRGB, srcAlpha, dstAlpha) {
        this.set4('blendFuncSeparate', srcRGB, dstRGB, srcAlpha, dstAlpha);
    };
    /**
     * 设置混合模式
     * @param mode
     * example:
     * gl.blendEquation(gl.FUNC_ADD);
     * gl.blendEquation(gl.FUNC_SUBTRACT);
     * gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
     */
    GLPipelineContext.prototype.blendEquation = function (mode) {
        this.set1('blendEquation', mode);
    };
    /**
     * 可以分别对 RGB 和 Alpha 做不同的操作处理
     * @param modeRGB
     * @param modeAlpha
     * example:
     * gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_SUBTRACT);
     */
    GLPipelineContext.prototype.blendEquationSeparate = function (modeRGB, modeAlpha) {
        this.set2('blendEquationSeparate', modeRGB, modeAlpha);
    };
    /*** color end ***/
    /**
     * 图像预处理
     * @param pname
     * @param param
     * example:
     * var tex = gl.createTexture();
     * gl.bindTexture(gl.TEXTURE_2D, tex);
     * gl.pixelStorei(gl.PACK_ALIGNMENT, 4);
     */
    GLPipelineContext.prototype.setPixelStorei = function (pname, param) {
        var currentParam = this.pixelStorei[pname];
        if (currentParam !== param) {
            this.pixelStorei[pname] = param;
            this.gl.pixelStorei(pname, param);
        }
    };
    /**
     * 用来设置视口，即指定从标准设备到窗口坐标的x、y仿射变换。
     * @param x
     * @param y
     * @param width
     * @param height
     * example:
     * gl.viewport(0, 0, width, height);
     */
    GLPipelineContext.prototype.viewport = function (x, y, width, height) {
        this.set4('viewport', x, y, width, height);
    };
    /**
     * 激活指定的纹理单元
     * @param texture
     * example:
     * gl.activeTexture(gl.TEXTURE1);
     */
    GLPipelineContext.prototype.activeTexture = function (texture) {
        texture = Math.min(texture, this.maxTextureCount);
        if (this.activeTextureIndex !== texture) {
            this.activeTextureIndex = texture;
            this.gl.activeTexture(texture);
        }
    };
    /**
     * 绑定WebGLTexture
     * @param target
     * @param texture
     * @param force
     * example:
     * const texture = gl.createTexture();
     * gl.bindTexture(gl.TEXTURE_2D, texture)
     */
    // TODO: texture.bind 替换时对于这段逻辑的处理
    GLPipelineContext.prototype.bindTexture = function (target, texture, force) {
        if (this.currentTextureBinding !== texture || force) {
            this.gl.bindTexture(target, texture);
            this.currentTextureBinding = texture;
        }
        this.textureUnitDict[this.activeTextureIndex] = texture;
    };
    GLPipelineContext.prototype.set1 = function (name, param) {
        var value = this.glCapabilityCache[name];
        if (value !== param) {
            this.glCapabilityCache[name] = param;
            // @ts-expect-error save to assign
            this.gl[name](param);
        }
    };
    GLPipelineContext.prototype.set2 = function (name, param0, param1) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = { x: NaN, y: NaN };
        }
        if (value.x !== param0 || value.y !== param1) {
            // @ts-expect-error save to assign
            this.gl[name](value.x = param0, value.y = param1);
        }
    };
    GLPipelineContext.prototype.set3 = function (name, param0, param1, param2) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = { x: NaN, y: NaN, z: NaN };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2);
        }
    };
    GLPipelineContext.prototype.set4 = function (name, param0, param1, param2, param3) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = {
                x: NaN, y: NaN, z: NaN, w: NaN,
            };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2 || value.w !== param3) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2, value.w = param3);
        }
    };
    // TODO 命名
    GLPipelineContext.prototype.get = function (name) {
        return this.glCapabilityCache[name];
    };
    GLPipelineContext.prototype.setFloat = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1f(uniform, value);
    };
    GLPipelineContext.prototype.setInt = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1i(uniform, value);
    };
    GLPipelineContext.prototype.setFloats = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1fv(uniform, value);
    };
    GLPipelineContext.prototype.setVector2 = function (uniform, value) {
        this.setFloat2(uniform, value.x, value.y);
    };
    GLPipelineContext.prototype.setVector3 = function (uniform, value) {
        this.setFloat3(uniform, value.x, value.y, value.z);
    };
    GLPipelineContext.prototype.setVector4 = function (uniform, value) {
        this.setFloat4(uniform, value.x, value.y, value.z, value.w);
    };
    GLPipelineContext.prototype.setQuaternion = function (uniform, value) {
        this.setFloat4(uniform, value.x, value.y, value.z, value.w);
    };
    GLPipelineContext.prototype.setVector4Array = function (uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return;
        }
        this.gl.uniform4fv(uniform, array);
    };
    GLPipelineContext.prototype.setMatrix = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, value.elements);
    };
    GLPipelineContext.prototype.setMatrix3 = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniformMatrix3fv(uniform, false, value.elements);
    };
    GLPipelineContext.prototype.setMatrixArray = function (uniform, array) {
        if (!uniform || array.length % 16 !== 0) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, array);
    };
    GLPipelineContext.prototype.setTexture = function (uniform, channel, texture) {
        if (!uniform) {
            return;
        }
        this.gl.activeTexture(this.gl.TEXTURE0 + channel);
        var target = texture.target;
        this.gl.bindTexture(target, texture.textureBuffer);
        this.gl.uniform1i(uniform, channel);
    };
    /**
     * 查询所有uniform的location。
     * @param program 查询的shader program
     * @param uniformsNames 查询的uniform名称列表
     * @returns
     */
    GLPipelineContext.prototype.getUniforms = function (program, uniformsNames) {
        var results = [];
        for (var index = 0; index < uniformsNames.length; index++) {
            results.push(this.gl.getUniformLocation(program, uniformsNames[index]));
        }
        return results;
    };
    GLPipelineContext.prototype.setFloat4 = function (uniform, x, y, z, w) {
        if (!uniform) {
            return;
        }
        this.gl.uniform4f(uniform, x, y, z, w);
    };
    GLPipelineContext.prototype.setFloat3 = function (uniform, x, y, z) {
        if (!uniform) {
            return;
        }
        this.gl.uniform3f(uniform, x, y, z);
    };
    GLPipelineContext.prototype.setFloat2 = function (uniform, x, y) {
        if (!uniform) {
            return;
        }
        this.gl.uniform2f(uniform, x, y);
    };
    return GLPipelineContext;
}());

var GLRenderer = /** @class */ (function (_super) {
    __extends(GLRenderer, _super);
    function GLRenderer(canvas, framework, renderOptions) {
        var _this = _super.call(this) || this;
        _this.canvas = canvas;
        _this.temporaryRTs = {};
        var options = __assign$1({ preserveDrawingBuffer: undefined, alpha: true, stencil: true, antialias: true, depth: true, premultipliedAlpha: true }, renderOptions);
        _this.context = new GLContextManager(canvas, framework, options);
        var gl = _this.context.gl;
        assertExist(gl);
        // engine 先创建
        _this.engine = new GLEngine(gl);
        _this.engine.renderer = _this;
        _this.pipelineContext = new GLPipelineContext(_this.engine, gl);
        _this.glRenderer = new GLRendererInternal(_this.engine);
        _this.extension = new ExtWrap(_this);
        _this.renderingData = {
            //@ts-expect-error
            currentFrame: {},
        };
        _this.frameBuffer = new GLFrameBuffer({
            storeAction: {},
            viewport: [0, 0, _this.width, _this.height],
            attachments: [new GLTexture(_this.engine, {
                    sourceType: exports.TextureSourceType.framebuffer,
                    data: { width: _this.width, height: _this.height },
                })],
            depthStencilAttachment: { storageType: exports.RenderPassAttachmentStorageType.none },
        }, _this);
        return _this;
    }
    Object.defineProperty(GLRenderer.prototype, "isDestroyed", {
        get: function () {
            var internal = this.glRenderer;
            return internal ? internal.isDestroyed : true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRenderer.prototype, "height", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GLRenderer.prototype, "width", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0;
        },
        enumerable: false,
        configurable: true
    });
    GLRenderer.prototype.renderRenderFrame = function (renderFrame) {
        var e_1, _a, e_2, _b;
        var _c, _d;
        var frame = renderFrame;
        // TODO 需要一个贴图统一初始化的管理类，避免在渲染逻辑代码中初始化。
        // 初始化renderframe的贴图资源
        // if (frame.cachedTextures) {
        //   for (const texture of frame.cachedTextures) {
        //     (texture as GLTexture).initialize(this.pipelineContext);
        //   }
        // }
        if (frame.resource) {
            frame.resource.color_b.initialize();
        }
        frame.emptyTexture.initialize();
        frame.transparentTexture.initialize();
        var passes = frame._renderPasses;
        if (this.isDestroyed) {
            return console.error('renderer is destroyed', this);
        }
        frame.renderer.getShaderLibrary().compileAllShaders();
        this.setFrameBuffer(null);
        this.clear(frame.clearAction);
        this.renderingData.currentFrame = frame;
        this.renderingData.currentCamera = frame.camera;
        // 根据 priority 排序 pass
        sortByOrder(passes);
        try {
            for (var passes_1 = __values$1(passes), passes_1_1 = passes_1.next(); !passes_1_1.done; passes_1_1 = passes_1.next()) {
                var pass = passes_1_1.value;
                var delegate = pass.delegate;
                (_c = delegate.willBeginRenderPass) === null || _c === void 0 ? void 0 : _c.call(delegate, pass, this.renderingData);
                this.renderRenderPass(pass);
                (_d = delegate.didEndRenderPass) === null || _d === void 0 ? void 0 : _d.call(delegate, pass, this.renderingData);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (passes_1_1 && !passes_1_1.done && (_a = passes_1.return)) _a.call(passes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var passes_2 = __values$1(passes), passes_2_1 = passes_2.next(); !passes_2_1.done; passes_2_1 = passes_2.next()) {
                var pass = passes_2_1.value;
                pass.frameCleanup(this);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (passes_2_1 && !passes_2_1.done && (_b = passes_2.return)) _b.call(passes_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    GLRenderer.prototype.renderRenderPass = function (pass) {
        this.renderingData.currentPass = pass;
        // 初始化 pass attachment GPU资源
        pass.initialize(this);
        // 配置当前 renderer 的 RT
        pass.configure(this);
        // 执行当前 pass
        pass.execute(this);
    };
    GLRenderer.prototype.renderMeshes = function (meshes) {
        var e_3, _a;
        var _b, _c;
        var delegate = this.renderingData.currentPass.delegate;
        try {
            for (var meshes_1 = __values$1(meshes), meshes_1_1 = meshes_1.next(); !meshes_1_1.done; meshes_1_1 = meshes_1.next()) {
                var mesh = meshes_1_1.value;
                if (mesh.isDestroyed) {
                    // console.error(`mesh ${mesh.name} destroyed`, mesh);
                    continue;
                }
                if (!mesh.getVisible()) {
                    continue;
                }
                if (!mesh.material) {
                    console.warn('Mesh ' + mesh.name + ' 没有绑定材质。');
                    continue;
                }
                mesh.material.initialize();
                mesh.geometry.initialize();
                (_b = delegate.willRenderMesh) === null || _b === void 0 ? void 0 : _b.call(delegate, mesh, this.renderingData);
                mesh.render(this);
                (_c = delegate.didRenderMesh) === null || _c === void 0 ? void 0 : _c.call(delegate, mesh, this.renderingData);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (meshes_1_1 && !meshes_1_1.done && (_a = meshes_1.return)) _a.call(meshes_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    GLRenderer.prototype.setGlobalFloat = function (name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.floats[name] = value;
    };
    GLRenderer.prototype.setGlobalInt = function (name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.ints[name] = value;
    };
    GLRenderer.prototype.setGlobalMatrix = function (name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.matrices[name] = value;
    };
    GLRenderer.prototype.drawGeometry = function (geometry, material) {
        this.glRenderer.drawGeometry(geometry, material);
    };
    GLRenderer.prototype.setFrameBuffer = function (frameBuffer) {
        if (frameBuffer) {
            this.frameBuffer = frameBuffer;
            this.frameBuffer.bind();
            this.setViewport(frameBuffer.viewport[0], frameBuffer.viewport[1], frameBuffer.viewport[2], frameBuffer.viewport[3]);
        }
        else {
            //this.frameBuffer = null;
            this.pipelineContext.bindSystemFramebuffer();
            this.setViewport(0, 0, this.getWidth(), this.getHeight());
        }
    };
    GLRenderer.prototype.getFrameBuffer = function () {
        return this.frameBuffer;
    };
    GLRenderer.prototype.getTemporaryRT = function (name, width, height, depthBuffer, filter, format) {
        if (this.temporaryRTs[name]) {
            return this.temporaryRTs[name];
        }
        var textureFilter;
        var textureType;
        var depthType = exports.RenderPassAttachmentStorageType.none;
        // TODO 建立Map映射
        if (filter === exports.FilterMode.Linear) {
            textureFilter = glContext.LINEAR;
        }
        else if (filter === exports.FilterMode.Nearest) {
            textureFilter = glContext.NEAREST;
        }
        if (format === exports.RenderTextureFormat.RGBA32) {
            textureType = glContext.UNSIGNED_BYTE;
        }
        else if (format === exports.RenderTextureFormat.RGBAHalf) {
            textureType = glContext.HALF_FLOAT;
        }
        if (depthBuffer === 0) {
            depthType = exports.RenderPassAttachmentStorageType.none;
        }
        else if (depthBuffer === 16) {
            depthType = exports.RenderPassAttachmentStorageType.depth_16_opaque;
        }
        else if (depthBuffer === 24) {
            depthType = exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture;
        }
        var colorAttachment = new GLTexture(this.engine, {
            sourceType: exports.TextureSourceType.framebuffer,
            minFilter: textureFilter,
            magFilter: textureFilter,
            internalFormat: glContext.RGBA,
            format: glContext.RGBA,
            type: textureType,
        });
        var newFrameBuffer = new GLFrameBuffer({
            name: name,
            storeAction: {},
            viewport: [0, 0, width, height],
            viewportScale: 1,
            isCustomViewport: true,
            attachments: [colorAttachment],
            depthStencilAttachment: { storageType: depthType },
        }, this);
        this.temporaryRTs[name] = newFrameBuffer;
        return newFrameBuffer;
    };
    GLRenderer.prototype.setViewport = function (x, y, width, height) {
        this.pipelineContext.viewport(x, y, width, height);
    };
    GLRenderer.prototype.clear = function (action) {
        var state = this.pipelineContext;
        var bit = 0;
        if (action.colorAction === exports.TextureLoadAction.clear) {
            var clearColor = action.clearColor;
            if (clearColor) {
                state.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            }
            state.colorMask(true, true, true, true);
            bit = glContext.COLOR_BUFFER_BIT;
        }
        if (action.stencilAction === exports.TextureLoadAction.clear) {
            state.stencilMask(0xff);
            state.clearStencil(action.clearStencil || 0);
            bit = bit | glContext.STENCIL_BUFFER_BIT;
        }
        if (action.depthAction === exports.TextureLoadAction.clear) {
            var depth = action.clearDepth;
            state.depthMask(true);
            state.clearDepth(Number.isFinite(depth) ? depth : 1);
            bit = bit | glContext.DEPTH_BUFFER_BIT;
        }
        if (bit) {
            state.clear(bit);
        }
    };
    GLRenderer.prototype.addLostHandler = function (lostHandler) {
        this.context.addLostHandler(lostHandler);
    };
    GLRenderer.prototype.addRestoreHandler = function (restoreHandler) {
        this.context.addRestoreHandler(restoreHandler);
    };
    GLRenderer.prototype.getShaderLibrary = function () {
        return this.pipelineContext.shaderLibrary;
    };
    GLRenderer.prototype.getWidth = function () {
        return this.width;
    };
    GLRenderer.prototype.getHeight = function () {
        return this.height;
    };
    GLRenderer.prototype.dispose = function () {
        var _a;
        this.context.dispose();
        this.extension.dispose();
        this.pipelineContext.dispose();
        (_a = this.glRenderer) === null || _a === void 0 ? void 0 : _a.dispose();
        // @ts-expect-error
        this.canvas = null;
        this.engine.dispose();
    };
    GLRenderer.prototype.lost = function (e) {
        e.preventDefault();
        this.pipelineContext.dispose();
        this.extension.dispose();
        this.glRenderer.lost(e);
    };
    GLRenderer.prototype.restore = function () {
        // FIXME: 需要测试下lost和restore流程
        var gl = this.context.gl;
        if (!gl) {
            throw new Error('Can not restore automatically because losing gl context');
        }
        this.engine = new GLEngine(gl);
        this.engine.renderer = this;
        this.pipelineContext = new GLPipelineContext(this.engine, gl);
        this.glRenderer = new GLRendererInternal(this.engine);
        this.extension = new ExtWrap(this);
    };
    GLRenderer.prototype.resize = function (width, height) {
        var internal = this.glRenderer;
        if (internal) {
            if (this.width !== width || this.height !== height) {
                internal.resize(width, height);
            }
        }
    };
    GLRenderer.prototype.checkGlobalUniform = function (name) {
        var globalUniforms = this.renderingData.currentFrame.globalUniforms;
        if (!globalUniforms.uniforms.includes(name)) {
            globalUniforms.uniforms.push(name);
        }
    };
    return GLRenderer;
}(Renderer));

var HELP_LINK = {
    'Container size overflowed': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'DPI overflowed': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'Invalid container size': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'Container is not an HTMLElement': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'Never use destroyed player again': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
    'Current running player count': 'https://galacean.antgroup.com/effects/#/user/gasrv4ka5sacrwpg',
};

function isDowngradeIOS() {
    var iOSVersionRegex = /iPhone OS (\d+)_(\d+)/;
    var match = iOSVersionRegex.exec(alipay.navigator.userAgent);
    if (match) {
        return match[1] === '13' || (match[1] === '16' && match[2] === '5');
    }
    return false;
}

var playerMap = new Map();
var enableDebugType = false;
var seed = 1;
/**
 * Galacean Effects 播放器
 */
var Player = /** @class */ (function () {
    /**
     * 播放器的构造函数
     * @param config
     */
    function Player(config) {
        var _this = this;
        var _a, _b;
        /**
         * 当前播放的合成对象数组，请不要修改内容
         */
        this.compositions = [];
        this.displayScale = 1;
        this.resumePending = false;
        this.disposed = false;
        this.assetManagers = [];
        this.speed = 1;
        this.baseCompositionIndex = 0;
        /**
         * 播放器在 `webglcontextlost` 时执行的操作
         * @param e - Event
         */
        this.lost = function (e) {
            var _a, _b;
            (_a = _this.ticker) === null || _a === void 0 ? void 0 : _a.pause();
            _this.compositions.forEach(function (comp) { return comp.lost(e); });
            _this.renderer.lost(e);
            (_b = _this.handleWebGLContextLost) === null || _b === void 0 ? void 0 : _b.call(_this, e);
            broadcastPlayerEvent(_this, false);
        };
        /**
         * 播放器在 `webglcontextrestored` 时执行的操作
         * @returns
         */
        this.restore = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            var _this = this;
            var _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this.renderer.restore();
                        _a = this;
                        return [4 /*yield*/, Promise.all(this.compositions.map(function (composition) { return __awaiter(_this, void 0, void 0, function () {
                                var currentTime, url, speed, keepResource, reusable, renderOrder, transform, videoState, newComposition, i, video;
                                var _a;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            currentTime = composition.time, url = composition.url, speed = composition.speed, keepResource = composition.keepResource, reusable = composition.reusable, renderOrder = composition.renderOrder, transform = composition.transform, videoState = composition.videoState;
                                            return [4 /*yield*/, this.loadScene(url)];
                                        case 1:
                                            newComposition = _b.sent();
                                            newComposition.speed = speed;
                                            newComposition.reusable = reusable;
                                            newComposition.keepResource = keepResource;
                                            newComposition.renderOrder = renderOrder;
                                            newComposition.transform = transform;
                                            i = 0;
                                            _b.label = 2;
                                        case 2:
                                            if (!(i < videoState.length)) return [3 /*break*/, 5];
                                            if (!videoState[i]) return [3 /*break*/, 4];
                                            video = newComposition.textures[i].source.video;
                                            video.currentTime = (_a = videoState[i]) !== null && _a !== void 0 ? _a : 0;
                                            return [4 /*yield*/, video.play()];
                                        case 3:
                                            _b.sent();
                                            _b.label = 4;
                                        case 4:
                                            i++;
                                            return [3 /*break*/, 2];
                                        case 5:
                                            newComposition.content.start();
                                            newComposition.gotoAndPlay(currentTime);
                                            return [2 /*return*/, newComposition];
                                    }
                                });
                            }); }))];
                    case 1:
                        _a.compositions = _d.sent();
                        (_b = this.handleWebGLContextRestored) === null || _b === void 0 ? void 0 : _b.call(this);
                        (_c = this.ticker) === null || _c === void 0 ? void 0 : _c.resume();
                        return [2 /*return*/];
                }
            });
        }); };
        this.handleResume = function () {
            var _a;
            (_a = _this.handlePlayableUpdate) === null || _a === void 0 ? void 0 : _a.call(_this, {
                player: _this,
                playing: true,
            });
        };
        this.handleClick = function (e) {
            var x = e.x, y = e.y;
            _this.compositions.forEach(function (composition) {
                var _a;
                var regions = composition.hitTest(x, y);
                if (regions.length) {
                    for (var i = 0; i < regions.length; i++) {
                        var behavior = regions[i].behavior || InteractBehavior$2.NOTIFY;
                        if (behavior === InteractBehavior$2.NOTIFY) {
                            if (composition.onItemClicked) {
                                composition.onItemClicked(__assign$1({}, regions[i]));
                            }
                            else {
                                (_a = _this.handleItemClicked) === null || _a === void 0 ? void 0 : _a.call(_this, __assign$1(__assign$1({}, regions[i]), { compositionId: composition.id, compositionName: composition.name, composition: composition.name, player: _this }));
                            }
                        }
                        else if (behavior === InteractBehavior$2.RESUME_PLAYER) {
                            void _this.resume();
                        }
                    }
                }
            });
        };
        var container = config.container, canvas = config.canvas, gl = config.gl, fps = config.fps, name = config.name, pixelRatio = config.pixelRatio, manualRender = config.manualRender, interactive = config.interactive, reportGPUTime = config.reportGPUTime, onMessageItem = config.onMessageItem, onPausedByItem = config.onPausedByItem, onItemClicked = config.onItemClicked, onPlayableUpdate = config.onPlayableUpdate, onRenderError = config.onRenderError, onWebGLContextLost = config.onWebGLContextLost, onWebGLContextRestored = config.onWebGLContextRestored, glType = config.renderFramework, _c = config.env, env = _c === void 0 ? '' : _c, notifyTouch = config.notifyTouch;
        if (initErrors.length) {
            throw new Error("Errors before player create: ".concat(initErrors.map(function (message, index) { return "\n ".concat(index + 1, ": ").concat(message); })));
        }
        // v2.0.0 将 willCaptureImage, premultiplyAlpha 统一到 renderOptions 下
        var _d = (_b = (_a = config.renderOptions) !== null && _a !== void 0 ? _a : config) !== null && _b !== void 0 ? _b : {}, willCaptureImage = _d.willCaptureImage, premultiplyAlpha = _d.premultiplyAlpha;
        // 原 debug-disable 直接返回
        if (enableDebugType || glType === 'debug-disable') {
            return;
        }
        // 注意：安卓设备和 iOS 13/iOS 16.5 在 WebGL2 下有渲染或卡顿问题，故默认使用 WebGL1
        var framework = (isAndroid() || isDowngradeIOS()) ? 'webgl' : 'webgl2';
        // 用户可以通过传入 renderFramework，手动强制使用 WebGL 1/2 来渲染
        if (glType) {
            framework = glType === 'webgl' ? 'webgl' : 'webgl2';
        }
        this.handleWebGLContextLost = onWebGLContextLost;
        this.handleWebGLContextRestored = onWebGLContextRestored;
        this.reportGPUTime = reportGPUTime;
        this.handleItemClicked = onItemClicked;
        this.handleMessageItem = onMessageItem;
        this.handlePlayableUpdate = onPlayableUpdate;
        this.handleRenderError = onRenderError;
        this.handlePlayerPause = function (item) {
            _this.pause();
            onPausedByItem === null || onPausedByItem === void 0 ? void 0 : onPausedByItem({
                name: item.name,
                player: _this,
            });
        };
        this.pixelRatio = Number.isFinite(pixelRatio) ? pixelRatio : getPixelRatio();
        this.offscreenMode = true;
        this.env = env;
        if (canvas) {
            this.canvas = canvas;
        }
        else if (gl) {
            this.canvas = gl.canvas;
            var version = gl instanceof alipay.WebGLRenderingContext ? 'webgl' : 'webgl2';
            if (framework !== version) {
                logger.error("The gl context(".concat(version, ") is inconsistent with renderFramework or default version(").concat(framework, ")"));
                framework = version;
            }
        }
        else {
            assertContainer(container);
            this.canvas = alipay.document.createElement('canvas');
            container.appendChild(this.canvas);
        }
        this.renderer = Renderer.create(this.canvas, framework, {
            preserveDrawingBuffer: willCaptureImage,
            premultipliedAlpha: premultiplyAlpha,
        });
        this.renderer.env = env;
        this.renderer.addLostHandler({ lost: this.lost });
        this.renderer.addRestoreHandler({ restore: this.restore });
        this.gpuCapability = this.renderer.engine.gpuCapability;
        // 如果存在WebGL和WebGL2的Player，需要给出警告
        playerMap.forEach(function (player) {
            if (player.gpuCapability.type !== _this.gpuCapability.type) {
                logger.warn("Create player with different webgl version: old=".concat(player.gpuCapability.type, ", new=").concat(_this.gpuCapability.type));
            }
        });
        if (!manualRender) {
            this.ticker = new Ticker(fps);
            this.ticker.add(this.tick.bind(this));
        }
        this.event = new EventSystem(this.canvas, !!notifyTouch);
        this.event.bindListeners();
        this.event.addEventListener(EVENT_TYPE_CLICK, this.handleClick);
        this.interactive = interactive !== null && interactive !== void 0 ? interactive : false;
        this.name = name || "".concat(seed++);
        if (!gl) {
            this.resize();
        }
        setSpriteMeshMaxItemCountByGPU(this.gpuCapability.detail);
        this.container = this.canvas.parentElement;
        playerMap.set(this.canvas, this);
        assertNoConcurrentPlayers();
        broadcastPlayerEvent(this, true);
    }
    /**
     * 设置 player 的播放速度，
     * @param speed - 播放速度
     */
    Player.prototype.setSpeed = function (speed) {
        if (!isNaN(speed)) {
            this.speed = speed;
        }
    };
    Player.prototype.getSpeed = function () {
        return this.speed;
    };
    /**
     * 根据名称查找对应的合成，可能找不到
     * @param name - 目标合成名称
     */
    Player.prototype.getCompositionByName = function (name) {
        return this.compositions.find(function (comp) { return comp.name === name; });
    };
    /**
     * 获取当前播放的所有合成, 请不要修改返回数组的内容
     */
    Player.prototype.getCompositions = function () {
        return this.compositions;
    };
    Object.defineProperty(Player.prototype, "hasPlayable", {
        /**
         * 是否有合成在播放
         */
        get: function () {
            return this.compositions.length > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "paused", {
        /**
         * 播放器是否已暂停
         */
        get: function () {
            var _a;
            return (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.getPaused();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "interactive", {
        /**
         * 获取播放器是否可交互
         */
        get: function () {
            return this.event.enabled;
        },
        /**
         * 设置播放器是否可交互
         */
        set: function (enable) {
            this.event.enabled = enable;
        },
        enumerable: false,
        configurable: true
    });
    Player.prototype.loadScene = function (scene, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var composition, baseOrder;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        baseOrder = this.baseCompositionIndex;
                        if (!isArray(scene)) return [3 /*break*/, 2];
                        this.baseCompositionIndex += scene.length;
                        return [4 /*yield*/, Promise.all(scene.map(function (scn, index) { return __awaiter(_this, void 0, void 0, function () {
                                var res;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.createComposition(scn, options)];
                                        case 1:
                                            res = _a.sent();
                                            res.setIndex(baseOrder + index);
                                            return [2 /*return*/, res];
                                    }
                                });
                            }); }))];
                    case 1:
                        composition = _b.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        this.baseCompositionIndex += 1;
                        return [4 /*yield*/, this.createComposition(scene, options)];
                    case 3:
                        composition = _b.sent();
                        composition.setIndex(baseOrder);
                        _b.label = 4;
                    case 4:
                        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.start();
                        return [2 /*return*/, composition];
                }
            });
        });
    };
    Player.prototype.createComposition = function (url, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var renderer, last, opts, source, assetManager, scene, composition, firstFrameTime;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        renderer = this.renderer;
                        last = alipay.performance.now();
                        opts = __assign$1({ autoplay: true }, options);
                        if (isSceneWithOptions(url)) {
                            source = url.scene;
                            opts = __assign$1(__assign$1({}, opts), url.options || {});
                        }
                        else {
                            source = url;
                        }
                        assetManager = new AssetManager(opts);
                        this.assetManagers.push(assetManager);
                        return [4 /*yield*/, assetManager.loadScene(source, this.renderer, { env: this.env })];
                    case 1:
                        scene = _a.sent();
                        // 加载期间 player 销毁
                        if (this.disposed) {
                            throw new Error('Disposed player can not used to create Composition');
                        }
                        composition = new Composition(__assign$1(__assign$1({}, opts), { renderer: renderer, width: renderer.getWidth(), height: renderer.getHeight(), event: this.event, onPlayerPause: this.handlePlayerPause, onMessageItem: this.handleMessageItem }), scene);
                        if (this.ticker) {
                            if (composition.renderLevel === RenderLevel$1.B) {
                                this.ticker.setFPS(Math.min(this.ticker.getFPS(), 30));
                            }
                        }
                        return [4 /*yield*/, new Promise(function (resolve) {
                                _this.renderer.getShaderLibrary().compileAllShaders(function () {
                                    resolve(null);
                                });
                            })];
                    case 2:
                        _a.sent();
                        if (opts.autoplay) {
                            this.autoPlaying = true;
                            composition.play();
                        }
                        else {
                            composition.pause();
                        }
                        firstFrameTime = (alipay.performance.now() - last) + composition.statistic.loadTime;
                        composition.statistic.firstFrameTime = firstFrameTime;
                        logger.info("first frame: [".concat(composition.name, "]").concat(firstFrameTime.toFixed(4), "ms"));
                        this.compositions.push(composition);
                        return [2 /*return*/, composition];
                }
            });
        });
    };
    /**
     * 播放通过 player 加载好的全部合成
     */
    Player.prototype.play = function () {
        var _a;
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = true;
        this.compositions.map(function (composition) {
            composition.play();
        });
        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.start();
    };
    /**
     * 跳转全部合成到指定时间后播放
     * @param time - 指定时间, 单位秒
     */
    Player.prototype.gotoAndPlay = function (time) {
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = true;
        this.compositions.map(function (composition) {
            composition.gotoAndPlay(time);
        });
        if (!this.ticker) {
            this.doTick(0, true);
        }
        else {
            this.ticker.start();
        }
    };
    /**
     * 跳转全部合成到指定时间并停留
     * @param time - 指定时间, 单位秒
     */
    Player.prototype.gotoAndStop = function (time) {
        var _a, _b;
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = false;
        this.compositions.map(function (composition) {
            composition.gotoAndStop(time);
        });
        if (!this.ticker || ((_a = this.ticker) === null || _a === void 0 ? void 0 : _a.getPaused())) {
            this.doTick(0, true);
        }
        (_b = this.handlePlayableUpdate) === null || _b === void 0 ? void 0 : _b.call(this, {
            player: this,
            playing: false,
        });
    };
    /**
     * 顺序播放一组还未开始播放的合成
     * @param compositions - 要播放的合成数组
     */
    Player.prototype.playSequence = function (compositions) {
        var _a;
        var _loop_1 = function (i) {
            var composition = compositions[i];
            var preEndHandler = composition.onEnd;
            composition.onEnd = function () {
                preEndHandler === null || preEndHandler === void 0 ? void 0 : preEndHandler.call(composition, composition);
                compositions[i + 1].play();
            };
        };
        for (var i = 0; i < compositions.length - 1; i++) {
            _loop_1(i);
        }
        compositions[0].play();
        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.start();
    };
    /**
     * 暂停播放器
     * @param options
     * @param options.offloadTexture - 是否卸载贴图纹理，减少内存
     * @returns
     */
    Player.prototype.pause = function (options) {
        var _a, _b;
        if (!this.paused) {
            (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.pause();
            (_b = this.handlePlayableUpdate) === null || _b === void 0 ? void 0 : _b.call(this, {
                player: this,
                playing: false,
            });
            if (options && options.offloadTexture) {
                this.offloadTexture();
            }
        }
    };
    /**
     * 恢复播放器
     * > 如果暂停时卸载了纹理贴图，此函数将自动请求网络重新加载纹理
     * @returns
     */
    Player.prototype.resume = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.resumePending) {
                            return [2 /*return*/];
                        }
                        if (!this.paused) return [3 /*break*/, 2];
                        this.resumePending = true;
                        return [4 /*yield*/, Promise.all(this.compositions.map(function (c) { return c.reloadTexture(); }))];
                    case 1:
                        _b.sent();
                        this.resumePending = false;
                        this.handleResume();
                        _b.label = 2;
                    case 2:
                        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.resume();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * player 在定时器每帧的回调
     * @param dt - 时间差，毫秒
     */
    Player.prototype.tick = function (dt) {
        this.doTick(dt, this.forceRenderNextFrame);
        this.forceRenderNextFrame = false;
    };
    Player.prototype.doTick = function (dt, forceRender) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        var renderErrors = this.renderer.engine.renderErrors;
        // TODO: 临时处理，2.0.0 做优化
        if (renderErrors.size > 0) {
            (_a = this.handleRenderError) === null || _a === void 0 ? void 0 : _a.call(this, renderErrors.values().next().value);
            // 有渲染错误时暂停播放
            (_b = this.ticker) === null || _b === void 0 ? void 0 : _b.pause();
        }
        dt = Math.min(dt, 33) * this.speed;
        var comps = this.compositions;
        var skipRender = false;
        comps.sort(function (a, b) { return a.getIndex() - b.getIndex(); });
        this.compositions = [];
        for (var i = 0; i < comps.length; i++) {
            var composition = comps[i];
            if (composition.textureOffloaded) {
                skipRender = true;
                logger.error("Composition ".concat(composition.name, " texture offloaded, skip render."));
                this.compositions.push(composition);
                continue;
            }
            if (!composition.isDestroyed && composition.renderer) {
                composition.update(dt);
            }
            if (!composition.isDestroyed) {
                this.compositions.push(composition);
            }
        }
        this.baseCompositionIndex = this.compositions.length;
        if (skipRender) {
            (_c = this.handleRenderError) === null || _c === void 0 ? void 0 : _c.call(this, new Error('play when texture offloaded'));
            return (_d = this.ticker) === null || _d === void 0 ? void 0 : _d.pause();
        }
        if (!this.paused || forceRender) {
            var level = this.gpuCapability.level;
            var gl = this.renderer.context.gl;
            var time = (level === 2 && this.reportGPUTime) ? gpuTimer(gl) : undefined;
            time === null || time === void 0 ? void 0 : time.begin();
            if (this.compositions.length || this.compositions.length < comps.length || forceRender) {
                this.renderer.setFrameBuffer(null);
                this.renderer.clear({
                    stencilAction: exports.TextureLoadAction.clear,
                    clearStencil: 0,
                    depthAction: exports.TextureLoadAction.clear,
                    clearDepth: 1,
                    colorAction: exports.TextureLoadAction.clear,
                    clearColor: [0, 0, 0, 0],
                });
                for (var i = 0; i < comps.length; i++) {
                    !comps[i].renderFrame.isDestroyed && this.renderer.renderRenderFrame(comps[i].renderFrame);
                }
            }
            time === null || time === void 0 ? void 0 : time.end();
            time === null || time === void 0 ? void 0 : time.getTime().then(function (t) { var _a; return (_a = _this.reportGPUTime) === null || _a === void 0 ? void 0 : _a.call(_this, t !== null && t !== void 0 ? t : 0); }).catch;
            if (this.autoPlaying) {
                (_e = this.handlePlayableUpdate) === null || _e === void 0 ? void 0 : _e.call(this, {
                    player: this,
                    playing: true,
                });
            }
        }
    };
    /**
     * 调整画布的宽高比
     * @param aspect
     * @param scale
     */
    Player.prototype.resizeToAspect = function (aspect, scale) {
        if (scale === void 0) { scale = 1; }
        if (aspect !== this.displayAspect) {
            this.displayAspect = aspect;
        }
        if (scale !== this.displayScale) {
            this.displayScale = scale;
        }
        this.resize();
    };
    /**
     * 将播放器重新和父容器大小对齐
     */
    Player.prototype.resize = function () {
        var _a;
        var parentElement = this.canvas.parentElement;
        var containerWidth;
        var containerHeight;
        var canvasWidth;
        var canvasHeight;
        if (parentElement) {
            var size = this.getTargetSize(parentElement);
            containerWidth = size[0];
            containerHeight = size[1];
            canvasWidth = size[2];
            canvasHeight = size[3];
        }
        else {
            containerWidth = canvasWidth = this.canvas.width;
            containerHeight = canvasHeight = this.canvas.height;
        }
        var aspect = containerWidth / containerHeight;
        if (containerWidth && containerHeight) {
            var documentWidth = alipay.document.documentElement.clientWidth;
            if (canvasWidth > documentWidth * 2) {
                logger.error("DPI overflowed, width ".concat(canvasWidth, " is more than 2x document width ").concat(documentWidth, ", see ").concat(HELP_LINK['DPI overflowed']));
            }
            var maxSize = this.env ? this.gpuCapability.detail.maxTextureSize : 2048;
            if ((canvasWidth > maxSize || canvasHeight > maxSize)) {
                logger.error("Container size overflowed ".concat(canvasWidth, "x").concat(canvasHeight, ", see ").concat(HELP_LINK['Container size overflowed']));
                if (aspect > 1) {
                    canvasWidth = Math.round(maxSize);
                    canvasHeight = Math.round(maxSize / aspect);
                }
                else {
                    canvasHeight = Math.round(maxSize);
                    canvasWidth = Math.round(maxSize * aspect);
                }
            }
            // ios 14.1 -ios 14.3 resize canvas will cause memory leak
            this.renderer.resize(canvasWidth, canvasHeight);
            this.canvas.style.width = containerWidth + 'px';
            this.canvas.style.height = containerHeight + 'px';
            logger.info("Resize player ".concat(this.name, " [").concat(canvasWidth, ",").concat(canvasHeight, ",").concat(containerWidth, ",").concat(containerHeight, "]."));
            (_a = this.compositions) === null || _a === void 0 ? void 0 : _a.forEach(function (comp) {
                comp.camera.aspect = aspect;
            });
        }
    };
    /**
     * 清空 canvas 的画面
     * @param immediate - 如果立即清理，当前画面将会消失，如果 player 还有合成在渲染，可能出现闪烁
     */
    Player.prototype.clearCanvas = function (immediate) {
        if (immediate) {
            this.renderer.clear({
                stencilAction: exports.TextureLoadAction.clear,
                clearStencil: 0,
                depthAction: exports.TextureLoadAction.clear,
                clearDepth: 1,
                colorAction: exports.TextureLoadAction.clear,
                clearColor: [0, 0, 0, 0],
            });
        }
        else {
            this.forceRenderNextFrame = true;
        }
    };
    /**
     * @internal
     * @deprecated since 2.0.0
     * @param id
     * @param options
     */
    Player.prototype.destroyItem = function (id, options) {
    };
    /**
     * 销毁当前播放的所有 Composition
     */
    Player.prototype.destroyCurrentCompositions = function () {
        this.compositions.forEach(function (comp) { return comp.dispose(); });
        this.compositions.length = 0;
        this.baseCompositionIndex = 0;
    };
    /**
     * 销毁播放器
     * @param keepCanvas - 是否保留 canvas 画面，默认不保留，canvas 不能再被使用
     */
    Player.prototype.dispose = function (keepCanvas) {
        var _a;
        logger.info("call player destroy: ".concat(this.name));
        if (this.disposed) {
            return;
        }
        playerMap.delete(this.canvas);
        this.pause();
        (_a = this.ticker) === null || _a === void 0 ? void 0 : _a.stop();
        this.assetManagers.forEach(function (assetManager) { return assetManager.dispose(); });
        this.compositions.forEach(function (comp) { return comp.dispose(); });
        this.compositions.length = 0;
        this.renderer.context.removeLostHandler({ lost: this.lost });
        this.renderer.context.removeRestoreHandler({ restore: this.restore });
        this.event.dispose();
        this.renderer.dispose(!keepCanvas);
        broadcastPlayerEvent(this, false);
        if (this.canvas instanceof alipay.HTMLCanvasElement &&
            !keepCanvas &&
            this.renderer.context) {
            // TODO: 数据模版下掉可以由文本模块单独管理
            canvasPool.dispose();
            // canvas will become a cry emoji in Android if still in dom
            if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas.remove();
        }
        // 在报错函数中传入 player.name
        var errorMsg = getDestroyedErrorMessage(this.name);
        var throwErrorFunc = function () { return throwDestroyedError(errorMsg); };
        var throwErrorPromiseFunc = function () { return throwDestroyedErrorPromise(errorMsg); };
        this.tick = throwErrorFunc;
        this.resize = throwErrorFunc;
        this.loadScene = throwErrorPromiseFunc;
        this.play = throwErrorPromiseFunc;
        this.gotoAndPlay = throwErrorPromiseFunc;
        this.gotoAndStop = throwErrorPromiseFunc;
        this.playSequence = throwErrorFunc;
        this.destroyCurrentCompositions = throwErrorFunc;
        this.resume = throwErrorPromiseFunc;
        this.disposed = true;
    };
    Player.prototype.offloadTexture = function () {
        this.compositions.forEach(function (comp) { return comp.offloadTexture(); });
    };
    Player.prototype.getTargetSize = function (parentEle) {
        assertContainer(parentEle);
        var displayAspect = this.displayAspect;
        var targetWidth;
        var targetHeight;
        if (displayAspect) {
            var parentAspect = parentEle.clientWidth / parentEle.clientHeight;
            if (parentAspect > displayAspect) {
                targetHeight = parentEle.clientHeight * this.displayScale;
                targetWidth = targetHeight * displayAspect;
            }
            else {
                targetWidth = parentEle.clientWidth * this.displayScale;
                targetHeight = targetWidth / displayAspect;
            }
        }
        else {
            targetWidth = parentEle.clientWidth;
            targetHeight = parentEle.clientHeight;
        }
        var ratio = this.pixelRatio;
        var containerWidth = targetWidth;
        var containerHeight = targetHeight;
        targetWidth = Math.round(targetWidth * ratio);
        targetHeight = Math.round(targetHeight * ratio);
        if (targetHeight < 1 || targetHeight < 1) {
            if (this.offscreenMode) {
                targetWidth = targetHeight = containerWidth = containerHeight = 1;
            }
            else {
                throw Error("Invalid container size ".concat(targetWidth, "x").concat(targetHeight, ", see ").concat(HELP_LINK['Invalid container size']));
            }
        }
        return [containerWidth, containerHeight, targetWidth, targetHeight];
    };
    return Player;
}());
function isSceneWithOptions(scene) {
    // TODO: 判断不太优雅，后期试情况优化
    return isObject(scene) && 'scene' in scene && 'options' in scene;
}
/**
 * 禁止/允许创建新的播放器，已创建的不受影响
 * @param disable - 是否禁止
 */
function disableAllPlayer(disable) {
    enableDebugType = !!disable;
}
/**
 * 判断指定的 canvas 是否有播放器正在使用
 * @param canvas - 指定的 canvas
 * @returns
 */
function isCanvasUsedByPlayer(canvas) {
    return playerMap.has(canvas);
}
/**
 * 获取 canvas 对应的播放器
 * @param canvas - 指定的 canvas
 * @returns
 */
function getPlayerByCanvas(canvas) {
    return playerMap.get(canvas);
}
/**
 * 获取使用中的播放器
 * @returns
 */
function getActivePlayers() {
    return Array.from(playerMap.values());
}
/**
 * 播放器在实例化、销毁（`dispose`）时分别触发插件的 `onPlayerCreated`、`onPlayerDestroy` 回调
 * @param player - 播放器
 * @param isCreate - 是否处于实例化时
 */
function broadcastPlayerEvent(player, isCreate) {
    Object.keys(pluginLoaderMap).forEach(function (key) {
        var ctrl = pluginLoaderMap[key];
        var func = isCreate ? ctrl.onPlayerCreated : ctrl.onPlayerDestroy;
        func === null || func === void 0 ? void 0 : func(player);
    });
}
/**
 * 同时允许的播放器数量超过 1 时打印错误
 */
function assertNoConcurrentPlayers() {
    var e_1, _a;
    var runningPlayers = [];
    try {
        for (var _b = __values$1(playerMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var player_1 = _c.value;
            if (!player_1.paused) {
                runningPlayers.push(player_1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (runningPlayers.length > 1) {
        logger.error("Current running player count: ".concat(runningPlayers.length, ", see ").concat(HELP_LINK['Current running player count']), runningPlayers);
    }
}
/**
 * 创建播放器传入的容器不是 `HTMLElement` 时抛出错误
 * @param container
 */
function assertContainer(container) {
    if (container === undefined || container === null) {
        throw new Error("Container is not an HTMLElement, see ".concat(HELP_LINK['Container is not an HTMLElement']));
    }
}
function getDestroyedErrorMessage(name) {
    return "Never use destroyed player: ".concat(name, " again, see ").concat(HELP_LINK['Never use destroyed player again']);
}
function throwDestroyedError(destroyedErrorMessage) {
    throw new Error(destroyedErrorMessage);
}
function throwDestroyedErrorPromise(destroyedErrorMessage) {
    return Promise.reject(destroyedErrorMessage);
}

Texture.create = function (engine, props) {
    return new GLTexture(engine, props);
};
Texture.createWithData = function (engine, data, options) {
    if (data === void 0) { data = imageDataFromColor('#fff'); }
    if (options === void 0) { options = {}; }
    var _a = options, _b = _a.type, type = _b === void 0 ? glContext.UNSIGNED_BYTE : _b, _c = _a.format, format = _c === void 0 ? glContext.RGBA : _c, internalFormat = _a.internalFormat, _d = _a.wrapS, wrapS = _d === void 0 ? glContext.MIRRORED_REPEAT : _d, _e = _a.wrapT, wrapT = _e === void 0 ? glContext.MIRRORED_REPEAT : _e, _f = _a.minFilter, minFilter = _f === void 0 ? glContext.NEAREST : _f, _g = _a.magFilter, magFilter = _g === void 0 ? glContext.NEAREST : _g, _h = _a.flipY, flipY = _h === void 0 ? false : _h;
    var tex = new GLTexture(engine, {
        data: data,
        type: type,
        sourceType: exports.TextureSourceType.data,
        format: format,
        internalFormat: internalFormat || format,
        wrapS: wrapS,
        wrapT: wrapT,
        minFilter: minFilter,
        magFilter: magFilter,
        flipY: flipY,
    });
    return tex;
};
Material.create = function (engine, props) {
    return new GLMaterial(engine, props);
};
Geometry.create = function (engine, props) {
    return new GLGeometry(engine, props);
};
Mesh.create = function (engine, props) {
    return new Mesh(engine, props);
};
RenderBuffer.create = function (props) {
    return new GLRenderBuffer(props);
};
FrameBuffer.create = function (props, renderer) {
    return new GLFrameBuffer(props, renderer);
};
Renderer.create = function (canvas, framework, renderOptions) {
    return new GLRenderer(canvas, framework, renderOptions);
};
Engine.create = function (gl) {
    return new GLEngine(gl);
};
var version = "1.6.0";
logger.info('player version: ' + version);

exports.AbstractPlugin = AbstractPlugin;
exports.AssetManager = AssetManager;
exports.BYTES_TYPE_MAP = BYTES_TYPE_MAP;
exports.BezierCurve = BezierCurve;
exports.BezierCurvePath = BezierCurvePath;
exports.COMPRESSED_TEXTURE = COMPRESSED_TEXTURE;
exports.COPY_FRAGMENT_SHADER = COPY_FRAGMENT_SHADER;
exports.COPY_MESH_SHADER_ID = COPY_MESH_SHADER_ID;
exports.COPY_VERTEX_SHADER = COPY_VERTEX_SHADER;
exports.CalculateItem = CalculateItem;
exports.CalculateLoader = CalculateLoader;
exports.CalculateVFXItem = CalculateVFXItem;
exports.Camera = Camera;
exports.CameraController = CameraController;
exports.CameraVFXItem = CameraVFXItem;
exports.CameraVFXItemLoader = CameraVFXItemLoader;
exports.Composition = Composition;
exports.CompositionSourceManager = CompositionSourceManager;
exports.DEFAULT_FONTS = DEFAULT_FONTS;
exports.Downloader = Downloader;
exports.EFFECTS_COPY_MESH_NAME = EFFECTS_COPY_MESH_NAME;
exports.EVENT_TYPE_CLICK = EVENT_TYPE_CLICK;
exports.EVENT_TYPE_TOUCH_END = EVENT_TYPE_TOUCH_END;
exports.EVENT_TYPE_TOUCH_MOVE = EVENT_TYPE_TOUCH_MOVE;
exports.EVENT_TYPE_TOUCH_START = EVENT_TYPE_TOUCH_START;
exports.Engine = Engine;
exports.EventSystem = EventSystem;
exports.FILTER_NAME_NONE = FILTER_NAME_NONE;
exports.FilterSpriteVFXItem = FilterSpriteVFXItem;
exports.Float16ArrayWrapper = Float16ArrayWrapper;
exports.FrameBuffer = FrameBuffer;
exports.GLEngine = GLEngine;
exports.GLGeometry = GLGeometry;
exports.GLRenderer = GLRenderer;
exports.GPUCapability = GPUCapability;
exports.Geometry = Geometry;
exports.GlobalUniforms = GlobalUniforms;
exports.GradientValue = GradientValue;
exports.HELP_LINK = HELP_LINK$1;
exports.InteractBehavior = InteractBehavior$1;
exports.InteractItem = InteractItem;
exports.InteractLoader = InteractLoader;
exports.InteractMesh = InteractMesh;
exports.InteractVFXItem = InteractVFXItem;
exports.KTXTexture = KTXTexture;
exports.LineSegments = LineSegments;
exports.LinearValue = LinearValue;
exports.Material = Material;
exports.MaterialDataBlock = MaterialDataBlock;
exports.Mesh = Mesh;
exports.PLAYER_OPTIONS_ENV_EDITOR = PLAYER_OPTIONS_ENV_EDITOR;
exports.POST_PROCESS_SETTINGS = POST_PROCESS_SETTINGS;
exports.ParticleLoader = ParticleLoader;
exports.ParticleMesh = ParticleMesh;
exports.ParticleSystem = ParticleSystem;
exports.ParticleVFXItem = ParticleVFXItem;
exports.PassTextureCache = PassTextureCache;
exports.Player = Player;
exports.PluginSystem = PluginSystem;
exports.QCanvasViewer = QCanvasViewer;
exports.QText = QText;
exports.RENDER_PASS_NAME_PREFIX = RENDER_PASS_NAME_PREFIX;
exports.RENDER_PREFER_LOOKUP_TEXTURE = RENDER_PREFER_LOOKUP_TEXTURE;
exports.RUNTIME_ENV = RUNTIME_ENV;
exports.RandomSetValue = RandomSetValue;
exports.RandomValue = RandomValue;
exports.RandomVectorValue = RandomVectorValue;
exports.RenderBuffer = RenderBuffer;
exports.RenderFrame = RenderFrame;
exports.RenderPass = RenderPass;
exports.RenderPassPriorityNormal = RenderPassPriorityNormal;
exports.RenderPassPriorityPostprocess = RenderPassPriorityPostprocess;
exports.RenderPassPriorityPrepare = RenderPassPriorityPrepare;
exports.RenderTargetHandle = RenderTargetHandle;
exports.Renderer = Renderer;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SPRITE_VERTEX_STRIDE = SPRITE_VERTEX_STRIDE;
exports.SemanticMap = SemanticMap;
exports.Shader = Shader;
exports.SpriteItem = SpriteItem;
exports.SpriteLoader = SpriteLoader;
exports.SpriteMesh = SpriteMesh;
exports.SpriteVFXItem = SpriteVFXItem;
exports.StaticValue = StaticValue;
exports.TEMPLATE_USE_OFFSCREEN_CANVAS = TEMPLATE_USE_OFFSCREEN_CANVAS;
exports.TextItem = TextItem;
exports.TextLoader = TextLoader;
exports.TextMesh = TextMesh;
exports.TextVFXItem = TextVFXItem;
exports.Texture = Texture;
exports.TextureFactory = TextureFactory;
exports.Ticker = Ticker;
exports.TimelineComponent = TimelineComponent;
exports.Transform = Transform;
exports.VFXItem = VFXItem;
exports.ValueGetter = ValueGetter;
exports.adapter = index$3;
exports.addByOrder = addByOrder;
exports.addItem = addItem;
exports.addItemWithOrder = addItemWithOrder;
exports.alphaFrameFrag = alphaFrameFrag;
exports.alphaMaskFrag = alphaMaskFrag;
exports.assertExist = assertExist;
exports.asserts = asserts;
exports.blend = blend;
exports.bloomMixVert = bloomMixVert;
exports.bloomThresholdVert = bloomThresholdVert;
exports.calculateTranslation = calculateTranslation;
exports.cameraMoveFrag = cameraMove_frag;
exports.cameraMoveVert = cameraMoveVert;
exports.canvasPool = canvasPool;
exports.colorGradingFrag = colorGradingFrag;
exports.colorStopsFromGradient = colorStopsFromGradient;
exports.colorToArr = colorToArr$1;
exports.combineImageTemplate = combineImageTemplate;
exports.combineImageTemplate1 = combineImageTemplate1;
exports.combineImageTemplate1Async = combineImageTemplate1Async;
exports.combineImageTemplate2 = combineImageTemplate2;
exports.combineImageTemplate2Async = combineImageTemplate2Async;
exports.combineImageTemplateAsync = combineImageTemplateAsync;
exports.compatibleFrag = compatible_frag;
exports.compatibleVert = compatible_vert;
exports.convertAnchor = convertAnchor;
exports.copyFrag = copyFrag;
exports.createCopyShader = createCopyShader;
exports.createFilter = createFilter;
exports.createFilterShaders = createFilterShaders;
exports.createGLContext = createGLContext;
exports.createKeyFrameMeta = createKeyFrameMeta;
exports.createShaderWithMarcos = createShaderWithMarcos;
exports.createShape = createShape;
exports.createVFXItem = createVFXItem;
exports.createValueGetter = createValueGetter;
exports.decimalEqual = decimalEqual;
exports.deepClone = deepClone;
exports.defaultGlobalVolume = defaultGlobalVolume;
exports.defaultPlugins = defaultPlugins;
exports.delayFrag = delayFrag;
exports.deserializeMipmapTexture = deserializeMipmapTexture;
exports.disableAllPlayer = disableAllPlayer;
exports.distortionFrag = distortionFrag;
exports.distortionVert = distortionVert;
exports.earcut = earcut;
exports.enlargeBuffer = enlargeBuffer;
exports.ensureVec3 = ensureVec3;
exports.filters = filters;
exports.findPreviousRenderPass = findPreviousRenderPass;
exports.gaussianDownFrag = gaussianDown_frag;
exports.gaussianDownHFrag = gaussianDownHFrag;
exports.gaussianDownVFrag = gaussianDownVFrag;
exports.gaussianUpFrag = gaussianUpFrag;
exports.generateEmptyTypedArray = generateEmptyTypedArray;
exports.generateHalfFloatTexture = generateHalfFloatTexture;
exports.getActivePlayers = getActivePlayers;
exports.getBackgroundImage = getBackgroundImage;
exports.getColorFromGradientStops = getColorFromGradientStops;
exports.getConfig = getConfig;
exports.getDefaultTemplateCanvasPool = getDefaultTemplateCanvasPool;
exports.getDefaultTextureFactory = getDefaultTextureFactory;
exports.getGeometryByShape = getGeometryByShape;
exports.getGeometryTriangles = getGeometryTriangles;
exports.getImageItemRenderInfo = getImageItemRenderInfo;
exports.getKTXTextureOptions = getKTXTextureOptions;
exports.getKeyFrameMetaByRawValue = getKeyFrameMetaByRawValue;
exports.getParticleMeshShader = getParticleMeshShader;
exports.getPixelRatio = getPixelRatio;
exports.getPlayerByCanvas = getPlayerByCanvas;
exports.getPreMultiAlpha = getPreMultiAlpha;
exports.getStandardComposition = getStandardComposition;
exports.getStandardImage = getStandardImage;
exports.getStandardItem = getStandardItem;
exports.getStandardJSON = getStandardJSON;
exports.getTextureSize = getTextureSize;
exports.glContext = glContext;
exports.gpuTimer = gpuTimer;
exports.imageDataFromColor = imageDataFromColor;
exports.imageDataFromGradient = imageDataFromGradient;
exports.initErrors = initErrors;
exports.initGLContext = initGLContext;
exports.integrate = integrate;
exports.interpolateColor = interpolateColor;
exports.isAlipayMiniApp = isAlipayMiniApp;
exports.isAndroid = isAndroid;
exports.isArray = isArray;
exports.isCanvasUsedByPlayer = isCanvasUsedByPlayer;
exports.isFunction = isFunction;
exports.isIOS = isIOS;
exports.isObject = isObject;
exports.isScene = isScene;
exports.isSceneWithOptions = isSceneWithOptions;
exports.isSimulatorCellPhone = isSimulatorCellPhone;
exports.isString = isString;
exports.isUniformStruct = isUniformStruct;
exports.isUniformStructArray = isUniformStructArray;
exports.isValidFontFamily = isValidFontFamily;
exports.isWebGL2 = isWebGL2;
exports.itemFrag = itemFrag;
exports.itemFrameFrag = itemFrameFrag;
exports.itemVert = itemVert;
exports.loadBinary = loadBinary;
exports.loadBlob = loadBlob;
exports.loadImage = loadImage;
exports.loadMedia = loadMedia;
exports.loadVideo = loadVideo;
exports.loadWebPOptional = loadWebPOptional;
exports.logger = logger;
exports.math = index;
exports.modifyMaxKeyframeShader = modifyMaxKeyframeShader;
exports.nearestPowerOfTwo = nearestPowerOfTwo;
exports.noop = noop;
exports.numberToFix = numberToFix;
exports.parsePercent = parsePercent$1;
exports.particleFrag = particleFrag;
exports.particleOriginTranslateMap = particleOriginTranslateMap;
exports.particleUniformTypeMap = particleUniformTypeMap;
exports.particleVert = particleVert;
exports.pluginLoaderMap = pluginLoaderMap;
exports.pointOnLine = pointOnLine;
exports.random = random;
exports.registerFilter = registerFilter;
exports.registerFilters = registerFilters;
exports.registerPlugin = registerPlugin;
exports.removeItem = removeItem;
exports.requestAsync = requestAsync;
exports.rotateVec2 = rotateVec2;
exports.screenMeshVert = screenMeshVert;
exports.setBlendMode = setBlendMode;
exports.setConfig = setConfig;
exports.setDefaultTextureFactory = setDefaultTextureFactory;
exports.setMaskMode = setMaskMode;
exports.setMaxSpriteMeshItemCount = setMaxSpriteMeshItemCount;
exports.setRayFromCamera = setRayFromCamera;
exports.setSideMode = setSideMode;
exports.setSpriteMeshMaxFragmentTextures = setSpriteMeshMaxFragmentTextures;
exports.setSpriteMeshMaxItemCountByGPU = setSpriteMeshMaxItemCountByGPU;
exports.sortByOrder = sortByOrder;
exports.spec = index$1;
exports.spriteMeshShaderFromFilter = spriteMeshShaderFromFilter;
exports.spriteMeshShaderFromRenderInfo = spriteMeshShaderFromRenderInfo;
exports.spriteMeshShaderIdFromRenderInfo = spriteMeshShaderIdFromRenderInfo;
exports.thresholdFrag = thresholdFrag;
exports.throwDestroyedError = throwDestroyedError$1;
exports.trailVert = trailVert;
exports.translatePoint = translatePoint;
exports.trianglesFromRect = trianglesFromRect;
exports.unregisterPlugin = unregisterPlugin;
exports.valIfUndefined = valIfUndefined;
exports.value = value;
exports.valueDefine = valueDefine;
exports.vecAssign = vecAssign;
exports.vecFill = vecFill;
exports.vecMulCombine = vecMulCombine;
exports.vecNormalize = vecNormalize;
exports.version = version;
