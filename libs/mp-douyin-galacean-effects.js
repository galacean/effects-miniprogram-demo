'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var douyin = {};

var platform$1 = {};

Object.defineProperty(platform$1, "__esModule", { value: true });
platform$1.platform = void 0;
platform$1.platform = {
    getSystemInfoSync: function () {
        return {
            pixelRatio: 1,
            system: '',
            platform: '',
            language: '',
            screenWidth: 1,
            screenHeight: 1,
            windowWidth: 1,
            windowHeight: 1,
        };
    },
    createCanvas: function () {
        return {
            addEventListener: function (type, listener, options) {
            },
            removeEventListener: function (type, listener) { },
            dispatchEvent: function (event) { },
            width: 0,
            height: 0,
        };
    },
    createOffscreenCanvas: function (options) {
        return {
            addEventListener: function (type, listener, options) {
            },
            removeEventListener: function (type, listener) { },
            dispatchEvent: function (event) { },
            width: 0,
            height: 0,
        };
    },
    createImage: function () { },
    createSelectorQuery: function () { },
    request: function (object) { },
    downloadFile: function (options) { },
    createVideoContext: function (id) { },
    startDeviceMotionListening: function (object) { },
    stopDeviceMotionListening: function () { },
    onDeviceMotionChange: function (listener) { },
    offDeviceMotionChange: function (listener) { },
};

var platform_1$8 = platform$1;
platform_1$8.platform.createCanvas = tt.createCanvas;
platform_1$8.platform.createImage = tt.createImage;
platform_1$8.platform.createOffscreenCanvas = tt.createOffscreenCanvas;
platform_1$8.platform.createSelectorQuery = tt.createSelectorQuery;
platform_1$8.platform.getSystemInfoSync = tt.getSystemInfoSync;
platform_1$8.platform.request = tt.request;
platform_1$8.platform.createVideoContext = tt.createVideoContext;
platform_1$8.platform.downloadFile = tt.downloadFile;
platform_1$8.platform.startDeviceMotionListening = tt.startDeviceMotionListening;
platform_1$8.platform.stopDeviceMotionListening = tt.stopDeviceMotionListening;
platform_1$8.platform.onDeviceMotionChange = tt.onDeviceMotionChange;
platform_1$8.platform.offDeviceMotionChange = tt.offDeviceMotionChange;

var core = {};

var eventIniter = {};

var touchEvent = {};

var document = {};

var body = {};

var htmlElement = {};

var mixin = {};

var screen = {};

Object.defineProperty(screen, "__esModule", { value: true });
screen.screen = void 0;
var platform_1$7 = platform$1;
var _a = platform_1$7.platform.getSystemInfoSync(), screenWidth = _a.screenWidth, screenHeight = _a.screenHeight, windowWidth = _a.windowWidth, windowHeight = _a.windowHeight;
screen.screen = {
    width: screenWidth,
    height: screenHeight,
    availWidth: windowWidth,
    availHeight: windowHeight,
    availLeft: 0,
    availTop: 0,
};

var noop$2 = {};

Object.defineProperty(noop$2, "__esModule", { value: true });
noop$2.noop = void 0;
function noop$1() { }
noop$2.noop = noop$1;

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(mixin, "__esModule", { value: true });
mixin.classList = mixin.scrollRegion = mixin.offsetRegion = mixin.clientRegion = mixin.style = mixin.parentNode = void 0;
var screen_1 = screen;
var document_1$6 = document;
var noop_1$1 = noop$2;
var innerWidth = screen_1.screen.availWidth, innerHeight = screen_1.screen.availHeight;
function parentNode(obj, level) {
    if (!('parentNode' in obj)) {
        var parent_1;
        if (level === 0) {
            parent_1 = function () {
                return null;
            };
        }
        else if (level === 1) {
            parent_1 = function () {
                return document_1$6.document.documentElement;
            };
        }
        else {
            parent_1 = function () {
                return document_1$6.document.body;
            };
        }
        Object.defineProperty(obj, 'parentNode', {
            enumerable: true,
            get: parent_1,
        });
    }
    if (!('parentElement' in obj)) {
        var parent_2;
        if (level === 0) {
            parent_2 = function () {
                return null;
            };
        }
        else if (level === 1) {
            parent_2 = function () {
                return document_1$6.document.documentElement;
            };
        }
        else {
            parent_2 = function () {
                return document_1$6.document.body;
            };
        }
        Object.defineProperty(obj, 'parentElement', {
            enumerable: true,
            get: parent_2,
        });
    }
}
mixin.parentNode = parentNode;
function style(obj) {
    var _a;
    obj.style = __assign(__assign({}, ((_a = obj.style) !== null && _a !== void 0 ? _a : {})), { top: '0px', left: '0px', width: innerWidth + 'px', height: innerHeight + 'px', margin: '0px', padding: '0px' });
}
mixin.style = style;
function clientRegion(obj) {
    if (!('clientLeft' in obj)) {
        obj.clientLeft = 0;
        obj.clientTop = 0;
    }
    if (!('clientWidth' in obj)) {
        obj.clientWidth = innerWidth;
        obj.clientHeight = innerHeight;
    }
    if (!('getBoundingClientRect' in obj)) {
        obj.getBoundingClientRect = function () {
            return {
                x: 0,
                y: 0,
                top: obj.top || 0,
                left: obj.left || 0,
                width: this.clientWidth,
                height: this.clientHeight,
                right: this.clientWidth,
                bottom: this.clientHeight,
            };
        };
    }
}
mixin.clientRegion = clientRegion;
function offsetRegion(obj) {
    if (!('offsetLeft' in obj)) {
        obj.offsetLeft = 0;
        obj.offsetTop = 0;
    }
    if (!('offsetWidth' in obj)) {
        obj.offsetWidth = innerWidth;
        obj.offsetHeight = innerHeight;
    }
}
mixin.offsetRegion = offsetRegion;
function scrollRegion(obj) {
    if (!('scrollLeft' in obj)) {
        obj.scrollLeft = 0;
        obj.scrollTop = 0;
    }
    if (!('scrollWidth' in obj)) {
        obj.scrollWidth = innerWidth;
        obj.scrollHeight = innerHeight;
    }
}
mixin.scrollRegion = scrollRegion;
function classList(obj) {
    obj.classList = [];
    obj.classList.add = noop_1$1.noop;
    obj.classList.remove = noop_1$1.noop;
    obj.classList.contains = noop_1$1.noop;
    obj.classList.toggle = noop_1$1.noop;
}
mixin.classList = classList;

var element = {};

var node = {};

var eventTarget = {};

Object.defineProperty(eventTarget, "__esModule", { value: true });
eventTarget.EventTarget = void 0;
var eventMap = new WeakMap();
var EventTarget = /** @class */ (function () {
    function EventTarget() {
        eventMap.set(this, {});
    }
    EventTarget.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        var events = eventMap.get(this);
        if (!events) {
            events = {};
        }
        if (!events[type]) {
            events[type] = [];
        }
        events[type].push(listener);
        eventMap.set(this, events);
        if (options.capture) ;
        if (options.once) ;
        if (options.passive) ;
    };
    EventTarget.prototype.removeEventListener = function (type, listener, options) {
        var events = eventMap.get(this);
        if (events) {
            var listeners = events[type];
            if (listeners && listeners.length > 0) {
                for (var i = listeners.length; i--; i > 0) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        }
    };
    EventTarget.prototype.dispatchEvent = function (event) {
        var listeners = eventMap.get(this)[event.type];
        if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
                listeners[i](event);
            }
        }
    };
    return EventTarget;
}());
eventTarget.EventTarget = EventTarget;

var __extends$b = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(node, "__esModule", { value: true });
node.Node = void 0;
var event_target_1$1 = eventTarget;
var Node$1 = /** @class */ (function (_super) {
    __extends$b(Node, _super);
    function Node() {
        var _this = _super.call(this) || this;
        _this.childNodes = [];
        return _this;
    }
    Node.prototype.appendChild = function (node) {
        this.childNodes.push(node);
        // if (node instanceof Node) {
        //   this.childNodes.push(node)
        // } else {
        //   throw new TypeError('Failed to executed \'appendChild\' on \'Node\': parameter 1 is not of type \'Node\'.')
        // }
    };
    Node.prototype.cloneNode = function () {
        var copyNode = Object.create(this);
        Object.assign(copyNode, this);
        return copyNode;
    };
    Node.prototype.removeChild = function (node) {
        var index = this.childNodes.findIndex(function (child) { return child === node; });
        if (index > -1) {
            return this.childNodes.splice(index, 1);
        }
        return null;
    };
    return Node;
}(event_target_1$1.EventTarget));
node.Node = Node$1;

var __extends$a = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(element, "__esModule", { value: true });
element.Element = void 0;
var node_1 = node;
var Element = /** @class */ (function (_super) {
    __extends$a(Element, _super);
    function Element() {
        var _this = _super.call(this) || this;
        _this.className = '';
        _this.children = [];
        return _this;
    }
    Element.prototype.setAttribute = function (name, value) {
        this[name] = value;
    };
    Element.prototype.getAttribute = function (name) {
        return this[name];
    };
    Element.prototype.setAttributeNS = function (name, value) {
        this[name] = value;
    };
    Element.prototype.getAttributeNS = function (name) {
        return this[name];
    };
    return Element;
}(node_1.Node));
element.Element = Element;

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding$1 = (undefined && undefined.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (undefined && undefined.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(htmlElement, "__esModule", { value: true });
htmlElement.HTMLElement = void 0;
var Mixin$1 = __importStar$1(mixin);
var noop_1 = noop$2;
var element_1 = element;
var HTMLElement = /** @class */ (function (_super) {
    __extends$9(HTMLElement, _super);
    function HTMLElement(tagName, level) {
        if (tagName === void 0) { tagName = ''; }
        var _this = _super.call(this) || this;
        _this.className = '';
        _this.children = [];
        _this.focus = noop_1.noop;
        _this.blur = noop_1.noop;
        _this.insertBefore = noop_1.noop;
        _this.appendChild = noop_1.noop;
        _this.removeChild = noop_1.noop;
        _this.remove = noop_1.noop;
        _this.innerHTML = '';
        _this.tagName = tagName.toUpperCase();
        Mixin$1.parentNode(_this, level);
        Mixin$1.style(_this);
        Mixin$1.classList(_this);
        Mixin$1.clientRegion(_this);
        Mixin$1.offsetRegion(_this);
        Mixin$1.scrollRegion(_this);
        return _this;
    }
    return HTMLElement;
}(element_1.Element));
htmlElement.HTMLElement = HTMLElement;
// eslint-disable-next-line compat/compat
Object.defineProperty(HTMLElement, Symbol.hasInstance, {
    value: function (instance) {
        return (instance === null || instance === void 0 ? void 0 : instance.tagName) === 'BODY';
    },
});

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(body, "__esModule", { value: true });
body.Body = void 0;
var html_element_1$2 = htmlElement;
var document_1$5 = document;
var Body = /** @class */ (function (_super) {
    __extends$8(Body, _super);
    function Body() {
        // 为了性能, 此处不按照标准的 DOM 层级关系设计
        // 将 body 设置为 0 级, parent 元素为 null
        return _super.call(this, 'body', 0) || this;
    }
    Body.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        document_1$5.document.addEventListener(type, listener, options);
    };
    Body.prototype.removeEventListener = function (type, listener) {
        document_1$5.document.removeEventListener(type, listener);
    };
    Body.prototype.dispatchEvent = function (event) {
        document_1$5.document.dispatchEvent(event);
    };
    return Body;
}(html_element_1$2.HTMLElement));
body.Body = Body;

var htmlVideoElement = {};

var htmlMediaElement = {};

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(htmlMediaElement, "__esModule", { value: true });
htmlMediaElement.HTMLMediaElement = void 0;
var html_element_1$1 = htmlElement;
var HTMLMediaElement = /** @class */ (function (_super) {
    __extends$7(HTMLMediaElement, _super);
    function HTMLMediaElement(tagName) {
        return _super.call(this, tagName) || this;
    }
    HTMLMediaElement.prototype.addTextTrack = function () { };
    HTMLMediaElement.prototype.captureStream = function () { };
    HTMLMediaElement.prototype.fastSeek = function () { };
    HTMLMediaElement.prototype.load = function () { };
    HTMLMediaElement.prototype.pause = function () { };
    HTMLMediaElement.prototype.play = function () { };
    return HTMLMediaElement;
}(html_element_1$1.HTMLElement));
htmlMediaElement.HTMLMediaElement = HTMLMediaElement;

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(htmlVideoElement, "__esModule", { value: true });
htmlVideoElement.HTMLVideoElement = void 0;
var html_media_element_1$1 = htmlMediaElement;
var HTMLVideoElement = /** @class */ (function (_super) {
    __extends$6(HTMLVideoElement, _super);
    // srcObject: any;
    // videoContext: any;
    //
    function HTMLVideoElement() {
        return _super.call(this, 'video') || this;
        // this.videoContext = platform.createVideoContext('GEVideo');
    }
    return HTMLVideoElement;
}(html_media_element_1$1.HTMLMediaElement));
htmlVideoElement.HTMLVideoElement = HTMLVideoElement;

var image = {};

var constructor = {};

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(constructor, "__esModule", { value: true });
constructor.HTMLAudioElement = constructor.HTMLCanvasElement = constructor.HTMLImageElement = void 0;
var html_element_1 = htmlElement;
var html_media_element_1 = htmlMediaElement;
var HTMLImageElement = /** @class */ (function (_super) {
    __extends$5(HTMLImageElement, _super);
    function HTMLImageElement() {
        return _super.call(this, 'img') || this;
    }
    return HTMLImageElement;
}(html_element_1.HTMLElement));
constructor.HTMLImageElement = HTMLImageElement;
// eslint-disable-next-line compat/compat
Object.defineProperty(HTMLImageElement, Symbol.hasInstance, {
    value: function (instance) {
        return (instance === null || instance === void 0 ? void 0 : instance.tagName) === 'IMG' || (instance === null || instance === void 0 ? void 0 : instance.crossOrigin);
    },
});
var HTMLCanvasElement = /** @class */ (function (_super) {
    __extends$5(HTMLCanvasElement, _super);
    function HTMLCanvasElement() {
        return _super.call(this, 'canvas') || this;
    }
    return HTMLCanvasElement;
}(html_element_1.HTMLElement));
constructor.HTMLCanvasElement = HTMLCanvasElement;
var HTMLAudioElement = /** @class */ (function (_super) {
    __extends$5(HTMLAudioElement, _super);
    function HTMLAudioElement() {
        return _super.call(this, 'audio') || this;
    }
    return HTMLAudioElement;
}(html_media_element_1.HTMLMediaElement));
constructor.HTMLAudioElement = HTMLAudioElement;

var register$1 = {};

var __createBinding = (undefined && undefined.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (undefined && undefined.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(register$1, "__esModule", { value: true });
register$1.isMiniGame = register$1.getCanvas = register$1.registerOffscreenCanvas = register$1.registerCanvas = void 0;
var platform_1$6 = platform$1;
var document_1$4 = document;
var Mixin = __importStar(mixin);
// 同步和异步都需要的数据
var canvas = {};
var _isMiniGame = false;
/**
 * 异步注册 canvas
 * @param options
 * @returns
 */
function registerCanvas() {
    return __awaiter(this, arguments, void 0, function (options) {
        var _a, id, _b, isMiniGame, _c, elementLevel;
        if (options === void 0) { options = {}; }
        return __generator$1(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = options.id, id = _a === void 0 ? 'J-canvas' : _a, _b = options.isMiniGame, isMiniGame = _b === void 0 ? false : _b, _c = options.elementLevel, elementLevel = _c === void 0 ? 0 : _c;
                    if (!(typeof id === 'string')) return [3 /*break*/, 4];
                    if (!isMiniGame) return [3 /*break*/, 1];
                    canvas = platform_1$6.platform.createCanvas();
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, getCanvasById(id)];
                case 2:
                    canvas = _d.sent();
                    _d.label = 3;
                case 3: return [3 /*break*/, 5];
                case 4:
                    canvas = id;
                    canvas.id = id;
                    _d.label = 5;
                case 5:
                    registerOffscreenCanvas(canvas, elementLevel);
                    _isMiniGame = isMiniGame;
                    return [2 /*return*/, canvas];
            }
        });
    });
}
register$1.registerCanvas = registerCanvas;
/**
 * 异步注册 canvas
 * @param options
 * @returns
 */
function registerOffscreenCanvas(canvas, elementLevel) {
    if (!('tagName' in canvas)) {
        canvas.tagName = 'CANVAS';
    }
    canvas.type = 'canvas';
    canvas.width = canvas.width * 2;
    canvas.height = canvas.height * 2;
    Mixin.parentNode(canvas, elementLevel !== null && elementLevel !== void 0 ? elementLevel : 0);
    Mixin.style(canvas);
    Mixin.classList(canvas);
    Mixin.offsetRegion(canvas);
    canvas.focus = function () { };
    canvas.blur = function () { };
    canvas.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        document_1$4.document.addEventListener(type, listener, options);
    };
    canvas.removeEventListener = function (type, listener) {
        document_1$4.document.removeEventListener(type, listener);
    };
    canvas.dispatchEvent = function (event) {
        document_1$4.document.dispatchEvent(event);
    };
    return canvas;
}
register$1.registerOffscreenCanvas = registerOffscreenCanvas;
function getCanvasById(id) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator$1(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    platform_1$6.platform.createSelectorQuery()
                        // @ts-expect-error
                        .select(id).node()
                        .select(id).boundingClientRect()
                        // @ts-expect-error
                        .exec(function (res) {
                        try {
                            var canvas_1 = res[0].node;
                            var rect_1 = res[1];
                            if (canvas_1) {
                                canvas_1.getBoundingClientRect = function () { return rect_1; };
                                resolve(canvas_1);
                            }
                            else {
                                reject("create canvas fail, canvas is ".concat(canvas_1));
                            }
                        }
                        catch (e) {
                            reject("Cannot find canvas by id: ".concat(id, ", ").concat(e));
                        }
                    });
                })];
        });
    });
}
/**
 * 获取 canvas
 * @returns
 */
function getCanvas() {
    return canvas;
}
register$1.getCanvas = getCanvas;
function isMiniGame() {
    return _isMiniGame;
}
register$1.isMiniGame = isMiniGame;

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(image, "__esModule", { value: true });
image.Image = void 0;
var constructor_1 = constructor;
var platform_1$5 = platform$1;
var register_1$4 = register$1;
var Image = /** @class */ (function (_super) {
    __extends$4(Image, _super);
    function Image() {
        var _a, _b;
        var _this = _super.call(this) || this;
        if ((0, register_1$4.isMiniGame)()) {
            _this.image = platform_1$5.platform.createImage();
        }
        else {
            var canvas = (0, register_1$4.getCanvas)();
            _this.image = (_b = (_a = canvas.createImage) === null || _a === void 0 ? void 0 : _a.call(canvas)) !== null && _b !== void 0 ? _b : {};
        }
        _this.image.constructor = Image;
        return _this.image;
    }
    return Image;
}(constructor_1.HTMLImageElement));
image.Image = Image;

(function (exports) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.document = void 0;
var platform_1 = platform$1;
var body_1 = body;
var html_element_1 = htmlElement;
var html_video_element_1 = htmlVideoElement;
var image_1 = image;
var register_1 = register$1;
var DocumentElement = /** @class */ (function (_super) {
    __extends(DocumentElement, _super);
    function DocumentElement() {
        return _super.call(this, 'html', 0) || this;
    }
    DocumentElement.prototype.addEventListener = function (type, listener, options) {
        if (options === void 0) { options = {}; }
        exports.document.addEventListener(type, listener, options);
    };
    DocumentElement.prototype.removeEventListener = function (type, listener) {
        exports.document.removeEventListener(type, listener);
    };
    DocumentElement.prototype.dispatchEvent = function (event) {
        exports.document.dispatchEvent(event);
    };
    return DocumentElement;
}(html_element_1.HTMLElement));
var events = {};
exports.document = {
    readyState: 'complete',
    visibilityState: 'visible', // 'visible' , 'hidden'
    hidden: false,
    fullscreen: true,
    scripts: [],
    style: {},
    ontouchstart: null,
    ontouchmove: null,
    ontouchend: null,
    onvisibilitychange: null,
    parentNode: null,
    parentElement: null,
    head: null,
    body: null,
    documentElement: null,
    createElement: function (tagName) {
        tagName = tagName.toLowerCase();
        if (tagName === 'canvas') {
            if ((0, register_1.isMiniGame)()) {
                var canvas = platform_1.platform.createCanvas();
                // 小游戏适配
                canvas.addEventListener = function (type, listener, options) {
                    if (options === void 0) { options = {}; }
                    exports.document.addEventListener(type, listener, options);
                };
                canvas.removeEventListener = function (type, listener) {
                    exports.document.removeEventListener(type, listener);
                };
                canvas.dispatchEvent = function (event) {
                    exports.document.dispatchEvent(event);
                };
                return canvas;
            }
            else {
                var canvas = platform_1.platform.createOffscreenCanvas({ type: '2d' });
                (0, register_1.registerOffscreenCanvas)(canvas);
                return canvas;
            }
        }
        else if (tagName === 'img') {
            return new image_1.Image();
        }
        else if (tagName === 'video') {
            return new html_video_element_1.HTMLVideoElement();
        }
        return new html_element_1.HTMLElement(tagName);
    },
    createElementNS: function (nameSpace, tagName) {
        return this.createElement(tagName);
    },
    createTextNode: function (text) {
        // TODO: Do we need the TextNode Class ???
        return text;
    },
    getElementById: function (id) {
        var canvas = (0, register_1.getCanvas)();
        if (id === canvas.id) {
            return canvas;
        }
        else {
            return null;
        }
    },
    getElementsByTagName: function (tagName) {
        tagName = tagName.toLowerCase();
        if (tagName === 'head') {
            return [exports.document.head];
        }
        else if (tagName === 'body') {
            return [exports.document.body];
        }
        else if (tagName === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    getElementsByTagNameNS: function (nameSpace, tagName) {
        return this.getElementsByTagName(tagName);
    },
    getElementsByName: function (tagName) {
        if (tagName === 'head') {
            return [exports.document.head];
        }
        else if (tagName === 'body') {
            return [exports.document.body];
        }
        else if (tagName === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    querySelector: function (query) {
        var canvas = (0, register_1.getCanvas)();
        if (query === 'head') {
            return exports.document.head;
        }
        else if (query === 'body') {
            return exports.document.body;
        }
        else if (query === 'canvas') {
            return canvas;
        }
        else if (query === "#".concat(canvas.id)) {
            return canvas;
        }
        return null;
    },
    querySelectorAll: function (query) {
        if (query === 'head') {
            return [exports.document.head];
        }
        else if (query === 'body') {
            return [exports.document.body];
        }
        else if (query === 'canvas') {
            return [(0, register_1.getCanvas)()];
        }
        return [];
    },
    addEventListener: function (type, listener, options) {
        if (!events[type]) {
            events[type] = [];
        }
        events[type].push(listener);
    },
    removeEventListener: function (type, listener) {
        var listeners = events[type];
        if (listeners && listeners.length > 0) {
            for (var i = listeners.length; i--; i > 0) {
                if (listeners[i] === listener) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    },
    dispatchEvent: function (event) {
        var type = event.type;
        var listeners = events[type];
        if (listeners) {
            for (var i = 0; i < listeners.length; i++) {
                listeners[i](event);
            }
        }
        if (event.target && typeof event.target['on' + type] === 'function') {
            event.target['on' + type](event);
        }
    },
};
exports.document.documentElement = new DocumentElement();
exports.document.head = new html_element_1.HTMLElement('head');
exports.document.body = new body_1.Body();
}(document));

var event = {};

Object.defineProperty(event, "__esModule", { value: true });
event.Event = void 0;
var Event = /** @class */ (function () {
    function Event(type) {
        this.cancelBubble = false;
        this.cancelable = false;
        this.target = null;
        this.currentTarget = null;
        this.preventDefault = function () { };
        this.stopPropagation = function () { };
        this.type = type;
        this.timeStamp = Date.now();
    }
    return Event;
}());
event.Event = Event;

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(touchEvent, "__esModule", { value: true });
touchEvent.dispatchTouchCancel = touchEvent.dispatchTouchEnd = touchEvent.dispatchTouchMove = touchEvent.dispatchTouchStart = void 0;
var document_1$3 = document;
var event_1$1 = event;
var register_1$3 = register$1;
var TouchEvent = /** @class */ (function (_super) {
    __extends$3(TouchEvent, _super);
    function TouchEvent(type) {
        var _this = _super.call(this, type) || this;
        _this.touches = [];
        _this.targetTouches = [];
        _this.changedTouches = [];
        _this.target = (0, register_1$3.getCanvas)();
        _this.currentTarget = (0, register_1$3.getCanvas)();
        return _this;
    }
    return TouchEvent;
}(event_1$1.Event));
function mapEvent(event) {
    var _a = event || {}, _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c, _d = _a.clientX, clientX = _d === void 0 ? 0 : _d, _e = _a.clientY, clientY = _e === void 0 ? 0 : _e;
    // 小程序不支持Object.hasOwnProperty
    // (抹平不同的view事件)[https://docs.alipay.com/mini/framework/event-object]
    if (Object.keys(event).includes('x')) {
        event.pageX = event.clientX = x;
        event.pageY = event.clientY = y;
    }
    else {
        event.x = clientX;
        event.y = clientY;
    }
    if (!event.target) {
        event.target = (0, register_1$3.getCanvas)();
    }
}
function eventHandlerFactory$2(type) {
    return function (rawEvent) {
        var event = new TouchEvent(type);
        event.changedTouches = rawEvent.changedTouches || rawEvent.touches;
        event.touches = rawEvent.touches;
        event.targetTouches = Array.prototype.slice.call(rawEvent.touches);
        event.timeStamp = rawEvent.timeStamp;
        event.changedTouches.forEach(function (e) { return mapEvent(e); });
        event.touches.forEach(function (e) { return mapEvent(e); });
        event.targetTouches.forEach(function (e) { return mapEvent(e); });
        document_1$3.document.dispatchEvent(event);
    };
}
var dispatchTouchStart = eventHandlerFactory$2('touchstart');
touchEvent.dispatchTouchStart = dispatchTouchStart;
var dispatchTouchMove = eventHandlerFactory$2('touchmove');
touchEvent.dispatchTouchMove = dispatchTouchMove;
var dispatchTouchEnd = eventHandlerFactory$2('touchend');
touchEvent.dispatchTouchEnd = dispatchTouchEnd;
var dispatchTouchCancel = eventHandlerFactory$2('touchcancel');
touchEvent.dispatchTouchCancel = dispatchTouchCancel;

var pointerEvent = {};

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(pointerEvent, "__esModule", { value: true });
pointerEvent.dispatchPointerCancel = pointerEvent.dispatchPointerLeave = pointerEvent.dispatchPointerUp = pointerEvent.dispatchPointerMove = pointerEvent.dispatchPointerDown = void 0;
var event_1 = event;
var register_1$2 = register$1;
var document_1$2 = document;
var PointerEvent = /** @class */ (function (_super) {
    __extends$2(PointerEvent, _super);
    function PointerEvent(type) {
        var _this = _super.call(this, type) || this;
        _this.target = (0, register_1$2.getCanvas)();
        _this.currentTarget = (0, register_1$2.getCanvas)();
        return _this;
    }
    return PointerEvent;
}(event_1.Event));
var CLONE_PROPS = [
    // MouseEvent
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    // PointerEvent
    'pointerId',
    'width',
    'height',
    'pressure',
    'tiltX',
    'tiltY',
    'pointerType',
    'hwTimestamp',
    'isPrimary',
    // event instance
    'pageX',
    'pageY',
    'timeStamp',
];
var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    // DOM Level 3
    0,
    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    '',
    0,
    false,
    // event instance
    0,
    0,
    0,
];
var POINTER_TYPE = 'touch';
function touchToPointer(type, touch) {
    var e = new PointerEvent(type);
    for (var i = 0; i < CLONE_PROPS.length; i++) {
        var p = CLONE_PROPS[i];
        e[p] = touch[p] || CLONE_DEFAULTS[i];
    }
    e.type = type;
    e.target = (0, register_1$2.getCanvas)();
    e.currentTarget = (0, register_1$2.getCanvas)();
    e.buttons = typeToButtons(type);
    e.which = e.buttons;
    e.pointerId = (touch.identifier || 0) + 2;
    e.bubbles = true;
    e.cancelable = true; // e.detail = this.clickCount;
    e.button = 0;
    e.width = (touch.radiusX || 0.5) * 2;
    e.height = (touch.radiusY || 0.5) * 2;
    e.pressure = touch.force || 0.5;
    e.isPrimary = isPrimaryPointer(touch);
    e.pointerType = POINTER_TYPE; // forward modifier keys
    // @ts-expect-error
    e.offsetX = touch.pageX || touch.x;
    // @ts-expect-error
    e.offsetY = touch.pageY || touch.y;
    return e;
}
function typeToButtons(type) {
    var ret = 0;
    if (type === 'touchstart' || type === 'touchmove' || type === 'pointerdown' || type === 'pointermove') {
        ret = 1;
    }
    return ret;
}
var firstPointer = null;
function isPrimaryPointer(touch) {
    return firstPointer === touch.identifier;
}
function setPrimaryPointer(touch) {
    if (firstPointer === null) {
        firstPointer = touch.identifier;
    }
}
function removePrimaryPointer(touch) {
    if (firstPointer === touch.identifier) {
        firstPointer = null;
    }
}
function eventHandlerFactory$1(type) {
    return function (rawEvent) {
        var changedTouches = rawEvent.changedTouches || rawEvent.touches;
        for (var i = 0; i < changedTouches.length; i++) {
            var touch = changedTouches[i];
            switch (type) {
                case 'pointerdown':
                    i === 0 && setPrimaryPointer(touch);
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointermove':
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointerup':
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
                case 'pointerleave':
                case 'pointercancel':
                    removePrimaryPointer(touch);
                    document_1$2.document.dispatchEvent(touchToPointer(type, touch));
                    break;
            }
        }
    };
}
var dispatchPointerDown = eventHandlerFactory$1('pointerdown');
pointerEvent.dispatchPointerDown = dispatchPointerDown;
var dispatchPointerMove = eventHandlerFactory$1('pointermove');
pointerEvent.dispatchPointerMove = dispatchPointerMove;
var dispatchPointerUp = eventHandlerFactory$1('pointerup');
pointerEvent.dispatchPointerUp = dispatchPointerUp;
var dispatchPointerLeave = eventHandlerFactory$1('pointerleave');
pointerEvent.dispatchPointerLeave = dispatchPointerLeave;
var dispatchPointerCancel = eventHandlerFactory$1('pointercancel');
pointerEvent.dispatchPointerCancel = dispatchPointerCancel;

var mouseEvent = {};

Object.defineProperty(mouseEvent, "__esModule", { value: true });
mouseEvent.dispatchMouseUp = mouseEvent.dispatchMouseMove = mouseEvent.dispatchMouseDown = void 0;
var document_1$1 = document;
// class MouseEvent extends Event {
//   constructor (type: string) {
//     super(type);
//   }
// }
function eventHandlerFactory(type) {
    return function (rawEvent) {
        rawEvent.type = type;
        document_1$1.document.dispatchEvent(rawEvent);
    };
}
var dispatchMouseDown = eventHandlerFactory('mousedown');
mouseEvent.dispatchMouseDown = dispatchMouseDown;
var dispatchMouseMove = eventHandlerFactory('mousemove');
mouseEvent.dispatchMouseMove = dispatchMouseMove;
var dispatchMouseUp = eventHandlerFactory('mouseup');
mouseEvent.dispatchMouseUp = dispatchMouseUp;

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(touchEvent, exports);
__exportStar(pointerEvent, exports);
__exportStar(mouseEvent, exports);
}(eventIniter));

var accelerometer = {};

Object.defineProperty(accelerometer, "__esModule", { value: true });
accelerometer.Accelerometer = void 0;
var platform_1$4 = platform$1;
var document_1 = document;
var Accelerometer = /** @class */ (function () {
    function Accelerometer() {
    }
    Accelerometer.prototype.handleDeviceMotionChange = function (event) {
        document_1.document.dispatchEvent({
            alpha: event.alpha,
            gamma: event.gamma,
            beta: -event.beta,
            type: 'deviceorientation',
        });
    };
    Accelerometer.prototype.startWatch = function (interval) {
        var _this = this;
        if (interval === void 0) { interval = 'ui'; }
        platform_1$4.platform.startDeviceMotionListening({
            interval: interval,
            success: function () {
                platform_1$4.platform.onDeviceMotionChange(_this.handleDeviceMotionChange);
            },
        });
    };
    Accelerometer.prototype.stopWatch = function () {
        platform_1$4.platform.offDeviceMotionChange(this.handleDeviceMotionChange);
    };
    return Accelerometer;
}());
accelerometer.Accelerometer = Accelerometer;

var atob$1 = {};

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(atob$1, "__esModule", { value: true });
atob$1.btoa = atob$1.atob = void 0;
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var InvalidCharacterError = /** @class */ (function (_super) {
    __extends$1(InvalidCharacterError, _super);
    function InvalidCharacterError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = 'InvalidCharacterError';
        return _this;
    }
    return InvalidCharacterError;
}(Error));
function atob(input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 === 1) {
        throw new InvalidCharacterError('\'atob\' failed: The string to be decoded is not correctly encoded.');
    }
    var output = '';
    for (
    // initialize result and counters
    var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
    // get next character
    (buffer = str.charAt(idx++)); 
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer &&
        (
        // @ts-expect-error
        (bs = bc % 4 ? bs * 64 + buffer : buffer),
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4)
        ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
        : 0) {
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
    }
    return output;
}
atob$1.atob = atob;
function btoa(string) {
    string = String(string);
    var bitmap;
    var a;
    var b;
    var c;
    var result = '';
    var i = 0;
    var rest = string.length % 3; // To determine the final padding
    for (; i < string.length;) {
        if ((a = string.charCodeAt(i++)) > 255 || (b = string.charCodeAt(i++)) > 255 || (c = string.charCodeAt(i++)) > 255) {
            throw new TypeError('Failed to execute \'btoa\' on \'Window\': The string to be encoded contains characters outside of the Latin1 range.');
        }
        bitmap = (a << 16) | (b << 8) | c;
        result +=
            chars.charAt((bitmap >> 18) & 63) +
                chars.charAt((bitmap >> 12) & 63) +
                chars.charAt((bitmap >> 6) & 63) +
                chars.charAt(bitmap & 63);
    }
    // If there's need of padding, replace the last 'A's with equal signs
    return rest ? result.slice(0, rest - 3) + '==='.substring(rest) : result;
}
atob$1.btoa = btoa;

var blob = {};

Object.defineProperty(blob, "__esModule", { value: true });
blob.Blob = void 0;
var Blob = /** @class */ (function () {
    /**
     *
     * @param buffers only support zero index
     * @param type mimetype image/png image/webp...
     */
    function Blob(buffers, type) {
        if (type === void 0) { type = 'image/png'; }
        this.buffers = buffers;
        this.type = type;
    }
    Blob.prototype.arraybuffer = function () {
        return Promise.resolve(this.buffers[0]);
    };
    Blob.prototype.stream = function () {
        throw 'not implemented';
    };
    Blob.prototype.text = function () {
        throw 'not implemented';
    };
    Blob.prototype.slice = function (start, end, contentType) {
        throw 'not implemented';
    };
    return Blob;
}());
blob.Blob = Blob;

var devicePixelRatio = {};

Object.defineProperty(devicePixelRatio, "__esModule", { value: true });
devicePixelRatio.devicePixelRatio = void 0;
var platform_1$3 = platform$1;
devicePixelRatio.devicePixelRatio = platform_1$3.platform.getSystemInfoSync().pixelRatio;

var imageData = {};

Object.defineProperty(imageData, "__esModule", { value: true });
imageData.ImageData = void 0;
var ImageData = /** @class */ (function () {
    function ImageData() {
        var len = arguments.length;
        if (len == 2) {
            if (typeof arguments[0] == 'number' && typeof arguments[1] == 'number') {
                this.w = arguments[0];
                this.h = arguments[1];
                this.d = new Uint8ClampedArray(this.w * this.h * 4);
                return;
            }
        }
        else if (len == 3) {
            if (typeof arguments[0] == 'object' && typeof arguments[1] == 'number' && typeof arguments[2] == 'number') {
                this.d = arguments[0];
                this.w = arguments[1];
                this.h = arguments[2];
            }
        }
        throw new Error('ImageData: params error');
    }
    Object.defineProperty(ImageData.prototype, "width", {
        get: function () {
            return this.w;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageData.prototype, "height", {
        get: function () {
            return this.h;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageData.prototype, "data", {
        get: function () {
            return this.d;
        },
        enumerable: false,
        configurable: true
    });
    return ImageData;
}());
imageData.ImageData = ImageData;

var location = {};

Object.defineProperty(location, "__esModule", { value: true });
location.location = void 0;
location.location = {
    href: '',
};

var navigator = {};

Object.defineProperty(navigator, "__esModule", { value: true });
navigator.navigator = void 0;
var platform_1$2 = platform$1;
var info$1 = platform_1$2.platform.getSystemInfoSync();
var platform = info$1.platform, language = info$1.language;
var android = platform.toLowerCase().includes('android');
var uaDesc = android ? 'Android; CPU Android 6.0' : 'iPhone; CPU iPhone OS 10_3_1 like Mac OS X';
var ua = "Mozilla/5.0 (".concat(uaDesc, ") AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/").concat(language);
navigator.navigator = {
    platform: platform,
    language: language,
    appVersion: "5.0 (".concat(uaDesc, ") AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1"),
    userAgent: ua,
};

var offscreenCanvas = {};

Object.defineProperty(offscreenCanvas, "__esModule", { value: true });
offscreenCanvas._OffscreenCanvas = void 0;
var platform_1$1 = platform$1;
var register_1$1 = register$1;
// 会导致蒙版失效，暂时不进行 Adapter 操作
var _OffscreenCanvas = /** @class */ (function () {
    function _OffscreenCanvas(width, height) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        var canvas;
        if ((0, register_1$1.isMiniGame)()) {
            canvas = platform_1$1.platform.createCanvas();
            canvas.width = width;
            canvas.height = height;
        }
        else {
            canvas = platform_1$1.platform.createOffscreenCanvas({ width: width, height: height });
        }
        return canvas;
    }
    return _OffscreenCanvas;
}());
offscreenCanvas._OffscreenCanvas = _OffscreenCanvas;

var performance$1 = {};

Object.defineProperty(performance$1, "__esModule", { value: true });
performance$1.performance = void 0;
var performance = /** @class */ (function () {
    function performance() {
    }
    performance.now = function () {
        return Date.now();
    };
    performance.clearMarks = function () { };
    performance.clearMeasures = function () { };
    performance.clearResourceTimings = function () { };
    performance.getEntries = function () { };
    performance.getEntriesByName = function () { };
    performance.getEntriesByType = function () { };
    performance.mark = function () { };
    performance.measure = function () { };
    performance.setResourceTimingBufferSize = function () { };
    performance.toJSON = function () { };
    performance.eventCounts = 0;
    performance.timeOrigin = 0;
    return performance;
}());
performance$1.performance = performance;

var requestAnimationFrame$1 = {};

Object.defineProperty(requestAnimationFrame$1, "__esModule", { value: true });
requestAnimationFrame$1.cancelAnimationFrame = requestAnimationFrame$1.requestAnimationFrame = void 0;
var register_1 = register$1;
var lastTime = 0;
var id = 0;
function hack(cb) {
    var now = Date.now();
    var nextTime = Math.max(lastTime + 23, now);
    id = setTimeout(function () {
        cb((lastTime = nextTime));
    }, nextTime - now);
    return id;
}
function requestAnimationFrame(cb) {
    var canvas = (0, register_1.getCanvas)();
    if (canvas.requestAnimationFrame) {
        return canvas.requestAnimationFrame(cb);
    }
    else {
        return hack(cb);
    }
}
requestAnimationFrame$1.requestAnimationFrame = requestAnimationFrame;
function cancelAnimationFrame(id) {
    var canvas = (0, register_1.getCanvas)();
    if (canvas.cancelAnimationFrame) {
        return canvas.cancelAnimationFrame(id);
    }
    else {
        return clearTimeout(id);
    }
}
requestAnimationFrame$1.cancelAnimationFrame = cancelAnimationFrame;

var url = {};

Object.defineProperty(url, "__esModule", { value: true });
url.URL = void 0;
var atob_1 = atob$1;
var URL = /** @class */ (function () {
    // todo: 完善URL对象
    function URL(url, host) {
        if (host === void 0) { host = ''; }
        // 如果 URL 是绝对的，则直接使用它
        if (url.indexOf('http://') == 0 || url.indexOf('https://') == 0) {
            this.href = url;
            return;
        }
        // 如果是相对地址
        // 移除基础 URL 的文件名部分（如果有）
        host = host.substring(0, host.lastIndexOf('/') + 1);
        // 移除相对 URL 的 "./" 部分（如果有）
        url = url.startsWith('./') ? url.substring(2) : url;
        // 拼接两个部分以构建绝对 URL
        this.href = host + url;
    }
    /**
     * fake createObject, use base64 instead
     * @param blob
     */
    URL.createObjectURL = function (blob) {
        var buffer = blob.buffers[0];
        var type = typeof blob.type === 'object' ? blob.type.type : blob.type;
        var base64 = _arrayBufferToBase64(buffer);
        var prefix = "data:".concat(type, ";base64,");
        return prefix + base64;
    };
    URL.revokeObjectURL = function () {
    };
    return URL;
}());
url.URL = URL;
function _arrayBufferToBase64(buffer) {
    var binary = '';
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return (0, atob_1.btoa)(binary);
}

var xmlHttpRequest = {};

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(xmlHttpRequest, "__esModule", { value: true });
xmlHttpRequest.XMLHttpRequest = void 0;
// @ts-nocheck
var platform_1 = platform$1;
var event_target_1 = eventTarget;
var _requestHeader = new WeakMap();
var _responseHeader = new WeakMap();
var _requestTask = new WeakMap();
var contentTypes = {
    json: 'application/json',
    text: 'application/text',
    arraybuffer: 'application/octet-stream',
};
function _triggerEvent(type, event) {
    if (event === void 0) { event = {}; }
    event.target = event.target || this;
    if (typeof this["on".concat(type)] === 'function') {
        this["on".concat(type)].call(this, event);
    }
}
function _changeReadyState(readyState, event) {
    if (event === void 0) { event = {}; }
    this.readyState = readyState;
    event.readyState = readyState;
    _triggerEvent.call(this, 'readystatechange', event);
}
function _isRelativePath(url) {
    return !/^(http|https|ftp|wxfile):\/\/.*/i.test(url);
}
var XMLHttpRequest = /** @class */ (function (_super) {
    __extends(XMLHttpRequest, _super);
    function XMLHttpRequest() {
        var _this = _super.call(this) || this;
        _this.runtime = platform_1.platform.getSystemInfoSync().platform;
        /*
         * TODO 这一批事件应该是在 XMLHttpRequestEventTarget.prototype 上面的
         */
        _this.onabort = null;
        _this.onerror = null;
        _this.onload = null;
        _this.onloadstart = null;
        _this.onprogress = null;
        _this.ontimeout = null;
        _this.onloadend = null;
        _this.onreadystatechange = null;
        _this.readyState = 0;
        _this.response = null;
        _this.responseText = null;
        _this.responseType = 'text';
        _this.dataType = 'string';
        _this.responseXML = null;
        _this.status = 0;
        _this.statusText = '';
        _this.upload = {};
        _this.withCredentials = false;
        _requestHeader.set(_this, {
            'content-type': 'application/x-www-form-urlencoded',
        });
        _responseHeader.set(_this, {});
        return _this;
    }
    XMLHttpRequest.prototype.abort = function () {
        var myRequestTask = _requestTask.get(this);
        if (myRequestTask) {
            myRequestTask.abort();
        }
    };
    XMLHttpRequest.prototype.getAllResponseHeaders = function () {
        var responseHeader = _responseHeader.get(this);
        return Object.keys(responseHeader)
            .map(function (header) {
            return "".concat(header, ": ").concat(responseHeader[header]);
        })
            .join('\n');
    };
    XMLHttpRequest.prototype.getResponseHeader = function (header) {
        return _responseHeader.get(this)[header];
    };
    /* async, user, password 这几个参数在小程序内不支持 */
    XMLHttpRequest.prototype.open = function (method, url) {
        this._method = method;
        this._url = url;
        _changeReadyState.call(this, XMLHttpRequest.OPENED);
    };
    XMLHttpRequest.prototype.overrideMimeType = function () { };
    XMLHttpRequest.prototype.send = function (data) {
        var _this = this;
        if (data === void 0) { data = ''; }
        if (this.readyState !== XMLHttpRequest.OPENED) {
            throw new Error('Failed to execute \'send\' on \'XMLHttpRequest\': The object\'s state must be OPENED.');
        }
        else {
            var url_1 = this._url;
            var header_1 = _requestHeader.get(this);
            var responseType_1 = this.responseType;
            var dataType_1 = this.dataType;
            if (contentTypes[responseType_1] && !header_1['content-type']) {
                header_1['content-type'] = contentTypes[responseType_1];
            }
            var relative_1 = _isRelativePath(url_1);
            var encoding = void 0;
            if (responseType_1 === 'arraybuffer') {
                // 避免被默认转换为JSON
                dataType_1 = 'arrayBuffer';
            }
            else {
                encoding = 'utf8';
            }
            if (responseType_1 === 'json') {
                dataType_1 = 'json';
                responseType_1 = 'text';
            }
            delete this.response;
            this.response = null;
            var resolved_1 = false;
            var onSuccess_1 = function (_a) {
                var data = _a.data, statusCode = _a.statusCode, header = _a.header;
                // console.log('onSuccess', url);
                if (resolved_1) {
                    return;
                }
                resolved_1 = true;
                statusCode = statusCode === undefined ? 200 : statusCode;
                if (typeof data !== 'string' && !(data instanceof ArrayBuffer) && dataType_1 !== 'json') {
                    try {
                        data = JSON.stringify(data);
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    }
                    catch (e) { /* empty */ }
                }
                _this.status = statusCode;
                if (header) {
                    _responseHeader.set(_this, header);
                }
                _triggerEvent.call(_this, 'loadstart');
                _changeReadyState.call(_this, XMLHttpRequest.HEADERS_RECEIVED);
                _changeReadyState.call(_this, XMLHttpRequest.LOADING);
                _this.response = data;
                if (data instanceof ArrayBuffer) {
                    Object.defineProperty(_this, 'responseText', {
                        enumerable: true,
                        configurable: true,
                        get: function () {
                            throw 'InvalidStateError : responseType is ' + this.responseType;
                        },
                    });
                }
                else {
                    _this.responseText = data;
                }
                _changeReadyState.call(_this, XMLHttpRequest.DONE);
                _triggerEvent.call(_this, 'load');
                _triggerEvent.call(_this, 'loadend');
            };
            var onFail_1 = function (e) {
                var errMsg = e.message || e.errorMessage;
                // TODO 规范错误
                if (resolved_1) {
                    return;
                }
                resolved_1 = true;
                if (errMsg.indexOf('abort') !== -1) {
                    _triggerEvent.call(_this, 'abort');
                }
                else {
                    _triggerEvent.call(_this, 'error', {
                        message: errMsg,
                    });
                }
                _triggerEvent.call(_this, 'loadend');
                if (relative_1) {
                    // 用户即使没监听error事件, 也给出相应的警告
                    console.warn(errMsg);
                }
            };
            if (relative_1) {
                var fs = platform_1.platform.getFileSystemManager();
                var options = {
                    filePath: url_1,
                    success: onSuccess_1,
                    fail: onFail_1,
                };
                if (encoding) {
                    options['encoding'] = encoding;
                }
                fs.readFile(options);
                return;
            }
            // IOS在某些情况下不会触发onSuccess...
            var usePatch = responseType_1 === 'arraybuffer' && this.runtime === 'ios' && XMLHttpRequest.useFetchPatch;
            platform_1.platform.request({
                data: data,
                url: url_1,
                method: this._method.toUpperCase(),
                header: header_1,
                dataType: dataType_1,
                responseType: responseType_1,
                enableCache: false,
                success: onSuccess_1,
                // success: usePatch ? undefined : onSuccess,
                fail: onFail_1,
            });
            if (usePatch) {
                setTimeout(function () {
                    platform_1.platform.request({
                        data: data,
                        url: url_1,
                        method: this._method,
                        header: header_1,
                        dataType: dataType_1,
                        responseType: responseType_1,
                        enableCache: true,
                        success: onSuccess_1,
                        fail: onFail_1,
                    });
                }, XMLHttpRequest.fetchPatchDelay);
            }
        }
    };
    XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
        var myHeader = _requestHeader.get(this);
        myHeader[header] = value;
        _requestHeader.set(this, myHeader);
    };
    XMLHttpRequest.prototype.addEventListener = function (type, listener) {
        var _this = this;
        if (typeof listener !== 'function') {
            return;
        }
        this['on' + type] = function (event) {
            if (event === void 0) { event = {}; }
            event.target = event.target || _this;
            listener.call(_this, event);
        };
    };
    XMLHttpRequest.prototype.removeEventListener = function (type, listener) {
        if (this['on' + type] === listener) {
            this['on' + type] = null;
        }
    };
    return XMLHttpRequest;
}(event_target_1.EventTarget));
xmlHttpRequest.XMLHttpRequest = XMLHttpRequest;
// TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态
XMLHttpRequest.UNSEND = 0;
XMLHttpRequest.OPENED = 1;
XMLHttpRequest.HEADERS_RECEIVED = 2;
XMLHttpRequest.LOADING = 3;
XMLHttpRequest.DONE = 4;
// 某些情况下IOS会不success不触发。。。
XMLHttpRequest.useFetchPatch = false;
XMLHttpRequest.fetchPatchDelay = 200;

var webgl = {};

Object.defineProperty(webgl, "__esModule", { value: true });
webgl.WebGLRenderingContext = void 0;
webgl.WebGLRenderingContext = {
    GCCSO_SHADER_BINARY_FJ: 0x9260,
    _3DC_XY_AMD: 0x87fa,
    _3DC_X_AMD: 0x87f9,
    ACTIVE_ATTRIBUTES: 0x8b89,
    ACTIVE_ATTRIBUTE_MAX_LENGTH: 0x8b8a,
    ACTIVE_PROGRAM_EXT: 0x8259,
    ACTIVE_TEXTURE: 0x84e0,
    ACTIVE_UNIFORMS: 0x8b86,
    ACTIVE_UNIFORM_MAX_LENGTH: 0x8b87,
    ALIASED_LINE_WIDTH_RANGE: 0x846e,
    ALIASED_POINT_SIZE_RANGE: 0x846d,
    ALL_COMPLETED_NV: 0x84f2,
    ALL_SHADER_BITS_EXT: 0xffffffff,
    ALPHA: 0x1906,
    ALPHA16F_EXT: 0x881c,
    ALPHA32F_EXT: 0x8816,
    ALPHA8_EXT: 0x803c,
    ALPHA8_OES: 0x803c,
    ALPHA_BITS: 0xd55,
    ALPHA_TEST_FUNC_QCOM: 0xbc1,
    ALPHA_TEST_QCOM: 0xbc0,
    ALPHA_TEST_REF_QCOM: 0xbc2,
    ALREADY_SIGNALED_APPLE: 0x911a,
    ALWAYS: 0x207,
    AMD_compressed_3DC_texture: 0x1,
    AMD_compressed_ATC_texture: 0x1,
    AMD_performance_monitor: 0x1,
    AMD_program_binary_Z400: 0x1,
    ANGLE_depth_texture: 0x1,
    ANGLE_framebuffer_blit: 0x1,
    ANGLE_framebuffer_multisample: 0x1,
    ANGLE_instanced_arrays: 0x1,
    ANGLE_pack_reverse_row_order: 0x1,
    ANGLE_program_binary: 0x1,
    ANGLE_texture_compression_dxt3: 0x1,
    ANGLE_texture_compression_dxt5: 0x1,
    ANGLE_texture_usage: 0x1,
    ANGLE_translated_shader_source: 0x1,
    ANY_SAMPLES_PASSED_CONSERVATIVE_EXT: 0x8d6a,
    ANY_SAMPLES_PASSED_EXT: 0x8c2f,
    APPLE_copy_texture_levels: 0x1,
    APPLE_framebuffer_multisample: 0x1,
    APPLE_rgb_422: 0x1,
    APPLE_sync: 0x1,
    APPLE_texture_format_BGRA8888: 0x1,
    APPLE_texture_max_level: 0x1,
    ARM_mali_program_binary: 0x1,
    ARM_mali_shader_binary: 0x1,
    ARM_rgba8: 0x1,
    ARRAY_BUFFER: 0x8892,
    ARRAY_BUFFER_BINDING: 0x8894,
    ATC_RGBA_EXPLICIT_ALPHA_AMD: 0x8c93,
    ATC_RGBA_INTERPOLATED_ALPHA_AMD: 0x87ee,
    ATC_RGB_AMD: 0x8c92,
    ATTACHED_SHADERS: 0x8b85,
    BACK: 0x405,
    BGRA8_EXT: 0x93a1,
    BGRA_EXT: 0x80e1,
    BGRA_IMG: 0x80e1,
    BINNING_CONTROL_HINT_QCOM: 0x8fb0,
    BLEND: 0xbe2,
    BLEND_COLOR: 0x8005,
    BLEND_DST_ALPHA: 0x80ca,
    BLEND_DST_RGB: 0x80c8,
    BLEND_EQUATION: 0x8009,
    BLEND_EQUATION_ALPHA: 0x883d,
    BLEND_EQUATION_RGB: 0x8009,
    BLEND_SRC_ALPHA: 0x80cb,
    BLEND_SRC_RGB: 0x80c9,
    BLUE_BITS: 0xd54,
    BOOL: 0x8b56,
    BOOL_VEC2: 0x8b57,
    BOOL_VEC3: 0x8b58,
    BOOL_VEC4: 0x8b59,
    BUFFER: 0x82e0,
    BUFFER_ACCESS_OES: 0x88bb,
    BUFFER_MAPPED_OES: 0x88bc,
    BUFFER_MAP_POINTER_OES: 0x88bd,
    BUFFER_OBJECT_EXT: 0x9151,
    BUFFER_SIZE: 0x8764,
    BUFFER_USAGE: 0x8765,
    BYTE: 0x1400,
    CCW: 0x901,
    CLAMP_TO_BORDER_NV: 0x812d,
    CLAMP_TO_EDGE: 0x812f,
    COLOR_ATTACHMENT0: 0x8ce0,
    COLOR_ATTACHMENT0_NV: 0x8ce0,
    COLOR_ATTACHMENT10_NV: 0x8cea,
    COLOR_ATTACHMENT11_NV: 0x8ceb,
    COLOR_ATTACHMENT12_NV: 0x8cec,
    COLOR_ATTACHMENT13_NV: 0x8ced,
    COLOR_ATTACHMENT14_NV: 0x8cee,
    COLOR_ATTACHMENT15_NV: 0x8cef,
    COLOR_ATTACHMENT1_NV: 0x8ce1,
    COLOR_ATTACHMENT2_NV: 0x8ce2,
    COLOR_ATTACHMENT3_NV: 0x8ce3,
    COLOR_ATTACHMENT4_NV: 0x8ce4,
    COLOR_ATTACHMENT5_NV: 0x8ce5,
    COLOR_ATTACHMENT6_NV: 0x8ce6,
    COLOR_ATTACHMENT7_NV: 0x8ce7,
    COLOR_ATTACHMENT8_NV: 0x8ce8,
    COLOR_ATTACHMENT9_NV: 0x8ce9,
    COLOR_ATTACHMENT_EXT: 0x90f0,
    COLOR_BUFFER_BIT: 0x4000,
    COLOR_BUFFER_BIT0_QCOM: 0x1,
    COLOR_BUFFER_BIT1_QCOM: 0x2,
    COLOR_BUFFER_BIT2_QCOM: 0x4,
    COLOR_BUFFER_BIT3_QCOM: 0x8,
    COLOR_BUFFER_BIT4_QCOM: 0x10,
    COLOR_BUFFER_BIT5_QCOM: 0x20,
    COLOR_BUFFER_BIT6_QCOM: 0x40,
    COLOR_BUFFER_BIT7_QCOM: 0x80,
    COLOR_CLEAR_VALUE: 0xc22,
    COLOR_EXT: 0x1800,
    COLOR_WRITEMASK: 0xc23,
    COMPARE_REF_TO_TEXTURE_EXT: 0x884e,
    COMPILE_STATUS: 0x8b81,
    COMPRESSED_RGBA_ASTC_10x10_KHR: 0x93bb,
    COMPRESSED_RGBA_ASTC_10x5_KHR: 0x93b8,
    COMPRESSED_RGBA_ASTC_10x6_KHR: 0x93b9,
    COMPRESSED_RGBA_ASTC_10x8_KHR: 0x93ba,
    COMPRESSED_RGBA_ASTC_12x10_KHR: 0x93bc,
    COMPRESSED_RGBA_ASTC_12x12_KHR: 0x93bd,
    COMPRESSED_RGBA_ASTC_4x4_KHR: 0x93b0,
    COMPRESSED_RGBA_ASTC_5x4_KHR: 0x93b1,
    COMPRESSED_RGBA_ASTC_5x5_KHR: 0x93b2,
    COMPRESSED_RGBA_ASTC_6x5_KHR: 0x93b3,
    COMPRESSED_RGBA_ASTC_6x6_KHR: 0x93b4,
    COMPRESSED_RGBA_ASTC_8x5_KHR: 0x93b5,
    COMPRESSED_RGBA_ASTC_8x6_KHR: 0x93b6,
    COMPRESSED_RGBA_ASTC_8x8_KHR: 0x93b7,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,
    COMPRESSED_RGBA_PVRTC_2BPPV2_IMG: 0x9137,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
    COMPRESSED_RGBA_PVRTC_4BPPV2_IMG: 0x9138,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
    COMPRESSED_RGBA_S3TC_DXT3_ANGLE: 0x83f2,
    COMPRESSED_RGBA_S3TC_DXT5_ANGLE: 0x83f3,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 0x93db,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 0x93d8,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 0x93d9,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR: 0x93da,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 0x93dc,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 0x93dd,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 0x93d0,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 0x93d1,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 0x93d2,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 0x93d3,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 0x93d4,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 0x93d5,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 0x93d6,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 0x93d7,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV: 0x8c4d,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV: 0x8c4e,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV: 0x8c4f,
    COMPRESSED_SRGB_S3TC_DXT1_NV: 0x8c4c,
    COMPRESSED_TEXTURE_FORMATS: 0x86a3,
    CONDITION_SATISFIED_APPLE: 0x911c,
    CONSTANT_ALPHA: 0x8003,
    CONSTANT_COLOR: 0x8001,
    CONTEXT_FLAG_DEBUG_BIT: 0x2,
    CONTEXT_ROBUST_ACCESS_EXT: 0x90f3,
    COUNTER_RANGE_AMD: 0x8bc1,
    COUNTER_TYPE_AMD: 0x8bc0,
    COVERAGE_ALL_FRAGMENTS_NV: 0x8ed5,
    COVERAGE_ATTACHMENT_NV: 0x8ed2,
    COVERAGE_AUTOMATIC_NV: 0x8ed7,
    COVERAGE_BUFFERS_NV: 0x8ed3,
    COVERAGE_BUFFER_BIT_NV: 0x8000,
    COVERAGE_COMPONENT4_NV: 0x8ed1,
    COVERAGE_COMPONENT_NV: 0x8ed0,
    COVERAGE_EDGE_FRAGMENTS_NV: 0x8ed6,
    COVERAGE_SAMPLES_NV: 0x8ed4,
    CPU_OPTIMIZED_QCOM: 0x8fb1,
    CULL_FACE: 0xb44,
    CULL_FACE_MODE: 0xb45,
    CURRENT_PROGRAM: 0x8b8d,
    CURRENT_QUERY_EXT: 0x8865,
    CURRENT_VERTEX_ATTRIB: 0x8626,
    CW: 0x900,
    DEBUG_CALLBACK_FUNCTION: 0x8244,
    DEBUG_CALLBACK_USER_PARAM: 0x8245,
    DEBUG_GROUP_STACK_DEPTH: 0x826d,
    DEBUG_LOGGED_MESSAGES: 0x9145,
    DEBUG_NEXT_LOGGED_MESSAGE_LENGTH: 0x8243,
    DEBUG_OUTPUT: 0x92e0,
    DEBUG_OUTPUT_SYNCHRONOUS: 0x8242,
    DEBUG_SEVERITY_HIGH: 0x9146,
    DEBUG_SEVERITY_LOW: 0x9148,
    DEBUG_SEVERITY_MEDIUM: 0x9147,
    DEBUG_SEVERITY_NOTIFICATION: 0x826b,
    DEBUG_SOURCE_API: 0x8246,
    DEBUG_SOURCE_APPLICATION: 0x824a,
    DEBUG_SOURCE_OTHER: 0x824b,
    DEBUG_SOURCE_SHADER_COMPILER: 0x8248,
    DEBUG_SOURCE_THIRD_PARTY: 0x8249,
    DEBUG_SOURCE_WINDOW_SYSTEM: 0x8247,
    DEBUG_TYPE_DEPRECATED_BEHAVIOR: 0x824d,
    DEBUG_TYPE_ERROR: 0x824c,
    DEBUG_TYPE_MARKER: 0x8268,
    DEBUG_TYPE_OTHER: 0x8251,
    DEBUG_TYPE_PERFORMANCE: 0x8250,
    DEBUG_TYPE_POP_GROUP: 0x826a,
    DEBUG_TYPE_PORTABILITY: 0x824f,
    DEBUG_TYPE_PUSH_GROUP: 0x8269,
    DEBUG_TYPE_UNDEFINED_BEHAVIOR: 0x824e,
    DECR: 0x1e03,
    DECR_WRAP: 0x8508,
    DELETE_STATUS: 0x8b80,
    DEPTH24_STENCIL8_OES: 0x88f0,
    DEPTH_ATTACHMENT: 0x8d00,
    DEPTH_STENCIL_ATTACHMENT: 0x821a,
    DEPTH_BITS: 0xd56,
    DEPTH_BUFFER_BIT: 0x100,
    DEPTH_BUFFER_BIT0_QCOM: 0x100,
    DEPTH_BUFFER_BIT1_QCOM: 0x200,
    DEPTH_BUFFER_BIT2_QCOM: 0x400,
    DEPTH_BUFFER_BIT3_QCOM: 0x800,
    DEPTH_BUFFER_BIT4_QCOM: 0x1000,
    DEPTH_BUFFER_BIT5_QCOM: 0x2000,
    DEPTH_BUFFER_BIT6_QCOM: 0x4000,
    DEPTH_BUFFER_BIT7_QCOM: 0x8000,
    DEPTH_CLEAR_VALUE: 0xb73,
    DEPTH_COMPONENT: 0x1902,
    DEPTH_COMPONENT16: 0x81a5,
    DEPTH_COMPONENT16_NONLINEAR_NV: 0x8e2c,
    DEPTH_COMPONENT16_OES: 0x81a5,
    DEPTH_COMPONENT24_OES: 0x81a6,
    DEPTH_COMPONENT32_OES: 0x81a7,
    DEPTH_EXT: 0x1801,
    DEPTH_FUNC: 0xb74,
    DEPTH_RANGE: 0xb70,
    DEPTH_STENCIL: 0x84f9,
    DEPTH_STENCIL_OES: 0x84f9,
    DEPTH_TEST: 0xb71,
    DEPTH_WRITEMASK: 0xb72,
    DITHER: 0xbd0,
    DMP_shader_binary: 0x1,
    DONT_CARE: 0x1100,
    DRAW_BUFFER0_NV: 0x8825,
    DRAW_BUFFER10_NV: 0x882f,
    DRAW_BUFFER11_NV: 0x8830,
    DRAW_BUFFER12_NV: 0x8831,
    DRAW_BUFFER13_NV: 0x8832,
    DRAW_BUFFER14_NV: 0x8833,
    DRAW_BUFFER15_NV: 0x8834,
    DRAW_BUFFER1_NV: 0x8826,
    DRAW_BUFFER2_NV: 0x8827,
    DRAW_BUFFER3_NV: 0x8828,
    DRAW_BUFFER4_NV: 0x8829,
    DRAW_BUFFER5_NV: 0x882a,
    DRAW_BUFFER6_NV: 0x882b,
    DRAW_BUFFER7_NV: 0x882c,
    DRAW_BUFFER8_NV: 0x882d,
    DRAW_BUFFER9_NV: 0x882e,
    DRAW_BUFFER_EXT: 0xc01,
    DRAW_FRAMEBUFFER_ANGLE: 0x8ca9,
    DRAW_FRAMEBUFFER_APPLE: 0x8ca9,
    DRAW_FRAMEBUFFER_BINDING_ANGLE: 0x8ca6,
    DRAW_FRAMEBUFFER_BINDING_APPLE: 0x8ca6,
    DRAW_FRAMEBUFFER_BINDING_NV: 0x8ca6,
    DRAW_FRAMEBUFFER_NV: 0x8ca9,
    DST_ALPHA: 0x304,
    DST_COLOR: 0x306,
    DYNAMIC_DRAW: 0x88e8,
    ELEMENT_ARRAY_BUFFER: 0x8893,
    ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
    EQUAL: 0x202,
    ES_VERSION_2_0: 0x1,
    ETC1_RGB8_OES: 0x8d64,
    ETC1_SRGB8_NV: 0x88ee,
    EXTENSIONS: 0x1f03,
    EXT_blend_minmax: 0x1,
    EXT_color_buffer_half_float: 0x1,
    EXT_debug_label: 0x1,
    EXT_debug_marker: 0x1,
    EXT_discard_framebuffer: 0x1,
    EXT_map_buffer_range: 0x1,
    EXT_multi_draw_arrays: 0x1,
    EXT_multisampled_render_to_texture: 0x1,
    EXT_multiview_draw_buffers: 0x1,
    EXT_occlusion_query_boolean: 0x1,
    EXT_read_format_bgra: 0x1,
    EXT_robustness: 0x1,
    EXT_sRGB: 0x1,
    EXT_separate_shader_objects: 0x1,
    EXT_shader_framebuffer_fetch: 0x1,
    EXT_shader_texture_lod: 0x1,
    EXT_shadow_samplers: 0x1,
    EXT_texture_compression_dxt1: 0x1,
    EXT_texture_filter_anisotropic: 0x1,
    EXT_texture_format_BGRA8888: 0x1,
    EXT_texture_rg: 0x1,
    EXT_texture_storage: 0x1,
    EXT_texture_type_2_10_10_10_REV: 0x1,
    EXT_unpack_subimage: 0x1,
    FALSE: 0x0,
    FASTEST: 0x1101,
    FENCE_CONDITION_NV: 0x84f4,
    FENCE_STATUS_NV: 0x84f3,
    FIXED: 0x140c,
    FJ_shader_binary_GCCSO: 0x1,
    FLOAT: 0x1406,
    FLOAT_MAT2: 0x8b5a,
    FLOAT_MAT3: 0x8b5b,
    FLOAT_MAT4: 0x8b5c,
    FLOAT_VEC2: 0x8b50,
    FLOAT_VEC3: 0x8b51,
    FLOAT_VEC4: 0x8b52,
    FRAGMENT_SHADER: 0x8b30,
    FRAGMENT_SHADER_BIT_EXT: 0x2,
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8b8b,
    FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT: 0x8a52,
    FRAMEBUFFER: 0x8d40,
    FRAMEBUFFER_ATTACHMENT_ANGLE: 0x93a3,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES: 0x8cd4,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT: 0x8d6c,
    FRAMEBUFFER_BINDING: 0x8ca6,
    FRAMEBUFFER_COMPLETE: 0x8cd5,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT: 0x8d56,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG: 0x9134,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV: 0x8d56,
    FRAMEBUFFER_UNDEFINED_OES: 0x8219,
    FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
    FRONT: 0x404,
    FRONT_AND_BACK: 0x408,
    FRONT_FACE: 0xb46,
    FUNC_ADD: 0x8006,
    FUNC_REVERSE_SUBTRACT: 0x800b,
    FUNC_SUBTRACT: 0x800a,
    GENERATE_MIPMAP_HINT: 0x8192,
    GEQUAL: 0x206,
    GPU_OPTIMIZED_QCOM: 0x8fb2,
    GREATER: 0x204,
    GREEN_BITS: 0xd53,
    GUILTY_CONTEXT_RESET_EXT: 0x8253,
    HALF_FLOAT_OES: 0x8d61,
    HIGH_FLOAT: 0x8df2,
    HIGH_INT: 0x8df5,
    IMG_multisampled_render_to_texture: 0x1,
    IMG_program_binary: 0x1,
    IMG_read_format: 0x1,
    IMG_shader_binary: 0x1,
    IMG_texture_compression_pvrtc: 0x1,
    IMG_texture_compression_pvrtc2: 0x1,
    IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
    IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
    INCR: 0x1e02,
    INCR_WRAP: 0x8507,
    INFO_LOG_LENGTH: 0x8b84,
    INNOCENT_CONTEXT_RESET_EXT: 0x8254,
    INT: 0x1404,
    INT_10_10_10_2_OES: 0x8df7,
    INT_VEC2: 0x8b53,
    INT_VEC3: 0x8b54,
    INT_VEC4: 0x8b55,
    INVALID_ENUM: 0x500,
    INVALID_FRAMEBUFFER_OPERATION: 0x506,
    INVALID_OPERATION: 0x502,
    INVALID_VALUE: 0x501,
    INVERT: 0x150a,
    KEEP: 0x1e00,
    KHR_debug: 0x1,
    KHR_texture_compression_astc_ldr: 0x1,
    LEFT: 0x0406,
    LEQUAL: 0x203,
    LESS: 0x201,
    LINEAR: 0x2601,
    LINEAR_MIPMAP_LINEAR: 0x2703,
    LINEAR_MIPMAP_NEAREST: 0x2701,
    LINES: 0x1,
    LINE_LOOP: 0x2,
    LINE_STRIP: 0x3,
    LINE_WIDTH: 0xb21,
    LINK_STATUS: 0x8b82,
    LOSE_CONTEXT_ON_RESET_EXT: 0x8252,
    LOW_FLOAT: 0x8df0,
    LOW_INT: 0x8df3,
    LUMINANCE: 0x1909,
    LUMINANCE16F_EXT: 0x881e,
    LUMINANCE32F_EXT: 0x8818,
    LUMINANCE4_ALPHA4_OES: 0x8043,
    LUMINANCE8_ALPHA8_EXT: 0x8045,
    LUMINANCE8_ALPHA8_OES: 0x8045,
    LUMINANCE8_EXT: 0x8040,
    LUMINANCE8_OES: 0x8040,
    LUMINANCE_ALPHA: 0x190a,
    LUMINANCE_ALPHA16F_EXT: 0x881f,
    LUMINANCE_ALPHA32F_EXT: 0x8819,
    MALI_PROGRAM_BINARY_ARM: 0x8f61,
    MALI_SHADER_BINARY_ARM: 0x8f60,
    MAP_FLUSH_EXPLICIT_BIT_EXT: 0x10,
    MAP_INVALIDATE_BUFFER_BIT_EXT: 0x8,
    MAP_INVALIDATE_RANGE_BIT_EXT: 0x4,
    MAP_READ_BIT_EXT: 0x1,
    MAP_UNSYNCHRONIZED_BIT_EXT: 0x20,
    MAP_WRITE_BIT_EXT: 0x2,
    MAX_3D_TEXTURE_SIZE_OES: 0x8073,
    MAX_COLOR_ATTACHMENTS_NV: 0x8cdf,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
    MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
    MAX_DEBUG_GROUP_STACK_DEPTH: 0x826c,
    MAX_DEBUG_LOGGED_MESSAGES: 0x9144,
    MAX_DEBUG_MESSAGE_LENGTH: 0x9143,
    MAX_DRAW_BUFFERS_NV: 0x8824,
    MAX_EXT: 0x8008,
    MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
    MAX_LABEL_LENGTH: 0x82e8,
    MAX_MULTIVIEW_BUFFERS_EXT: 0x90f2,
    MAX_RENDERBUFFER_SIZE: 0x84e8,
    MAX_SAMPLES_ANGLE: 0x8d57,
    MAX_SAMPLES_APPLE: 0x8d57,
    MAX_SAMPLES_EXT: 0x8d57,
    MAX_SAMPLES_IMG: 0x9135,
    MAX_SAMPLES_NV: 0x8d57,
    MAX_SERVER_WAIT_TIMEOUT_APPLE: 0x9111,
    MAX_TEXTURE_IMAGE_UNITS: 0x8872,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
    MAX_TEXTURE_SIZE: 0xd33,
    MAX_VARYING_VECTORS: 0x8dfc,
    MAX_VERTEX_ATTRIBS: 0x8869,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
    MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
    MAX_VIEWPORT_DIMS: 0xd3a,
    MEDIUM_FLOAT: 0x8df1,
    MEDIUM_INT: 0x8df4,
    MIN_EXT: 0x8007,
    MIRRORED_REPEAT: 0x8370,
    MULTISAMPLE_BUFFER_BIT0_QCOM: 0x1000000,
    MULTISAMPLE_BUFFER_BIT1_QCOM: 0x2000000,
    MULTISAMPLE_BUFFER_BIT2_QCOM: 0x4000000,
    MULTISAMPLE_BUFFER_BIT3_QCOM: 0x8000000,
    MULTISAMPLE_BUFFER_BIT4_QCOM: 0x10000000,
    MULTISAMPLE_BUFFER_BIT5_QCOM: 0x20000000,
    MULTISAMPLE_BUFFER_BIT6_QCOM: 0x40000000,
    MULTISAMPLE_BUFFER_BIT7_QCOM: 0x80000000,
    MULTIVIEW_EXT: 0x90f1,
    NEAREST: 0x2600,
    NEAREST_MIPMAP_LINEAR: 0x2702,
    NEAREST_MIPMAP_NEAREST: 0x2700,
    NEVER: 0x200,
    NICEST: 0x1102,
    NONE: 0x0,
    NOTEQUAL: 0x205,
    NO_ERROR: 0x0,
    NO_RESET_NOTIFICATION_EXT: 0x8261,
    NUM_COMPRESSED_TEXTURE_FORMATS: 0x86a2,
    NUM_PROGRAM_BINARY_FORMATS_OES: 0x87fe,
    NUM_SHADER_BINARY_FORMATS: 0x8df9,
    NV_coverage_sample: 0x1,
    NV_depth_nonlinear: 0x1,
    NV_draw_buffers: 0x1,
    NV_draw_instanced: 0x1,
    NV_fbo_color_attachments: 0x1,
    NV_fence: 0x1,
    NV_framebuffer_blit: 0x1,
    NV_framebuffer_multisample: 0x1,
    NV_generate_mipmap_sRGB: 0x1,
    NV_instanced_arrays: 0x1,
    NV_read_buffer: 0x1,
    NV_read_buffer_front: 0x1,
    NV_read_depth: 0x1,
    NV_read_depth_stencil: 0x1,
    NV_read_stencil: 0x1,
    NV_sRGB_formats: 0x1,
    NV_shadow_samplers_array: 0x1,
    NV_shadow_samplers_cube: 0x1,
    NV_texture_border_clamp: 0x1,
    NV_texture_compression_s3tc_update: 0x1,
    NV_texture_npot_2D_mipmap: 0x1,
    OBJECT_TYPE_APPLE: 0x9112,
    OES_EGL_image: 0x1,
    OES_EGL_image_external: 0x1,
    OES_compressed_ETC1_RGB8_texture: 0x1,
    OES_compressed_paletted_texture: 0x1,
    OES_depth24: 0x1,
    OES_depth32: 0x1,
    OES_depth_texture: 0x1,
    OES_element_index_uint: 0x1,
    OES_fbo_render_mipmap: 0x1,
    OES_fragment_precision_high: 0x1,
    OES_get_program_binary: 0x1,
    OES_mapbuffer: 0x1,
    OES_packed_depth_stencil: 0x1,
    OES_required_internalformat: 0x1,
    OES_rgb8_rgba8: 0x1,
    OES_standard_derivatives: 0x1,
    OES_stencil1: 0x1,
    OES_stencil4: 0x1,
    OES_surfaceless_context: 0x1,
    OES_texture_3D: 0x1,
    OES_texture_float: 0x1,
    OES_texture_float_linear: 0x1,
    OES_texture_half_float: 0x1,
    OES_texture_half_float_linear: 0x1,
    OES_texture_npot: 0x1,
    OES_vertex_array_object: 0x1,
    OES_vertex_half_float: 0x1,
    OES_vertex_type_10_10_10_2: 0x1,
    ONE: 0x1,
    ONE_MINUS_CONSTANT_ALPHA: 0x8004,
    ONE_MINUS_CONSTANT_COLOR: 0x8002,
    ONE_MINUS_DST_ALPHA: 0x305,
    ONE_MINUS_DST_COLOR: 0x307,
    ONE_MINUS_SRC_ALPHA: 0x303,
    ONE_MINUS_SRC_COLOR: 0x301,
    OUT_OF_MEMORY: 0x505,
    PACK_ALIGNMENT: 0xd05,
    PACK_REVERSE_ROW_ORDER_ANGLE: 0x93a4,
    PALETTE4_R5_G6_B5_OES: 0x8b92,
    PALETTE4_RGB5_A1_OES: 0x8b94,
    PALETTE4_RGB8_OES: 0x8b90,
    PALETTE4_RGBA4_OES: 0x8b93,
    PALETTE4_RGBA8_OES: 0x8b91,
    PALETTE8_R5_G6_B5_OES: 0x8b97,
    PALETTE8_RGB5_A1_OES: 0x8b99,
    PALETTE8_RGB8_OES: 0x8b95,
    PALETTE8_RGBA4_OES: 0x8b98,
    PALETTE8_RGBA8_OES: 0x8b96,
    PERCENTAGE_AMD: 0x8bc3,
    PERFMON_GLOBAL_MODE_QCOM: 0x8fa0,
    PERFMON_RESULT_AMD: 0x8bc6,
    PERFMON_RESULT_AVAILABLE_AMD: 0x8bc4,
    PERFMON_RESULT_SIZE_AMD: 0x8bc5,
    POINTS: 0x0,
    POLYGON_OFFSET_FACTOR: 0x8038,
    POLYGON_OFFSET_FILL: 0x8037,
    POLYGON_OFFSET_UNITS: 0x2a00,
    PROGRAM: 0x82e2,
    PROGRAM_BINARY_ANGLE: 0x93a6,
    PROGRAM_BINARY_FORMATS_OES: 0x87ff,
    PROGRAM_BINARY_LENGTH_OES: 0x8741,
    PROGRAM_OBJECT_EXT: 0x8b40,
    PROGRAM_PIPELINE_BINDING_EXT: 0x825a,
    PROGRAM_PIPELINE_OBJECT_EXT: 0x8a4f,
    PROGRAM_SEPARABLE_EXT: 0x8258,
    QCOM_alpha_test: 0x1,
    QCOM_binning_control: 0x1,
    QCOM_driver_control: 0x1,
    QCOM_extended_get: 0x1,
    QCOM_extended_get2: 0x1,
    QCOM_perfmon_global_mode: 0x1,
    QCOM_tiled_rendering: 0x1,
    QCOM_writeonly_rendering: 0x1,
    QUERY: 0x82e3,
    QUERY_OBJECT_EXT: 0x9153,
    QUERY_RESULT_AVAILABLE_EXT: 0x8867,
    QUERY_RESULT_EXT: 0x8866,
    R16F_EXT: 0x822d,
    R32F_EXT: 0x822e,
    R8_EXT: 0x8229,
    READ_BUFFER_EXT: 0xc02,
    READ_BUFFER_NV: 0xc02,
    READ_FRAMEBUFFER_ANGLE: 0x8ca8,
    READ_FRAMEBUFFER_APPLE: 0x8ca8,
    READ_FRAMEBUFFER_BINDING_ANGLE: 0x8caa,
    READ_FRAMEBUFFER_BINDING_APPLE: 0x8caa,
    READ_FRAMEBUFFER_BINDING_NV: 0x8caa,
    READ_FRAMEBUFFER_NV: 0x8ca8,
    RED_BITS: 0xd52,
    RED_EXT: 0x1903,
    RENDERBUFFER: 0x8d41,
    RENDERBUFFER_ALPHA_SIZE: 0x8d53,
    RENDERBUFFER_BINDING: 0x8ca7,
    RENDERBUFFER_BLUE_SIZE: 0x8d52,
    RENDERBUFFER_DEPTH_SIZE: 0x8d54,
    RENDERBUFFER_GREEN_SIZE: 0x8d51,
    RENDERBUFFER_HEIGHT: 0x8d43,
    RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
    RENDERBUFFER_RED_SIZE: 0x8d50,
    RENDERBUFFER_SAMPLES_ANGLE: 0x8cab,
    RENDERBUFFER_SAMPLES_APPLE: 0x8cab,
    RENDERBUFFER_SAMPLES_EXT: 0x8cab,
    RENDERBUFFER_SAMPLES_IMG: 0x9133,
    RENDERBUFFER_SAMPLES_NV: 0x8cab,
    RENDERBUFFER_STENCIL_SIZE: 0x8d55,
    RENDERBUFFER_WIDTH: 0x8d42,
    RENDERER: 0x1f01,
    RENDER_DIRECT_TO_FRAMEBUFFER_QCOM: 0x8fb3,
    REPEAT: 0x2901,
    REPLACE: 0x1e01,
    REQUIRED_TEXTURE_IMAGE_UNITS_OES: 0x8d68,
    RESET_NOTIFICATION_STRATEGY_EXT: 0x8256,
    RG16F_EXT: 0x822f,
    RG32F_EXT: 0x8230,
    RG8_EXT: 0x822b,
    RGB: 0x1907,
    RGB10_A2_EXT: 0x8059,
    RGB10_EXT: 0x8052,
    RGB16F_EXT: 0x881b,
    RGB32F_EXT: 0x8815,
    RGB565: 0x8d62,
    RGB565_OES: 0x8d62,
    RGB5_A1: 0x8057,
    RGB5_A1_OES: 0x8057,
    RGB8_OES: 0x8051,
    RGBA: 0x1908,
    RGBA16F_EXT: 0x881a,
    RGBA32F_EXT: 0x8814,
    RGBA4: 0x8056,
    RGBA4_OES: 0x8056,
    RGBA8_OES: 0x8058,
    RGB_422_APPLE: 0x8a1f,
    RG_EXT: 0x8227,
    RIGHT: 0x0407,
    SAMPLER: 0x82e6,
    SAMPLER_2D: 0x8b5e,
    SAMPLER_2D_ARRAY_SHADOW_NV: 0x8dc4,
    SAMPLER_2D_SHADOW_EXT: 0x8b62,
    SAMPLER_3D_OES: 0x8b5f,
    SAMPLER_CUBE: 0x8b60,
    SAMPLER_CUBE_SHADOW_NV: 0x8dc5,
    SAMPLER_EXTERNAL_OES: 0x8d66,
    SAMPLES: 0x80a9,
    SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
    SAMPLE_BUFFERS: 0x80a8,
    SAMPLE_COVERAGE: 0x80a0,
    SAMPLE_COVERAGE_INVERT: 0x80ab,
    SAMPLE_COVERAGE_VALUE: 0x80aa,
    SCISSOR_BOX: 0xc10,
    SCISSOR_TEST: 0xc11,
    SGX_BINARY_IMG: 0x8c0a,
    SGX_PROGRAM_BINARY_IMG: 0x9130,
    SHADER: 0x82e1,
    SHADER_BINARY_DMP: 0x9250,
    SHADER_BINARY_FORMATS: 0x8df8,
    SHADER_BINARY_VIV: 0x8fc4,
    SHADER_COMPILER: 0x8dfa,
    SHADER_OBJECT_EXT: 0x8b48,
    SHADER_SOURCE_LENGTH: 0x8b88,
    SHADER_TYPE: 0x8b4f,
    SHADING_LANGUAGE_VERSION: 0x8b8c,
    SHORT: 0x1402,
    SIGNALED_APPLE: 0x9119,
    SLUMINANCE8_ALPHA8_NV: 0x8c45,
    SLUMINANCE8_NV: 0x8c47,
    SLUMINANCE_ALPHA_NV: 0x8c44,
    SLUMINANCE_NV: 0x8c46,
    SRC_ALPHA: 0x302,
    SRC_ALPHA_SATURATE: 0x308,
    SRC_COLOR: 0x300,
    SRGB8_ALPHA8_EXT: 0x8c43,
    SRGB8_NV: 0x8c41,
    SRGB_ALPHA_EXT: 0x8c42,
    SRGB_EXT: 0x8c40,
    STACK_OVERFLOW: 0x503,
    STACK_UNDERFLOW: 0x504,
    STATE_RESTORE: 0x8bdc,
    STATIC_DRAW: 0x88e4,
    STENCIL_ATTACHMENT: 0x8d20,
    STENCIL_BACK_FAIL: 0x8801,
    STENCIL_BACK_FUNC: 0x8800,
    STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
    STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
    STENCIL_BACK_REF: 0x8ca3,
    STENCIL_BACK_VALUE_MASK: 0x8ca4,
    STENCIL_BACK_WRITEMASK: 0x8ca5,
    STENCIL_BITS: 0xd57,
    STENCIL_BUFFER_BIT: 0x400,
    STENCIL_BUFFER_BIT0_QCOM: 0x10000,
    STENCIL_BUFFER_BIT1_QCOM: 0x20000,
    STENCIL_BUFFER_BIT2_QCOM: 0x40000,
    STENCIL_BUFFER_BIT3_QCOM: 0x80000,
    STENCIL_BUFFER_BIT4_QCOM: 0x100000,
    STENCIL_BUFFER_BIT5_QCOM: 0x200000,
    STENCIL_BUFFER_BIT6_QCOM: 0x400000,
    STENCIL_BUFFER_BIT7_QCOM: 0x800000,
    STENCIL_CLEAR_VALUE: 0xb91,
    STENCIL_EXT: 0x1802,
    STENCIL_FAIL: 0xb94,
    STENCIL_FUNC: 0xb92,
    STENCIL_INDEX1_OES: 0x8d46,
    STENCIL_INDEX4_OES: 0x8d47,
    STENCIL_INDEX: 0x1901,
    STENCIL_INDEX8: 0x8d48,
    STENCIL_PASS_DEPTH_FAIL: 0xb95,
    STENCIL_PASS_DEPTH_PASS: 0xb96,
    STENCIL_REF: 0xb97,
    STENCIL_TEST: 0xb90,
    STENCIL_VALUE_MASK: 0xb93,
    STENCIL_WRITEMASK: 0xb98,
    STREAM_DRAW: 0x88e0,
    SUBPIXEL_BITS: 0xd50,
    SYNC_CONDITION_APPLE: 0x9113,
    SYNC_FENCE_APPLE: 0x9116,
    SYNC_FLAGS_APPLE: 0x9115,
    SYNC_FLUSH_COMMANDS_BIT_APPLE: 0x1,
    SYNC_GPU_COMMANDS_COMPLETE_APPLE: 0x9117,
    SYNC_OBJECT_APPLE: 0x8a53,
    SYNC_STATUS_APPLE: 0x9114,
    TEXTURE: 0x1702,
    TEXTURE0: 0x84c0,
    TEXTURE1: 0x84c1,
    TEXTURE10: 0x84ca,
    TEXTURE11: 0x84cb,
    TEXTURE12: 0x84cc,
    TEXTURE13: 0x84cd,
    TEXTURE14: 0x84ce,
    TEXTURE15: 0x84cf,
    TEXTURE16: 0x84d0,
    TEXTURE17: 0x84d1,
    TEXTURE18: 0x84d2,
    TEXTURE19: 0x84d3,
    TEXTURE2: 0x84c2,
    TEXTURE20: 0x84d4,
    TEXTURE21: 0x84d5,
    TEXTURE22: 0x84d6,
    TEXTURE23: 0x84d7,
    TEXTURE24: 0x84d8,
    TEXTURE25: 0x84d9,
    TEXTURE26: 0x84da,
    TEXTURE27: 0x84db,
    TEXTURE28: 0x84dc,
    TEXTURE29: 0x84dd,
    TEXTURE3: 0x84c3,
    TEXTURE30: 0x84de,
    TEXTURE31: 0x84df,
    TEXTURE4: 0x84c4,
    TEXTURE5: 0x84c5,
    TEXTURE6: 0x84c6,
    TEXTURE7: 0x84c7,
    TEXTURE8: 0x84c8,
    TEXTURE9: 0x84c9,
    TEXTURE_2D: 0xde1,
    TEXTURE_3D_OES: 0x806f,
    TEXTURE_BINDING_2D: 0x8069,
    TEXTURE_BINDING_3D_OES: 0x806a,
    TEXTURE_BINDING_CUBE_MAP: 0x8514,
    TEXTURE_BINDING_EXTERNAL_OES: 0x8d67,
    TEXTURE_BORDER_COLOR_NV: 0x1004,
    TEXTURE_COMPARE_FUNC_EXT: 0x884d,
    TEXTURE_COMPARE_MODE_EXT: 0x884c,
    TEXTURE_CUBE_MAP: 0x8513,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
    TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
    TEXTURE_DEPTH_QCOM: 0x8bd4,
    TEXTURE_EXTERNAL_OES: 0x8d65,
    TEXTURE_FORMAT_QCOM: 0x8bd6,
    TEXTURE_HEIGHT_QCOM: 0x8bd3,
    TEXTURE_IMAGE_VALID_QCOM: 0x8bd8,
    TEXTURE_IMMUTABLE_FORMAT_EXT: 0x912f,
    TEXTURE_INTERNAL_FORMAT_QCOM: 0x8bd5,
    TEXTURE_MAG_FILTER: 0x2800,
    TEXTURE_MAX_ANISOTROPY_EXT: 0x84fe,
    TEXTURE_MAX_LEVEL_APPLE: 0x813d,
    TEXTURE_MIN_FILTER: 0x2801,
    TEXTURE_NUM_LEVELS_QCOM: 0x8bd9,
    TEXTURE_OBJECT_VALID_QCOM: 0x8bdb,
    TEXTURE_SAMPLES_IMG: 0x9136,
    TEXTURE_TARGET_QCOM: 0x8bda,
    TEXTURE_TYPE_QCOM: 0x8bd7,
    TEXTURE_USAGE_ANGLE: 0x93a2,
    TEXTURE_WIDTH_QCOM: 0x8bd2,
    TEXTURE_WRAP_R_OES: 0x8072,
    TEXTURE_WRAP_S: 0x2802,
    TEXTURE_WRAP_T: 0x2803,
    TIMEOUT_EXPIRED_APPLE: 0x911b,
    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
    TIMEOUT_IGNORED_APPLE: 0xffffffffffffffff,
    TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE: 0x93a0,
    TRIANGLES: 0x4,
    TRIANGLE_FAN: 0x6,
    TRIANGLE_STRIP: 0x5,
    TRUE: 0x1,
    UNKNOWN_CONTEXT_RESET_EXT: 0x8255,
    UNPACK_ALIGNMENT: 0xcf5,
    UNPACK_ROW_LENGTH: 0xcf2,
    UNPACK_SKIP_PIXELS: 0xcf4,
    UNPACK_SKIP_ROWS: 0xcf3,
    UNSIGNALED_APPLE: 0x9118,
    UNSIGNED_BYTE: 0x1401,
    UNSIGNED_INT: 0x1405,
    UNSIGNED_INT64_AMD: 0x8bc2,
    UNSIGNED_INT_10_10_10_2_OES: 0x8df6,
    UNSIGNED_INT_24_8_OES: 0x84fa,
    UNSIGNED_INT_2_10_10_10_REV_EXT: 0x8368,
    UNSIGNED_NORMALIZED_EXT: 0x8c17,
    UNSIGNED_SHORT: 0x1403,
    UNSIGNED_SHORT_1_5_5_5_REV_EXT: 0x8366,
    UNSIGNED_SHORT_4_4_4_4: 0x8033,
    UNSIGNED_SHORT_4_4_4_4_REV_EXT: 0x8365,
    UNSIGNED_SHORT_4_4_4_4_REV_IMG: 0x8365,
    UNSIGNED_SHORT_5_5_5_1: 0x8034,
    UNSIGNED_SHORT_5_6_5: 0x8363,
    UNSIGNED_SHORT_8_8_APPLE: 0x85ba,
    UNSIGNED_SHORT_8_8_REV_APPLE: 0x85bb,
    VALIDATE_STATUS: 0x8b83,
    VENDOR: 0x1f00,
    VERSION: 0x1f02,
    VERTEX_ARRAY_BINDING_OES: 0x85b5,
    VERTEX_ARRAY_OBJECT_EXT: 0x9154,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,
    VERTEX_ATTRIB_ARRAY_DIVISOR_NV: 0x88fe,
    VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
    VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
    VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
    VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
    VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
    VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
    VERTEX_SHADER: 0x8b31,
    VERTEX_SHADER_BIT_EXT: 0x1,
    VIEWPORT: 0xba2,
    VIV_shader_binary: 0x1,
    WAIT_FAILED_APPLE: 0x911d,
    WRITEONLY_RENDERING_QCOM: 0x8823,
    WRITE_ONLY_OES: 0x88b9,
    Z400_BINARY_AMD: 0x8740,
    ZERO: 0x0,
    RASTERIZER_DISCARD: 0x8c89,
    UNPACK_FLIP_Y_WEBGL: 0x9240,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
    CONTEXT_LOST_WEBGL: 0x9242,
    UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
    BROWSER_DEFAULT_WEBGL: 0x9244,
};

var webgl2 = {};

Object.defineProperty(webgl2, "__esModule", { value: true });
webgl2.WebGL2RenderingContext = void 0;
webgl2.WebGL2RenderingContext = {};

var crypto = {};

/*
  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
  so it's better encapsulated. Now you can have multiple random number generators
  and they won't stomp all over eachother's state.

  If you want to use this as a substitute for Math.random(), use the random()
  method like so:

  var m = new MersenneTwister();
  var randomNumber = m.random();

  You can also call the other genrand_{foo}() methods on the instance.

  If you want to use a specific seed in order to get a repeatable random
  sequence, pass an integer into the constructor:

  var m = new MersenneTwister(123);

  and that will always produce the same random sequence.

  Sean McCullough (banksean@gmail.com)
*/

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_seed(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

var MersenneTwister$1 = function(seed) {
	if (seed == undefined) {
		seed = new Date().getTime();
	}

	/* Period parameters */
	this.N = 624;
	this.M = 397;
	this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	this.mt = new Array(this.N); /* the array for the state vector */
	this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	if (seed.constructor == Array) {
		this.init_by_array(seed, seed.length);
	}
	else {
		this.init_seed(seed);
	}
};

/* initializes mt[N] with a seed */
/* origin name init_genrand */
MersenneTwister$1.prototype.init_seed = function(s) {
	this.mt[0] = s >>> 0;
	for (this.mti=1; this.mti<this.N; this.mti++) {
		var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		+ this.mti;
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		this.mt[this.mti] >>>= 0;
		/* for >32 bit machines */
	}
};

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
MersenneTwister$1.prototype.init_by_array = function(init_key, key_length) {
	var i, j, k;
	this.init_seed(19650218);
	i=1; j=0;
	k = (this.N>key_length ? this.N : key_length);
	for (; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		+ init_key[j] + j; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=this.N-1; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		- i; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	}

	this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
};

/* generates a random number on [0,0xffffffff]-interval */
/* origin name genrand_int32 */
MersenneTwister$1.prototype.random_int = function() {
	var y;
	var mag01 = new Array(0x0, this.MATRIX_A);
	/* mag01[x] = x * MATRIX_A  for x=0,1 */

	if (this.mti >= this.N) { /* generate N words at one time */
		var kk;

		if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			this.init_seed(5489);  /* a default initial seed is used */

		for (kk=0;kk<this.N-this.M;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		for (;kk<this.N-1;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		this.mti = 0;
	}

	y = this.mt[this.mti++];

	/* Tempering */
	y ^= (y >>> 11);
	y ^= (y << 7) & 0x9d2c5680;
	y ^= (y << 15) & 0xefc60000;
	y ^= (y >>> 18);

	return y >>> 0;
};

/* generates a random number on [0,0x7fffffff]-interval */
/* origin name genrand_int31 */
MersenneTwister$1.prototype.random_int31 = function() {
	return (this.random_int()>>>1);
};

/* generates a random number on [0,1]-real-interval */
/* origin name genrand_real1 */
MersenneTwister$1.prototype.random_incl = function() {
	return this.random_int()*(1.0/4294967295.0);
	/* divided by 2^32-1 */
};

/* generates a random number on [0,1)-real-interval */
MersenneTwister$1.prototype.random = function() {
	return this.random_int()*(1.0/4294967296.0);
	/* divided by 2^32 */
};

/* generates a random number on (0,1)-real-interval */
/* origin name genrand_real3 */
MersenneTwister$1.prototype.random_excl = function() {
	return (this.random_int() + 0.5)*(1.0/4294967296.0);
	/* divided by 2^32 */
};

/* generates a random number on [0,1) with 53-bit resolution*/
/* origin name genrand_res53 */
MersenneTwister$1.prototype.random_long = function() {
	var a=this.random_int()>>>5, b=this.random_int()>>>6;
	return (a*67108864.0+b)*(1.0/9007199254740992.0);
};

/* These real versions are due to Isaku Wada, 2002/01/09 added */

var mersenneTwister = MersenneTwister$1;

var MersenneTwister = mersenneTwister;

var twister = new MersenneTwister(Math.random()*Number.MAX_SAFE_INTEGER);

var polyfillCrypto_getrandomvalues = getRandomValues$1;


function getRandomValues$1 (abv) {
  var l = abv.length;
  while (l--) {
    abv[l] = Math.floor(randomFloat() * 256);
  }
  return abv
}

function randomFloat() {
  return twister.random()
}

var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(crypto, "__esModule", { value: true });
crypto.crypto = void 0;
var polyfill_crypto_getrandomvalues_1 = __importDefault(polyfillCrypto_getrandomvalues);
crypto.crypto = { getRandomValues: polyfill_crypto_getrandomvalues_1.default };

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(eventIniter, exports);
__exportStar(platform$1, exports);
__exportStar(accelerometer, exports);
__exportStar(atob$1, exports);
__exportStar(blob, exports);
__exportStar(body, exports);
__exportStar(constructor, exports);
__exportStar(devicePixelRatio, exports);
__exportStar(document, exports);
__exportStar(element, exports);
__exportStar(event, exports);
__exportStar(eventTarget, exports);
__exportStar(htmlElement, exports);
__exportStar(htmlMediaElement, exports);
__exportStar(htmlVideoElement, exports);
__exportStar(image, exports);
__exportStar(imageData, exports);
__exportStar(location, exports);
__exportStar(navigator, exports);
__exportStar(offscreenCanvas, exports);
__exportStar(performance$1, exports);
__exportStar(register$1, exports);
__exportStar(node, exports);
__exportStar(requestAnimationFrame$1, exports);
__exportStar(screen, exports);
__exportStar(url, exports);
__exportStar(xmlHttpRequest, exports);
__exportStar(webgl, exports);
__exportStar(webgl2, exports);
__exportStar(crypto, exports);
}(core));

(function (exports) {
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.window = void 0;

var core_1 = core;
exports.window = {
    innerWidth: core_1.screen.availWidth,
    innerHeight: core_1.screen.availHeight,
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
    atob: core_1.atob,
    btoa: core_1.btoa,
    devicePixelRatio: core_1.devicePixelRatio,
    document: core_1.document,
    navigator: core_1.navigator,
    location: core_1.location,
    screen: core_1.screen,
    Blob: core_1.Blob,
    Event: core_1.Event,
    EventTarget: core_1.EventTarget,
    Node: core_1.Node,
    Element: core_1.Element,
    HTMLElement: core_1.HTMLElement,
    HTMLCanvasElement: core_1.HTMLCanvasElement,
    HTMLImageElement: core_1.HTMLImageElement,
    HTMLMediaElement: core_1.HTMLMediaElement,
    HTMLAudioElement: core_1.HTMLAudioElement,
    HTMLVideoElement: core_1.HTMLVideoElement,
    Image: core_1.Image,
    ImageData: core_1.ImageData,
    requestAnimationFrame: core_1.requestAnimationFrame,
    cancelAnimationFrame: core_1.cancelAnimationFrame,
    XMLHttpRequest: core_1.XMLHttpRequest,
    performance: core_1.performance,
    URL: core_1.URL,
    WebGLRenderingContext: core_1.WebGLRenderingContext,
    WebGL2RenderingContext: core_1.WebGL2RenderingContext,
    addEventListener: function (type, listener, options) {
        if (options === void 0) { options = {}; }
        core_1.document.addEventListener(type, listener, options);
    },
    removeEventListener: function (type, listener) {
        core_1.document.removeEventListener(type, listener);
    },
    dispatchEvent: function (event) {
        core_1.document.dispatchEvent(event);
    },
};
__exportStar(core, exports);
}(douyin));

var index$2 = /*@__PURE__*/getDefaultExportFromCjs(douyin);

var index$3 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	'default': index$2
}, [douyin]);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}

function _instanceof1(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return _instanceof1(left, right);
}

function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
typeof SuppressedError === "function" ? SuppressedError : function _SuppressedError(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof douyin.crypto !== "undefined" && douyin.crypto.getRandomValues && douyin.crypto.getRandomValues.bind(douyin.crypto);
        if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
    }
    return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var byteToHex = [];
for(var i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset) {
    if (offset === void 0) offset = 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

var randomUUID = typeof douyin.crypto !== "undefined" && douyin.crypto.randomUUID && douyin.crypto.randomUUID.bind(douyin.crypto);
var native = {
    randomUUID: randomUUID
};

function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return unsafeStringify(rnds);
}

function addItem(arr, value) {
    if (!arr.includes(value)) {
        arr.push(value);
    }
    return arr;
}
/**
 * 性能测试：https://blog.mutoe.com/2019/compare-filter-vs-splice-in-javascript/
 * @param arr
 * @param value
 * @returns
 */ function removeItem(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
    }
    return arr;
}
/**
 * 原 arrAddWithOrder 根据property的大小在arr中插入item
 * @param arr
 * @param item
 * @param property
 * @param descending
 * @returns
 */ function addItemWithOrder(arr, item, property, descending) {
    if (descending === void 0) descending = false;
    if (arr.includes(item)) {
        return;
    }
    arr.push(item);
    if (arr.length === 1) {
        return;
    }
    //单次插入排序
    var index = arr.length - 1;
    if (index) {
        var currentItem = arr[index];
        if (descending) {
            while(arr[index - 1][property] < currentItem[property]){
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        } else {
            while(arr[index - 1][property] > currentItem[property]){
                arr[index] = arr[index - 1];
                index--;
                if (index === 0) {
                    break;
                }
            }
        }
        arr[index] = currentItem;
    }
}
function enlargeBuffer(typeArray, length, maxSize, increase) {
    if (increase === void 0) increase = 1;
    var buffer = typeArray.buffer;
    if (buffer.byteLength < typeArray.BYTES_PER_ELEMENT * length) {
        var size = Math.ceil(length * increase);
        if (!Number.isNaN(maxSize)) {
            size = Math.min(size, maxSize);
        }
        var nbuffer = new ArrayBuffer(typeArray.BYTES_PER_ELEMENT * size);
        var nArr = new typeArray.constructor(nbuffer);
        nArr.set(typeArray);
        return nArr;
    }
    return typeArray;
}

function colorToArr$1(hex, normalized) {
    var ret = [
        0,
        0,
        0,
        0
    ];
    if (isString(hex)) {
        hex = hex.replace(/[\s\t\r\n]/g, "");
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [
                +m[1],
                +m[2],
                +m[3],
                isNaN(a) ? 255 : a * 255
            ];
        } else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [
                parseInt(hex[1] + hex[1], 16),
                parseInt(hex[2] + hex[2], 16),
                parseInt(hex[3] + hex[3], 16),
                255
            ];
        // eslint-disable-next-line no-cond-assign
        } else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [
                parseInt(m[1], 16),
                parseInt(m[2], 16),
                parseInt(m[3], 16),
                255
            ] || [
                0,
                0,
                0,
                255
            ];
        }
    } else if (_instanceof1(hex, Array)) {
        ret = [
            hex[0],
            hex[1],
            hex[2],
            isNaN(hex[3]) ? 255 : hex[3]
        ];
    }
    if (normalized) {
        for(var i = 0; i < 4; i++){
            ret[i] /= 255;
        }
    }
    return ret;
}
function getColorFromGradientStops(stops, key, normalize) {
    if (stops.length) {
        var color;
        for(var j = 1; j <= stops.length - 1; j++){
            var s0 = stops[j - 1];
            var s1 = stops[j];
            if (s0.stop <= key && key <= s1.stop) {
                color = interpolateColor(s0.color, s1.color, (key - s0.stop) / (s1.stop - s0.stop));
                break;
            }
        }
        if (!color) {
            color = stops[stops.length - 1].color;
        }
        return normalize ? color.map(function(n) {
            return n / 255;
        }) : color;
    }
    return [
        0,
        0,
        0,
        0
    ];
}
function colorStopsFromGradient(gradient) {
    var stops = [];
    if (_instanceof1(gradient, Array)) {
        gradient.forEach(function(val) {
            var s = val[0], r = val[1], g = val[2], b = val[3], a = val[4];
            stops.push({
                // TODO
                // @ts-expect-error
                stop: parsePercent$1(s),
                color: [
                    r,
                    g,
                    b,
                    a
                ]
            });
        });
    } else {
        Object.keys(gradient).forEach(function(stop) {
            var colorRGB = gradient[stop];
            var color = colorToArr$1(colorRGB);
            stops.push({
                stop: parsePercent$1(stop),
                color: color
            });
        });
    }
    stops = stops.sort(function(a, b) {
        return a.stop - b.stop;
    });
    if (stops.length) {
        if (stops[0].stop !== 0) {
            stops.unshift({
                stop: 0,
                color: stops[0].color.slice()
            });
        }
        var lastStop = stops[stops.length - 1];
        if (lastStop.stop !== 1) {
            stops.push({
                stop: 1,
                color: lastStop.color.slice()
            });
        }
    }
    return stops;
}
function interpolateColor(a, b, s, origin) {
    var ret = [];
    var ms = 1 - s;
    if (origin) {
        for(var i = 0; i < 4; i++){
            ret[i] = a[i] * ms + b[i] * s;
        }
    } else {
        for(var i1 = 0; i1 < 3; i1++){
            ret[i1] = Math.round(Math.sqrt(a[i1] * a[i1] * ms + b[i1] * b[i1] * s));
        }
        ret[3] = Math.round(a[3] * ms + b[3] * s);
    }
    return ret;
}
function parsePercent$1(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}

function getPixelRatio() {
    if (typeof douyin.screen === "object" && typeof douyin.document === "object") {
        var viewportWidth = Math.max(douyin.document.documentElement.clientWidth, douyin.window.innerWidth || 0);
        var screenWidth = douyin.screen.width;
        var viewportScale = screenWidth / viewportWidth;
        return Math.min(2 * viewportScale, 2);
    }
    return 1;
}
function isIOS() {
    // real ios device not in simulator
    return !!douyin.navigator.platform && /iPad|iPhone|iPod/.test(douyin.navigator.platform);
}
function isIOSByUA() {
    var str = douyin.navigator.userAgent.toLowerCase();
    var ver = str.match(/cpu (iphone )?os (.*?) like mac os/);
    return ver ? parseInt(ver[2], 10) : 0;
}
function isAndroid() {
    return /\b[Aa]ndroid\b/.test(douyin.navigator.userAgent);
}
function isSimulatorCellPhone() {
    return isAndroid() || /\b(iPad|iPhone|iPod)\b/.test(douyin.navigator.userAgent);
}
function isMiniProgram() {
    return isAlipayMiniApp() || isWechatMiniApp();
}
function isAlipayMiniApp() {
    var _my;
    return typeof my !== "undefined" && ((_my = my) == null ? void 0 : _my.renderTarget) === "web";
}
function isWechatMiniApp() {
    return douyin.window.__wxjs_environment === "miniprogram";
}

function imageDataFromColor(value) {
    if (isString(value)) {
        value = colorToArr$1(value);
    }
    var color = value;
    var image = {
        width: 1,
        height: 1,
        data: new Uint8Array(1 * 1 * 4)
    };
    var data = image.data;
    for(var i = 0; i < 4; i++){
        data[i] = color[i];
    }
    return image;
}
function imageDataFromGradient(gradient) {
    var width = 128;
    var image = {
        width: width,
        height: 1,
        data: new Uint8Array(width * 1 * 4)
    };
    var data = image.data;
    var stops = colorStopsFromGradient(gradient);
    if (stops.length) {
        data.set(stops[0].color, 0);
        for(var i = 1, cursor = 0; i < width - 1; i++){
            var index = i / width;
            var s0 = void 0;
            var s1 = void 0;
            for(var j = cursor; j < stops.length; j++){
                s0 = stops[j];
                s1 = stops[j + 1];
                if (s0.stop <= index && s1.stop > index) {
                    break;
                }
            }
            var color = interpolateColor(s0.color, s1.color, (index - s0.stop) / (s1.stop - s0.stop));
            data.set(color, i * 4);
        }
        data.set(stops[stops.length - 1].color, (width - 1) * 4);
    }
    return image;
}

exports.OrderType = void 0;
(function(OrderType) {
    OrderType[OrderType["none"] = 1] = "none";
    OrderType[OrderType["ascending"] = 2] = "ascending";
    OrderType[OrderType["descending"] = 3] = "descending";
})(exports.OrderType || (exports.OrderType = {}));
/**
 * 按照指定排序方式对数组排序
 * @param arr - 要排序的数组
 * @param order - 排序方式
 * @returns
 */ function sortByOrder(arr, order) {
    if (order === void 0) order = 2;
    var length = arr.length;
    if (length <= 1 || order === 1) {
        return arr;
    }
    if (length <= 30) {
        for(var i = 1; i < length; i++){
            insertionSort(arr, i, order);
        }
        return arr;
    } else {
        return fastSort(arr, order);
    }
}
/**
 * 按照指定排序方式往Sortable数组中添加成员
 * @param arr - 被添加的数组
 * @param item - 要添加的成员
 * @param order - 排序方式
 * @returns
 */ function addByOrder(arr, item, order) {
    if (order === void 0) order = 2;
    if (arr.includes(item)) {
        return arr;
    }
    arr.push(item);
    if (arr.length === 1) {
        return arr;
    }
    if (order !== 1) {
        insertionSort(arr, arr.length - 1, order);
    }
    return arr;
}
function insertionSort(array, index, order) {
    var currentItem = array[index];
    if (order !== 2) {
        while(index >= 1 && array[index - 1].priority < currentItem.priority){
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    } else {
        while(index >= 1 && array[index - 1].priority > currentItem.priority){
            array[index] = array[index - 1];
            index--;
            if (index === 0) {
                break;
            }
        }
    }
    array[index] = currentItem;
}
function fastSort(arr, order, start, end) {
    if (start === void 0) start = 0;
    if (end === void 0) end = arr.length - 1;
    // 终止条件
    if (start >= end) {
        return arr;
    }
    var base = arr[start];
    var left = start;
    var right = end;
    while(left < right){
        if (order === 2) {
            // 从右向左，寻找第一个小于base的值
            while(arr[right].priority > base.priority && right >= left){
                right--;
            }
            // 从左向右，寻找第一个大于base的值
            while(arr[left].priority <= base.priority && left < right){
                left++;
            }
        } else {
            // 从右向左，寻找第一个大于base的值
            while(arr[right].priority < base.priority && right >= left){
                right--;
            }
            // 从左向右，寻找第一个小于base的值
            while(arr[left].priority >= base.priority && left < right){
                left++;
            }
        }
        var ref;
        // 将两个值交换位置
        ref = [
            arr[right],
            arr[left]
        ], arr[left] = ref[0], arr[right] = ref[1];
    }
    var ref1;
    // 将最后两个游标相遇的位置的值与base值交换
    ref1 = [
        arr[left],
        arr[start]
    ], arr[start] = ref1[0], arr[left] = ref1[1];
    fastSort(arr, order, start, left - 1);
    fastSort(arr, order, right + 1, end);
    return arr;
}

function assertExist(item, msg) {
    if (msg === void 0) msg = "item doesn't exist";
    if (item === undefined || item === null) {
        throw new Error(msg);
    }
}
function asserts(condition, msg) {
    if (msg === void 0) msg = "asserts failed";
    if (!condition) {
        throw new Error(msg);
    }
}

/**
 * 判断是否为可解析的字体
 * - 首字母不能为数字或 `.`
 * - 不能包含特殊字符，`_-` 是被允许的
 * @param fontFamily - 字体名称
 * @returns
 */ function isValidFontFamily(fontFamily) {
    // iOS 11/12 不支持自定义字体开头为数字的名称，特殊字符也有风险
    return /^[^\d.][\w-]*$/.test(fontFamily);
}

var prefix = "[Galacean Effects]";
var localLogger;
function format(message) {
    return [
        "%c" + prefix,
        "color: #AA0100",
        "" + message
    ];
}
function error(message) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    var _console;
    (_console = console).error.apply(_console, [].concat(format(message), [
        args
    ]));
    localLogger == null ? void 0 : localLogger("error", message, args);
}
/**
 * info 会转换成浏览器的 console.debug
 * @param message
 * @param args
 */ function info(message) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    var _console;
    (_console = console).debug.apply(_console, [].concat(format(message)));
    localLogger == null ? void 0 : localLogger("info", message, args);
}
function warn(message) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    var _console;
    (_console = console).warn.apply(_console, [].concat(format(message)));
    localLogger == null ? void 0 : localLogger("warn", message, args);
}
/**
 * 注册自定义埋点函数
 *
 * @param fn
 */ function register(fn) {
    if (fn && isFunction(fn)) {
        localLogger = fn;
    }
}
var logger = {
    error: error,
    info: info,
    warn: warn,
    register: register
};

exports.DestroyOptions = void 0;
(function(DestroyOptions) {
    DestroyOptions[DestroyOptions["destroy"] = 0] = "destroy";
    DestroyOptions[DestroyOptions["keep"] = 1] = "keep";
    DestroyOptions[DestroyOptions["force"] = 0] = "force";
})(exports.DestroyOptions || (exports.DestroyOptions = {}));
function noop() {}
/**
 * 判断对象是否是`String`类型
 *
 * @static
 * @function isString
 * @param obj - 要判断的对象
 * @return
 */ function isString(obj) {
    return typeof obj === "string";
}
/**
 * 判断对象是否是`Array`类型
 *
 * @static
 * @function isArray
 * @param obj - 要判断的对象
 * @return
 */ var isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
};
/**
 * 判断对象是否是函数类型
 *
 * @static
 * @function isFunction
 * @param obj - 要判断的对象
 * @return
 */ function isFunction(obj) {
    return Object.prototype.toString.call(obj) === "[object Function]";
}
/**
 * 判断对象是否是`Object`类型
 *
 * @static
 * @function isObject
 * @param obj - 要判断的对象
 * @return
 */ function isObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
}
function isCanvas(canvas) {
    var _canvas_tagName;
    // 小程序 Canvas 无法使用 instanceof HTMLCanvasElement 判断
    return typeof canvas === "object" && canvas !== null && ((_canvas_tagName = canvas.tagName) == null ? void 0 : _canvas_tagName.toUpperCase()) === "CANVAS";
}
/**
 * 生成一个位于 min 和 max 之间的随机数
 * @param min
 * @param max
 * @returns
 */ function randomInRange(min, max) {
    return min + Math.random() * (max - min);
}
function throwDestroyedError() {
    throw new Error("Destroyed item cannot be used again.");
}
function generateGUID() {
    return v4().replace(/-/g, "");
}
function base64ToFile(base64, filename, contentType) {
    if (filename === void 0) filename = "base64File";
    if (contentType === void 0) contentType = "";
    // 去掉 Base64 字符串的 Data URL 部分（如果存在）
    var base64WithoutPrefix = base64.split(",")[1] || base64;
    // 将 base64 编码的字符串转换为二进制字符串
    var byteCharacters = douyin.atob(base64WithoutPrefix);
    // 创建一个 8 位无符号整数值的数组，即“字节数组”
    var byteArrays = [];
    // 切割二进制字符串为多个片段，并将每个片段转换成一个字节数组
    for(var offset = 0; offset < byteCharacters.length; offset += 512){
        var slice = byteCharacters.slice(offset, offset + 512);
        var byteNumbers = new Array(slice.length);
        for(var i = 0; i < slice.length; i++){
            byteNumbers[i] = slice.charCodeAt(i);
        }
        var byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
    }
    // 使用字节数组创建 Blob 对象
    var blob = new douyin.Blob(byteArrays, {
        type: contentType
    });
    // 创建 File 对象
    var file = new File([
        blob
    ], filename, {
        type: contentType
    });
    return file;
}
function applyMixins(derivedCtrl, baseCtrls) {
    baseCtrls.forEach(function(baseCtrl) {
        Object.getOwnPropertyNames(baseCtrl.prototype).forEach(function(name) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(baseCtrl.prototype, name);
            if (!propertyDescriptor) {
                throw new Error("Cannot find property descriptor of class " + baseCtrl);
            }
            Object.defineProperty(derivedCtrl.prototype, name, propertyDescriptor);
        });
    });
}

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var PI2 = Math.PI * 2;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
var NumberEpsilon = 1e-6;
function isZero(v) {
    return isNaN(v) || Math.abs(v) < NumberEpsilon;
}
function isEqual(a, b) {
    return Math.abs(a - b) < NumberEpsilon || a === Infinity && b === Infinity || a === -Infinity && b === -Infinity;
}
// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
var damp = function(x, y, lambda, dt) {
    return lerp(x, y, 1 - Math.exp(-lambda * dt));
};
// https://en.wikipedia.org/wiki/Linear_interpolation
var lerp = function(x, y, t) {
    return (1 - t) * x + t * y;
};
var degToRad = function(degrees) {
    return degrees * DEG2RAD;
};
var radToDeg = function(radians) {
    return radians * RAD2DEG;
};
function clamp$1(value, min, max) {
    var fixedMin = isNaN(min) ? -Infinity : min;
    var fixedMax = isNaN(max) ? Infinity : max;
    var lower = Math.min(fixedMin, fixedMax);
    var upper = Math.max(fixedMin, fixedMax);
    return Math.min(Math.max(value, lower), upper);
}

/**
 * 二维向量
 */ var Vector2 = /*#__PURE__*/ function() {
    function Vector2(x, y) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this.x = x;
        this.y = y;
    }
    var _proto = Vector2.prototype;
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @returns
     */ _proto.set = function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */ _proto.setZero = function setZero() {
        this.x = 0;
        this.y = 0;
        return this;
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */ _proto.setFromNumber = function setFromNumber(num) {
        this.x = num;
        this.y = num;
        return this;
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var _array_offset;
        this.x = (_array_offset = array[offset]) != null ? _array_offset : 0;
        var _array_;
        this.y = (_array_ = array[offset + 1]) != null ? _array_ : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param src - 要拷贝的对象
     * @returns 向量
     */ _proto.copyFrom = function copyFrom(src) {
        this.x = src.x;
        this.y = src.y;
        return this;
    };
    /**
     * 克隆向量
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Vector2(this.x, this.y);
    };
    /**
     * 根据下标设置元素值
     * @param index - 下标值
     * @param value - 数字
     * @returns 向量
     */ _proto.setElement = function setElement(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                console.error("index is out of range: " + index);
        }
        return this;
    };
    /**
     * 根据下标获取值
     * @param index - 下标
     * @returns 值
     */ _proto.getElement = function getElement(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                console.error("index is out of range: " + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 向量 | 数字
     * @returns 向量
     */ _proto.add = function add(right) {
        if (typeof right === "number") {
            this.x += right;
            this.y += right;
        } else if (_instanceof1(right, Array)) {
            this.x += right[0];
            this.y += right[1];
        } else {
            this.x += right.x;
            this.y += right.y;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 相加结果
     */ _proto.addVectors = function addVectors(left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        return this;
    };
    /**
     * 向量相减
     * @param right - 向量 |  数字
     * @returns 相减结果
     */ _proto.subtract = function subtract(right) {
        if (typeof right === "number") {
            this.x -= right;
            this.y -= right;
        } else if (_instanceof1(right, Array)) {
            this.x -= right[0];
            this.y -= right[1];
        } else {
            this.x -= right.x;
            this.y -= right.y;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 相减结果
     */ _proto.subtractVectors = function subtractVectors(left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 向量 | 数字
     * @returns 相乘结果
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            this.x *= right;
            this.y *= right;
        } else if (_instanceof1(right, Array)) {
            this.x *= right[0];
            this.y *= right[1];
        } else {
            this.x *= right.x;
            this.y *= right.y;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 相乘结果
     */ _proto.multiplyVectors = function multiplyVectors(left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        return this;
    };
    /**
     * 向量相除
     * @param right - 向量 | 数字
     * @returns 相除结果
     */ _proto.divide = function divide(right) {
        if (typeof right === "number") {
            this.x /= right;
            this.y /= right;
        } else if (_instanceof1(right, Array)) {
            this.x /= right[0];
            this.y /= right[1];
        } else {
            this.x /= right.x;
            this.y /= right.y;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */ _proto.scale = function scale(v) {
        this.x *= v;
        this.y *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */ _proto.sum = function sum() {
        return this.x + this.y;
    };
    /**
     * 向量求最小值
     * @param v - 向量
     * @returns 最小值
     */ _proto.min = function min(v) {
        if (typeof v === "number") {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
        } else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量
     * @returns 最大值
     */ _proto.max = function max(v) {
        if (typeof v === "number") {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
        } else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 极小值
     * @param max - 极大值
     * @returns 向量
     */ _proto.clamp = function clamp(min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */ _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */ _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    };
    /**
     * 向量取四舍五入
     * @returns 四舍五入结果
     */ _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */ _proto.abs = function abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        return this;
    };
    /**
     * 向量取反
     * @returns 取反结果
     */ _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    };
    /**
     * 向量长度
     * @returns 求值结果
     */ _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    /**
     * 向量长度平方
     * @returns 求值结果
     */ _proto.lengthSquared = function lengthSquared() {
        return this.x * this.x + this.y * this.y;
    };
    /**
     * 向量归一化
     * @returns 归一化结果
     */ _proto.normalize = function normalize() {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */ _proto.setLength = function setLength(length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量线性插值
     * @param other - 向量
     * @param alpha - 插值比
     * @returns 计算结果
     */ _proto.lerp = function lerp(other, alpha) {
        this.x += (other.x - this.x) * alpha;
        this.y += (other.y - this.y) * alpha;
        return this;
    };
    /**
     * 向量线性插值
     * @param v1 - 向量
     * @param v2 - 向量
     * @param alpha - 插值比
     * @returns 计算结果
     */ _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    };
    /**
     * 向量点乘
     * @param v - 向量
     * @returns 点乘结果
     */ _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y;
    };
    /**
     * 向量叉乘
     * @param v - 向量
     * @returns 叉乘结果
     */ _proto.cross = function cross(v) {
        return this.x * v.y - this.y * v.x;
    };
    /**
     * 点距离
     * @param v - 点
     * @returns 距离
     */ _proto.distance = function distance(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * 点距离平方
     * @param v - 点
     * @returns 距离平方
     */ _proto.distanceSquared = function distanceSquared(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        return dx * dx + dy * dy;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */ _proto.equals = function equals(v) {
        return this.x === v.x && this.y === v.y;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */ _proto.isZero = function isZero() {
        var eps = NumberEpsilon;
        var _this = this, x = _this.x, y = _this.y;
        return Math.abs(x) <= eps && Math.abs(y) <= eps;
    };
    /**
     * 向量转数组
     * @returns 数组
     */ _proto.toArray = function toArray() {
        return [
            this.x,
            this.y
        ];
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
    };
    /**
     * 随机生成向量
     * @returns 向量
     */ _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    };
    /**
     * 通过标量创建向量
     * @param num - 数值
     * @returns 向量
     */ Vector2.fromNumber = function fromNumber(num) {
        return new Vector2().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ Vector2.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Vector2().setFromArray(array, offset);
    };
    return Vector2;
}();
/**
     * 二维向量的常量
     */ Vector2.ONE = new Vector2(1.0, 1.0);
Vector2.ZERO = new Vector2(0.0, 0.0);

/**
 * 三维向量
 */ var Vector3 = /*#__PURE__*/ function() {
    function Vector3(x, y, z) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    var _proto = Vector3.prototype;
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @param z - z 轴分量
     * @returns 向量
     */ _proto.set = function set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */ _proto.setZero = function setZero() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        return this;
    };
    /**
     * 通过标量数值设置向量
     * @param num - 数值
     * @returns 向量
     */ _proto.setFromNumber = function setFromNumber(num) {
        this.x = num;
        this.y = num;
        this.z = num;
        return this;
    };
    /**
     * 通过数组设置向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var _array_offset;
        this.x = (_array_offset = array[offset]) != null ? _array_offset : 0;
        var _array_;
        this.y = (_array_ = array[offset + 1]) != null ? _array_ : 0;
        var _array_1;
        this.z = (_array_1 = array[offset + 2]) != null ? _array_1 : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param v - 要拷贝的对象
     * @returns 向量
     */ _proto.copyFrom = function copyFrom(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    };
    /**
     * 克隆向量
     * @returns 向量
     */ _proto.clone = function clone() {
        return new Vector3(this.x, this.y, this.z);
    };
    /**
     * 根据下标设置向量分量
     * @param index - 下标值
     * @param value - 数字
     * @returns 向量
     */ _proto.setElement = function setElement(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                console.error("index is out of range: " + index);
        }
        return this;
    };
    /**
     * 根据下标获取向量分量
     * @param index - 下标
     * @returns
     */ _proto.getElement = function getElement(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                console.error("index is out of range: " + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 向量 | 数字
     * @returns 相加结果
     */ _proto.add = function add(right) {
        if (typeof right === "number") {
            this.x += right;
            this.y += right;
            this.z += right;
        } else if (_instanceof1(right, Array)) {
            this.x += right[0];
            this.y += right[1];
            this.z += right[2];
        } else {
            this.x += right.x;
            this.y += right.y;
            this.z += right.z;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 相加结果
     */ _proto.addVectors = function addVectors(left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        return this;
    };
    /**
     * 向量乘比例后相加
     * @param right - 向量
     * @param s - 比例
     * @returns 相加结果
     */ _proto.addScaledVector = function addScaledVector(right, s) {
        this.x += right.x * s;
        this.y += right.y * s;
        this.z += right.z * s;
        return this;
    };
    /**
     * 向量相减
     * @param right - 向量 | 数字
     * @returns 相减
     */ _proto.subtract = function subtract(right) {
        if (typeof right === "number") {
            this.x -= right;
            this.y -= right;
            this.z -= right;
        } else if (_instanceof1(right, Array)) {
            this.x -= right[0];
            this.y -= right[1];
            this.z -= right[2];
        } else {
            this.x -= right.x;
            this.y -= right.y;
            this.z -= right.z;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 相减结果
     */ _proto.subtractVectors = function subtractVectors(left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        this.z = left.z - right.z;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 向量 | 数字
     * @returns 相乘结果
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            this.x *= right;
            this.y *= right;
            this.z *= right;
        } else if (_instanceof1(right, Array)) {
            this.x *= right[0];
            this.y *= right[1];
            this.z *= right[2];
        } else {
            this.x *= right.x;
            this.y *= right.y;
            this.z *= right.z;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 相乘结果
     */ _proto.multiplyVectors = function multiplyVectors(left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        this.z = left.z * right.z;
        return this;
    };
    /**
     * 向量相除
     * @param right - 向量 | 数字
     * @returns 相除结果
     */ _proto.divide = function divide(right) {
        if (typeof right === "number") {
            this.x /= right;
            this.y /= right;
            this.z /= right;
        } else if (_instanceof1(right, Array)) {
            this.x /= right[0];
            this.y /= right[1];
            this.z /= right[2];
        } else {
            this.x /= right.x;
            this.y /= right.y;
            this.z /= right.z;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */ _proto.scale = function scale(v) {
        this.x *= v;
        this.y *= v;
        this.z *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */ _proto.sum = function sum() {
        return this.x + this.y + this.z;
    };
    /**
     * 向量求最小值
     * @param v - 向量或数值
     * @returns 求值结果
     */ _proto.min = function min(v) {
        if (typeof v === "number") {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
            this.z = Math.min(this.z, v);
        } else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量或数值
     * @returns 求值结果
     */ _proto.max = function max(v) {
        if (typeof v === "number") {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
            this.z = Math.max(this.z, v);
        } else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 向量
     * @param max - 向量
     * @returns 求值结果
     */ _proto.clamp = function clamp(min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */ _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */ _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    };
    /**
     * 向量四舍五入
     * @returns 计算结果
     */ _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */ _proto.abs = function abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        this.z = Math.abs(this.z);
        return this;
    };
    /**
     * 向量取反
     * @returns 向量
     */ _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 向量长度
     * @returns 长度
     */ _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    /**
     * 向量长度平方
     * @returns 长度平方
     */ _proto.lengthSquared = function lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    /**
     * 向量归一化
     * @returns 向量
     */ _proto.normalize = function normalize() {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */ _proto.setLength = function setLength(length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量间求线性插值
     * @param other - 向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */ _proto.lerp = function lerp(other, alpha) {
        this.x += (other.x - this.x) * alpha;
        this.y += (other.y - this.y) * alpha;
        this.z += (other.z - this.z) * alpha;
        return this;
    };
    /**
     * 向量间求线性插值
     * @param v1 - 第一个向量
     * @param v2 - 第二个向量
     * @param alpha - 插值比例
     * @returns 求值结果
     */ _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    };
    /**
     * 向量求点积，点积为零表示两向量垂直
     * @param v - 向量
     * @returns 点积结果
     */ _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    };
    /**
     * 向量求叉积
     * @param right - 向量
     * @returns 叉积结果
     */ _proto.cross = function cross(right) {
        return this.crossVectors(this, right);
    };
    /**
     * 向量（a 与 b）求叉积
     * @param left - 向量
     * @param right - 向量
     * @returns 叉积结果
     */ _proto.crossVectors = function crossVectors(left, right) {
        var ax = left.x, ay = left.y, az = left.z;
        var bx = right.x, by = right.y, bz = right.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    };
    /**
     * 向量反射
     * @param normal - 法线
     * @returns 反射结果
     */ _proto.reflect = function reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.subtract(normal.clone().multiply(2 * this.dot(normal)));
    };
    /**
     * 计算向量距离
     * @param v - 向量
     * @returns 距离
     */ _proto.distance = function distance(v) {
        return Math.sqrt(this.distanceSquared(v));
    };
    /**
     * 计算向量距离平方
     * @param v - 向量
     * @returns 距离平方
     */ _proto.distanceSquared = function distanceSquared(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */ _proto.equals = function equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */ _proto.isZero = function isZero() {
        var eps = NumberEpsilon;
        var _this = this, x = _this.x, y = _this.y, z = _this.z;
        return Math.abs(x) <= eps && Math.abs(y) <= eps && Math.abs(z) <= eps;
    };
    /**
     * 向量转数组
     * @param array - 目标保存对象
     * @returns 数组
     */ _proto.toArray = function toArray() {
        return [
            this.x,
            this.y,
            this.z
        ];
    };
    _proto.toVector2 = function toVector2() {
        return new Vector2(this.x, this.y);
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
    };
    /**
     * 获取随机向量
     * @returns
     */ _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    };
    /**
     * 用欧拉角旋转向量
     * @param euler - 欧拉角
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 旋转结果
     */ _proto.applyEuler = function applyEuler(euler, out) {
        return euler.rotateVector3(this, out);
    };
    /**
     * 用四元数旋转向量
     * @param q - 四元数
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 旋转结果
     */ _proto.applyQuaternion = function applyQuaternion(q, out) {
        return q.rotateVector3(this, out);
    };
    /**
     * 用矩阵变换点
     * @param m - 变换矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 结果点
     */ _proto.applyMatrix = function applyMatrix(m, out) {
        return m.transformPoint(this, out);
    };
    /**
     * 用法向量矩阵变换法向量
     * @param m - 法向量矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 向量
     */ _proto.applyNormalMatrix = function applyNormalMatrix(m, out) {
        return m.transformNormal(this, out);
    };
    /**
     * 用投影矩阵变换点
     * @param m - 投影矩阵
     * @param [out] - 输出结果，如果没有就覆盖当前向量值
     * @returns 结果点
     */ _proto.applyProjectionMatrix = function applyProjectionMatrix(m, out) {
        return m.projectPoint(this, out);
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */ Vector3.fromNumber = function fromNumber(num) {
        return new Vector3().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ Vector3.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Vector3().setFromArray(array, offset);
    };
    return Vector3;
}();
/**
     * 三维向量的常量
     */ Vector3.X = new Vector3(1.0, 0.0, 0.0);
Vector3.Y = new Vector3(0.0, 1.0, 0.0);
Vector3.Z = new Vector3(0.0, 0.0, 1.0);
Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);

/**
 * 四元数
 */ var Quaternion = /*#__PURE__*/ function() {
    function Quaternion(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 1;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    var _proto = Quaternion.prototype;
    /**
     * 四元数设置
     * @param x - x 分量
     * @param y - y 分量
     * @param z - z 分量
     * @param w - w 分量
     * @returns 四元数
     */ _proto.set = function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    /**
     * 通过欧拉角设置四元数
     * @param euler - 欧拉角
     * @returns
     */ _proto.setFromEuler = function setFromEuler(euler) {
        euler.toQuaternion(this);
        return this;
    };
    /**
     * 通过旋转轴和旋转角度设置四元数
     * @param axis - 旋转轴
     * @param angle - 旋转角度（弧度）
     * @returns
     */ _proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
        var halfAngle = angle / 2;
        var s = Math.sin(halfAngle);
        var v = Quaternion.tempVec0;
        v.copyFrom(axis).normalize();
        this.x = v.x * s;
        this.y = v.y * s;
        this.z = v.z * s;
        this.w = Math.cos(halfAngle);
        return this;
    };
    /**
     * 通过 Vector4Like 创建四元数
     * @param v - Vector4Like
     * @returns
     */ _proto.setFromVector4 = function setFromVector4(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    };
    /**
     * 通过数组设置四元数
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    };
    /**
     * 通过矩阵设置四元数
     * @param m - 矩阵
     * @returns
     */ _proto.setFromRotationMatrix = function setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;
        var m11 = te[0];
        var m12 = te[4];
        var m13 = te[8];
        var m21 = te[1];
        var m22 = te[5];
        var m23 = te[9];
        var m31 = te[2];
        var m32 = te[6];
        var m33 = te[10];
        var trace = m11 + m22 + m33;
        if (trace > 0) {
            var s = 0.5 / Math.sqrt(trace + 1.0);
            this.w = 0.25 / s;
            this.x = (m32 - m23) * s;
            this.y = (m13 - m31) * s;
            this.z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            var s1 = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this.w = (m32 - m23) / s1;
            this.x = 0.25 * s1;
            this.y = (m12 + m21) / s1;
            this.z = (m13 + m31) / s1;
            this.negate();
        } else if (m22 > m33) {
            var s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this.w = (m13 - m31) / s2;
            this.x = (m12 + m21) / s2;
            this.y = 0.25 * s2;
            this.z = (m23 + m32) / s2;
            this.negate();
        } else {
            var s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this.w = (m21 - m12) / s3;
            this.x = (m13 + m31) / s3;
            this.y = (m23 + m32) / s3;
            this.z = 0.25 * s3;
            this.negate();
        }
        // 兼容原先数学库
        return this;
    };
    /**
     * 通过开始和结束向量设置四元数
     * @param from - 开始向量
     * @param to - 结束向量
     * @returns
     */ _proto.setFromUnitVectors = function setFromUnitVectors(from, to) {
        // assumes direction vectors vFrom and vTo are normalized
        var r = from.dot(to) + 1;
        if (r < Number.EPSILON) {
            r = 0;
            if (Math.abs(from.x) > Math.abs(from.z)) {
                this.x = -from.y;
                this.y = from.x;
                this.z = 0;
                this.w = r;
            } else {
                this.x = 0;
                this.y = -from.z;
                this.z = from.y;
                this.w = r;
            }
        } else {
            this.x = from.y * to.z - from.z * to.y;
            this.y = from.z * to.x - from.x * to.z;
            this.z = from.x * to.y - from.y * to.x;
            this.w = r;
        }
        return this.normalize();
    };
    /**
     * 四元数拷贝
     * @param quat - 拷贝目标四元数
     * @returns 拷贝四元数
     */ _proto.copyFrom = function copyFrom(quat) {
        this.x = quat.x;
        this.y = quat.y;
        this.z = quat.z;
        this.w = quat.w;
        return this;
    };
    /**
     * 四元数克隆
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };
    /**
     * 四元数间的夹角计算
     * @param other - 其他四元数
     * @returns 夹角
     */ _proto.angleTo = function angleTo(other) {
        return 2 * Math.acos(Math.abs(clamp$1(this.dot(other), -1, 1)));
    };
    /**
     * 四元数向目标旋转
     * @param q - 四元数
     * @param step - 旋转弧度
     * @returns 目标四元数
     */ _proto.rotateTowards = function rotateTowards(q, step) {
        var angle = this.angleTo(q);
        if (angle === 0) {
            return this;
        }
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    };
    /**
     * 四元数单位化
     * @returns 单位四元数
     */ _proto.identity = function identity() {
        return this.set(0, 0, 0, 1);
    };
    /**
     * 四元数求逆
     * @returns 四元数的逆
     */ _proto.invert = function invert() {
        return this.conjugate();
    };
    /**
     * 四元数取负
     * @returns 负四元数
     */ _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    };
    /**
     * 四元数求共轭值
     * @returns 四元数的共轭值
     */ _proto.conjugate = function conjugate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 四元数点乘结果
     * @param v
     * @return
     */ _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    /**
     * 四元数的模平方
     * @return
     */ _proto.lengthSquared = function lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    /**
     * 四元数的欧式长度
     * @returns 长度
     */ _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    /**
     * 四元数归一化
     * @returns 归一化值
     */ _proto.normalize = function normalize() {
        var l = this.length();
        if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        } else {
            l = 1 / l;
            this.x = this.x * l;
            this.y = this.y * l;
            this.z = this.z * l;
            this.w = this.w * l;
        }
        return this;
    };
    /**
     * 四元数右乘
     * @param right - 右乘的四元数
     * @returns
     */ _proto.multiply = function multiply(right) {
        return this.multiplyQuaternions(this, right);
    };
    /**
     * 四元数左乘
     * @param left - 左乘的四元数
     * @returns
     */ _proto.premultiply = function premultiply(left) {
        return this.multiplyQuaternions(left, this);
    };
    /**
     * 四元数乘法
     * @param left - 四元数
     * @param right - 四元数
     * @returns 四元数
     */ _proto.multiplyQuaternions = function multiplyQuaternions(left, right) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = left.x;
        var qay = left.y;
        var qaz = left.z;
        var qaw = left.w;
        var qbx = right.x;
        var qby = right.y;
        var qbz = right.z;
        var qbw = right.w;
        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        return this;
    };
    /**
     * 四元数线性插值
     * @see http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
     * @param other - 四元数
     * @param t - 插值比
     * @returns 插值结果
     */ _proto.slerp = function slerp(other, t) {
        if (t === 0) {
            return this;
        }
        if (t === 1) {
            return this.copyFrom(other);
        }
        var _this = this, x = _this.x, y = _this.y, z = _this.z, w = _this.w;
        var cosHalfTheta = w * other.w + x * other.x + y * other.y + z * other.z;
        if (cosHalfTheta < 0) {
            this.w = -other.w;
            this.x = -other.x;
            this.y = -other.y;
            this.z = -other.z;
            cosHalfTheta = -cosHalfTheta;
        } else {
            this.copyFrom(other);
        }
        if (cosHalfTheta >= 1.0) {
            this.w = w;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            var s = 1 - t;
            this.w = s * w + t * this.w;
            this.x = s * x + t * this.x;
            this.y = s * y + t * this.y;
            this.z = s * z + t * this.z;
            this.normalize();
            return this;
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
        var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this.w = w * ratioA + this.w * ratioB;
        this.x = x * ratioA + this.x * ratioB;
        this.y = y * ratioA + this.y * ratioB;
        this.z = z * ratioA + this.z * ratioB;
        return this;
    };
    /**
     * 两个四元数的线性插值
     * @param qa - 四元数
     * @param qb - 四元数
     * @param t - 插值比
     */ _proto.slerpQuaternions = function slerpQuaternions(qa, qb, t) {
        this.copyFrom(qa).slerp(qb, t);
    };
    /**
     * 通过四元数旋转向量
     * @param v - 待旋转向量
     * @param [out] - 旋转结果，如果没有传入直接覆盖输入值
     * @returns
     */ _proto.rotateVector3 = function rotateVector3(v, out) {
        var _this = this, qx = _this.x, qy = _this.y, qz = _this.z, qw = _this.w;
        var vx = v.x, vy = v.y, vz = v.z;
        var ix = qw * vx + qy * vz - qz * vy;
        var iy = qw * vy + qz * vx - qx * vz;
        var iz = qw * vz + qx * vy - qy * vx;
        var iw = -qx * vx - qy * vy - qz * vz;
        var res = out != null ? out : v;
        res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return res;
    };
    /**
     * 四元数判等
     * @param quaternion - 四元数
     * @returns 判等结果
     */ _proto.equals = function equals(quaternion) {
        return quaternion.x === this.x && quaternion.y === this.y && quaternion.z === this.z && quaternion.w === this.w;
    };
    /**
     * 四元数保存为数组
     * @returns
     */ _proto.toArray = function toArray() {
        return [
            this.x,
            this.y,
            this.z,
            this.w
        ];
    };
    /**
     * 四元数转四维向量数组
     * @param vec - 目标保存对象
     * @returns 保存结果
     */ _proto.toVector4 = function toVector4(vec) {
        return vec.set(this.x, this.y, this.z, this.w);
    };
    /**
     * 四元数转欧拉角
     * @param euler - 目标欧拉角
     * @returns 欧拉角
     */ _proto.toEuler = function toEuler(euler) {
        return euler.setFromQuaternion(this);
    };
    /**
     * 四元数转矩阵
     * @param mat - 目标矩阵
     * @returns
     */ _proto.toMatrix4 = function toMatrix4(mat) {
        return mat.compose(Vector3.ZERO, this, Vector3.ONE);
    };
    /**
     * 通过欧拉角创建四元数
     * @param euler - 欧拉角
     * @returns 四元数
     */ Quaternion.fromEuler = function fromEuler(euler) {
        return new Quaternion().setFromEuler(euler);
    };
    /**
     * 通过旋转轴和旋转角度创建四元数
     * @param axis - 旋转轴
     * @param angle - 旋转角（弧度值）
     * @returns 四元数
     */ Quaternion.fromAxisAngle = function fromAxisAngle(axis, angle) {
        return new Quaternion().setFromAxisAngle(axis, angle);
    };
    /**
     * 通过 Vector4Like 创建四元数
     * @param v - Vector4Like
     * @returns 四元数
     */ Quaternion.fromVector4 = function fromVector4(v) {
        return new Quaternion().setFromVector4(v);
    };
    /**
     * 通过数组创建四元数
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 四元数
     */ Quaternion.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Quaternion().setFromArray(array, offset);
    };
    /**
     * 通过旋转矩阵创建四元数
     * @param m - 旋转矩阵
     * @returns 四元数
     */ Quaternion.fromRotationMatrix = function fromRotationMatrix(m) {
        return new Quaternion().setFromRotationMatrix(m);
    };
    /**
     * 通过开始和结束向量创建四元数
     * @param from - 开始向量
     * @param to - 结束向量
     * @returns
     */ Quaternion.fromUnitVectors = function fromUnitVectors(from, to) {
        return new Quaternion().setFromUnitVectors(from, to);
    };
    return Quaternion;
}();
Quaternion.tempVec0 = new Vector3();

/**
 * 四阶矩阵（列优先矩阵）
 */ var Matrix4$1 = /*#__PURE__*/ function() {
    function Matrix4(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44) {
        if (m11 === void 0) m11 = 1;
        if (m21 === void 0) m21 = 0;
        if (m31 === void 0) m31 = 0;
        if (m41 === void 0) m41 = 0;
        if (m12 === void 0) m12 = 0;
        if (m22 === void 0) m22 = 1;
        if (m32 === void 0) m32 = 0;
        if (m42 === void 0) m42 = 0;
        if (m13 === void 0) m13 = 0;
        if (m23 === void 0) m23 = 0;
        if (m33 === void 0) m33 = 1;
        if (m43 === void 0) m43 = 0;
        if (m14 === void 0) m14 = 0;
        if (m24 === void 0) m24 = 0;
        if (m34 === void 0) m34 = 0;
        if (m44 === void 0) m44 = 1;
        this.elements = [
            m11,
            m21,
            m31,
            m41,
            m12,
            m22,
            m32,
            m42,
            m13,
            m23,
            m33,
            m43,
            m14,
            m24,
            m34,
            m44
        ];
    }
    var _proto = Matrix4.prototype;
    /**
     * 设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m21 - 第 2 行，第 1 列
     * @param m31 - 第 3 行，第 1 列
     * @param m41 - 第 4 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m22 - 第 2 行，第 2 列
     * @param m32 - 第 3 行，第 2 列
     * @param m42 - 第 4 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m23 - 第 2 行，第 3 列
     * @param m33 - 第 3 行，第 3 列
     * @param m43 - 第 4 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m24 - 第 2 行，第 4 列
     * @param m34 - 第 3 行，第 4 列
     * @param m44 - 第 4 行，第 4 列
     * @returns 矩阵
     */ _proto.set = function set(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m21;
        e[2] = m31;
        e[3] = m41;
        e[4] = m12;
        e[5] = m22;
        e[6] = m32;
        e[7] = m42;
        e[8] = m13;
        e[9] = m23;
        e[10] = m33;
        e[11] = m43;
        e[12] = m14;
        e[13] = m24;
        e[14] = m34;
        e[15] = m44;
        return this;
    };
    /**
     * 通过行优先数据设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m24 - 第 2 行，第 4 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @param m34 - 第 3 行，第 4 列
     * @param m41 - 第 4 行，第 1 列
     * @param m42 - 第 4 行，第 2 列
     * @param m43 - 第 4 行，第 3 列
     * @param m44 - 第 4 行，第 4 列
     * @returns 矩阵
     */ _proto.setFromRowMajorData = function setFromRowMajorData(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[4] = m12;
        e[8] = m13;
        e[12] = m14;
        e[1] = m21;
        e[5] = m22;
        e[9] = m23;
        e[13] = m24;
        e[2] = m31;
        e[6] = m32;
        e[10] = m33;
        e[14] = m34;
        e[3] = m41;
        e[7] = m42;
        e[11] = m43;
        e[15] = m44;
        return this;
    };
    /**
     * 通过四个列向量设置矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @param c4 - 第四列
     * @returns 矩阵
     */ _proto.setFromColumnVectors = function setFromColumnVectors(c1, c2, c3, c4) {
        return this.set(c1.x, c1.y, c1.z, c1.w, c2.x, c2.y, c2.z, c2.w, c3.x, c3.y, c3.z, c3.w, c4.x, c4.y, c4.z, c4.w);
    };
    /**
     * 通过三维矩阵设置矩阵
     * @param m - 三维矩阵
     * @returns 设置结果
     */ _proto.setFromMatrix3 = function setFromMatrix3(m) {
        var me = m.elements;
        this.set(me[0], me[1], me[2], 0, me[3], me[4], me[5], 0, me[6], me[7], me[8], 0, 0, 0, 0, 1);
        return this;
    };
    /**
     * 通过数组设置矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        for(var i = 0; i < 16; i++){
            this.elements[i] = array[offset + i];
        }
        return this;
    };
    /**
     * 通过缩放设置矩阵
     * @param x - x 方向缩放
     * @param y - y 方向缩放
     * @param z - z 方向缩放
     * @returns 缩放矩阵
     */ _proto.setFromScale = function setFromScale(x, y, z) {
        return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    };
    /**
     * 通过平移设置矩阵
     * @param x - x 方向平移
     * @param y - y 方向平移
     * @param z - z 方向平移
     * @returns 平移矩阵
     */ _proto.setFromTranslation = function setFromTranslation(x, y, z) {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1);
    };
    /**
     * 通过 x 轴旋转角度设置矩阵
     * @param theta - x 轴旋转弧度
     * @returns 矩阵
     */ _proto.setFromRotationX = function setFromRotationX(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过 y 轴旋转角度设置矩阵
     * @param theta - y 轴旋转弧度
     * @returns 矩阵
     */ _proto.setFromRotationY = function setFromRotationY(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过 z 轴旋转角度设置矩阵
     * @param theta - z 轴旋转弧度
     * @returns 矩阵
     */ _proto.setFromRotationZ = function setFromRotationZ(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 根据三维旋转轴与弧度设置矩阵
     * @param axis - 三维旋转轴
     * @param angle - 旋转弧度
     * @returns 矩阵
     */ _proto.setFromRotationAxis = function setFromRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        var v = Matrix4.tempVec0;
        v.copyFrom(axis).normalize();
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = v.x, y = v.y, z = v.z;
        var tx = t * x;
        var ty = t * y;
        return this.set(tx * x + c, tx * y + s * z, tx * z - s * y, 0, tx * y - s * z, ty * y + c, ty * z + s * x, 0, tx * z + s * y, ty * z - s * x, t * z * z + c, 0, 0, 0, 0, 1);
    };
    /**
     * 通过欧拉角设置矩阵
     * @param euler - 欧拉角
     * @returns 矩阵
     */ _proto.setFromEuler = function setFromEuler(euler) {
        euler.toMatrix4(this);
        return this;
    };
    /**
     * 通过四元数设置矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */ _proto.setFromQuaternion = function setFromQuaternion(quat) {
        return this.compose(Vector3.ZERO, quat, Vector3.ONE);
    };
    /**
     * 通过倾斜参数设置矩阵
     * @param x - x 方向倾斜分量
     * @param y - y 方向倾斜分量
     * @param z - z 方向倾斜分量
     * @returns 倾斜矩阵
     */ _proto.setFromShear = function setFromShear(x, y, z) {
        return this.set(1, x, x, 0, y, 1, y, 0, z, z, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 通过基轴设置矩阵
     * @param xAxis - x 轴
     * @param yAxis - y 轴
     * @param zAxis - z 轴
     * @returns 倾斜矩阵
     */ _proto.setFromBasis = function setFromBasis(xAxis, yAxis, zAxis) {
        return this.set(xAxis.x, xAxis.y, xAxis.z, 0, yAxis.x, yAxis.y, yAxis.z, 0, zAxis.x, zAxis.y, zAxis.z, 0, 0, 0, 0, 1);
    };
    /**
     * 矩阵清零
     * @returns 零矩阵
     */ _proto.setZero = function setZero() {
        for(var i = 0; i < 16; i++){
            this.elements[i] = 0;
        }
        return this;
    };
    /**
     * 矩阵单位化
     * @returns 单位矩阵
     */ _proto.identity = function identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 单位阵判断
     * @returns 判断结果
     */ _proto.isIdentity = function isIdentity() {
        var e = this.elements;
        return e[0] === 1 && e[4] === 0 && e[8] === 0 && e[12] === 0 && e[1] === 0 && e[5] === 1 && e[9] === 0 && e[13] === 0 && e[2] === 0 && e[6] === 0 && e[10] === 1 && e[14] === 0 && e[3] === 0 && e[7] === 0 && e[11] === 0 && e[15] === 1;
    };
    /**
     * 矩阵克隆
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        var e = this.elements;
        return new Matrix4(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
    };
    /**
     * 矩阵复制
     * @param m - 复制对象
     * @returns 复制结果
     */ _proto.copyFrom = function copyFrom(m) {
        this.elements = [].concat(m.elements);
        return this;
    };
    /**
     * 得到列向量
     * @param i - 列向量索引，从 0 开始
     * @param v
     * @returns 矩阵
     */ _proto.getColumnVector = function getColumnVector(i, v) {
        return v.set(this.elements[i * 4], this.elements[i * 4 + 1], this.elements[i * 4 + 2], this.elements[i * 4 + 3]);
    };
    /**
     * 设置相机矩阵
     * @param eye - 相机位置
     * @param target - 目标位置
     * @param up - 相机方向
     * @returns 矩阵
     */ _proto.lookAt = function lookAt(eye, target, up) {
        var vX = Matrix4.tempVec0;
        var vY = Matrix4.tempVec1;
        var vZ = Matrix4.tempVec2;
        vZ.subtractVectors(eye, target);
        vZ.normalize();
        vX.crossVectors(up, vZ);
        vX.normalize();
        vY.crossVectors(vZ, vX);
        var te = this.elements;
        te[0] = vX.x;
        te[1] = vY.x;
        te[2] = vZ.x;
        te[3] = 0;
        te[4] = vX.y;
        te[5] = vY.y;
        te[6] = vZ.y;
        te[7] = 0;
        te[8] = vX.z;
        te[9] = vY.z;
        te[10] = vZ.z;
        te[11] = 0;
        te[12] = -vX.dot(eye);
        te[13] = -vY.dot(eye);
        te[14] = -vZ.dot(eye);
        te[15] = 1;
        return this;
    };
    /**
     * 矩阵乘比例后相加
     * @param right - 矩阵
     * @param s - 比例
     * @returns 相加结果
     */ _proto.addScaledMatrix = function addScaledMatrix(right, s) {
        var te = this.elements;
        var re = right.elements;
        for(var i = 0; i < 16; i++){
            te[i] += re[i] * s;
        }
        return this;
    };
    /**
     * 矩阵右乘
     * @param right - 右侧矩阵或数值
     * @returns 右乘结果
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            for(var i = 0; i < 16; i++){
                this.elements[i] *= right;
            }
            return this;
        } else {
            return this.multiplyMatrices(this, right);
        }
    };
    /**
     * 矩阵左乘
     * @param left - 左侧矩阵
     * @returns 左乘结果
     */ _proto.premultiply = function premultiply(left) {
        return this.multiplyMatrices(left, this);
    };
    /**
     * 矩阵相乘
     * @param left - 矩阵
     * @param right - 矩阵
     * @returns 相乘结果
     */ _proto.multiplyMatrices = function multiplyMatrices(left, right) {
        var ae = left.elements;
        var be = right.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    };
    /**
     * 矩阵缩放
     * @param s - 缩放比例
     * @returns 缩放结果
     */ _proto.multiplyScalar = function multiplyScalar(s) {
        var e = this.elements;
        e[0] *= s;
        e[4] *= s;
        e[8] *= s;
        e[12] *= s;
        e[1] *= s;
        e[5] *= s;
        e[9] *= s;
        e[13] *= s;
        e[2] *= s;
        e[6] *= s;
        e[10] *= s;
        e[14] *= s;
        e[3] *= s;
        e[7] *= s;
        e[11] *= s;
        e[15] *= s;
        return this;
    };
    /**
     * 矩阵求行列式值
     * @returns 行列式值
     */ _proto.determinant = function determinant() {
        var e = this.elements;
        var m11 = e[0], m12 = e[4], m13 = e[8], m14 = e[12];
        var m21 = e[1], m22 = e[5], m23 = e[9], m24 = e[13];
        var m31 = e[2], m32 = e[6], m33 = e[10], m34 = e[14];
        var m41 = e[3], m42 = e[7], m43 = e[11], m44 = e[15];
        return m41 * (+m14 * m23 * m32 - m13 * m24 * m32 - m14 * m22 * m33 + m12 * m24 * m33 + m13 * m22 * m34 - m12 * m23 * m34) + m42 * (+m11 * m23 * m34 - m11 * m24 * m33 + m14 * m21 * m33 - m13 * m21 * m34 + m13 * m24 * m31 - m14 * m23 * m31) + m43 * (+m11 * m24 * m32 - m11 * m22 * m34 - m14 * m21 * m32 + m12 * m21 * m34 + m14 * m22 * m31 - m12 * m24 * m31) + m44 * (-m13 * m22 * m31 - m11 * m23 * m32 + m11 * m22 * m33 + m13 * m21 * m32 - m12 * m21 * m33 + m12 * m23 * m31);
    };
    /**
     * 矩阵转置
     * @returns 转置结果
     */ _proto.transpose = function transpose() {
        var e = this.elements;
        var t;
        t = e[1];
        e[1] = e[4];
        e[4] = t;
        t = e[2];
        e[2] = e[8];
        e[8] = t;
        t = e[3];
        e[3] = e[12];
        e[12] = t;
        //
        t = e[6];
        e[6] = e[9];
        e[9] = t;
        t = e[7];
        e[7] = e[13];
        e[13] = t;
        t = e[11];
        e[11] = e[14];
        e[14] = t;
        return this;
    };
    /**
     * 矩阵求逆
     * @returns 逆矩阵
     */ _proto.invert = function invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var e = this.elements;
        var m11 = e[0], m21 = e[1], m31 = e[2], m41 = e[3];
        var m12 = e[4], m22 = e[5], m32 = e[6], m42 = e[7];
        var m13 = e[8], m23 = e[9], m33 = e[10], m43 = e[11];
        var m14 = e[12], m24 = e[13], m34 = e[14], m44 = e[15];
        var t11 = m23 * m34 * m42 - m24 * m33 * m42 + m24 * m32 * m43 - m22 * m34 * m43 - m23 * m32 * m44 + m22 * m33 * m44;
        var t12 = m14 * m33 * m42 - m13 * m34 * m42 - m14 * m32 * m43 + m12 * m34 * m43 + m13 * m32 * m44 - m12 * m33 * m44;
        var t13 = m13 * m24 * m42 - m14 * m23 * m42 + m14 * m22 * m43 - m12 * m24 * m43 - m13 * m22 * m44 + m12 * m23 * m44;
        var t14 = m14 * m23 * m32 - m13 * m24 * m32 - m14 * m22 * m33 + m12 * m24 * m33 + m13 * m22 * m34 - m12 * m23 * m34;
        var det = m11 * t11 + m21 * t12 + m31 * t13 + m41 * t14;
        if (det === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        var detInv = 1 / det;
        e[0] = t11 * detInv;
        e[1] = (m24 * m33 * m41 - m23 * m34 * m41 - m24 * m31 * m43 + m21 * m34 * m43 + m23 * m31 * m44 - m21 * m33 * m44) * detInv;
        e[2] = (m22 * m34 * m41 - m24 * m32 * m41 + m24 * m31 * m42 - m21 * m34 * m42 - m22 * m31 * m44 + m21 * m32 * m44) * detInv;
        e[3] = (m23 * m32 * m41 - m22 * m33 * m41 - m23 * m31 * m42 + m21 * m33 * m42 + m22 * m31 * m43 - m21 * m32 * m43) * detInv;
        e[4] = t12 * detInv;
        e[5] = (m13 * m34 * m41 - m14 * m33 * m41 + m14 * m31 * m43 - m11 * m34 * m43 - m13 * m31 * m44 + m11 * m33 * m44) * detInv;
        e[6] = (m14 * m32 * m41 - m12 * m34 * m41 - m14 * m31 * m42 + m11 * m34 * m42 + m12 * m31 * m44 - m11 * m32 * m44) * detInv;
        e[7] = (m12 * m33 * m41 - m13 * m32 * m41 + m13 * m31 * m42 - m11 * m33 * m42 - m12 * m31 * m43 + m11 * m32 * m43) * detInv;
        e[8] = t13 * detInv;
        e[9] = (m14 * m23 * m41 - m13 * m24 * m41 - m14 * m21 * m43 + m11 * m24 * m43 + m13 * m21 * m44 - m11 * m23 * m44) * detInv;
        e[10] = (m12 * m24 * m41 - m14 * m22 * m41 + m14 * m21 * m42 - m11 * m24 * m42 - m12 * m21 * m44 + m11 * m22 * m44) * detInv;
        e[11] = (m13 * m22 * m41 - m12 * m23 * m41 - m13 * m21 * m42 + m11 * m23 * m42 + m12 * m21 * m43 - m11 * m22 * m43) * detInv;
        e[12] = t14 * detInv;
        e[13] = (m13 * m24 * m31 - m14 * m23 * m31 + m14 * m21 * m33 - m11 * m24 * m33 - m13 * m21 * m34 + m11 * m23 * m34) * detInv;
        e[14] = (m14 * m22 * m31 - m12 * m24 * m31 - m14 * m21 * m32 + m11 * m24 * m32 + m12 * m21 * m34 - m11 * m22 * m34) * detInv;
        e[15] = (m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) * detInv;
        return this;
    };
    /**
     * 提取基轴
     * @param xAxis - 提取的 x 轴
     * @param yAxis - 提取的 y 轴
     * @param zAxis - 提取的 z 轴
     * @returns
     */ _proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
    };
    /**
     * 根据基础信息组装矩阵
     * @param translation - 位置信息
     * @param rotation - 旋转信息
     * @param scale - 缩放信息
     * @param [anchor] - 锚点信息
     * @returns 矩阵
     */ _proto.compose = function compose(translation, rotation, scale, anchor) {
        if (anchor === void 0) anchor = Vector3.ZERO;
        var te = this.elements;
        var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
        var l = -anchor.x;
        var m = -anchor.y;
        var n = -anchor.z;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = l * te[0] + m * te[4] + n * te[8] - l + translation.x;
        te[13] = l * te[1] + m * te[5] + n * te[9] - m + translation.y;
        te[14] = l * te[2] + m * te[6] + n * te[10] - n + translation.z;
        return this;
    };
    /**
     * 矩阵拆分为基础信息
     * @param translation - 位置信息
     * @param rotation - 旋转信息
     * @param scale - 缩放信息
     * @returns 矩阵
     */ _proto.decompose = function decompose(translation, rotation, scale) {
        var v = Matrix4.tempVec0;
        var te = this.elements;
        var sx = v.set(te[0], te[1], te[2]).length();
        var sy = v.set(te[4], te[5], te[6]).length();
        var sz = v.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if (det < 0) {
            sx = -sx;
        }
        translation.x = te[12];
        translation.y = te[13];
        translation.z = te[14];
        // scale the rotation part
        var m = Matrix4.tempMat0;
        m.copyFrom(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        m.elements[0] *= invSX;
        m.elements[1] *= invSX;
        m.elements[2] *= invSX;
        m.elements[4] *= invSY;
        m.elements[5] *= invSY;
        m.elements[6] *= invSY;
        m.elements[8] *= invSZ;
        m.elements[9] *= invSZ;
        m.elements[10] *= invSZ;
        rotation.setFromRotationMatrix(m);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    };
    _proto.getTranslation = function getTranslation(translation) {
        var te = this.elements;
        return translation.set(te[12], te[13], te[14]);
    };
    _proto.getScale = function getScale(scale) {
        var te = this.elements;
        return scale.set(Math.hypot(te[0], te[1], te[2]), Math.hypot(te[4], te[5], te[6]), Math.hypot(te[8], te[9], te[10]));
    };
    /**
     * 获得矩阵分解的结果
     * @returns 分解的结果
     */ _proto.getTransform = function getTransform() {
        var translation = new Vector3();
        var rotation = new Quaternion();
        var scale = new Vector3();
        this.decompose(translation, rotation, scale);
        return {
            translation: translation,
            rotation: rotation,
            scale: scale
        };
    };
    /**
     * 根据视窗信息设置正交相机投影矩阵
     * @param left - 视窗左平面位置
     * @param right - 视窗右平面位置
     * @param top - 视窗上平面位置
     * @param bottom - 视窗下平面位置
     * @param near - 视窗近平面位置
     * @param far - 视窗远平面位置
     * @returns 矩阵
     */ _proto.orthographic = function orthographic(left, right, top, bottom, near, far) {
        var a = 1.0 / (right - left);
        var b = 1.0 / (top - bottom);
        var c = 1.0 / (far - near);
        var tx = -(right + left) * a;
        var ty = -(top + bottom) * b;
        var tz = -(far + near) * c;
        a *= 2.0;
        b *= 2.0;
        c *= -2.0;
        var te = this.elements;
        te[0] = a;
        te[1] = 0.0;
        te[2] = 0.0;
        te[3] = 0.0;
        //
        te[4] = 0.0;
        te[5] = b;
        te[6] = 0.0;
        te[7] = 0.0;
        //
        te[8] = 0.0;
        te[9] = 0.0;
        te[10] = c;
        te[11] = 0.0;
        //
        te[12] = tx;
        te[13] = ty;
        te[14] = tz;
        te[15] = 1.0;
        return this;
    };
    /**
     * 通过透视相机基础参数设置投影矩阵
     * @param fov - 视角(弧度)
     * @param aspect - 视窗比例
     * @param near - 近平面
     * @param far - 远平面
     * @param [reverse] - 视锥体长宽反转(3D这里反了？)
     * @returns 投影矩阵
     */ _proto.perspective = function perspective(fov, aspect, near, far, reverse) {
        var f = 1.0 / Math.tan(fov * 0.5);
        var nf = 1 / (near - far);
        var te = this.elements;
        te[0] = reverse ? f : f / aspect;
        te[1] = 0;
        te[2] = 0;
        te[3] = 0;
        //
        te[4] = 0;
        te[5] = reverse ? f * aspect : f;
        te[6] = 0;
        te[7] = 0;
        //
        te[8] = 0;
        te[9] = 0;
        te[10] = (far + near) * nf;
        te[11] = -1;
        //
        te[12] = 0;
        te[13] = 0;
        te[14] = 2 * far * near * nf;
        te[15] = 0;
        if (far === null || far === Infinity) {
            te[10] = -1;
            te[14] = -2 * near;
        }
        return this;
    };
    /**
     * 对点进行投影变换
     * @param v - 输入点
     * @param [out] - 输出点，如果没有就覆盖输入的数据
     * @returns 投影后的点
     */ _proto.projectPoint = function projectPoint(v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out != null ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        var w = e[3] * x + e[7] * y + e[11] * z + e[15];
        return res.multiply(1 / w);
    };
    /**
     * 对点进行矩阵变换
     * @param v - 输入点
     * @param [out] - 输出点，如果没有就覆盖输入的数据
     * @returns 变换后的点
     */ _proto.transformPoint = function transformPoint(v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out != null ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return res;
    };
    /**
     * 对法向量进行矩阵变换
     * @param v - 输入法向量
     * @param [out] - 输出法向量，如果没有就覆盖输入的数据
     * @returns 变换后的法向量
     */ _proto.transformNormal = function transformNormal(v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out != null ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z;
        res.y = e[1] * x + e[5] * y + e[9] * z;
        res.z = e[2] * x + e[6] * y + e[10] * z;
        return res.normalize();
    };
    /**
     * 对四维向量进行矩阵变换
     * @param v - 输入向量
     * @param [out] - 输出向量，如果没有就覆盖输入的数据
     * @returns 变换后向量
     */ _proto.transformVector4 = function transformVector4(v, out) {
        var x = v.x, y = v.y, z = v.z, w = v.w;
        var e = this.elements;
        var res = out != null ? out : v;
        res.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        res.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        res.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        res.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return res;
    };
    /**
     * 矩阵判等
     * @param matrix - 矩阵
     * @returns 判等结果
     */ _proto.equals = function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for(var i = 0; i < 16; i++){
            if (!isEqual(te[i], me[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * 矩阵转数组
     * @returns
     */ _proto.toArray = function toArray() {
        return [].concat(this.elements);
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
    };
    /**
     * 创建单位阵
     * @returns 单位矩阵
     */ Matrix4.fromIdentity = function fromIdentity() {
        return new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * 创建相机矩阵
     * @param eye - 相机位置
     * @param target - 目标位置
     * @param up - 相机方向
     * @returns 矩阵
     */ Matrix4.fromLookAt = function fromLookAt(eye, target, up) {
        return new Matrix4().lookAt(eye, target, up);
    };
    /**
     * 创建投影矩阵
     * @param fov - 视角
     * @param aspect - 视窗比例
     * @param near - 近平面
     * @param far - 远平面
     * @param [reverse] - 视锥体长宽反转
     * @returns 投影矩阵
     */ Matrix4.fromPerspective = function fromPerspective(fov, aspect, near, far, reverse) {
        return new Matrix4().perspective(fov, aspect, near, far, reverse);
    };
    /**
     * 通过四个列向量创建矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @param c4 - 第四列
     * @returns
     */ Matrix4.fromColumnVectors = function fromColumnVectors(c1, c2, c3, c4) {
        return new Matrix4().setFromColumnVectors(c1, c2, c3, c4);
    };
    /**
     * 通过三阶矩阵创建矩阵
     * @param m - 三阶矩阵
     * @returns 创建的矩阵
     */ Matrix4.fromMatrix3 = function fromMatrix3(m) {
        return new Matrix4().setFromMatrix3(m);
    };
    /**
     * 通过数组创建矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */ Matrix4.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Matrix4().setFromArray(array, offset);
    };
    /**
     * 通过缩放创建矩阵
     * @param x - x 缩放
     * @param y - y 缩放
     * @param z - z 缩放
     * @returns 缩放结果
     */ Matrix4.fromScale = function fromScale(x, y, z) {
        return new Matrix4().setFromScale(x, y, z);
    };
    /**
     * 通过平移创建矩阵
     * @param x - x 平移
     * @param y - y 平移
     * @param z - z 平移
     * @returns 平移结果
     */ Matrix4.fromTranslation = function fromTranslation(x, y, z) {
        return new Matrix4().setFromTranslation(x, y, z);
    };
    /**
     * 通过 x 轴旋转创建矩阵
     * @param theta - x 轴旋转弧度
     * @returns 矩阵
     */ Matrix4.fromRotationX = function fromRotationX(theta) {
        return new Matrix4().setFromRotationX(theta);
    };
    /**
     * 通过 y 轴旋转创建矩阵
     * @param theta - y 轴旋转弧度
     * @returns 矩阵
     */ Matrix4.fromRotationY = function fromRotationY(theta) {
        return new Matrix4().setFromRotationY(theta);
    };
    /**
     * 通过 z 轴旋转创建矩阵
     * @param theta - z 轴旋转弧度
     * @returns
     */ Matrix4.fromRotationZ = function fromRotationZ(theta) {
        return new Matrix4().setFromRotationZ(theta);
    };
    /**
     * 通过旋转轴与旋转弧度创建矩阵
     * @param axis - 旋转轴
     * @param angle - 旋转弧度
     * @returns
     */ Matrix4.fromRotationAxis = function fromRotationAxis(axis, angle) {
        return new Matrix4().setFromRotationAxis(axis, angle);
    };
    /**
     * 通过欧拉角创建矩阵
     * @param euler - 欧拉角
     * @returns
     */ Matrix4.fromEuler = function fromEuler(euler) {
        return new Matrix4().setFromEuler(euler);
    };
    /**
     * 通过四元数创建矩阵
     * @param quat - 四元数
     * @returns
     */ Matrix4.fromQuaternion = function fromQuaternion(quat) {
        return new Matrix4().setFromQuaternion(quat);
    };
    /**
     * 通过倾斜创建矩阵
     * @param x - x 方向倾斜分量
     * @param y - y 方向倾斜分量
     * @param z - z 方向倾斜分量
     * @returns 倾斜矩阵
     */ Matrix4.fromShear = function fromShear(x, y, z) {
        return new Matrix4().setFromShear(x, y, z);
    };
    /**
     * 通过基轴创建矩阵
     * @param xAxis - x 轴
     * @param yAxis - y 轴
     * @param zAxis - z 轴
     * @returns
     */ Matrix4.fromBasis = function fromBasis(xAxis, yAxis, zAxis) {
        return new Matrix4().setFromBasis(xAxis, yAxis, zAxis);
    };
    /**
     * 通过行优先数据设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m14 - 第 1 行，第 4 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m24 - 第 2 行，第 4 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @param m34 - 第 3 行，第 4 列
     * @param m41 - 第 4 行，第 1 列
     * @param m42 - 第 4 行，第 2 列
     * @param m43 - 第 4 行，第 3 列
     * @param m44 - 第 4 行，第 4 列
     * @returns
     */ Matrix4.fromRowMajorData = function fromRowMajorData(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        return new Matrix4(m11, m21, m31, m41, m12, m22, m32, m42, m13, m23, m33, m43, m14, m24, m34, m44);
    };
    return Matrix4;
}();
Matrix4$1.IDENTITY = new Matrix4$1(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
Matrix4$1.ZERO = new Matrix4$1(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
Matrix4$1.tempVec0 = new Vector3();
Matrix4$1.tempVec1 = new Vector3();
Matrix4$1.tempVec2 = new Vector3();
Matrix4$1.tempMat0 = new Matrix4$1();

/**
 * 欧拉角顺序
 */ var EulerOrder;
(function(EulerOrder) {
    EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
    EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
    EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
    EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
    EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
    EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
})(EulerOrder || (EulerOrder = {}));
/**
 * 欧拉角
 */ var Euler = /*#__PURE__*/ function() {
    function Euler(x, y, z, order) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (order === void 0) order = Euler.DEFAULT_ORDER;
        this.x = x;
        this.y = y;
        this.z = z;
        this.order = order;
    }
    var _proto = Euler.prototype;
    /**
     * 设置欧拉角
     * @param x - x 方向分量
     * @param y - y 方向分量
     * @param z - z 方向分量
     * @param [order] - 欧拉角顺序
     * @returns
     */ _proto.set = function set(x, y, z, order) {
        if (order === void 0) order = this.order;
        this.x = x;
        this.y = y;
        this.z = z;
        this.order = order;
        return this;
    };
    _proto.setZero = function setZero(order) {
        if (order === void 0) order = this.order;
        return this.set(0, 0, 0, order);
    };
    /**
     * 通过矩阵设置欧拉角
     * @param m - 矩阵
     * @param [order] - 欧拉角顺序
     * @returns
     */ _proto.setFromRotationMatrix4 = function setFromRotationMatrix4(m, order) {
        if (order === void 0) order = this.order;
        var te = m.elements;
        var m11 = te[0];
        var m12 = te[4];
        var m13 = te[8];
        var m21 = te[1];
        var m22 = te[5];
        var m23 = te[9];
        var m31 = te[2];
        var m32 = te[6];
        var m33 = te[10];
        switch(order){
            case EulerOrder.XYZ:
                this.y = Math.asin(clamp$1(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this.x = Math.atan2(-m23, m33);
                    this.z = Math.atan2(-m12, m11);
                } else {
                    this.x = Math.atan2(m32, m22);
                    this.z = 0;
                }
                break;
            case EulerOrder.YXZ:
                this.x = Math.asin(-clamp$1(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this.y = Math.atan2(m13, m33);
                    this.z = Math.atan2(m21, m22);
                } else {
                    this.y = Math.atan2(-m31, m11);
                    this.z = 0;
                }
                break;
            case EulerOrder.ZXY:
                this.x = Math.asin(clamp$1(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this.y = Math.atan2(-m31, m33);
                    this.z = Math.atan2(-m12, m22);
                } else {
                    this.y = 0;
                    this.z = Math.atan2(m21, m11);
                }
                break;
            case EulerOrder.ZYX:
                this.y = Math.asin(-clamp$1(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this.x = Math.atan2(m32, m33);
                    this.z = Math.atan2(m21, m11);
                } else {
                    this.x = 0;
                    this.z = Math.atan2(-m12, m22);
                }
                break;
            case EulerOrder.YZX:
                this.z = Math.asin(clamp$1(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this.x = Math.atan2(-m23, m22);
                    this.y = Math.atan2(-m31, m11);
                } else {
                    this.x = 0;
                    this.y = Math.atan2(m13, m33);
                }
                break;
            case EulerOrder.XZY:
                this.z = Math.asin(-clamp$1(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this.x = Math.atan2(m32, m22);
                    this.y = Math.atan2(m13, m11);
                } else {
                    this.x = Math.atan2(-m23, m33);
                    this.y = 0;
                }
                break;
            default:
                console.error("setFromRotationMatrix: unknown order: " + order);
        }
        this.x *= RAD2DEG;
        this.y *= RAD2DEG;
        this.z *= RAD2DEG;
        this.order = order;
        return this;
    };
    /**
     * 通过四元数设置欧拉角
     * @param quat - 四元数
     * @param [order] - 欧拉角顺序
     * @returns
     */ _proto.setFromQuaternion = function setFromQuaternion(quat, order) {
        if (order === void 0) order = this.order;
        var matrix = Euler.tempMat0;
        matrix.setFromQuaternion(quat);
        return this.setFromRotationMatrix4(matrix, order);
    };
    /**
     * 通过三维向量设置欧拉角
     * @param v - 三维向量
     * @param [order] - 欧拉角顺序
     * @returns
     */ _proto.setFromVector3 = function setFromVector3(v, order) {
        if (order === void 0) order = this.order;
        return this.set(v.x, v.y, v.z, order);
    };
    /**
     * 通过数组设置欧拉角
     * @param array - 数组
     * @param [offset=0] - 偏移
     * @param [order] - 欧拉角顺序
     * @returns
     */ _proto.setFromArray = function setFromArray(array, offset, order) {
        if (offset === void 0) offset = 0;
        if (order === void 0) order = this.order;
        var _array_offset;
        this.x = (_array_offset = array[offset]) != null ? _array_offset : 0;
        var _array_;
        this.y = (_array_ = array[offset + 1]) != null ? _array_ : 0;
        var _array_1;
        this.z = (_array_1 = array[offset + 2]) != null ? _array_1 : 0;
        var _array_2;
        this.order = (_array_2 = array[offset + 3]) != null ? _array_2 : order;
        return this;
    };
    /**
     * 克隆欧拉角
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Euler(this.x, this.y, this.z, this.order);
    };
    /**
     * 复制欧拉角
     * @param euler - 复制对象
     * @returns 复制结果
     */ _proto.copyFrom = function copyFrom(euler) {
        this.x = euler.x;
        this.y = euler.y;
        this.z = euler.z;
        this.order = euler.order;
        return this;
    };
    _proto.add = function add(euler) {
        if (this.order != euler.order) {
            console.error("add euler with different order");
            return this;
        }
        this.x += euler.x;
        this.y += euler.y;
        this.z += euler.z;
        return this;
    };
    _proto.addEulers = function addEulers(left, right) {
        if (left.order != right.order) {
            console.error("add euler with different order");
            return this;
        }
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        this.order = left.order;
        return this;
    };
    _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    };
    /**
     * 修改欧拉角顺序
     * @param newOrder - 欧拉角顺序
     * @returns 修改结果
     */ _proto.reorder = function reorder(newOrder) {
        var quaternion = new Quaternion();
        quaternion.setFromEuler(this);
        return this.setFromQuaternion(quaternion, newOrder);
    };
    /**
     * 通过四元数旋转向量
     * @param v - 待旋转向量
     * @param out - 旋转结果，如果没有传入直接覆盖输入值
     * @returns
     */ _proto.rotateVector3 = function rotateVector3(v, out) {
        var q = Euler.tempQuat0;
        return q.setFromEuler(this).rotateVector3(v, out);
    };
    /**
     * 欧拉角相等判断
     * @param euler - 欧拉角
     * @returns 判断结果
     */ _proto.equals = function equals(euler) {
        return euler.x === this.x && euler.y === this.y && euler.z === this.z && euler.order === this.order;
    };
    /**
     * 欧拉角保存于三维向量
     * @param vec - 目标保存对象
     * @returns 保存结果
     */ _proto.toVector3 = function toVector3(vec) {
        return vec.set(this.x, this.y, this.z);
    };
    /**
     * 欧拉角转数组
     * @returns 保存结果
     */ _proto.toArray = function toArray() {
        return [
            this.x,
            this.y,
            this.z
        ];
    };
    /**
     * 欧拉角转四元数
     * @param quat - 目标四元数
     * @returns 目标四元数
     */ _proto.toQuaternion = function toQuaternion(quat) {
        var _this = this, x = _this.x, y = _this.y, z = _this.z, order = _this.order;
        var c1 = Math.cos(x * DEG2RAD * 0.5);
        var c2 = Math.cos(y * DEG2RAD * 0.5);
        var c3 = Math.cos(z * DEG2RAD * 0.5);
        var s1 = Math.sin(x * DEG2RAD * 0.5);
        var s2 = Math.sin(y * DEG2RAD * 0.5);
        var s3 = Math.sin(z * DEG2RAD * 0.5);
        switch(order){
            case EulerOrder.XYZ:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.YXZ:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            case EulerOrder.ZXY:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.ZYX:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            case EulerOrder.YZX:
                quat.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 + s1 * c2 * s3, c1 * c2 * s3 - s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
                break;
            case EulerOrder.XZY:
                quat.set(s1 * c2 * c3 - c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 + s1 * s2 * s3);
                break;
            default:
                console.error("unknown euler order: " + order);
        }
        return quat;
    };
    /**
     * 欧拉角转矩阵
     * @param mat - 目标矩阵
     * @returns 返回目标矩阵
     */ _proto.toMatrix4 = function toMatrix4(mat) {
        var me = mat.elements;
        var _this = this, x = _this.x, y = _this.y, z = _this.z, order = _this.order;
        var cosX = Math.cos(x * DEG2RAD), sinX = Math.sin(x * DEG2RAD);
        var cosY = Math.cos(y * DEG2RAD), sinY = Math.sin(y * DEG2RAD);
        var cosZ = Math.cos(z * DEG2RAD), sinZ = Math.sin(z * DEG2RAD);
        if (order === EulerOrder.XYZ) {
            var cosXcosZ = cosX * cosZ;
            var cosXsinZ = cosX * sinZ;
            var sinXcosZ = sinX * cosZ;
            var sinXsinZ = sinX * sinZ;
            me[0] = cosY * cosZ;
            me[4] = -cosY * sinZ;
            me[8] = sinY;
            me[1] = cosXsinZ + sinXcosZ * sinY;
            me[5] = cosXcosZ - sinXsinZ * sinY;
            me[9] = -sinX * cosY;
            me[2] = sinXsinZ - cosXcosZ * sinY;
            me[6] = sinXcosZ + cosXsinZ * sinY;
            me[10] = cosX * cosY;
        } else if (order === EulerOrder.YXZ) {
            var cosYcosZ = cosY * cosZ;
            var cosYsinZ = cosY * sinZ;
            var sinYcosZ = sinY * cosZ;
            var sinYsinZ = sinY * sinZ;
            me[0] = cosYcosZ + sinYsinZ * sinX;
            me[4] = sinYcosZ * sinX - cosYsinZ;
            me[8] = cosX * sinY;
            me[1] = cosX * sinZ;
            me[5] = cosX * cosZ;
            me[9] = -sinX;
            me[2] = cosYsinZ * sinX - sinYcosZ;
            me[6] = sinYsinZ + cosYcosZ * sinX;
            me[10] = cosX * cosY;
        } else if (order === EulerOrder.ZXY) {
            var cosYcosZ1 = cosY * cosZ;
            var cosYsinZ1 = cosY * sinZ;
            var sinYcosZ1 = sinY * cosZ;
            var sinYsinZ1 = sinY * sinZ;
            me[0] = cosYcosZ1 - sinYsinZ1 * sinX;
            me[4] = -cosX * sinZ;
            me[8] = sinYcosZ1 + cosYsinZ1 * sinX;
            me[1] = cosYsinZ1 + sinYcosZ1 * sinX;
            me[5] = cosX * cosZ;
            me[9] = sinYsinZ1 - cosYcosZ1 * sinX;
            me[2] = -cosX * sinY;
            me[6] = sinX;
            me[10] = cosX * cosY;
        } else if (order === EulerOrder.ZYX) {
            var cosXcosZ1 = cosX * cosZ;
            var cosXsinZ1 = cosX * sinZ;
            var sinXcosZ1 = sinX * cosZ;
            var sinXsinZ1 = sinX * sinZ;
            me[0] = cosY * cosZ;
            me[4] = sinXcosZ1 * sinY - cosXsinZ1;
            me[8] = cosXcosZ1 * sinY + sinXsinZ1;
            me[1] = cosY * sinZ;
            me[5] = sinXsinZ1 * sinY + cosXcosZ1;
            me[9] = cosXsinZ1 * sinY - sinXcosZ1;
            me[2] = -sinY;
            me[6] = sinX * cosY;
            me[10] = cosX * cosY;
        } else if (order === EulerOrder.YZX) {
            var cosXcosY = cosX * cosY;
            var cosXsinY = cosX * sinY;
            var sinXcosY = sinX * cosY;
            var sinXsinY = sinX * sinY;
            me[0] = cosY * cosZ;
            me[4] = sinXsinY - cosXcosY * sinZ;
            me[8] = sinXcosY * sinZ + cosXsinY;
            me[1] = sinZ;
            me[5] = cosX * cosZ;
            me[9] = -sinX * cosZ;
            me[2] = -sinY * cosZ;
            me[6] = cosXsinY * sinZ + sinXcosY;
            me[10] = cosXcosY - sinXsinY * sinZ;
        } else if (order === EulerOrder.XZY) {
            var cosXcosY1 = cosX * cosY;
            var cosXsinY1 = cosX * sinY;
            var sinXcosY1 = sinX * cosY;
            var sinXsinY1 = sinX * sinY;
            me[0] = cosY * cosZ;
            me[4] = -sinZ;
            me[8] = sinY * cosZ;
            me[1] = cosXcosY1 * sinZ + sinXsinY1;
            me[5] = cosX * cosZ;
            me[9] = cosXsinY1 * sinZ - sinXcosY1;
            me[2] = sinXcosY1 * sinZ - cosXsinY1;
            me[6] = sinX * cosZ;
            me[10] = sinXsinY1 * sinZ + cosXcosY1;
        } else {
            console.error("toMatrix4: Invalid order " + order);
        }
        // bottom row
        me[3] = 0;
        me[7] = 0;
        me[11] = 0;
        // last column
        me[12] = 0;
        me[13] = 0;
        me[14] = 0;
        me[15] = 1;
        return mat;
    };
    /**
     * 通过矩阵创建欧拉角
     * @param m - 矩阵
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */ Euler.fromRotationMatrix4 = function fromRotationMatrix4(m, order) {
        if (order === void 0) order = Euler.DEFAULT_ORDER;
        return new Euler().setFromRotationMatrix4(m, order);
    };
    /**
     * 通过四元数创建欧拉角
     * @param quat - 四元数
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */ Euler.fromQuaternion = function fromQuaternion(quat, order) {
        if (order === void 0) order = Euler.DEFAULT_ORDER;
        return new Euler().setFromQuaternion(quat, order);
    };
    /**
     * 通过三维向量创建欧拉角
     * @param v - 三维向量
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */ Euler.fromVector3 = function fromVector3(v, order) {
        if (order === void 0) order = Euler.DEFAULT_ORDER;
        return new Euler().setFromVector3(v, order);
    };
    /**
     * 通过数组创建欧拉角
     * @param array - 数组
     * @param [offset=0] - 偏移
     * @param [order=Euler.DEFAULT_ORDER] - 欧拉角顺序
     * @returns 创建结果
     */ Euler.fromArray = function fromArray(array, offset, order) {
        if (offset === void 0) offset = 0;
        if (order === void 0) order = Euler.DEFAULT_ORDER;
        return new Euler().setFromArray(array, offset, order);
    };
    return Euler;
}();
Euler.DEFAULT_ORDER = EulerOrder.ZYX;
Euler.tempQuat0 = new Quaternion();
Euler.tempMat0 = new Matrix4$1();

/*********************************************/ /*               元素属性参数类型               */ /*********************************************/ /**
 * 渲染等级
 */ var RenderLevel;
(function(RenderLevel) {
    RenderLevel["S"] = "S";
    RenderLevel["APlus"] = "A+";
    RenderLevel["A"] = "A";
    RenderLevel["BPlus"] = "B+";
    RenderLevel["B"] = "B";
})(RenderLevel || (RenderLevel = {}));
/**
 * 混合模式
 */ var BlendingMode;
(function(BlendingMode) {
    /**
     * 普通混合模式
     */ BlendingMode[BlendingMode["ALPHA"] = 0] = "ALPHA";
    /**
     * 叠加混合模式
     */ BlendingMode[BlendingMode["ADD"] = 1] = "ADD";
    /**
     * 相乘混合模式
     */ BlendingMode[BlendingMode["MULTIPLY"] = 2] = "MULTIPLY";
    /**
     * 亮度混合模式
     */ BlendingMode[BlendingMode["BRIGHTNESS"] = 3] = "BRIGHTNESS";
    /**
     * 减色混合模式
     */ BlendingMode[BlendingMode["SUBTRACTION"] = 4] = "SUBTRACTION";
    /**
     * 强光混合模式
     */ BlendingMode[BlendingMode["STRONG_LIGHT"] = 5] = "STRONG_LIGHT";
    /**
     * 弱光混合模式
     */ BlendingMode[BlendingMode["WEAK_LIGHT"] = 6] = "WEAK_LIGHT";
    /**
     * 亮度叠加混合模式
     */ BlendingMode[BlendingMode["SUPERPOSITION"] = 7] = "SUPERPOSITION";
})(BlendingMode || (BlendingMode = {}));
/**
 * 单双面模式
 */ var SideMode;
(function(SideMode) {
    /**
     * 双面模式
     */ SideMode[SideMode["DOUBLE"] = 1032] = "DOUBLE";
    /**
     * 正面模式
     */ SideMode[SideMode["FRONT"] = 1028] = "FRONT";
    /**
     * 背面模式
     */ SideMode[SideMode["BACK"] = 1029] = "BACK";
})(SideMode || (SideMode = {}));
/**
 * 蒙版模式
 */ var MaskMode;
(function(MaskMode) {
    /**
     * 无蒙版
     */ MaskMode[MaskMode["NONE"] = 0] = "NONE";
    /**
     * 蒙版
     */ MaskMode[MaskMode["MASK"] = 1] = "MASK";
    /**
     * 被遮挡
     */ MaskMode[MaskMode["OBSCURED"] = 2] = "OBSCURED";
    /**
     * 被反向遮挡
     */ MaskMode[MaskMode["REVERSE_OBSCURED"] = 3] = "REVERSE_OBSCURED";
})(MaskMode || (MaskMode = {}));
/**
 * 发射器形状
 */ var ShapeType;
(function(ShapeType) {
    /**
     * 没有类型
     */ ShapeType[ShapeType["NONE"] = 0] = "NONE";
    /**
     * 圆球
     */ ShapeType[ShapeType["SPHERE"] = 1] = "SPHERE";
    /**
     * 圆锥
     */ ShapeType[ShapeType["CONE"] = 2] = "CONE";
    /**
     * 半球
     */ ShapeType[ShapeType["HEMISPHERE"] = 3] = "HEMISPHERE";
    /**
     * 圆
     */ ShapeType[ShapeType["CIRCLE"] = 4] = "CIRCLE";
    /**
     * 圆环
     */ ShapeType[ShapeType["DONUT"] = 5] = "DONUT";
    /**
     * 矩形
     */ ShapeType[ShapeType["RECTANGLE"] = 6] = "RECTANGLE";
    /**
     * 矩形框
     */ ShapeType[ShapeType["RECTANGLE_EDGE"] = 7] = "RECTANGLE_EDGE";
    /**
     * 直线
     */ ShapeType[ShapeType["EDGE"] = 8] = "EDGE";
    /**
     * 贴图
     */ ShapeType[ShapeType["TEXTURE"] = 9] = "TEXTURE";
})(ShapeType || (ShapeType = {}));
/**
 * 插件类型
 */ var PluginType;
(function(PluginType) {
    /**
     * 陀螺仪
     */ PluginType[PluginType["GYROSCOPE"] = 0] = "GYROSCOPE";
    /**
     * Spine
     */ PluginType[PluginType["SPINE"] = 1] = "SPINE";
})(PluginType || (PluginType = {}));
/**
 * 交互类型
 */ var InteractType;
(function(InteractType) {
    /**
     * 点击
     */ InteractType[InteractType["CLICK"] = 0] = "CLICK";
    /**
     * 消息
     * 前端收到 onMessageItem 回调
     */ InteractType[InteractType["MESSAGE"] = 1] = "MESSAGE";
    /**
     * 拖拽
     */ InteractType[InteractType["DRAG"] = 2] = "DRAG";
})(InteractType || (InteractType = {}));
/**
 * 交互行为
 */ var InteractBehavior;
(function(InteractBehavior) {
    /**
     * 无
     */ InteractBehavior[InteractBehavior["NONE"] = 0] = "NONE";
    /**
     * 通知
     */ InteractBehavior[InteractBehavior["NOTIFY"] = 1] = "NOTIFY";
    /**
     * 重置播放器
     */ InteractBehavior[InteractBehavior["RESUME_PLAYER"] = 2] = "RESUME_PLAYER";
    /**
     * 清除元素
     */ InteractBehavior[InteractBehavior["REMOVE"] = 3] = "REMOVE";
    /**
     * 暂停播放器
     */ InteractBehavior[InteractBehavior["PAUSE"] = 4] = "PAUSE";
})(InteractBehavior || (InteractBehavior = {}));
/**
 * 元素类型
 */ var ItemType;
(function(ItemType) {
    /**
     * 错误元素
     */ ItemType["base"] = "0";
    /**
     * 图层元素
     */ ItemType["sprite"] = "1";
    /**
     * 粒子元素
     */ ItemType["particle"] = "2";
    /**
     * 空节点元素
     */ ItemType["null"] = "3";
    /**
     * 交互元素
     */ ItemType["interact"] = "4";
    /**
     * 插件元素
     */ ItemType["plugin"] = "5";
    /**
     * 相机元素
     */ ItemType["camera"] = "6";
    /**
     * 预合成元素
     */ ItemType["composition"] = "7";
    /**
     * Spine 元素
     */ ItemType["spine"] = "spine";
    /**
     * Mesh 元素
     */ ItemType["mesh"] = "mesh";
    /**
     * 节点树元素
     */ ItemType["tree"] = "tree";
    /**
     * 文本元素
     */ ItemType["text"] = "text";
    /**
     * 灯光元素
     */ ItemType["light"] = "light";
    /**
     * 天空盒元素
     */ ItemType["skybox"] = "skybox";
    /**
     * 特效元素
     */ ItemType["effect"] = "effect";
    /**
     * 节点元素
     */ ItemType["node"] = "node";
})(ItemType || (ItemType = {}));
/**
 * 渲染模式
 */ var RenderMode;
(function(RenderMode) {
    /**
     * 广告牌模式
     */ RenderMode[RenderMode["BILLBOARD"] = 0] = "BILLBOARD";
    /**
     * 网格模式
     */ RenderMode[RenderMode["MESH"] = 1] = "MESH";
    /**
     * 垂直广告牌模式
     */ RenderMode[RenderMode["VERTICAL_BILLBOARD"] = 2] = "VERTICAL_BILLBOARD";
    /**
     * 水平广告牌模式
     */ RenderMode[RenderMode["HORIZONTAL_BILLBOARD"] = 3] = "HORIZONTAL_BILLBOARD";
})(RenderMode || (RenderMode = {}));
/**
 * 变换中心
 */ var ParticleOrigin;
(function(ParticleOrigin) {
    /**
     * 水平和垂直中点
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER"] = 0] = "PARTICLE_ORIGIN_CENTER";
    /**
     * 水平左侧 垂直顶部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_TOP"] = 1] = "PARTICLE_ORIGIN_LEFT_TOP";
    /**
     * 水平左侧 垂直中间
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_CENTER"] = 2] = "PARTICLE_ORIGIN_LEFT_CENTER";
    /**
     * 水平左侧 垂直底部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_LEFT_BOTTOM"] = 3] = "PARTICLE_ORIGIN_LEFT_BOTTOM";
    /**
     * 水平中间 垂直顶部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_TOP"] = 4] = "PARTICLE_ORIGIN_CENTER_TOP";
    /**
     * 水平中间 垂直底部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_CENTER_BOTTOM"] = 5] = "PARTICLE_ORIGIN_CENTER_BOTTOM";
    /**
     * 水平右侧 垂直顶部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_TOP"] = 6] = "PARTICLE_ORIGIN_RIGHT_TOP";
    /**
     * 水平右侧 垂直中间
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_CENTER"] = 7] = "PARTICLE_ORIGIN_RIGHT_CENTER";
    /**
     * 水平右侧 垂直底部
     */ ParticleOrigin[ParticleOrigin["PARTICLE_ORIGIN_RIGHT_BOTTOM"] = 8] = "PARTICLE_ORIGIN_RIGHT_BOTTOM";
})(ParticleOrigin || (ParticleOrigin = {}));
var RenderType;
(function(RenderType) {
    RenderType["Opaque"] = "Opaque";
    RenderType["Transparent"] = "Transparent";
})(RenderType || (RenderType = {}));
var RenderFace;
(function(RenderFace) {
    RenderFace["Both"] = "Both";
    RenderFace["Back"] = "Back";
    RenderFace["Front"] = "Front";
})(RenderFace || (RenderFace = {}));

/**
 * 销毁
 */ var END_BEHAVIOR_DESTROY = 0;
/**
 * 暂停
 * @deprecated since 2.0 - use `END_BEHAVIOR_FREEZE` instead
 */ var END_BEHAVIOR_PAUSE = 1;
/**
 * 无限播放
 */ var END_BEHAVIOR_FORWARD = 2;
/**
 * 销毁并保留最后一帧
 * @deprecated since 2.0
 */ var END_BEHAVIOR_PAUSE_AND_DESTROY = 3;
/**
 * 冻结
 */ var END_BEHAVIOR_FREEZE = 4;
/**
 * 重播
 */ var END_BEHAVIOR_RESTART = 5;
/**
 *
 */ var END_BEHAVIOR_DESTROY_CHILDREN = 6;
var CAMERA_CLIP_MODE_VERTICAL = 1;
var CAMERA_CLIP_MODE_NORMAL = 0;
var MESSAGE_ITEM_PHRASE_BEGIN = 2;
var MESSAGE_ITEM_PHRASE_END = 1;

var CameraClipMode;
(function(CameraClipMode) {
    /**
     * 剪裁上下
     */ CameraClipMode[CameraClipMode["portrait"] = 1] = "portrait";
    /**
     * 剪裁左右
     */ CameraClipMode[CameraClipMode["landscape"] = 0] = "landscape";
})(CameraClipMode || (CameraClipMode = {}));

/**
 * 动态换图类型
 * @since 1.1.0
 */ var BackgroundType;
(function(BackgroundType) {
    BackgroundType["video"] = "video";
    BackgroundType["image"] = "image";
})(BackgroundType || (BackgroundType = {}));

/*********************************************/ /*               基本数值属性参数              */ /*********************************************/ var ValueType;
(function(ValueType) {
    /**
     * 常数
     */ ValueType[ValueType["CONSTANT"] = 0] = "CONSTANT";
    /**
     * 二维常数向量
     */ ValueType[ValueType["CONSTANT_VEC2"] = 1] = "CONSTANT_VEC2";
    /**
     * 三维常数向量
     */ ValueType[ValueType["CONSTANT_VEC3"] = 2] = "CONSTANT_VEC3";
    /**
     * 四维常数向量
     */ ValueType[ValueType["CONSTANT_VEC4"] = 3] = "CONSTANT_VEC4";
    /**
     * 随机数
     */ ValueType[ValueType["RANDOM"] = 4] = "RANDOM";
    /**
     * 直线
     */ ValueType[ValueType["LINE"] = 5] = "LINE";
    /**
     * 曲线
     */ ValueType[ValueType["CURVE"] = 6] = "CURVE";
    /**
     * 贝塞尔路径
     */ ValueType[ValueType["BEZIER_PATH"] = 7] = "BEZIER_PATH";
    /**
     * 颜色
     */ ValueType[ValueType["RGBA_COLOR"] = 8] = "RGBA_COLOR";
    /**
     * 渐变色
     */ ValueType[ValueType["GRADIENT_COLOR"] = 9] = "GRADIENT_COLOR";
    /**
     * 蒙版形状点集
     */ ValueType[ValueType["SHAPE_POINTS"] = 10] = "SHAPE_POINTS";
    /**
     * 蒙版形状切分
     */ ValueType[ValueType["SHAPE_SPLITS"] = 11] = "SHAPE_SPLITS";
    /**
     * 直线路径
     */ ValueType[ValueType["LINEAR_PATH"] = 12] = "LINEAR_PATH";
    /**
     * 多色
     */ ValueType[ValueType["COLORS"] = 13] = "COLORS";
    /**
     * 二进制指针
     */ ValueType[ValueType["BINARY"] = 20] = "BINARY";
    /**
     * 贝塞尔曲线
     */ ValueType[ValueType["BEZIER_CURVE"] = 21] = "BEZIER_CURVE";
    /**
     * 贝塞尔曲线路径
     */ ValueType[ValueType["BEZIER_CURVE_PATH"] = 22] = "BEZIER_CURVE_PATH";
    /**
     * 贝塞尔曲线四元数
     */ ValueType[ValueType["BEZIER_CURVE_QUAT"] = 23] = "BEZIER_CURVE_QUAT";
})(ValueType || (ValueType = {}));
/**
 * 关键帧类型
 */ var BezierKeyframeType;
(function(BezierKeyframeType) {
    BezierKeyframeType[BezierKeyframeType["AUTO"] = 0] = "AUTO";
    BezierKeyframeType[BezierKeyframeType["EASE"] = 1] = "EASE";
    BezierKeyframeType[BezierKeyframeType["EASE_IN"] = 2] = "EASE_IN";
    BezierKeyframeType[BezierKeyframeType["EASE_OUT"] = 3] = "EASE_OUT";
    BezierKeyframeType[BezierKeyframeType["LINE"] = 4] = "LINE";
    BezierKeyframeType[BezierKeyframeType["HOLD"] = 5] = "HOLD";
    BezierKeyframeType[BezierKeyframeType["LINE_OUT"] = 6] = "LINE_OUT";
})(BezierKeyframeType || (BezierKeyframeType = {}));

/**
 * 结束行为
 */ var EndBehavior;
(function(EndBehavior) {
    /**
     * 销毁
     */ EndBehavior[EndBehavior["destroy"] = 0] = "destroy";
    /**
     * 重播
     */ EndBehavior[EndBehavior["restart"] = 5] = "restart";
    /**
     * 无限播放
     */ EndBehavior[EndBehavior["forward"] = 2] = "forward";
    /**
     * 冻结
     */ EndBehavior[EndBehavior["freeze"] = 4] = "freeze";
})(EndBehavior || (EndBehavior = {}));
var ParentItemEndBehavior;
(function(ParentItemEndBehavior) {
    ParentItemEndBehavior[ParentItemEndBehavior["destroyChildren"] = 6] = "destroyChildren";
})(ParentItemEndBehavior || (ParentItemEndBehavior = {}));

/**
 * 粒子交互行为
 */ var ParticleInteractionBehavior;
(function(ParticleInteractionBehavior) {
    /**
     * 无
     */ ParticleInteractionBehavior[ParticleInteractionBehavior["none"] = 0] = "none";
    /**
     * 移出粒子
     */ ParticleInteractionBehavior[ParticleInteractionBehavior["removeParticle"] = 1] = "removeParticle";
})(ParticleInteractionBehavior || (ParticleInteractionBehavior = {}));

var ShapeArcMode;
(function(ShapeArcMode) {
    /**
     * 随机
     */ ShapeArcMode[ShapeArcMode["RANDOM"] = 0] = "RANDOM";
    /**
     * 单向循环
     */ ShapeArcMode[ShapeArcMode["UNIDIRECTIONAL_CYCLE"] = 1] = "UNIDIRECTIONAL_CYCLE";
    /**
     * 双向循环
     */ ShapeArcMode[ShapeArcMode["BIDIRECTIONAL_CYCLE"] = 2] = "BIDIRECTIONAL_CYCLE";
    /**
     * 均匀爆发
     */ ShapeArcMode[ShapeArcMode["UNIFORM_BURST"] = 3] = "UNIFORM_BURST";
})(ShapeArcMode || (ShapeArcMode = {}));

var LightType;
(function(LightType) {
    /**
     * 点光源
     */ LightType["point"] = "point";
    /**
     * 聚光灯
     */ LightType["spot"] = "spot";
    /**
     * 方向光
     */ LightType["directional"] = "directional";
    /**
     * 环境光
     */ LightType["ambient"] = "ambient";
})(LightType || (LightType = {}));

var ModelBoundingType;
(function(ModelBoundingType) {
    ModelBoundingType[ModelBoundingType["box"] = 2] = "box";
    ModelBoundingType[ModelBoundingType["sphere"] = 3] = "sphere";
})(ModelBoundingType || (ModelBoundingType = {}));

var CameraType;
(function(CameraType) {
    CameraType["orthographic"] = "orthographic";
    CameraType["perspective"] = "perspective";
})(CameraType || (CameraType = {}));

// 材质类型
var MaterialType;
(function(MaterialType) {
    MaterialType["unlit"] = "unlit";
    MaterialType["pbr"] = "pbr";
    // 头发材质，在 pbr 材质基础上扩展
    MaterialType["hair"] = "hair";
})(MaterialType || (MaterialType = {}));
// 混合模式
var MaterialBlending;
(function(MaterialBlending) {
    MaterialBlending[MaterialBlending["opaque"] = 100] = "opaque";
    MaterialBlending[MaterialBlending["masked"] = 101] = "masked";
    MaterialBlending[MaterialBlending["translucent"] = 102] = "translucent";
    MaterialBlending[MaterialBlending["additive"] = 103] = "additive";
})(MaterialBlending || (MaterialBlending = {}));

/**
 * 3D渲染模式：将渲染过程中的中间结果输出，主要用于排查渲染效果问题，支持 pbr 和 unlit 材质
 */ var RenderMode3D;
(function(RenderMode3D) {
    /**
     * 正常渲染
     */ RenderMode3D["none"] = "none";
    /**
     * 纹理坐标
     */ RenderMode3D["uv"] = "uv";
    /**
     * 世界坐标法线
     */ RenderMode3D["normal"] = "normal";
    /**
     * 基础颜色
     */ RenderMode3D["basecolor"] = "basecolor";
    /**
     * 基础颜色 Alpha
     */ RenderMode3D["alpha"] = "alpha";
    /**
     * 金属度
     */ RenderMode3D["metallic"] = "metallic";
    /**
     * 粗超度
     */ RenderMode3D["roughness"] = "roughness";
    /**
     * 环境遮蔽
     */ RenderMode3D["ao"] = "ao";
    /**
     * 自发光
     */ RenderMode3D["emissive"] = "emissive";
})(RenderMode3D || (RenderMode3D = {}));

var TextOverflow;
(function(TextOverflow) {
    /**
     * display 模式下，会显示所有文本，存在文本超过边界框的情况。
     */ TextOverflow[TextOverflow["display"] = 0] = "display";
    /**
     * clip 模式下，当文本内容超出边界框时，多余的会被截断。
     */ TextOverflow[TextOverflow["clip"] = 1] = "clip";
    /**
     * ellipsis 模式下，会使用（...）来代替超出边界框的内容。
     */ TextOverflow[TextOverflow["ellipsis"] = 2] = "ellipsis";
})(TextOverflow || (TextOverflow = {}));
var TextBaseline;
(function(TextBaseline) {
    /**
     * 文本顶对齐。
     */ TextBaseline[TextBaseline["top"] = 0] = "top";
    /**
     * 文本垂直居中对齐。
     */ TextBaseline[TextBaseline["middle"] = 1] = "middle";
    /**
     * 文本底对齐。
     */ TextBaseline[TextBaseline["bottom"] = 2] = "bottom";
})(TextBaseline || (TextBaseline = {}));
var TextAlignment;
(function(TextAlignment) {
    /**
     * text alignment starts from（x,y) to right direction
     * 从 (x,y) 开始第一个字符，向右边延伸
     */ TextAlignment[TextAlignment["left"] = 0] = "left";
    /**
     * (x,y) is middle position of text, where (left + right)/2 =(x,y)
     * (x,y) 为文字中间位置，（最左位置 + 最右位置)/2 = (x,y)
     */ TextAlignment[TextAlignment["middle"] = 1] = "middle";
    /**
     * text alignment ends with（x,y) from left direction
     * 从 (x,y) 结束最后一个字符，向左边延伸
     */ TextAlignment[TextAlignment["right"] = 2] = "right";
})(TextAlignment || (TextAlignment = {}));
/**
 * 文本字重
 */ var TextWeight;
(function(TextWeight) {
    /**
     * 正常
     */ TextWeight["normal"] = "normal";
    /**
     * 粗体
     */ TextWeight["bold"] = "bold";
    /**
     * 瘦体
     */ TextWeight["lighter"] = "lighter";
})(TextWeight || (TextWeight = {}));
/**
 * 文本样式
 */ var FontStyle;
(function(FontStyle) {
    /**
     * 正常
     */ FontStyle["normal"] = "normal";
    /**
     * 斜体
     */ FontStyle["italic"] = "italic";
    /**
     * 倾斜体
     */ FontStyle["oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));

var DataType;
(function(DataType) {
    DataType["VFXItemData"] = "VFXItemData";
    DataType["EffectComponent"] = "EffectComponent";
    DataType["Material"] = "Material";
    DataType["Shader"] = "Shader";
    DataType["SpriteComponent"] = "SpriteComponent";
    DataType["ParticleSystem"] = "ParticleSystem";
    DataType["InteractComponent"] = "InteractComponent";
    DataType["CameraController"] = "CameraController";
    DataType["Geometry"] = "Geometry";
    DataType["Texture"] = "Texture";
    DataType["AnimationClip"] = "AnimationClip";
    DataType["TextComponent"] = "TextComponent";
    DataType["BinaryAsset"] = "BinaryAsset";
    // Timeline
    DataType["TrackAsset"] = "TrackAsset";
    DataType["TimelineAsset"] = "TimelineAsset";
    DataType["ObjectBindingTrack"] = "ObjectBindingTrack";
    DataType["TransformTrack"] = "TransformTrack";
    DataType["SpriteColorTrack"] = "SpriteColorTrack";
    DataType["ActivationTrack"] = "ActivationTrack";
    DataType["SubCompositionTrack"] = "SubCompositionTrack";
    DataType["TransformPlayableAsset"] = "TransformPlayableAsset";
    DataType["SpriteColorPlayableAsset"] = "SpriteColorPlayableAsset";
    DataType["ActivationPlayableAsset"] = "ActivationPlayableAsset";
    DataType["SubCompositionPlayableAsset"] = "SubCompositionPlayableAsset";
    // FIXME: 先完成ECS的场景转换，后面移到spec中
    DataType["MeshComponent"] = "MeshComponent";
    DataType["SkyboxComponent"] = "SkyboxComponent";
    DataType["LightComponent"] = "LightComponent";
    DataType["CameraComponent"] = "CameraComponent";
    DataType["ModelPluginComponent"] = "ModelPluginComponent";
    DataType["TreeComponent"] = "TreeComponent";
    DataType["AnimationComponent"] = "AnimationComponent";
    DataType["SpineComponent"] = "SpineComponent";
    // Non-EffectObject
    DataType["TimelineClip"] = "TimelineClip";
})(DataType || (DataType = {}));
var GeometryType;
(function(GeometryType) {
    /**
     * Draw single points.
     */ GeometryType[GeometryType["POINTS"] = 0] = "POINTS";
    /**
     * Draw lines. Each vertex connects to the one after it.
     */ GeometryType[GeometryType["LINES"] = 1] = "LINES";
    /**
     * Draw lines. Each set of two vertices is treated as a separate line segment.
     */ GeometryType[GeometryType["LINE_LOOP"] = 2] = "LINE_LOOP";
    /**
     * Draw a connected group of line segments from the first vertex to the last.
     */ GeometryType[GeometryType["LINE_STRIP"] = 3] = "LINE_STRIP";
    /**
     * Draw triangles. Each set of three vertices creates a separate triangle.
     */ GeometryType[GeometryType["TRIANGLES"] = 4] = "TRIANGLES";
    /**
     * Draw a connected strip of triangles.
     */ GeometryType[GeometryType["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    /**
     * Draw a connected group of triangles. Each vertex connects to the previous and the first vertex in the fan.
     */ GeometryType[GeometryType["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(GeometryType || (GeometryType = {}));
var VertexFormatType;
(function(VertexFormatType) {
    VertexFormatType[VertexFormatType["Float16"] = 0] = "Float16";
    VertexFormatType[VertexFormatType["Float32"] = 1] = "Float32";
    VertexFormatType[VertexFormatType["Int8"] = 2] = "Int8";
    VertexFormatType[VertexFormatType["Int16"] = 3] = "Int16";
    VertexFormatType[VertexFormatType["Int32"] = 4] = "Int32";
    VertexFormatType[VertexFormatType["UInt8"] = 5] = "UInt8";
    VertexFormatType[VertexFormatType["UInt16"] = 6] = "UInt16";
    VertexFormatType[VertexFormatType["UInt32"] = 7] = "UInt32";
})(VertexFormatType || (VertexFormatType = {}));
var IndexFormatType;
(function(IndexFormatType) {
    IndexFormatType[IndexFormatType["None"] = -1] = "None";
    IndexFormatType[IndexFormatType["UInt8"] = 0] = "UInt8";
    IndexFormatType[IndexFormatType["UInt16"] = 1] = "UInt16";
    IndexFormatType[IndexFormatType["UInt32"] = 2] = "UInt32";
})(IndexFormatType || (IndexFormatType = {}));
// BINORMAL[n]	Binormal	float4
// BLENDINDICES[n]	混合索引	uint
// BLENDWEIGHT[n]	混合权重	FLOAT
// COLOR[n]	漫射和反射颜色	float4
// NORMAL[n]	法向矢量	float4
// POSITION[n]	对象空间中的顶点位置。	float4
// POSITIONT	变换的顶点位置。	float4
// PSIZE[n]	点大小	FLOAT
// TANGENT[n]	正切	float4
// TEXCOORD[n]	纹理坐标	float4
// POSITION_BS[n]	Blend Shape 空间中的顶点位置	float4
// NORMAL_BS[n]	Blend Shape 空间中的法向矢量	float4
// TANGENT_BS[n]	Blend Shape 空间中的正切矢量	float4
var VertexBufferSemantic;
(function(VertexBufferSemantic) {
    VertexBufferSemantic["Position"] = "POSITION";
    VertexBufferSemantic["Uv"] = "TEXCOORD0";
    VertexBufferSemantic["Uv2"] = "TEXCOORD1";
    VertexBufferSemantic["Normal"] = "NORMAL";
    VertexBufferSemantic["Tangent"] = "TANGENT";
    VertexBufferSemantic["Color"] = "COLOR";
    VertexBufferSemantic["Joints"] = "JOINTS";
    VertexBufferSemantic["Weights"] = "WEIGHTS";
    //
    VertexBufferSemantic["PositionBS0"] = "POSITION_BS0";
    VertexBufferSemantic["PositionBS1"] = "POSITION_BS1";
    VertexBufferSemantic["PositionBS2"] = "POSITION_BS2";
    VertexBufferSemantic["PositionBS3"] = "POSITION_BS3";
    VertexBufferSemantic["PositionBS4"] = "POSITION_BS4";
    VertexBufferSemantic["PositionBS5"] = "POSITION_BS5";
    VertexBufferSemantic["PositionBS6"] = "POSITION_BS6";
    VertexBufferSemantic["PositionBS7"] = "POSITION_BS7";
    VertexBufferSemantic["NormalBS0"] = "NORMAL_BS0";
    VertexBufferSemantic["NormalBS1"] = "NORMAL_BS1";
    VertexBufferSemantic["NormalBS2"] = "NORMAL_BS2";
    VertexBufferSemantic["NormalBS3"] = "NORMAL_BS3";
    VertexBufferSemantic["TangentBS0"] = "TANGENT_BS0";
    VertexBufferSemantic["TangentBS1"] = "TANGENT_BS1";
    VertexBufferSemantic["TangentBS2"] = "TANGENT_BS2";
    VertexBufferSemantic["TangentBS3"] = "TANGENT_BS3";
})(VertexBufferSemantic || (VertexBufferSemantic = {}));

var BuiltinObjectGUID = {
    WhiteTexture: "whitetexture00000000000000000000",
    PBRShader: "pbr00000000000000000000000000000",
    UnlitShader: "unlit000000000000000000000000000"
};

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get RenderLevel () { return RenderLevel; },
    get BlendingMode () { return BlendingMode; },
    get SideMode () { return SideMode; },
    get MaskMode () { return MaskMode; },
    get ShapeType () { return ShapeType; },
    get PluginType () { return PluginType; },
    get InteractType () { return InteractType; },
    get InteractBehavior () { return InteractBehavior; },
    get ItemType () { return ItemType; },
    get RenderMode () { return RenderMode; },
    get ParticleOrigin () { return ParticleOrigin; },
    get RenderType () { return RenderType; },
    get RenderFace () { return RenderFace; },
    get CameraClipMode () { return CameraClipMode; },
    get BackgroundType () { return BackgroundType; },
    END_BEHAVIOR_DESTROY: END_BEHAVIOR_DESTROY,
    END_BEHAVIOR_PAUSE: END_BEHAVIOR_PAUSE,
    END_BEHAVIOR_FORWARD: END_BEHAVIOR_FORWARD,
    END_BEHAVIOR_PAUSE_AND_DESTROY: END_BEHAVIOR_PAUSE_AND_DESTROY,
    END_BEHAVIOR_FREEZE: END_BEHAVIOR_FREEZE,
    END_BEHAVIOR_RESTART: END_BEHAVIOR_RESTART,
    END_BEHAVIOR_DESTROY_CHILDREN: END_BEHAVIOR_DESTROY_CHILDREN,
    CAMERA_CLIP_MODE_VERTICAL: CAMERA_CLIP_MODE_VERTICAL,
    CAMERA_CLIP_MODE_NORMAL: CAMERA_CLIP_MODE_NORMAL,
    MESSAGE_ITEM_PHRASE_BEGIN: MESSAGE_ITEM_PHRASE_BEGIN,
    MESSAGE_ITEM_PHRASE_END: MESSAGE_ITEM_PHRASE_END,
    get ValueType () { return ValueType; },
    get BezierKeyframeType () { return BezierKeyframeType; },
    get EndBehavior () { return EndBehavior; },
    get ParentItemEndBehavior () { return ParentItemEndBehavior; },
    get ParticleInteractionBehavior () { return ParticleInteractionBehavior; },
    get ShapeArcMode () { return ShapeArcMode; },
    get LightType () { return LightType; },
    get ModelBoundingType () { return ModelBoundingType; },
    get CameraType () { return CameraType; },
    get MaterialType () { return MaterialType; },
    get MaterialBlending () { return MaterialBlending; },
    get RenderMode3D () { return RenderMode3D; },
    get TextOverflow () { return TextOverflow; },
    get TextBaseline () { return TextBaseline; },
    get TextAlignment () { return TextAlignment; },
    get TextWeight () { return TextWeight; },
    get FontStyle () { return FontStyle; },
    get DataType () { return DataType; },
    get GeometryType () { return GeometryType; },
    get VertexFormatType () { return VertexFormatType; },
    get IndexFormatType () { return IndexFormatType; },
    get VertexBufferSemantic () { return VertexBufferSemantic; },
    BuiltinObjectGUID: BuiltinObjectGUID
});

var decoratorInitialStore = new Map();
var mergedStore = new Map();
var effectsClassStore = {};
function effectsClass(className) {
    return function(target, context) {
        if (effectsClassStore[className]) {
            console.warn("Class " + className + " is already registered.");
        }
        // TODO: three修改json dataType, 这边重复注册直接 return
        effectsClassStore[className] = target;
    };
}
function serialize(type, sourceName) {
    return generateSerializableMember(type, sourceName); // value member
}
function getMergedStore(target) {
    var classKey = target.constructor;
    if (mergedStore.get(classKey)) {
        return mergedStore.get(classKey);
    }
    var store = {};
    mergedStore.set(classKey, store);
    var currentTarget = target;
    var currentKey = classKey;
    while(currentKey){
        var initialStore = decoratorInitialStore.get(currentKey);
        for(var property in initialStore){
            store[property] = initialStore[property];
        }
        var parent = Object.getPrototypeOf(currentTarget);
        currentKey = Object.getPrototypeOf(parent).constructor;
        if (currentKey === Object) {
            break;
        }
        currentTarget = parent;
    }
    return store;
}
function generateSerializableMember(type, sourceName) {
    return function(target, propertyKey) {
        var classStore = getDirectStore(target);
        if (!classStore) {
            return;
        }
        if (!classStore[propertyKey]) {
            classStore[propertyKey] = {
                type: type,
                sourceName: sourceName
            };
        }
    };
}
function getDirectStore(target) {
    var classKey = target.constructor;
    if (!decoratorInitialStore.get(classKey)) {
        decoratorInitialStore.set(classKey, {});
    }
    return decoratorInitialStore.get(classKey);
}

/**
 * @since 2.0.0
 */ var EffectsObject = /*#__PURE__*/ function() {
    function EffectsObject(engine) {
        this.engine = engine;
        this.guid = generateGUID();
        this.taggedProperties = {};
        this.engine.addInstance(this);
    }
    var _proto = EffectsObject.prototype;
    _proto.getInstanceId = function getInstanceId() {
        return this.guid;
    };
    _proto.setInstanceId = function setInstanceId(guid) {
        this.engine.removeInstance(this.guid);
        this.guid = guid;
        this.engine.addInstance(this);
    };
    _proto.toData = function toData() {};
    /**
   * 反序列化函数
   *
   * @param data - 对象的序列化的数据
   */ _proto.fromData = function fromData(data) {
        if (data.id) {
            this.setInstanceId(data.id);
        }
    };
    _proto.dispose = function dispose() {};
    EffectsObject.is = function is(obj) {
        return _instanceof1(obj, EffectsObject) && "guid" in obj;
    };
    return EffectsObject;
}();

/**
 * @since 2.0.0
 */ var Component = /*#__PURE__*/ function(EffectsObject) {
    _inherits(Component, EffectsObject);
    function Component() {
        return EffectsObject.apply(this, arguments);
    }
    var _proto = Component.prototype;
    _proto.onAttached = function onAttached() {};
    _proto.onDestroy = function onDestroy() {};
    _proto.fromData = function fromData(data) {
        EffectsObject.prototype.fromData.call(this, data);
        if (data.item) {
            this.item = data.item;
        }
    };
    _proto.dispose = function dispose() {
        this.onDestroy();
        if (this.item) {
            removeItem(this.item.components, this);
        }
    };
    _create_class(Component, [
        {
            key: "transform",
            get: /**
   * 附加到的 VFXItem 对象 Transform 组件
   */ function get() {
                return this.item.transform;
            }
        }
    ]);
    return Component;
}(EffectsObject);
/**
 * @since 2.0.0
 */ var Behaviour = /*#__PURE__*/ function(Component) {
    _inherits(Behaviour, Component);
    function Behaviour() {
        var _this;
        _this = Component.apply(this, arguments) || this;
        _this.isAwakeCalled = false;
        _this.isStartCalled = false;
        _this._enabled = true;
        return _this;
    }
    var _proto = Behaviour.prototype;
    /**
   * 生命周期函数，初始化后调用，生命周期内只调用一次
   */ _proto.awake = function awake() {
    // OVERRIDE
    };
    /**
   * 在每次设置 enabled 为 true 时触发
   */ _proto.onEnable = function onEnable() {
    // OVERRIDE
    };
    /**
   * 生命周期函数，在第一次 update 前调用，生命周期内只调用一次
   */ _proto.start = function start() {
    // OVERRIDE
    };
    /**
   * 生命周期函数，每帧调用一次
   */ _proto.update = function update(dt) {
    // OVERRIDE
    };
    /**
   * 生命周期函数，每帧调用一次，在 update 之后调用
   */ _proto.lateUpdate = function lateUpdate(dt) {
    // OVERRIDE
    };
    _proto.onAttached = function onAttached() {
        this.item.itemBehaviours.push(this);
        if (!this.isAwakeCalled) {
            this.awake();
            this.isAwakeCalled = true;
        }
    };
    _proto.dispose = function dispose() {
        if (this.item) {
            removeItem(this.item.itemBehaviours, this);
        }
        Component.prototype.dispose.call(this);
    };
    _create_class(Behaviour, [
        {
            key: "isActiveAndEnabled",
            get: /**
   * 组件是否可以更新，true 更新，false 不更新
   */ function get() {
                return this.item.getVisible() && this.enabled;
            }
        },
        {
            key: "enabled",
            get: function get() {
                return this._enabled;
            },
            set: function set(value) {
                this._enabled = value;
                if (value) {
                    if (this.isActiveAndEnabled) {
                        this.onEnable();
                    }
                    if (!this.isStartCalled) {
                        this.start();
                        this.isStartCalled = true;
                    }
                }
            }
        }
    ]);
    return Behaviour;
}(Component);
__decorate([
    serialize()
], Behaviour.prototype, "_enabled", void 0);

/**
 * 所有渲染组件的基类
 * @since 2.0.0
 */ var RendererComponent = /*#__PURE__*/ function(Component) {
    _inherits(RendererComponent, Component);
    function RendererComponent() {
        var _this;
        _this = Component.apply(this, arguments) || this;
        _this.isStartCalled = false;
        _this.materials = [];
        _this._priority = 0;
        _this._enabled = true;
        return _this;
    }
    var _proto = RendererComponent.prototype;
    _proto.onEnable = function onEnable() {};
    _proto.start = function start() {};
    _proto.update = function update(dt) {};
    _proto.lateUpdate = function lateUpdate(dt) {};
    _proto.render = function render(renderer) {};
    _proto.onAttached = function onAttached() {
        this.item.rendererComponents.push(this);
    };
    _proto.fromData = function fromData(data) {
        Component.prototype.fromData.call(this, data);
    };
    _proto.toData = function toData() {
        Component.prototype.toData.call(this);
    };
    _proto.dispose = function dispose() {
        if (this.item) {
            removeItem(this.item.rendererComponents, this);
        }
        Component.prototype.dispose.call(this);
    };
    _create_class(RendererComponent, [
        {
            key: "priority",
            get: function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority = value;
            }
        },
        {
            key: "enabled",
            get: function get() {
                return this._enabled;
            },
            set: function set(value) {
                this._enabled = value;
                if (value) {
                    this.onEnable();
                }
            }
        },
        {
            key: "isActiveAndEnabled",
            get: /**
   * 组件是否可以更新，true 更新，false 不更新
   */ function get() {
                return this.item.getVisible() && this.enabled;
            }
        },
        {
            key: "material",
            get: function get() {
                return this.materials[0];
            },
            set: function set(material) {
                if (this.materials.length === 0) {
                    this.materials.push(material);
                } else {
                    this.materials[0] = material;
                }
            }
        }
    ]);
    return RendererComponent;
}(Component);
__decorate([
    serialize()
], RendererComponent.prototype, "materials", void 0);
__decorate([
    serialize()
], RendererComponent.prototype, "_priority", void 0);
__decorate([
    serialize()
], RendererComponent.prototype, "_enabled", void 0);

/**
 * 抽象插件类
 * 注册合成不同生命周期的回调函数
 */ var AbstractPlugin = /*#__PURE__*/ function() {
    function AbstractPlugin() {
        this.order = 100;
        this.name = "";
    }
    var _proto = AbstractPlugin.prototype;
    _proto.onCompositionConstructed = function onCompositionConstructed(composition, scene) {};
    _proto.onCompositionItemLifeBegin = function onCompositionItemLifeBegin(composition, item) {};
    _proto.onCompositionItemLifeEnd = function onCompositionItemLifeEnd(composition, item) {};
    _proto.onCompositionItemRemoved = function onCompositionItemRemoved(composition, item) {};
    _proto.onCompositionReset = function onCompositionReset(composition, frame) {};
    _proto.onCompositionWillReset = function onCompositionWillReset(composition, frame) {};
    _proto.onCompositionDestroyed = function onCompositionDestroyed(composition) {};
    _proto.onCompositionUpdate = function onCompositionUpdate(composition, dt) {};
    _proto.prepareRenderFrame = function prepareRenderFrame(composition, frame) {
        return false;
    };
    _proto.postProcessFrame = function postProcessFrame(composition, frame) {};
    /**
   * 在加载到 JSON 后，就可以进行提前编译
   * @param json
   * @param player
   */ AbstractPlugin.precompile = function precompile(compositions, renderer) {
        return Promise.resolve();
    };
    return AbstractPlugin;
}();

exports.CameraController = /*#__PURE__*/ function(Behaviour) {
    _inherits(CameraController, Behaviour);
    function CameraController(engine, props) {
        var _this;
        _this = Behaviour.call(this, engine) || this;
        if (props) {
            _this.fromData(props);
        }
        return _this;
    }
    var _proto = CameraController.prototype;
    _proto.update = function update() {
        if (this.item.composition && this.item.transform.getValid()) {
            var camera = this.item.composition.camera;
            camera.near = this.options.near;
            camera.far = this.options.far;
            camera.fov = this.options.fov;
            camera.clipMode = this.options.clipMode;
            camera.position = this.transform.getWorldPosition();
            camera.rotation = this.transform.getWorldRotation();
        }
    };
    _proto.fromData = function fromData(data) {
        Behaviour.prototype.fromData.call(this, data);
        this.options = data.options;
    };
    return CameraController;
}(Behaviour);
exports.CameraController = __decorate([
    effectsClass(DataType.CameraController)
], exports.CameraController);

var CameraVFXItemLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(CameraVFXItemLoader, AbstractPlugin);
    function CameraVFXItemLoader() {
        return AbstractPlugin.apply(this, arguments);
    }
    return CameraVFXItemLoader;
}(AbstractPlugin);

exports.HitTestType = void 0;
(function(HitTestType) {
    HitTestType[HitTestType["triangle"] = 1] = "triangle";
    HitTestType[HitTestType["box"] = 2] = "box";
    HitTestType[HitTestType["sphere"] = 3] = "sphere";
    HitTestType[HitTestType["custom"] = 4] = "custom";
})(exports.HitTestType || (exports.HitTestType = {}));

var EVENT_TYPE_CLICK = "click";
var EVENT_TYPE_TOUCH_START = "touchstart";
var EVENT_TYPE_TOUCH_MOVE = "touchmove";
var EVENT_TYPE_TOUCH_END = "touchend";
var EventSystem = /*#__PURE__*/ function() {
    function EventSystem(target, allowPropagation) {
        if (allowPropagation === void 0) allowPropagation = false;
        this.target = target;
        this.allowPropagation = allowPropagation;
        this.enabled = true;
        this.handlers = {};
        this.nativeHandlers = {};
    }
    var _proto = EventSystem.prototype;
    _proto.bindListeners = function bindListeners() {
        var _this = this;
        var x;
        var y;
        var currentTouch;
        var lastTouch;
        var getTouch;
        getTouch = function(event) {
            return event;
        };
        var touchstart = "mousedown";
        var touchmove = "mousemove";
        var touchend = "mouseup";
        var getTouchEventValue = function(event, x, y, dx, dy) {
            if (dx === void 0) dx = 0;
            if (dy === void 0) dy = 0;
            var vx = 0;
            var vy = 0;
            var ts = douyin.performance.now();
            if (!_this.target) {
                logger.error("Trigger TouchEvent after EventSystem is disposed.");
                return {
                    x: x,
                    y: y,
                    vx: 0,
                    vy: vy,
                    dx: dx,
                    dy: dy,
                    ts: ts,
                    width: 0,
                    height: 0,
                    origin: event
                };
            }
            var _this_target = _this.target, width = _this_target.width, height = _this_target.height;
            if (lastTouch) {
                var dt = ts - lastTouch.ts;
                vx = (dx - lastTouch.dx) / dt || 0;
                vy = (dy - lastTouch.dy) / dt || 0;
                lastTouch = {
                    dx: dx,
                    dy: dy,
                    ts: ts
                };
            }
            return {
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                dx: dx,
                dy: dy,
                ts: ts,
                width: width,
                height: height,
                origin: event
            };
        };
        if (isSimulatorCellPhone()) {
            getTouch = function(event) {
                var touches = event.touches, changedTouches = event.changedTouches;
                return touches[0] || changedTouches[0];
            };
            touchstart = "touchstart";
            touchmove = "touchmove";
            touchend = "touchend";
        }
        var _obj;
        this.nativeHandlers = (_obj = {}, _obj[touchstart] = function(event) {
            if (_this.enabled) {
                var touch = getTouch(event);
                var cood = getCoord(touch);
                x = cood.x;
                y = cood.y;
                lastTouch = currentTouch = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    ts: douyin.performance.now(),
                    x: x,
                    y: y
                };
                _this.dispatchEvent(EVENT_TYPE_TOUCH_START, getTouchEventValue(event, x, y));
            }
        }, _obj[touchmove] = function(event) {
            if (currentTouch && _this.enabled) {
                var cood = getCoord(getTouch(event));
                x = cood.x;
                y = cood.y;
                _this.dispatchEvent(EVENT_TYPE_TOUCH_MOVE, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
            }
        }, _obj[touchend] = function(event) {
            if (currentTouch && _this.enabled) {
                if (!_this.allowPropagation && event.cancelable) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                var touch = getTouch(event);
                var cood = getCoord(touch);
                var dt = Math.abs(currentTouch.clientX - touch.clientX) + Math.abs(currentTouch.clientY - touch.clientY);
                x = cood.x;
                y = cood.y;
                if (dt < 4) {
                    _this.dispatchEvent(EVENT_TYPE_CLICK, getTouchEventValue(event, x, y));
                }
                _this.dispatchEvent(EVENT_TYPE_TOUCH_END, getTouchEventValue(event, x, y, x - currentTouch.x, y - currentTouch.y));
            }
            currentTouch = 0;
        }, _obj);
        Object.keys(this.nativeHandlers).forEach(function(name) {
            var _this_target;
            (_this_target = _this.target) == null ? void 0 : _this_target.addEventListener(String(name), _this.nativeHandlers[name]);
        });
    };
    _proto.dispatchEvent = function dispatchEvent(type, event) {
        var handlers = this.handlers[type];
        handlers == null ? void 0 : handlers.forEach(function(fn) {
            return fn(event);
        });
    };
    _proto.addEventListener = function addEventListener(type, callback) {
        var handlers = this.handlers[type];
        if (!handlers) {
            handlers = this.handlers[type] = [];
        }
        addItem(handlers, callback);
        return function() {
            removeItem(handlers, callback);
        };
    };
    _proto.removeEventListener = function removeEventListener(type, callback) {
        var handlers = this.handlers[type];
        if (handlers) {
            removeItem(handlers, callback);
        }
    };
    _proto.dispose = function dispose() {
        var _this = this;
        if (this.target) {
            this.handlers = {};
            Object.keys(this.nativeHandlers).forEach(function(name) {
                var _this_target;
                (_this_target = _this.target) == null ? void 0 : _this_target.removeEventListener(String(name), _this.nativeHandlers[name]);
            });
            this.nativeHandlers = {};
            this.target = null;
        }
    };
    return EventSystem;
}();
function getCoord(event) {
    var ele = event.target;
    var clientX = event.clientX, clientY = event.clientY;
    var _ele_getBoundingClientRect = ele.getBoundingClientRect(), left = _ele_getBoundingClientRect.left, top = _ele_getBoundingClientRect.top, width = _ele_getBoundingClientRect.width, height = _ele_getBoundingClientRect.height;
    var x = (clientX - left) / width * 2 - 1;
    var y = 1 - (clientY - top) / height * 2;
    return {
        x: x,
        y: y
    };
}

var InteractLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(InteractLoader, AbstractPlugin);
    function InteractLoader() {
        return AbstractPlugin.apply(this, arguments);
    }
    return InteractLoader;
}(AbstractPlugin);

/**
 * 四维向量
 */ var Vector4$1 = /*#__PURE__*/ function() {
    function Vector4(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 0;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    var _proto = Vector4.prototype;
    /**
     * 设置向量
     * @param x - x 轴分量
     * @param y - y 轴分量
     * @param z - z 轴分量
     * @param w - w 轴分量
     * @returns
     */ _proto.set = function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    /**
     * 设置零向量
     * @returns 向量
     */ _proto.setZero = function setZero() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        return this;
    };
    /**
     * 通过标量数值设置向量
     * @param num - 数值
     * @returns 向量
     */ _proto.setFromNumber = function setFromNumber(num) {
        this.x = num;
        this.y = num;
        this.z = num;
        this.w = num;
        return this;
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var _array_offset;
        this.x = (_array_offset = array[offset]) != null ? _array_offset : 0;
        var _array_;
        this.y = (_array_ = array[offset + 1]) != null ? _array_ : 0;
        var _array_1;
        this.z = (_array_1 = array[offset + 2]) != null ? _array_1 : 0;
        var _array_2;
        this.w = (_array_2 = array[offset + 3]) != null ? _array_2 : 0;
        return this;
    };
    /**
     * 拷贝向量
     * @param v - 复制对象
     * @returns 拷贝结果
     */ _proto.copyFrom = function copyFrom(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
    };
    /**
     * 克隆向量
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Vector4(this.x, this.y, this.z, this.w);
    };
    /**
     * 根据下标设置向量分量
     * @param index - 下标值
     * @param value - 分量值
     * @returns 向量
     */ _proto.setElement = function setElement(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                console.error("index is out of range: " + index);
        }
        return this;
    };
    /**
     * 根据下标获取向量分量
     * @param index - 下标
     * @returns 分量值
     */ _proto.getElement = function getElement(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                console.error("index is out of range: " + index);
        }
        return 0;
    };
    /**
     * 向量相加
     * @param right - 相加对象，向量 | 数字
     * @returns 相加结果
     */ _proto.add = function add(right) {
        if (typeof right === "number") {
            this.x += right;
            this.y += right;
            this.z += right;
            this.w += right;
        } else if (_instanceof1(right, Array)) {
            this.x += right[0];
            this.y += right[1];
            this.z += right[2];
            this.w += right[3];
        } else {
            this.x += right.x;
            this.y += right.y;
            this.z += right.z;
            this.w += right.w;
        }
        return this;
    };
    /**
     * 向量相加
     * @param left - 向量
     * @param right - 向量
     * @returns 求和结果
     */ _proto.addVectors = function addVectors(left, right) {
        this.x = left.x + right.x;
        this.y = left.y + right.y;
        this.z = left.z + right.z;
        this.w = left.w + right.w;
        return this;
    };
    /**
     * 向量比例缩放后相加
     * @param right - 向量
     * @param s - 比例
     * @returns 求和结果
     */ _proto.addScaledVector = function addScaledVector(right, s) {
        this.x += right.x * s;
        this.y += right.y * s;
        this.z += right.z * s;
        this.w += right.w * s;
        return this;
    };
    /**
     * 向量相减
     * @param right - 相减对象，向量 | 数字
     * @returns 相减结果
     */ _proto.subtract = function subtract(right) {
        if (typeof right === "number") {
            this.x -= right;
            this.y -= right;
            this.z -= right;
            this.w -= right;
        } else if (_instanceof1(right, Array)) {
            this.x -= right[0];
            this.y -= right[1];
            this.z -= right[2];
            this.w -= right[3];
        } else {
            this.x -= right.x;
            this.y -= right.y;
            this.z -= right.z;
            this.w -= right.w;
        }
        return this;
    };
    /**
     * 向量相减
     * @param left - 向量
     * @param right - 向量
     * @returns 向量
     */ _proto.subtractVectors = function subtractVectors(left, right) {
        this.x = left.x - right.x;
        this.y = left.y - right.y;
        this.z = left.z - right.z;
        this.w = left.w - right.w;
        return this;
    };
    /**
     * 向量相乘
     * @param right - 相乘对象，对象 | 数字
     * @returns 向量
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            this.x *= right;
            this.y *= right;
            this.z *= right;
            this.w *= right;
        } else if (_instanceof1(right, Array)) {
            this.x *= right[0];
            this.y *= right[1];
            this.z *= right[2];
            this.w *= right[3];
        } else {
            this.x *= right.x;
            this.y *= right.y;
            this.z *= right.z;
            this.w *= right.w;
        }
        return this;
    };
    /**
     * 向量相乘
     * @param left - 向量
     * @param right - 向量
     * @returns 向量
     */ _proto.multiplyVectors = function multiplyVectors(left, right) {
        this.x = left.x * right.x;
        this.y = left.y * right.y;
        this.z = left.z * right.z;
        this.w = left.w * right.w;
        return this;
    };
    /**
     * 向量相除
     * @param right - 相除对象，对象 | 数字
     * @returns 向量
     */ _proto.divide = function divide(right) {
        if (typeof right === "number") {
            this.x /= right;
            this.y /= right;
            this.z /= right;
            this.w /= right;
        } else if (_instanceof1(right, Array)) {
            this.x /= right[0];
            this.y /= right[1];
            this.z /= right[2];
            this.w /= right[3];
        } else {
            this.x /= right.x;
            this.y /= right.y;
            this.z /= right.z;
            this.w /= right.w;
        }
        return this;
    };
    /**
     * 向量缩放
     * @param v - 数字
     * @returns 缩放结果
     */ _proto.scale = function scale(v) {
        this.x *= v;
        this.y *= v;
        this.z *= v;
        this.w *= v;
        return this;
    };
    /**
     * 分量求和
     * @returns 求和结果
     */ _proto.sum = function sum() {
        return this.x + this.y + this.z + this.w;
    };
    /**
     * 向量求最小值
     * @param v - 向量或数值
     * @returns 最小值
     */ _proto.min = function min(v) {
        if (typeof v === "number") {
            this.x = Math.min(this.x, v);
            this.y = Math.min(this.y, v);
            this.z = Math.min(this.z, v);
            this.w = Math.min(this.w, v);
        } else {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
        }
        return this;
    };
    /**
     * 向量求最大值
     * @param v - 向量或数值
     * @returns 最大值
     */ _proto.max = function max(v) {
        if (typeof v === "number") {
            this.x = Math.max(this.x, v);
            this.y = Math.max(this.y, v);
            this.z = Math.max(this.z, v);
            this.w = Math.max(this.w, v);
        } else {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
        }
        return this;
    };
    /**
     * 向量阈值约束
     * @param min - 最小值
     * @param max - 最大值
     * @returns 向量
     */ _proto.clamp = function clamp(min, max) {
        return this.max(min).min(max);
    };
    /**
     * 向量向下取整
     * @returns 取整结果
     */ _proto.floor = function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    };
    /**
     * 向量向上取整
     * @returns 取整结果
     */ _proto.ceil = function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    };
    /**
     * 向量四舍五入
     * @returns 求值结果
     */ _proto.round = function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    };
    /**
     * 向量取绝对值
     * @returns 向量
     */ _proto.abs = function abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        this.z = Math.abs(this.z);
        this.w = Math.abs(this.w);
        return this;
    };
    /**
     * 向量取反
     * @returns 取反结果
     */ _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    };
    /**
     * 向量长度平方
     * @returns 长度平方
     */ _proto.lengthSquared = function lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };
    /**
     * 向量长度
     * @returns 长度
     */ _proto.length = function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    /**
     * 向量归一化
     * @returns 归一化结果
     */ _proto.normalize = function normalize() {
        return this.divide(this.length() || 1);
    };
    /**
     * 设置向量长度
     * @param length - 长度
     * @returns 向量
     */ _proto.setLength = function setLength(length) {
        return this.normalize().multiply(length);
    };
    /**
     * 向量求线性插值
     * @param v - 向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */ _proto.lerp = function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    };
    /**
     * 两向量求线性插值
     * @param v1 - 第一个向量
     * @param v2 - 第二个向量
     * @param alpha - 插值比例
     * @returns 插值结果
     */ _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    };
    /**
     * 向量求点积
     * @param v - 向量
     * @returns 点积结果
     */ _proto.dot = function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    /**
     * 向量判等
     * @param v - 向量
     * @returns 判等结果
     */ _proto.equals = function equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    };
    /**
     * 是否零向量
     * @returns 是否零向量
     */ _proto.isZero = function isZero() {
        var eps = NumberEpsilon;
        var _this = this, x = _this.x, y = _this.y, z = _this.z, w = _this.w;
        return Math.abs(x) <= eps && Math.abs(y) <= eps && Math.abs(z) <= eps && Math.abs(w) <= eps;
    };
    /**
     * 向量转数组
     * @returns 数组
     */ _proto.toArray = function toArray() {
        return [
            this.x,
            this.y,
            this.z,
            this.w
        ];
    };
    _proto.toVector3 = function toVector3() {
        return new Vector3(this.x, this.y, this.z);
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
    };
    /**
     * 生成随机向量
     * @returns 向量
     */ _proto.random = function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    };
    /**
     * 变换矩阵作用于向量
     * @param m - 变换矩阵
     * @param [out] - 输出结果，如果没有设置就直接覆盖当前值
     * @returns 向量
     */ _proto.applyMatrix = function applyMatrix(m, out) {
        return m.transformVector4(this, out);
    };
    /**
     * 通过标量数值创建向量
     * @param num - 数值
     * @returns 向量
     */ Vector4.fromNumber = function fromNumber(num) {
        return new Vector4().setFromNumber(num);
    };
    /**
     * 通过数组创建向量
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 向量
     */ Vector4.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Vector4().setFromArray(array, offset);
    };
    return Vector4;
}();
/**
     * 四维向量的常量
     */ Vector4$1.ONE = new Vector4$1(1.0, 1.0, 1.0, 1.0);
Vector4$1.ZERO = new Vector4$1(0.0, 0.0, 0.0, 0.0);

/**
 * 三维矩阵（列优先矩阵）
 */ var Matrix3 = /*#__PURE__*/ function() {
    function Matrix3(m11, m21, m31, m12, m22, m32, m13, m23, m33) {
        if (m11 === void 0) m11 = 1;
        if (m21 === void 0) m21 = 0;
        if (m31 === void 0) m31 = 0;
        if (m12 === void 0) m12 = 0;
        if (m22 === void 0) m22 = 1;
        if (m32 === void 0) m32 = 0;
        if (m13 === void 0) m13 = 0;
        if (m23 === void 0) m23 = 0;
        if (m33 === void 0) m33 = 1;
        this.elements = [
            m11,
            m21,
            m31,
            m12,
            m22,
            m32,
            m13,
            m23,
            m33
        ];
    }
    var _proto = Matrix3.prototype;
    /**
     * 设置矩阵
     * @param m11 - 第 1 行，第 1 列
     * @param m21 - 第 2 行，第 1 列
     * @param m31 - 第 3 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m22 - 第 2 行，第 2 列
     * @param m32 - 第 3 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m23 - 第 2 行，第 3 列
     * @param m33 - 第 3 行，第 3 列
     * @returns
     */ _proto.set = function set(m11, m21, m31, m12, m22, m32, m13, m23, m33) {
        var e = this.elements;
        e[0] = m11;
        e[3] = m12;
        e[6] = m13;
        e[1] = m21;
        e[4] = m22;
        e[7] = m23;
        e[2] = m31;
        e[5] = m32;
        e[8] = m33;
        return this;
    };
    /**
     * 设置矩阵通过行优先数据
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @returns 矩阵
     */ _proto.setFromRowMajorData = function setFromRowMajorData(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[3] = m12;
        e[6] = m13;
        e[1] = m21;
        e[4] = m22;
        e[7] = m23;
        e[2] = m31;
        e[5] = m32;
        e[8] = m33;
        return this;
    };
    /**
     * 通过列向量设置矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @returns 矩阵
     */ _proto.setFromColumnVectors = function setFromColumnVectors(c1, c2, c3) {
        return this.set(c1.x, c1.y, c1.z, c2.x, c2.y, c2.z, c3.x, c3.y, c3.z);
    };
    /**
     * 通过四阶矩阵设置三阶矩阵
     * @param m - 四阶矩阵
     * @returns 矩阵
     */ _proto.setFromMatrix4 = function setFromMatrix4(m) {
        var me = m.elements;
        return this.set(me[0], me[1], me[2], me[4], me[5], me[6], me[8], me[9], me[10]);
    };
    /**
     * 通过数组设置矩阵
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        for(var i = 0; i < 9; i++){
            this.elements[i] = array[offset + i];
        }
        return this;
    };
    /**
     * 通过四元数设置矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */ _proto.setFromQuaternion = function setFromQuaternion(quat) {
        var x = quat.x, y = quat.y, z = quat.z, w = quat.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var te = this.elements;
        te[0] = 1 - (yy + zz);
        te[1] = xy + wz;
        te[2] = xz - wy;
        te[3] = xy - wz;
        te[4] = 1 - (xx + zz);
        te[5] = yz + wx;
        te[6] = xz + wy;
        te[7] = yz - wx;
        te[8] = 1 - (xx + yy);
        return this;
    };
    /**
     * 矩阵清零
     * @returns 零矩阵
     */ _proto.setZero = function setZero() {
        for(var i = 0; i < 9; i++){
            this.elements[i] = 0;
        }
        return this;
    };
    /**
     * 矩阵单位化
     * @returns 单位矩阵
     */ _proto.identity = function identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    };
    /**
     * 矩阵克隆
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        var e = this.elements;
        return new Matrix3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
    };
    /**
     * 矩阵复制
     * @param m - 复制对象
     * @returns 复制结果
     */ _proto.copyFrom = function copyFrom(m) {
        this.elements = [].concat(m.elements);
        return this;
    };
    /**
     * 得到列向量
     * @param i - 列向量索引，从 0 开始
     * @returns 列向量
     */ _proto.getColumnVector = function getColumnVector(i, v) {
        return v.set(this.elements[i * 3], this.elements[i * 3 + 1], this.elements[i * 3 + 2]);
    };
    /**
     * 矩阵缩放
     * @param sx - x 轴缩放分量
     * @param sy - y 轴缩放分量
     * @returns 缩放结果
     */ _proto.scale = function scale(sx, sy) {
        var e = this.elements;
        e[0] *= sx;
        e[3] *= sx;
        e[6] *= sx;
        e[1] *= sy;
        e[4] *= sy;
        e[7] *= sy;
        return this;
    };
    /**
     * 矩阵旋转
     * @param theta - 旋转角度（弧度）
     * @returns 旋转结果
     */ _proto.rotate = function rotate(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var e = this.elements;
        var m11 = e[0], m12 = e[3], m13 = e[6];
        var m21 = e[1], m22 = e[4], m23 = e[7];
        e[0] = c * m11 + s * m21;
        e[3] = c * m12 + s * m22;
        e[6] = c * m13 + s * m23;
        e[1] = -s * m11 + c * m21;
        e[4] = -s * m12 + c * m22;
        e[7] = -s * m13 + c * m23;
        return this;
    };
    /**
     * 矩阵平移
     * @param x - x 轴平移分量
     * @param y - y 轴平移分量
     * @returns 平移结果
     */ _proto.translate = function translate(x, y) {
        var e = this.elements;
        e[0] += x * e[2];
        e[3] += x * e[5];
        e[6] += x * e[8];
        e[1] += y * e[2];
        e[4] += y * e[5];
        e[7] += y * e[8];
        return this;
    };
    /**
     * 矩阵右乘
     * @param right - 相乘矩阵
     * @returns 右乘结果
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            for(var i = 0; i < 9; i++){
                this.elements[i] *= right;
            }
            return this;
        } else {
            return this.multiplyMatrices(this, right);
        }
    };
    /**
     * 矩阵左乘
     * @param left - 相乘矩阵
     * @returns 左乘结果
     */ _proto.premultiply = function premultiply(left) {
        return this.multiplyMatrices(left, this);
    };
    /**
     * 矩阵乘法
     * @param left - 矩阵
     * @param right - 矩阵
     * @returns 相乘结果
     */ _proto.multiplyMatrices = function multiplyMatrices(left, right) {
        var ae = left.elements;
        var be = right.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[3], a13 = ae[6];
        var a21 = ae[1], a22 = ae[4], a23 = ae[7];
        var a31 = ae[2], a32 = ae[5], a33 = ae[8];
        var b11 = be[0], b12 = be[3], b13 = be[6];
        var b21 = be[1], b22 = be[4], b23 = be[7];
        var b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    };
    /**
     * 矩阵求行列式值
     * @returns 行列式结果
     */ _proto.determinant = function determinant() {
        var e = this.elements;
        var m11 = e[0], m21 = e[3], m31 = e[6];
        var m12 = e[1], m22 = e[4], m32 = e[7];
        var m13 = e[2], m23 = e[5], m33 = e[8];
        return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
    };
    /**
     * 矩阵求逆
     * @returns 逆矩阵
     */ _proto.invert = function invert() {
        var e = this.elements;
        var m11 = e[0], m12 = e[3], m13 = e[6];
        var m21 = e[1], m22 = e[4], m23 = e[7];
        var m31 = e[2], m32 = e[5], m33 = e[8];
        var t11 = m33 * m22 - m32 * m23;
        var t12 = m32 * m13 - m33 * m12;
        var t13 = m23 * m12 - m22 * m13;
        var det = m11 * t11 + m21 * t12 + m31 * t13;
        if (det === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        var detInv = 1 / det;
        e[0] = t11 * detInv;
        e[1] = (m31 * m23 - m33 * m21) * detInv;
        e[2] = (m32 * m21 - m31 * m22) * detInv;
        e[3] = t12 * detInv;
        e[4] = (m33 * m11 - m31 * m13) * detInv;
        e[5] = (m31 * m12 - m32 * m11) * detInv;
        e[6] = t13 * detInv;
        e[7] = (m21 * m13 - m23 * m11) * detInv;
        e[8] = (m22 * m11 - m21 * m12) * detInv;
        return this;
    };
    /**
     * 矩阵转置
     * @returns 转置结果
     */ _proto.transpose = function transpose() {
        var t;
        var m = this.elements;
        t = m[1];
        m[1] = m[3];
        m[3] = t;
        t = m[2];
        m[2] = m[6];
        m[6] = t;
        t = m[5];
        m[5] = m[7];
        m[7] = t;
        return this;
    };
    /**
     * 对点进行矩阵变换
     * @param v - 输入点
     * @param out - 输出点，如果没有会覆盖输入的数据
     * @returns 变换后的结果
     */ _proto.transformPoint = function transformPoint(v, out) {
        var x = v.x, y = v.y, z = v.z;
        var e = this.elements;
        var res = out != null ? out : v;
        res.x = e[0] * x + e[3] * y + e[6] * z;
        res.y = e[1] * x + e[4] * y + e[7] * z;
        res.z = e[2] * x + e[5] * y + e[8] * z;
        return res;
    };
    /**
     * 对法向量进行矩阵变换
     * @param v - 输入向量
     * @param out - 输出向量，如果没有会覆盖输入的数据
     * @returns 变换后的结果
     */ _proto.transformNormal = function transformNormal(v, out) {
        return this.transformPoint(v, out).normalize();
    };
    /**
     * 矩阵判等
     * @param matrix - 矩阵
     * @returns 判等结果
     */ _proto.equals = function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for(var i = 0; i < 9; i++){
            if (!isEqual(te[i], me[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * 矩阵转为数组
     * @returns
     */ _proto.toArray = function toArray() {
        return [].concat(this.elements);
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        var e = this.elements;
        array[offset] = e[0];
        array[offset + 1] = e[1];
        array[offset + 2] = e[2];
        array[offset + 3] = e[3];
        array[offset + 4] = e[4];
        array[offset + 5] = e[5];
        array[offset + 6] = e[6];
        array[offset + 7] = e[7];
        array[offset + 8] = e[8];
    };
    /**
     * 创建单位阵
     * @returns 单位矩阵
     */ Matrix3.fromIdentity = function fromIdentity() {
        return new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    };
    /**
     * 通过列向量创建矩阵
     * @param c1 - 第一列
     * @param c2 - 第二列
     * @param c3 - 第三列
     * @returns 矩阵
     */ Matrix3.fromColumnVectors = function fromColumnVectors(c1, c2, c3) {
        return new Matrix3().setFromColumnVectors(c1, c2, c3);
    };
    /**
     * 通过四阶矩阵创建矩阵（获取空间变换矩阵旋转缩放部分）
     * @param m - 四阶矩阵
     * @returns 矩阵
     */ Matrix3.fromMatrix4 = function fromMatrix4(m) {
        return new Matrix3().setFromMatrix4(m);
    };
    /**
     * 通过数组创建矩阵
     * @param array - 数组（列优先）
     * @param [offset=0] - 起始偏移值
     * @returns 矩阵
     */ Matrix3.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Matrix3().setFromArray(array, offset);
    };
    /**
     * 通过四元数创建矩阵
     * @param quat - 四元数
     * @returns 矩阵
     */ Matrix3.fromQuaternion = function fromQuaternion(quat) {
        return new Matrix3().setFromQuaternion(quat);
    };
    /**
     * 设置矩阵通过行优先数据
     * @param m11 - 第 1 行，第 1 列
     * @param m12 - 第 1 行，第 2 列
     * @param m13 - 第 1 行，第 3 列
     * @param m21 - 第 2 行，第 1 列
     * @param m22 - 第 2 行，第 2 列
     * @param m23 - 第 2 行，第 3 列
     * @param m31 - 第 3 行，第 1 列
     * @param m32 - 第 3 行，第 2 列
     * @param m33 - 第 3 行，第 3 列
     * @returns 矩阵
     */ Matrix3.fromRowMajorData = function fromRowMajorData(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        return new Matrix3(m11, m21, m31, m12, m22, m32, m13, m23, m33);
    };
    return Matrix3;
}();

/**
 * 光线类
 */ var Ray = /*#__PURE__*/ function() {
    function Ray(origin, direction) {
        if (origin === void 0) origin = Vector3.ZERO;
        if (direction === void 0) direction = Vector3.X;
        /**
     * 光线的原点
     */ this.origin = new Vector3();
        /**
     * 光线的方向
     */ this.direction = new Vector3();
        // 注意这里必须拷贝
        this.origin.copyFrom(origin);
        this.direction.copyFrom(direction).normalize();
    }
    var _proto = Ray.prototype;
    /**
     * 光线设置
     * @param origin - 原点
     * @param direction - 方向
     * @returns
     */ _proto.set = function set(origin, direction) {
        this.origin.copyFrom(origin);
        this.direction.copyFrom(direction).normalize();
        return this;
    };
    /**
     * 光线克隆
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Ray(this.origin, this.direction);
    };
    /**
     * 光线拷贝
     * @param ray - 要拷贝对象
     * @returns 拷贝结果
     */ _proto.copyFrom = function copyFrom(ray) {
        return this.set(ray.origin, ray.direction);
    };
    /**
     * 根据t计算新的光线原点
     * @param t - 光线的系数 t
     * @returns
     */ _proto.recast = function recast(t) {
        this.origin.copyFrom(this.at(t, Ray.tempVec0));
        return this;
    };
    /**
     * 根据t值计算光线上的点
     * @param t - 光线的系数 t
     * @param [out] - 计算的点
     * @returns
     */ _proto.at = function at(t, out) {
        var ret = out ? out : new Vector3();
        ret.copyFrom(this.origin);
        return ret.addScaledVector(this.direction, t);
    };
    /**
     * 光线相等判断
     * @param other - 其他对象
     * @returns
     */ _proto.equals = function equals(other) {
        return this.origin.equals(other.origin) && this.direction.equals(other.direction);
    };
    /**
     * 根据矩阵对光线进行变换
     * @param m - 变换矩阵
     * @returns
     */ _proto.applyMatrix = function applyMatrix(m) {
        this.origin.applyProjectionMatrix(m);
        this.direction.applyNormalMatrix(m);
        return this;
    };
    /**
     * 光线和包围盒求交
     * @param box - 类包围盒对象
     * @param [out] - 交点
     * @returns
     */ _proto.intersectBox = function intersectBox(box, out) {
        var _this_origin = this.origin, ox = _this_origin.x, oy = _this_origin.y, oz = _this_origin.z;
        var _this_direction = this.direction, dx = _this_direction.x, dy = _this_direction.y, dz = _this_direction.z;
        var _box_min = box.min, bxmin = _box_min.x, bymin = _box_min.y, bzmin = _box_min.z;
        var _box_max = box.max, bxmax = _box_max.x, bymax = _box_max.y, bzmax = _box_max.z;
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / dx;
        var invdiry = 1 / dy;
        var invdirz = 1 / dz;
        if (invdirx >= 0) {
            tmin = (bxmin - ox) * invdirx;
            tmax = (bxmax - ox) * invdirx;
        } else {
            tmin = (bxmax - ox) * invdirx;
            tmax = (bxmin - ox) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (bymin - oy) * invdiry;
            tymax = (bymax - oy) * invdiry;
        } else {
            tymin = (bymax - oy) * invdiry;
            tymax = (bymin - oy) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) {
            return;
        }
        if (tymin > tmin || tmin !== tmin) {
            tmin = tymin;
        }
        if (tymax < tmax || tmax !== tmax) {
            tmax = tymax;
        }
        if (tymin > tmin || tmin !== tmin) {
            tmin = tymin;
        }
        if (tymax < tmax || tmax !== tmax) {
            tmax = tymax;
        }
        if (invdirz >= 0) {
            tzmin = (bzmin - oz) * invdirz;
            tzmax = (bzmax - oz) * invdirz;
        } else {
            tzmin = (bzmax - oz) * invdirz;
            tzmax = (bzmin - oz) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) {
            return;
        }
        if (tzmin > tmin || tmin !== tmin) {
            tmin = tzmin;
        }
        if (tzmax < tmax || tmax !== tmax) {
            tmax = tzmax;
        }
        if (tmax < 0) {
            return;
        }
        return tmin >= 0 ? this.at(tmin, out) : this.at(tmax, out);
    };
    /**
     * 光线和平面求交
     * @param plane - 类平面对象
     * @param [out] - 交点
     * @returns
     */ _proto.intersectPlane = function intersectPlane(plane, out) {
        var normal = plane.normal;
        var distance = plane.distance;
        var denominator = normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            var t = normal.dot(this.origin) + distance;
            if (t === 0) {
                var ret = out ? out : new Vector3();
                return ret.copyFrom(this.origin);
            }
            // Null is preferable to undefined since undefined means.... it is undefined
            return;
        }
        var t1 = -(this.origin.dot(normal) + distance) / denominator;
        // Return if the ray never intersects the plane
        return t1 >= 0 ? this.at(t1, out) : undefined;
    };
    /**
     * 光线和圆求交
     * @param sphere - 类球对象
     * @param [out] - 交点
     * @returns
     */ _proto.intersectSphere = function intersectSphere(sphere, out) {
        var center = sphere.center;
        var vector = Ray.tempVec0.subtractVectors(center, this.origin);
        var tca = vector.dot(this.direction);
        var d2 = vector.dot(vector) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) {
            return;
        }
        var thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        var t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        var t1 = tca + thc;
        // test to see if t1 is behind the ray - if so, return null
        if (t1 < 0) {
            return;
        }
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return t0 >= 0 ? this.at(t0, out) : this.at(t1, out);
    };
    /**
     * 光线和三角形求交
     * @param triangle - 类三角形对象
     * @param [out] - 交点
     * @param [backfaceCulling] - 是否背面剔除
     * @returns
     */ _proto.intersectTriangle = function intersectTriangle(triangle, out, backfaceCulling) {
        // FIXME: 交换out和backfaceCulling
        // Compute the offset origin, edges, and normal.
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        var a = triangle.p0;
        var b = triangle.p1;
        var c = triangle.p2;
        var edge1 = Ray.tempVec0.subtractVectors(b, a);
        var edge2 = Ray.tempVec1.subtractVectors(c, a);
        var diff = Ray.tempVec2.subtractVectors(this.origin, a);
        var normal = Ray.tempVec3.crossVectors(edge1, edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        var DdN = this.direction.dot(normal);
        var sign;
        if (DdN > 0) {
            if (backfaceCulling) {
                return;
            }
            sign = 1;
        } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        } else {
            return;
        }
        edge2.crossVectors(diff, edge2);
        var DdQxE2 = sign * this.direction.dot(edge2);
        // b1 < 0, no intersection
        if (DdQxE2 < 0) {
            return;
        }
        edge1.cross(diff);
        var DdE1xQ = sign * this.direction.dot(edge1);
        // b2 < 0, no intersection
        if (DdE1xQ < 0) {
            return;
        }
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) {
            return;
        }
        // Line intersects triangle, check if ray does.
        var QdN = -sign * diff.dot(normal);
        // t < 0, no intersection
        if (QdN < 0) {
            return;
        }
        // Ray intersects triangle.
        return this.at(QdN / DdN, out);
    };
    return Ray;
}();
Ray.tempVec0 = new Vector3();
Ray.tempVec1 = new Vector3();
Ray.tempVec2 = new Vector3();
Ray.tempVec3 = new Vector3();

var Color = /*#__PURE__*/ function() {
    function Color(r, g, b, a) {
        if (r === void 0) r = 0;
        if (g === void 0) g = 0;
        if (b === void 0) b = 0;
        if (a === void 0) a = 0;
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    var _proto = Color.prototype;
    /**
     * 设置颜色
     * @param r - r 分量
     * @param g - g 分量
     * @param b - b 分量
     * @param a - a 分量
     * @returns
     */ _proto.set = function set(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
    };
    /**
     * 设置零颜色
     * @returns
     */ _proto.setZero = function setZero() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        return this;
    };
    /**
     * 通过标量数值设置颜色
     * @param num - 数值
     * @returns
     */ _proto.setFromNumber = function setFromNumber(num) {
        this.r = num;
        this.g = num;
        this.b = num;
        this.a = num;
        return this;
    };
    /**
     * 通过Vector4创建颜色
     * @param v - Vector4
     * @returns
     */ _proto.setFromVector4 = function setFromVector4(v) {
        this.r = v.x;
        this.g = v.y;
        this.b = v.z;
        this.a = v.w;
        return this;
    };
    /**
     * 通过数组创建颜色
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */ _proto.setFromArray = function setFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var _array_offset;
        this.r = (_array_offset = array[offset]) != null ? _array_offset : 0;
        var _array_;
        this.g = (_array_ = array[offset + 1]) != null ? _array_ : 0;
        var _array_1;
        this.b = (_array_1 = array[offset + 2]) != null ? _array_1 : 0;
        var _array_2;
        this.a = (_array_2 = array[offset + 3]) != null ? _array_2 : 0;
        return this;
    };
    _proto.setFromHSV = function setFromHSV(hue, saturation, value, alpha) {
        if (alpha === void 0) alpha = 1;
        var chroma = value * saturation;
        var h = hue / 60;
        var x = chroma * (1 - Math.abs(h % 2 - 1));
        var r = 0;
        var g = 0;
        var b = 0;
        if (h >= 0 && h <= 1) {
            r = chroma;
            g = x;
        } else if (h >= 1 && h <= 2) {
            r = x;
            g = chroma;
        } else if (h >= 2 && h <= 3) {
            g = chroma;
            b = x;
        } else if (h >= 3 && h <= 4) {
            g = x;
            b = chroma;
        } else if (h >= 4 && h <= 5) {
            r = x;
            b = chroma;
        } else if (h >= 5 && h <= 6) {
            r = chroma;
            b = x;
        }
        var m = value - chroma;
        return this.set(r + m, g + m, b + m, alpha);
    };
    _proto.setFromHexString = function setFromHexString(hex) {
        if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
            return this;
        }
        var r = parseInt(hex.substring(1, 3), 16) / 255.0;
        var g = parseInt(hex.substring(3, 5), 16) / 255.0;
        var b = parseInt(hex.substring(5, 7), 16) / 255.0;
        var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) / 255.0 : 1.0;
        return this.set(r, g, b, a);
    };
    /**
     * 拷贝颜色
     * @param v - 复制对象
     * @returns 拷贝结果
     */ _proto.copyFrom = function copyFrom(v) {
        this.r = v.r;
        this.g = v.g;
        this.b = v.b;
        this.a = v.a;
        return this;
    };
    /**
     * 克隆颜色
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Color(this.r, this.g, this.b, this.a);
    };
    /**
     * 根据下标设置颜色分量
     * @param index - 下标值
     * @param value - 分量值
     * @returns
     */ _proto.setElement = function setElement(index, value) {
        switch(index){
            case 0:
                this.r = value;
                break;
            case 1:
                this.g = value;
                break;
            case 2:
                this.b = value;
                break;
            case 3:
                this.a = value;
                break;
            default:
                console.error("index is out of range: " + index);
        }
        return this;
    };
    /**
     * 根据下标获取颜色分量
     * @param index - 下标
     * @returns 分量值
     */ _proto.getElement = function getElement(index) {
        switch(index){
            case 0:
                return this.r;
            case 1:
                return this.g;
            case 2:
                return this.b;
            case 3:
                return this.a;
            default:
                console.error("index is out of range: " + index);
        }
        return 0;
    };
    /**
     * 颜色相加
     * @param right - 相加对象，颜色 | 数字
     * @returns 相加结果
     */ _proto.add = function add(right) {
        if (typeof right === "number") {
            this.r += right;
            this.g += right;
            this.b += right;
            this.a += right;
        } else if (_instanceof1(right, Array)) {
            this.r += right[0];
            this.g += right[1];
            this.b += right[2];
            this.a += right[3];
        } else {
            this.r += right.r;
            this.g += right.g;
            this.b += right.b;
            this.a += right.a;
        }
        return this;
    };
    /**
     * 颜色相减
     * @param right - 相减对象，颜色 | 数字
     * @returns 相减结果
     */ _proto.subtract = function subtract(right) {
        if (typeof right === "number") {
            this.r -= right;
            this.g -= right;
            this.b -= right;
            this.a -= right;
        } else if (_instanceof1(right, Array)) {
            this.r -= right[0];
            this.g -= right[1];
            this.b -= right[2];
            this.a -= right[3];
        } else {
            this.r -= right.r;
            this.g -= right.g;
            this.b -= right.b;
            this.a -= right.a;
        }
        return this;
    };
    /**
     * 颜色相乘
     * @param right - 相乘对象，对象 | 数字
     * @returns 颜色
     */ _proto.multiply = function multiply(right) {
        if (typeof right === "number") {
            this.r *= right;
            this.g *= right;
            this.b *= right;
            this.a *= right;
        } else if (_instanceof1(right, Array)) {
            this.r *= right[0];
            this.g *= right[1];
            this.b *= right[2];
            this.a *= right[3];
        } else {
            this.r *= right.r;
            this.g *= right.g;
            this.b *= right.b;
            this.a *= right.a;
        }
        return this;
    };
    /**
     * 颜色相除
     * @param right - 相除对象，对象 | 数字
     * @returns 颜色
     */ _proto.divide = function divide(right) {
        if (typeof right === "number") {
            this.r /= right;
            this.g /= right;
            this.b /= right;
            this.a /= right;
        } else if (_instanceof1(right, Array)) {
            this.r /= right[0];
            this.g /= right[1];
            this.b /= right[2];
            this.a /= right[3];
        } else {
            this.r /= right.r;
            this.g /= right.g;
            this.b /= right.b;
            this.a /= right.a;
        }
        return this;
    };
    /**
     * 颜色缩放
     * @param v - 数字
     * @returns 缩放结果
     */ _proto.scale = function scale(v) {
        this.r *= v;
        this.g *= v;
        this.b *= v;
        this.a *= v;
        return this;
    };
    /**
     * 颜色求最小值
     * @param v - 颜色或数值
     * @returns 最小值
     */ _proto.min = function min(v) {
        if (typeof v === "number") {
            this.r = Math.min(this.r, v);
            this.g = Math.min(this.g, v);
            this.b = Math.min(this.b, v);
            this.a = Math.min(this.a, v);
        } else {
            this.r = Math.min(this.r, v.r);
            this.g = Math.min(this.g, v.g);
            this.b = Math.min(this.b, v.b);
            this.a = Math.min(this.a, v.a);
        }
        return this;
    };
    /**
     * 颜色求最大值
     * @param v - 颜色或数值
     * @returns 最大值
     */ _proto.max = function max(v) {
        if (typeof v === "number") {
            this.r = Math.max(this.r, v);
            this.g = Math.max(this.g, v);
            this.b = Math.max(this.b, v);
            this.a = Math.max(this.a, v);
        } else {
            this.r = Math.max(this.r, v.r);
            this.g = Math.max(this.g, v.g);
            this.b = Math.max(this.b, v.b);
            this.a = Math.max(this.a, v.a);
        }
        return this;
    };
    /**
     * 颜色阈值约束
     * @param min - 最小值
     * @param max - 最大值
     * @returns 颜色
     */ _proto.clamp = function clamp(min, max) {
        return this.max(min).min(max);
    };
    /**
     * 颜色求线性插值
     * @param v - 颜色
     * @param alpha - 插值比例
     * @returns 插值结果
     */ _proto.lerp = function lerp(v, alpha) {
        this.r += (v.r - this.r) * alpha;
        this.g += (v.g - this.g) * alpha;
        this.b += (v.b - this.b) * alpha;
        this.a += (v.a - this.a) * alpha;
        return this;
    };
    /**
     * 计算颜色亮度值
     * @returns 亮度值
     */ _proto.luminance = function luminance() {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
    };
    /**
     * 颜色判等
     * @param v - 颜色
     * @returns 判等结果
     */ _proto.equals = function equals(v) {
        return v.r === this.r && v.g === this.g && v.b === this.b && v.a === this.a;
    };
    _proto.toLinear = function toLinear() {
        this.r = Color.gammaToLinear(this.r);
        this.g = Color.gammaToLinear(this.g);
        this.b = Color.gammaToLinear(this.b);
        return this;
    };
    _proto.toGamma = function toGamma() {
        this.r = Color.linearToGamma(this.r);
        this.g = Color.linearToGamma(this.g);
        this.b = Color.linearToGamma(this.b);
        return this;
    };
    /**
     * 颜色转数组
     * @returns 数组
     */ _proto.toArray = function toArray() {
        return [
            this.r,
            this.g,
            this.b,
            this.a
        ];
    };
    _proto.toVector4 = function toVector4() {
        return new Vector4$1(this.r, this.g, this.b, this.a);
    };
    /**
     * RGB 颜色空间转 HSV
     * @param result HSV 值
     */ _proto.toHSV = function toHSV() {
        var _this = this, r = _this.r, g = _this.g, b = _this.b, a = _this.a;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var v = max;
        var dm = max - min;
        var h = 0;
        var s = 0;
        if (max !== 0) {
            s = dm / max;
        }
        if (max != min) {
            if (max == r) {
                h = (g - b) / dm;
                if (g < b) {
                    h += 6;
                }
            } else if (max == g) {
                h = (b - r) / dm + 2;
            } else if (max == b) {
                h = (r - g) / dm + 4;
            }
            h *= 60;
        }
        return new Color(h, s, v, a);
    };
    _proto.toHexString = function toHexString(includeAlpha) {
        if (includeAlpha === void 0) includeAlpha = true;
        var R = Color.ToHex(Math.round(this.r * 255));
        var G = Color.ToHex(Math.round(this.g * 255));
        var B = Color.ToHex(Math.round(this.b * 255));
        var A = Color.ToHex(Math.round(this.a * 255));
        if (includeAlpha) {
            return "#" + R + G + B + A;
        } else {
            return "#" + R + G + B;
        }
    };
    _proto.fill = function fill(array, offset) {
        if (offset === void 0) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        array[offset + 3] = this.a;
    };
    /**
     * 通过标量数值创建颜色
     * @param num - 数值
     * @returns
     */ Color.fromNumber = function fromNumber(num) {
        return new Color().setFromNumber(num);
    };
    /**
     * 通过数组创建颜色
     * @param array - 数组
     * @param [offset=0] - 起始偏移值
     * @returns
     */ Color.fromArray = function fromArray(array, offset) {
        if (offset === void 0) offset = 0;
        return new Color().setFromArray(array, offset);
    };
    /**
     * 通过 hex 字符串创建颜色
     * @param hex - hex 字符串
     * @returns
     */ Color.fromHexString = function fromHexString(hex) {
        return new Color().setFromHexString(hex);
    };
    Color.fromHSV = function fromHSV(hue, saturation, value, alpha) {
        if (alpha === void 0) alpha = 1;
        return new Color().setFromHSV(hue, saturation, value, alpha);
    };
    /**
     * 颜色值从 Gamma 空间转到线性空间
     * @param v - Gamma 空间颜色值
     * @returns 线性空间颜色值
     */ Color.gammaToLinear = function gammaToLinear(v) {
        if (v <= 0.0) {
            return 0.0;
        } else if (v <= 0.04045) {
            return v / 12.92;
        } else if (v < 1.0) {
            return Math.pow((v + 0.055) / 1.055, 2.4);
        } else {
            return Math.pow(v, 2.4);
        }
    };
    /**
     * 颜色值从线性空间转到 Gamma 空间
     * @param value - 线性空间颜色值
     * @returns Gamma 空间颜色值
     */ Color.linearToGamma = function linearToGamma(value) {
        if (value <= 0.0) {
            return 0.0;
        } else if (value < 0.0031308) {
            return 12.92 * value;
        } else if (value < 1.0) {
            return 1.055 * Math.pow(value, 0.41666) - 0.055;
        } else {
            return Math.pow(value, 0.41666);
        }
    };
    Color.ToHex = function ToHex(i) {
        var str = i.toString(16);
        if (i <= 15) {
            return ("0" + str).toUpperCase();
        }
        return str.toUpperCase();
    };
    return Color;
}();
/**
     * 颜色的常量
     */ Color.BLACK = new Color(0, 0, 0, 1) // 纯黑色
;
Color.BLUE = new Color(0, 0, 1, 1) // 纯蓝色
;
Color.CLEAR = new Color(0, 0, 0, 0) // 完全透明
;
Color.CYAN = new Color(0, 1, 1, 1) // 青色
;
Color.GRAY = new Color(0.5, 0.5, 0.5, 1) // 灰色
;
Color.GREEN = new Color(0, 1, 0, 1) // 纯绿色
;
Color.MAGENTA = new Color(1, 0, 1, 1) // 洋红色
;
Color.RED = new Color(1, 0, 0, 1) // 纯红色
;
Color.WHITE = new Color(1, 1, 1, 1) // 纯白色
;
Color.YELLOW = new Color(1, 0.92, 0.016, 1) // 黄色
;

/**
 * 三维包围盒
 */ var Box3 = /*#__PURE__*/ function() {
    function Box3(min, max) {
        if (min === void 0) min = new Vector3(Infinity, Infinity, Infinity);
        if (max === void 0) max = new Vector3(-Infinity, -Infinity, -Infinity);
        this.min = min.clone();
        this.max = max.clone();
    }
    var _proto = Box3.prototype;
    /**
     * 设置三维包围盒的值
     * @param min - 三维包围盒最小点
     * @param max - 三维包围盒最大点
     * @returns
     */ _proto.set = function set(min, max) {
        this.min.copyFrom(min);
        this.max.copyFrom(max);
        return this;
    };
    /**
     * 通过数组构建三维包围盒
     * @param array - 数组集合（每三个数视为一个三维空间点）
     * @returns 三维包围盒
     */ _proto.setFromArray = function setFromArray(array) {
        var minX = Number(Infinity);
        var minY = Number(Infinity);
        var minZ = Number(Infinity);
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for(var i = 0, l = array.length; i < l; i += 3){
            var x = array[i];
            var y = array[i + 1];
            var z = array[i + 2];
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (z < minZ) {
                minZ = z;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
            if (z > maxZ) {
                maxZ = z;
            }
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    };
    /**
     * 通过三维空间点构建三维包围盒
     * @param points - 三维空间点集合
     * @returns 三维包围盒
     */ _proto.setFromPoints = function setFromPoints(points) {
        this.makeEmpty();
        for(var i = 0, il = points.length; i < il; i++){
            this.expandByPoint(points[i]);
        }
        return this;
    };
    /**
     * 通过三维空间点（包围盒中心）和大小确定包围盒
     * @param center - 三维包围盒中心点
     * @param size - 三维包围盒大小值
     * @returns 三维包围盒
     */ _proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
        var halfSize = size.clone().multiply(0.5);
        this.min.copyFrom(center).subtract(halfSize);
        this.max.copyFrom(center).add(halfSize);
        return this;
    };
    // TODO
    /**
     * 通过实体构建包围盒
     * @param object - 构件实体
     * @returns 三维包围盒
     */ _proto.setFromObject = function setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    };
    /**
     * 克隆三维包围盒
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Box3().copyFrom(this);
    };
    /**
     * 复制三维包围盒
     * @param box - 复制对象
     * @returns 复制结果
     */ _proto.copyFrom = function copyFrom(box) {
        this.min.copyFrom(box.min);
        this.max.copyFrom(box.max);
        return this;
    };
    /**
     * 三维包围盒置空
     * @returns 置空结果
     */ _proto.makeEmpty = function makeEmpty() {
        this.min.x = this.min.y = this.min.z = Number(Infinity);
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    };
    /**
     * 三维包围盒判空
     * @returns 判空结果
     */ _proto.isEmpty = function isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    };
    /**
     * 获取三维包围盒中心
     * @param [target=new Vector3()]
     * @returns
     */ _proto.getCenter = function getCenter(target) {
        if (target === void 0) target = new Vector3();
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiply(0.5);
    };
    /**
     * 获取三维包围盒大小
     * @param [target=new Vector3()] - 结果保存对象
     * @returns 三维包围盒大小
     */ _proto.getSize = function getSize(target) {
        if (target === void 0) target = new Vector3();
        return this.isEmpty() ? target.set(0, 0, 0) : target.subtractVectors(this.max, this.min);
    };
    /**
     * 通过三维空间点扩展三维包围盒
     * @param point - 三维空间点
     * @returns 扩展结果
     */ _proto.expandByPoint = function expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    };
    /**
     * 通过三维向量扩展三维包围盒
     * @param vector - 三维向量
     * @returns 扩展结果
     */ _proto.expandByVector = function expandByVector(vector) {
        this.min.subtract(vector);
        this.max.add(vector);
        return this;
    };
    /**
     * 通过实数扩展三维包围盒
     * @param scalar - 扩展大小
     * @returns 扩展结果
     */ _proto.expandByScalar = function expandByScalar(scalar) {
        this.min.add(-scalar);
        this.max.add(scalar);
        return this;
    };
    /**
     * 通过包围盒扩展三维包围盒
     * @param box
     * @returns
     */ _proto.expandByBox = function expandByBox(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    // TODO
    /**
     * 通过实体扩展三维包围盒
     * @param object - 构件实体
     * @returns 扩展结果
     */ _proto.expandByObject = function expandByObject(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        var geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
            }
            var box3 = new Box3();
            box3.copyFrom(geometry.boundingBox);
            box3.applyMatrix4(object.matrixWorld);
            this.union(box3);
        }
        var children = object.children;
        for(var i = 0, l = children.length; i < l; i++){
            this.expandByObject(children[i]);
        }
        return this;
    };
    /**
     * 判断三维包围盒相交关系(if this intersect other)
     * @param point - 三维空间点
     * @returns 点包含判断结果
     */ _proto.containsPoint = function containsPoint(point) {
        return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z);
    };
    /**
     * 判断三维包围盒与三维包围盒的包含关系
     * @param other - 三维包围盒
     * @returns 包围盒包含结果（true 表示包含 other, false 表示不包含 other）
     */ _proto.containsBox = function containsBox(other) {
        return this.min.x <= other.min.x && this.max.x >= other.max.x && this.min.y <= other.min.y && this.max.y >= other.max.y && this.min.z <= other.min.z && this.max.z >= other.max.z;
    };
    // TODO
    /**
     * 获取点在三维包围盒的比例位置
     * @param point - 三维空间点
     * @param [target=new Vector3()] - 结果保存对象
     * @returns 点在包围盒比例位置
     */ _proto.getParameter = function getParameter(point, target) {
        if (target === void 0) target = new Vector3();
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    };
    /**
     * 判断三维包围盒相交关系(if this intersect other)
     * @param other - 三维包围盒
     * @returns 相交判断结果
     */ _proto.intersectsBox = function intersectsBox(other) {
        // using 6 splitting planes to rule out intersections.
        return !(other.max.x < this.min.x || other.min.x > this.max.x || other.max.y < this.min.y || other.min.y > this.max.y || other.max.z < this.min.z || other.min.z > this.max.z);
    };
    /**
     * 判断三维包围盒和球是否相交
     * @param sphere
     * @returns
     */ _proto.intersectsSphere = function intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        var vector = new Vector3();
        this.clampPoint(sphere.center, vector);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return vector.distanceSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
    /**
     * 求点与三维包围盒的最近点
     * @param point - 三维空间点
     * @param [target=new Vector3()] - 结果存放对象
     * @returns 计算结果
     */ _proto.clampPoint = function clampPoint(point, target) {
        if (target === void 0) target = new Vector3();
        return target.copyFrom(point).clamp(this.min, this.max);
    };
    /**
     * 三维空间点到三维包围盒的距离
     * @param point - 三维包围盒
     * @returns 距离结果
     */ _proto.distanceToPoint = function distanceToPoint(point) {
        var clampedPoint = point.clone().clamp(this.min, this.max);
        return clampedPoint.subtract(point).length();
    };
    /**
     * 三维包围盒求交集
     * @param box - 三维包围盒
     * @returns 求交结果
     */ _proto.intersect = function intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) {
            this.makeEmpty();
        }
        return this;
    };
    /**
     * 三维包围盒求并集
     * @param box - 三维包围盒
     * @returns 求并结果
     */ _proto.union = function union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    };
    /**
     * 通过三维变换矩阵变化三维包围盒
     * @param matrix - 三维变换矩阵
     * @returns 变换结果
     */ _proto.applyMatrix4 = function applyMatrix4(matrix, center) {
        if (center === void 0) center = new Vector3();
        // transform of empty box is an empty box.
        if (this.isEmpty()) {
            return this;
        }
        var points = this.getOBBPoints(matrix, center);
        this.setFromPoints(points);
        return this;
    };
    _proto.getOBBPoints = function getOBBPoints(matrix, center) {
        if (center === void 0) center = new Vector3();
        // transform of empty box is an empty box.
        if (this.isEmpty()) {
            return [];
        }
        var points = [];
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        points[0] = new Vector3(this.min.x, this.min.y, this.min.z); // 000
        points[1] = new Vector3(this.min.x, this.min.y, this.max.z); // 001
        points[2] = new Vector3(this.min.x, this.max.y, this.min.z); // 010
        points[3] = new Vector3(this.min.x, this.max.y, this.max.z); // 011
        points[4] = new Vector3(this.max.x, this.min.y, this.min.z); // 100
        points[5] = new Vector3(this.max.x, this.min.y, this.max.z); // 101
        points[6] = new Vector3(this.max.x, this.max.y, this.min.z); // 110
        points[7] = new Vector3(this.max.x, this.max.y, this.max.z); // 111
        points.forEach(function(p) {
            p.subtract(center);
            p.applyMatrix(matrix);
            p.add(center);
        });
        return points;
    };
    /**
     * 通过包围盒获取包围球
     * @param target
     * @returns
     */ _proto.getBoundingSphere = function getBoundingSphere(target) {
        this.getCenter(target.center);
        var vector = new Vector3();
        target.radius = this.getSize(vector).length() * 0.5;
        return target;
    };
    /**
     * 三维包围盒位移
     * @param offset - 三维位移向量
     * @returns 位移结果
     */ _proto.translate = function translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    };
    /**
     * 三维包围盒判等
     * @param other - 三维包围盒
     * @returns 判等结果
     */ _proto.equals = function equals(other) {
        return other.min.equals(this.min) && other.max.equals(this.max);
    };
    return Box3;
}();

/**
 * 球
 */ var Sphere$1 = /*#__PURE__*/ function() {
    function Sphere(center, radius) {
        if (center === void 0) center = Vector3.ZERO;
        if (radius === void 0) radius = -1;
        this.center = center.clone();
        this.radius = radius;
    }
    var _proto = Sphere.prototype;
    /**
     * 通过参数设置球
     * @param center - 球心
     * @param radius - 半径
     * @returns
     */ _proto.set = function set(center, radius) {
        this.center.copyFrom(center);
        this.radius = radius;
        return this;
    };
    /**
     * 通过空间点与球心设置球
     * @param points - 三维空间点
     * @param [optionalCenter] - 指定球心
     * @returns
     */ _proto.setFromPoints = function setFromPoints(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== undefined) {
            center.copyFrom(optionalCenter);
            var maxRadiusSq = 0;
            for(var i = 0; i < points.length; i++){
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
        } else {
            var box = new Box3().setFromPoints(points);
            box.getCenter(center);
            this.radius = box.getSize().length() / 2;
        }
        return this;
    };
    /**
     * 复制球
     * @param sphere - 球信息
     * @returns 复制结果
     */ _proto.copyFrom = function copyFrom(sphere) {
        this.center.copyFrom(sphere.center);
        this.radius = sphere.radius;
        return this;
    };
    /**
     * 球判空
     * @returns 判空结果
     */ _proto.isEmpty = function isEmpty() {
        return this.radius < 0;
    };
    /**
     * 球置空
     * @returns 置空结果
     */ _proto.makeEmpty = function makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    };
    /**
     * 三维空间点包围判断
     * @param point - 三维空间点
     * @returns 空间点包含判断
     */ _proto.containsPoint = function containsPoint(point) {
        return point.distanceSquared(this.center) <= this.radius * this.radius;
    };
    /**
     * 空间点与球表面的最短距离
     * @param point - 三维空间点
     * @returns 距离结果
     */ _proto.distanceToPoint = function distanceToPoint(point) {
        return point.distance(this.center) - this.radius;
    };
    /**
     * 与球相交判断
     * @param sphere - 球
     * @returns 相交判断结果
     */ _proto.intersectsSphere = function intersectsSphere(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceSquared(this.center) <= radiusSum * radiusSum;
    };
    /**
     * 与包围盒相交判断
     * @param box - 三维包围盒
     * @returns 相交判断结果
     */ _proto.intersectsBox = function intersectsBox(box) {
        return box.intersectsSphere(this);
    };
    /**
     * 收敛空间点在球范围内
     * 注：乘法的效率要比开方高很多
     * @param point - 三维空间点
     * @param [target] - 结果保存对象
     * @returns 收敛结果
     */ _proto.clampPoint = function clampPoint(point, target) {
        var deltaLengthSq = this.center.distanceSquared(point);
        if (target === undefined) {
            target = new Vector3();
        }
        target.copyFrom(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.subtract(this.center).normalize();
            target.multiply(this.radius).add(this.center);
        }
        return target;
    };
    /**
     * 根据包围盒获取球
     * @param target - 包围盒
     * @returns 球
     */ _proto.getBoundingBox = function getBoundingBox(target) {
        if (target === undefined) {
            target = new Box3();
        }
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    };
    /**
     * 球空间变换
     * @param matrix - 空间变化矩阵
     * @returns 变换结果
     */ _proto.applyMatrix4 = function applyMatrix4(matrix) {
        var mt = matrix.elements;
        var scaleXSq = mt[0] * mt[0] + mt[1] * mt[1] + mt[2] * mt[2];
        var scaleYSq = mt[4] * mt[4] + mt[5] * mt[5] + mt[6] * mt[6];
        var scaleZSq = mt[8] * mt[8] + mt[9] * mt[9] + mt[10] * mt[10];
        var maxScale = Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        this.center.applyMatrix(matrix);
        this.radius = this.radius * maxScale;
        return this;
    };
    /**
     * 球位移
     * @param offset - 位移信息
     * @returns 位移结果
     */ _proto.translate = function translate(offset) {
        this.center.add(offset);
        return this;
    };
    /**
     * 通过三维空间点对球进行扩展
     * @param point - 扩展点
     * @returns 扩展结果
     */ _proto.expandByPoint = function expandByPoint(point) {
        var vector = new Vector3().subtractVectors(point, this.center);
        var lengthSquared = vector.lengthSquared();
        if (lengthSquared > this.radius * this.radius) {
            var length = Math.sqrt(lengthSquared);
            var missingRadiusHalf = (length - this.radius) * 0.5;
            // Nudge this sphere towards the target point. Add half the missing distance to radius,
            // and the other half to position. This gives a tighter enclosure, instead of if
            // the whole missing distance were just added to radius.
            this.center.add(vector.multiply(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
        }
        return this;
    };
    /**
     * 包围球求并集
     * @param sphere - 包围球
     * @returns 求并结果
     */ _proto.union = function union(sphere) {
        // To enclose another sphere into this sphere, we only need to enclose two points:
        // 1) Enclose the farthest point on the other sphere into this sphere.
        // 2) Enclose the opposite point of the farthest point into this sphere.
        var v1 = new Vector3();
        var toFarthestPoint = new Vector3();
        toFarthestPoint.subtractVectors(sphere.center, this.center).normalize().multiply(sphere.radius);
        this.expandByPoint(v1.copyFrom(sphere.center).add(toFarthestPoint));
        this.expandByPoint(v1.copyFrom(sphere.center).subtract(toFarthestPoint));
        return this;
    };
    /**
     * 包围球求交集
     * @param other - 其它包围球
     * @returns 求交结果
     */ _proto.intersect = function intersect(other) {
        var vector = new Vector3().subtractVectors(this.center, other.center);
        var distance = vector.length();
        var radiusSum = this.radius + other.radius;
        if (distance > radiusSum) {
            return this.makeEmpty();
        }
        this.center = this.center.add(vector.normalize().multiply(distance / 2));
        this.radius = this.radius + other.radius - distance;
        return this;
    };
    /**
     * 包围球判等
     * @param sphere - 包围球
     * @returns 判等结果
     */ _proto.equals = function equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    };
    /**
     * 包围球克隆
     * @returns 克隆结果
     */ _proto.clone = function clone() {
        return new Sphere().copyFrom(this);
    };
    return Sphere;
}();

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get EulerOrder () { return EulerOrder; },
    Euler: Euler,
    Quaternion: Quaternion,
    Vector2: Vector2,
    Vector3: Vector3,
    Vector4: Vector4$1,
    Matrix3: Matrix3,
    Matrix4: Matrix4$1,
    Ray: Ray,
    PI2: PI2,
    DEG2RAD: DEG2RAD,
    RAD2DEG: RAD2DEG,
    NumberEpsilon: NumberEpsilon,
    isZero: isZero,
    isEqual: isEqual,
    damp: damp,
    lerp: lerp,
    degToRad: degToRad,
    radToDeg: radToDeg,
    clamp: clamp$1,
    Color: Color,
    Box3: Box3,
    Sphere: Sphere$1
});

var SPRITE_VERTEX_STRIDE = 6;
var SEMANTIC_PRE_COLOR_ATTACHMENT_0 = "PRE_COLOR_0";
var SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = "PRE_COLOR_SIZE_0";
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = "PRE_MAIN_COLOR_0";
var SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = "PRE_MAIN_COLOR_SIZE_0";
var PLAYER_OPTIONS_ENV_EDITOR = "editor";
var HELP_LINK$1 = {
    "Item duration can't be less than 0": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#AOnQS",
    "ValueType: 21/22 is not supported": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#smO1b"
};

/**
 * Helper class to create a WebGL Context
 *
 * @param canvas
 * @param glType
 * @param options
 * @returns
 */ function createGLContext(canvas, glType, options) {
    if (glType === void 0) glType = "webgl";
    var context;
    if (glType === "webgl2") {
        context = canvas.getContext("webgl2", options);
        if (!context) {
            console.debug("WebGL2 context retrieval failed, falling back to WebGL context.");
        }
    }
    if (!context || glType === "webgl") {
        context = canvas.getContext("webgl", options);
    }
    if (!context) {
        throw new Error("This browser does not support WebGL or the WebGL version is incorrect. Please check your WebGL version.");
    }
    return context;
}

function gpuTimer(gl) {
    var ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");
    if (ext) {
        var query = gl.createQuery();
        var getTime = /*#__PURE__*/ _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    new Promise(function(resolve, reject) {
                        if (query) {
                            var available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
                            var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
                            if (available && !disjoint) {
                                // See how much time the rendering of the object took in nanoseconds.
                                var timeElapsed = gl.getQueryParameter(query, gl.QUERY_RESULT); // Do something useful with the time.  Note that care should be
                                // taken to use all significant bits of the result, not just the
                                // least significant 32 bits.
                                resolve(timeElapsed / 1000 / 1000);
                            }
                            if (available || disjoint) {
                                // Clean up the query object.
                                gl.deleteQuery(query); // Don't re-enter this polling loop.
                                query = null;
                            }
                            available !== null && query && douyin.window.setTimeout(function() {
                                getTime().then(resolve).catch;
                            }, 1);
                        }
                    })
                ];
            });
        });
        if (!query) {
            return;
        }
        return {
            begin: function() {
                query && gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
            },
            end: function() {
                gl.endQuery(ext.TIME_ELAPSED_EXT);
            },
            getTime: getTime
        };
    }
}

var initErrors = [];
// @ts-expect-error
var glContext = {};
if (!initErrors.length) {
    initGLContext();
}
function initGLContext() {
    // 重要：iOS 9/10 低版本需要拷贝 gl context 的 prototype，要不然会有属性值的缺失
    if (typeof douyin.WebGL2RenderingContext === "function") {
        copy(douyin.WebGL2RenderingContext);
    } else if (typeof douyin.WebGLRenderingContext !== "undefined") {
        copy(douyin.WebGLRenderingContext);
        copy(douyin.WebGLRenderingContext.prototype);
    } else {
        initErrors.push(// iOS 16 lockdown mode
        "iOS16 lockdown mode, WebGL Constants not in global");
    }
    if (!initErrors.length && !("HALF_FLOAT" in glContext)) {
        // @ts-expect-error set default value
        glContext["HALF_FLOAT"] = 5131;
    }
}
function isWebGL2(gl) {
    return typeof douyin.WebGL2RenderingContext !== "undefined" && gl.constructor.name === "WebGL2RenderingContext";
}
function copy(target) {
    for(var name in target){
        if (/^[A-Z_]/.test(name)) {
            // @ts-expect-error safe to assign
            glContext[name] = target[name];
        }
    }
}
function vertexFormatType2GLType(formatType) {
    switch(formatType){
        case VertexFormatType.Float32:
            return douyin.WebGLRenderingContext["FLOAT"];
        case VertexFormatType.Int16:
            return douyin.WebGLRenderingContext["SHORT"];
        case VertexFormatType.Int8:
            return douyin.WebGLRenderingContext["BYTE"];
        case VertexFormatType.UInt16:
            return douyin.WebGLRenderingContext["UNSIGNED_SHORT"];
        case VertexFormatType.UInt8:
            return douyin.WebGLRenderingContext["UNSIGNED_BYTE"];
        default:
            return douyin.WebGLRenderingContext["FLOAT"];
    }
}
function glType2VertexFormatType(webglType) {
    switch(webglType){
        case douyin.WebGLRenderingContext["FLOAT"]:
            return VertexFormatType.Float32;
        case douyin.WebGLRenderingContext["SHORT"]:
            return VertexFormatType.Int16;
        case douyin.WebGLRenderingContext["BYTE"]:
            return VertexFormatType.Int8;
        case douyin.WebGLRenderingContext["UNSIGNED_SHORT"]:
            return VertexFormatType.UInt16;
        case douyin.WebGLRenderingContext["UNSIGNED_BYTE"]:
            return VertexFormatType.UInt8;
        default:
            return VertexFormatType.Float32;
    }
}

exports.ShaderType = void 0;
(function(ShaderType) {
    ShaderType[ShaderType["vertex"] = 0] = "vertex";
    ShaderType[ShaderType["fragment"] = 1] = "fragment";
})(exports.ShaderType || (exports.ShaderType = {}));

function valIfUndefined(val, def) {
    if (val === undefined || val === null) {
        return def;
    }
    return val;
}
function getPreMultiAlpha(blending) {
    switch(blending){
        case BlendingMode.ALPHA:
            return 1;
        case BlendingMode.ADD:
            return 1;
        case BlendingMode.SUBTRACTION:
            return 1;
        case BlendingMode.STRONG_LIGHT:
            return 1;
        case BlendingMode.WEAK_LIGHT:
            return 1;
        case BlendingMode.SUPERPOSITION:
            return 2;
        case BlendingMode.BRIGHTNESS:
            return 3;
        case BlendingMode.MULTIPLY:
            return 0;
        default:
            // 处理undefined
            return 1;
    }
}
function setBlendMode(material, blendMode) {
    switch(blendMode){
        case undefined:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA,
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA
            ];
            break;
        case BlendingMode.ALPHA:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA,
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA
            ];
            break;
        case BlendingMode.ADD:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE,
                glContext.ONE,
                glContext.ONE
            ];
            break;
        case BlendingMode.SUBTRACTION:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE,
                glContext.ZERO,
                glContext.ONE
            ];
            material.blendEquation = [
                glContext.FUNC_REVERSE_SUBTRACT,
                glContext.FUNC_REVERSE_SUBTRACT
            ];
            break;
        case BlendingMode.SUPERPOSITION:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE,
                glContext.ONE,
                glContext.ONE
            ];
            break;
        case BlendingMode.MULTIPLY:
            material.blendFunction = [
                glContext.DST_COLOR,
                glContext.ONE_MINUS_SRC_ALPHA,
                glContext.DST_COLOR,
                glContext.ONE_MINUS_SRC_ALPHA
            ];
            break;
        case BlendingMode.BRIGHTNESS:
            material.blendFunction = [
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA,
                glContext.ONE,
                glContext.ONE_MINUS_SRC_ALPHA
            ];
            break;
        case BlendingMode.STRONG_LIGHT:
            material.blendFunction = [
                glContext.DST_COLOR,
                glContext.DST_ALPHA,
                glContext.ZERO,
                glContext.ONE
            ];
            break;
        case BlendingMode.WEAK_LIGHT:
            material.blendFunction = [
                glContext.DST_COLOR,
                glContext.ZERO,
                glContext.ZERO,
                glContext.ONE
            ];
            break;
        default:
            console.warn("BlendMode " + blendMode + " not in specification, please set blend params separately.");
    }
}
function setSideMode(material, side) {
    if (side === SideMode.DOUBLE) {
        material.culling = false;
    } else {
        material.culling = true;
        material.frontFace = glContext.CW;
        material.cullFace = side === SideMode.BACK ? glContext.BACK : glContext.FRONT;
    }
}
function setMaskMode(material, maskMode) {
    switch(maskMode){
        case undefined:
            material.stencilTest = false;
            break;
        case MaskMode.MASK:
            material.stencilTest = true;
            material.stencilFunc = [
                glContext.ALWAYS,
                glContext.ALWAYS
            ];
            material.stencilOpZPass = [
                glContext.REPLACE,
                glContext.REPLACE
            ];
            break;
        case MaskMode.OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [
                glContext.EQUAL,
                glContext.EQUAL
            ];
            break;
        case MaskMode.REVERSE_OBSCURED:
            material.stencilTest = true;
            material.stencilFunc = [
                glContext.NOTEQUAL,
                glContext.NOTEQUAL
            ];
            break;
        case MaskMode.NONE:
            material.stencilTest = false;
            break;
        default:
            console.warn("MaskMode " + maskMode + " not in specification, please set stencil params seperately.");
    }
}

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

exports.TextureLoadAction = void 0;
(function(TextureLoadAction) {
    TextureLoadAction[TextureLoadAction["whatever"] = 0] = "whatever";
    //preserve previous attachment
    //load = 1,
    //clear attachment
    TextureLoadAction[TextureLoadAction["clear"] = 2] = "clear";
})(exports.TextureLoadAction || (exports.TextureLoadAction = {}));
exports.TextureSourceType = void 0;
(function(TextureSourceType) {
    TextureSourceType[TextureSourceType["none"] = 0] = "none";
    TextureSourceType[TextureSourceType["data"] = 1] = "data";
    TextureSourceType[TextureSourceType["image"] = 2] = "image";
    TextureSourceType[TextureSourceType["compressed"] = 3] = "compressed";
    TextureSourceType[TextureSourceType["video"] = 4] = "video";
    TextureSourceType[TextureSourceType["canvas"] = 5] = "canvas";
    TextureSourceType[TextureSourceType["framebuffer"] = 6] = "framebuffer";
    TextureSourceType[TextureSourceType["mipmaps"] = 7] = "mipmaps";
})(exports.TextureSourceType || (exports.TextureSourceType = {}));

/**
 * 负责下载各种资源，并提供了一些异步加载和缓存管理的功能
 */ var Downloader = /*#__PURE__*/ function() {
    function Downloader() {
        /**
   * 存储多个回调函数的对象
   */ this.callbacks = {};
    }
    var _proto = Downloader.prototype;
    /**
   * 下载一个 JSON 文件
   * @param url - 要下载的 JSON 文件的 URL
   * @param onSuccess - 下载成功后的回调函数
   * @param onError - 下载失败后的回调函数
   */ _proto.downloadJSON = function downloadJSON(url, onSuccess, onError) {
        this.download(url, "json", onSuccess, onError);
    };
    /**
   * 下载一个二进制文件
   * @param url - 要下载的二进制文件的 URL
   * @param onSuccess - 下载成功后的回调函数
   * @param onError - 下载失败后的回调函数
   */ _proto.downloadBinary = function downloadBinary(url, onSuccess, onError) {
        this.download(url, "arraybuffer", onSuccess, onError);
    };
    /**
   * 下载一个 Blob 文件
   * @param url - 要下载的 Blob 文件的 URL
   * @param onSuccess - 下载成功后的回调函数
   * @param onError - 下载失败后的回调函数
   */ _proto.downloadBlob = function downloadBlob(url, onSuccess, onError) {
        this.download(url, "blob", onSuccess, onError);
    };
    _proto.download = function download(url, responseType, onSuccess, onError) {
        var _this = this;
        if (responseType === void 0) responseType = "json";
        if (this.start(url, onSuccess, onError)) {
            return;
        }
        var xhr = new douyin.XMLHttpRequest();
        var handleError = function() {
            _this.finish(url, xhr.status, xhr.response);
        };
        var handleLoad = function() {
            if (xhr.status == 200 || xhr.status == 0) {
                _this.finish(url, 200, xhr.response);
            } else {
                handleError();
            }
        };
        xhr.responseType = responseType;
        xhr.addEventListener("load", handleLoad);
        xhr.addEventListener("error", handleError);
        xhr.open("GET", url, true);
        xhr.send();
    };
    _proto.start = function start(url, onSuccess, onError) {
        var callbacks = this.callbacks[url];
        try {
            if (callbacks) {
                return true;
            }
            this.callbacks[url] = callbacks = [];
        } finally{
            callbacks.push(onSuccess, onError);
        }
    };
    _proto.finish = function finish(url, status, data) {
        var callbacks = this.callbacks[url];
        delete this.callbacks[url];
        var args = status == 200 || status == 0 ? [
            data
        ] : [
            status,
            data
        ];
        for(var i = args.length - 1, n = callbacks.length; i < n; i += 2){
            callbacks[i].apply(null, args);
        }
    };
    return Downloader;
}();
var webPFailed = false;
var avifFailed = false;
/**
 * 异步加载一个 WebP 图片文件，如果不支持 WebP，则加载 PNG 图片文件
 * @param png - PNG 图片文件的 URL
 * @param webp - WebP 图片文件的 URL
 */ function loadWebPOptional(png, webp) {
    return _loadWebPOptional.apply(this, arguments);
}
function _loadWebPOptional() {
    _loadWebPOptional = _async_to_generator(function(png, webp) {
        var image, image1, image2;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!(webPFailed || !webp)) return [
                        3,
                        2
                    ];
                    return [
                        4,
                        loadImage(png)
                    ];
                case 1:
                    image = _state.sent();
                    return [
                        2,
                        {
                            image: image,
                            url: png
                        }
                    ];
                case 2:
                    _state.trys.push([
                        2,
                        4,
                        ,
                        6
                    ]);
                    return [
                        4,
                        loadImage(webp)
                    ];
                case 3:
                    image1 = _state.sent();
                    return [
                        2,
                        {
                            image: image1,
                            url: webp
                        }
                    ];
                case 4:
                    _state.sent();
                    webPFailed = true;
                    return [
                        4,
                        loadImage(png)
                    ];
                case 5:
                    image2 = _state.sent();
                    return [
                        2,
                        {
                            image: image2,
                            url: png
                        }
                    ];
                case 6:
                    return [
                        2
                    ];
            }
        });
    });
    return _loadWebPOptional.apply(this, arguments);
}
/**
 * 异步加载一个 AVIF 图片文件，如果不支持 AVIF，则加载 PNG 图片文件
 * @param png - PNG 图片文件的 URL
 * @param avif - AVIF 图片文件的 URL
 */ function loadAVIFOptional(png, avif) {
    return _loadAVIFOptional.apply(this, arguments);
}
function _loadAVIFOptional() {
    _loadAVIFOptional = _async_to_generator(function(png, avif) {
        var image, image1, image2;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!(avifFailed || !avif)) return [
                        3,
                        2
                    ];
                    return [
                        4,
                        loadImage(png)
                    ];
                case 1:
                    image = _state.sent();
                    return [
                        2,
                        {
                            image: image,
                            url: png
                        }
                    ];
                case 2:
                    _state.trys.push([
                        2,
                        4,
                        ,
                        6
                    ]);
                    return [
                        4,
                        loadImage(avif)
                    ];
                case 3:
                    image1 = _state.sent();
                    return [
                        2,
                        {
                            image: image1,
                            url: avif
                        }
                    ];
                case 4:
                    _state.sent();
                    avifFailed = true;
                    return [
                        4,
                        loadImage(png)
                    ];
                case 5:
                    image2 = _state.sent();
                    return [
                        2,
                        {
                            image: image2,
                            url: png
                        }
                    ];
                case 6:
                    return [
                        2
                    ];
            }
        });
    });
    return _loadAVIFOptional.apply(this, arguments);
}
/**
 * 异步加载一个图片文件
 * @param source - 图片文件的 URL、Blob 或 HTMLImageElement 对象
 */ function loadImage(source) {
    return _loadImage.apply(this, arguments);
}
function _loadImage() {
    _loadImage = _async_to_generator(function(source) {
        var url, revokeURL;
        return __generator(this, function(_state) {
            url = "";
            // 1. string | Blob | HTMLImageElement 处理逻辑
            if (_instanceof1(source, douyin.HTMLImageElement)) {
                if (source.complete) {
                    return [
                        2,
                        source
                    ];
                }
                url = source.src;
            } else if (_instanceof1(source, douyin.Blob)) {
                url = douyin.URL.createObjectURL(source);
                revokeURL = true;
            } else if (typeof source === "string") {
                url = source;
            }
            // 2. 非法类型
            if (!url) {
                throw new Error("Invalid url type: " + JSON.stringify(source) + ".");
            }
            return [
                2,
                new Promise(function(resolve, reject) {
                    var img = new douyin.Image();
                    if (!/^data:/.test(url)) {
                        img.crossOrigin = "*";
                    }
                    img.onload = function() {
                        img.onload = null;
                        if (revokeURL) {
                            douyin.URL.revokeObjectURL(url);
                        }
                        return resolve(img);
                    };
                    img.onerror = function(e) {
                        img.onerror = null;
                        if (revokeURL) {
                            douyin.URL.revokeObjectURL(url);
                        }
                        return reject("Load image fail: " + url + ", reason: " + JSON.stringify(e));
                    };
                    img.src = url;
                })
            ];
        });
    });
    return _loadImage.apply(this, arguments);
}
/**
 * 异步加载一个二进制文件
 * @param url - 二进制文件的 URL
 */ function loadBinary(url) {
    return _loadBinary.apply(this, arguments);
}
function _loadBinary() {
    _loadBinary = _async_to_generator(function(url) {
        return __generator(this, function(_state) {
            return [
                2,
                new Promise(function(resolve, reject) {
                    new Downloader().downloadBinary(url, resolve, function(status, responseText) {
                        reject("Couldn't load bins " + url + ": status " + status + ", " + responseText);
                    });
                })
            ];
        });
    });
    return _loadBinary.apply(this, arguments);
}
/**
 * 异步加载一个 Blob 文件
 * @param url - Blob 文件的 URL
 */ function loadBlob(url) {
    return _loadBlob.apply(this, arguments);
}
function _loadBlob() {
    _loadBlob = _async_to_generator(function(url) {
        return __generator(this, function(_state) {
            return [
                2,
                new Promise(function(resolve, reject) {
                    new Downloader().downloadBlob(url, resolve, function(status, responseText) {
                        reject("Couldn't load blob " + url + ": status " + status + ", " + responseText);
                    });
                })
            ];
        });
    });
    return _loadBlob.apply(this, arguments);
}
/**
 * 异步加载一个视频文件
 * @param url - 视频文件的 URL 或 MediaProvider 对象
 */ function loadVideo(url) {
    return _loadVideo.apply(this, arguments);
}
function _loadVideo() {
    _loadVideo = _async_to_generator(function(url) {
        var video;
        return __generator(this, function(_state) {
            video = douyin.document.createElement("video");
            if (typeof url === "string") {
                video.src = url;
            } else {
                video.srcObject = url;
            }
            video.crossOrigin = "anonymous";
            video.muted = true;
            if (isAndroid()) {
                video.setAttribute("renderer", "standard");
            }
            video.setAttribute("playsinline", "playsinline");
            return [
                2,
                new Promise(function(resolve, reject) {
                    var pending = video.play();
                    if (pending) {
                        void pending.then(function() {
                            return resolve(video);
                        });
                    } else {
                        video.addEventListener("loadeddata", function listener() {
                            resolve(video);
                            video.removeEventListener("loadeddata", listener);
                        }, true);
                    }
                    video.addEventListener("error", function(e) {
                        reject(e);
                    });
                })
            ];
        });
    });
    return _loadVideo.apply(this, arguments);
}
function loadMedia(url, loadFn) {
    return _loadMedia.apply(this, arguments);
}
function _loadMedia() {
    _loadMedia = _async_to_generator(function(url, loadFn) {
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!Array.isArray(url)) return [
                        3,
                        5
                    ];
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        5
                    ]);
                    return [
                        4,
                        loadFn(url[0])
                    ];
                case 2:
                    return [
                        2,
                        _state.sent()
                    ];
                case 3:
                    _state.sent();
                    return [
                        4,
                        loadFn(url[1])
                    ];
                case 4:
                    return [
                        2,
                        _state.sent()
                    ];
                case 5:
                    return [
                        2,
                        loadFn(url)
                    ];
            }
        });
    });
    return _loadMedia.apply(this, arguments);
}

function deserializeMipmapTexture(textureOptions, bins, engine) {
    return _deserializeMipmapTexture.apply(this, arguments);
}
function _deserializeMipmapTexture() {
    _deserializeMipmapTexture = _async_to_generator(function(textureOptions, bins, engine, files) {
        var mipmaps, target, jobs, loadedMipmaps, mipmaps1, target1, jobs1, loadedMipmaps1, bin;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (files === void 0) files = [];
                    if (!(textureOptions.target === 34067)) return [
                        3,
                        2
                    ];
                    mipmaps = textureOptions.mipmaps, target = textureOptions.target;
                    jobs = mipmaps.map(function(mipmap) {
                        return Promise.all(mipmap.map(function(pointer) {
                            // @ts-expect-error
                            if (pointer.id) {
                                // @ts-expect-error
                                var loadedImageAsset = engine.assetLoader.loadGUID(pointer.id);
                                // @ts-expect-error
                                return loadedImageAsset.data;
                            } else {
                                return loadMipmapImage(pointer, bins);
                            }
                        }));
                    });
                    return [
                        4,
                        Promise.all(jobs)
                    ];
                case 1:
                    loadedMipmaps = _state.sent();
                    return [
                        2,
                        _extends({
                            keepImageSource: false
                        }, textureOptions, {
                            mipmaps: loadedMipmaps,
                            sourceFrom: {
                                target: target,
                                // bin,
                                type: exports.TextureSourceType.mipmaps
                            }
                        })
                    ];
                case 2:
                    // TODO: 补充测试用例
                    mipmaps1 = textureOptions.mipmaps, target1 = textureOptions.target;
                    jobs1 = mipmaps1.map(function(pointer) {
                        return loadMipmapImage(pointer, bins);
                    });
                    return [
                        4,
                        Promise.all(jobs1)
                    ];
                case 3:
                    loadedMipmaps1 = _state.sent();
                    bin = files[mipmaps1[0][1][0]].url;
                    return [
                        2,
                        _extends({
                            keepImageSource: false
                        }, textureOptions, {
                            mipmaps: loadedMipmaps1,
                            sourceType: exports.TextureSourceType.mipmaps,
                            sourceFrom: {
                                target: target1,
                                bin: bin,
                                type: exports.TextureSourceType.mipmaps,
                                mipmaps: mipmaps1.map(function(pointer) {
                                    return [
                                        pointer[1][1],
                                        pointer[1][2]
                                    ];
                                })
                            }
                        })
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return _deserializeMipmapTexture.apply(this, arguments);
}
function loadMipmapImage(pointer, bins) {
    return _loadMipmapImage.apply(this, arguments);
}
function _loadMipmapImage() {
    _loadMipmapImage = _async_to_generator(function(pointer, bins) {
        var _pointer_, index, start, length, bin;
        return __generator(this, function(_state) {
            _pointer_ = pointer[1], index = _pointer_[0], start = _pointer_[1], length = _pointer_[2];
            bin = bins[index];
            if (!bin) {
                throw new Error("Invalid bin pointer: " + JSON.stringify(pointer) + ".");
            }
            return [
                2,
                loadImage(new douyin.Blob([
                    new Uint8Array(bin, start, length)
                ]))
            ];
        });
    });
    return _loadMipmapImage.apply(this, arguments);
}

var seed$c = 1;
/**
 * Texture 抽象类
 */ var Texture = /*#__PURE__*/ function(EffectsObject) {
    _inherits(Texture, EffectsObject);
    function Texture(engine) {
        var _this;
        _this = EffectsObject.call(this, engine) || this;
        _this.destroyed = false;
        _this.id = "Tex" + seed$c++;
        return _this;
    }
    var _proto = Texture.prototype;
    /**
   * 获取 Texture 的宽度。
   */ _proto.getWidth = function getWidth() {
        return this.width || 0;
    };
    /**
   * 获取 Texture 的高度。
   */ _proto.getHeight = function getHeight() {
        return this.height || 0;
    };
    _proto.uploadCurrentVideoFrame = function uploadCurrentVideoFrame() {
    // OVERRIDE
    };
    /**
   * 释放 Texture GPU 资源。
   * 注意：该方法只释放资源，并不销毁 GPU textureBuffer 对象。
   * @override
   */ _proto.offloadData = function offloadData() {
    // OVERRIDE
    };
    /**
   * 重新加载 Texture  GPU 资源。
   * @override
   */ _proto.reloadData = function reloadData() {
    // OVERRIDE
    };
    /**
   * 初始化 GPU 资源
   * @override
   */ _proto.initialize = function initialize() {
    // OVERRIDE
    };
    _proto.assembleOptions = function assembleOptions(options) {
        var _options_target = options.target, target = _options_target === void 0 ? glContext.TEXTURE_2D : _options_target, tmp = options.format, internalFormat = tmp === void 0 ? glContext.RGBA : tmp;
        if (!options.sourceType) {
            if ("image" in options) {
                options.sourceType = exports.TextureSourceType.image;
            } else if ("data" in options) {
                options.sourceType = exports.TextureSourceType.data;
            } else if ("video" in options) {
                options.sourceType = exports.TextureSourceType.video;
            } else {
                options.sourceType = 0; // TextureSourceType.none
            }
        }
        return _extends({
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
            target: target,
            format: glContext.RGBA,
            internalFormat: internalFormat,
            type: glContext.UNSIGNED_BYTE
        }, options);
    };
    /**
   * 通过 URL 创建 Texture 对象。
   * @param url - 要创建的 Texture URL
   * @since 2.0.0
   */ Texture.fromImage = function fromImage(url, engine) {
        return _async_to_generator(function() {
            var image, texture;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            loadImage(url)
                        ];
                    case 1:
                        image = _state.sent();
                        texture = Texture.create(engine, {
                            sourceType: exports.TextureSourceType.image,
                            image: image,
                            id: generateGUID(),
                            flipY: true
                        });
                        texture.initialize();
                        return [
                            2,
                            texture
                        ];
                }
            });
        })();
    };
    _create_class(Texture, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return Texture;
}(EffectsObject);
function generateHalfFloatTexture(engine, data, width, height) {
    var channel = data.length / width / height;
    var format;
    var internalFormat;
    if (channel === 4 || channel === 0) {
        internalFormat = format = glContext.RGBA;
    } else if (channel === 3) {
        internalFormat = format = glContext.RGB;
    } else if (channel === 2) {
        internalFormat = format = glContext.LUMINANCE_ALPHA;
    } else {
        internalFormat = format = glContext.LUMINANCE;
    }
    return Texture.createWithData(engine, {
        data: data,
        width: width,
        height: height
    }, {
        type: glContext.HALF_FLOAT,
        format: format,
        internalFormat: internalFormat,
        wrapS: glContext.CLAMP_TO_EDGE,
        wrapT: glContext.CLAMP_TO_EDGE
    });
}
var sourceOptions = {
    type: glContext.UNSIGNED_BYTE,
    format: glContext.RGBA,
    internalFormat: glContext.RGBA,
    wrapS: glContext.MIRRORED_REPEAT,
    wrapT: glContext.MIRRORED_REPEAT,
    minFilter: glContext.NEAREST,
    magFilter: glContext.NEAREST
};
function generateWhiteTexture(engine) {
    return Texture.create(engine, _extends({
        id: "whitetexture00000000000000000000",
        data: {
            width: 1,
            height: 1,
            data: new Uint8Array([
                255,
                255,
                255,
                255
            ])
        },
        sourceType: exports.TextureSourceType.data
    }, sourceOptions));
}
function generateTransparentTexture(engine) {
    return Texture.create(engine, _extends({
        id: "transparenttexture00000000000000000000",
        data: {
            width: 1,
            height: 1,
            data: new Uint8Array([
                0,
                0,
                0,
                0
            ])
        },
        sourceType: exports.TextureSourceType.data
    }, sourceOptions));
}

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()
var TEX_2D = 2; // uses a gl.texImage2D()
//const TEX_3D = 3; // uses a gl.texImage3D()
var KTXTexture = /*#__PURE__*/ function() {
    function KTXTexture(arrayBuffer, facesExpected, baseOffset) {
        if (baseOffset === void 0) baseOffset = 0;
        this.arrayBuffer = arrayBuffer;
        this.baseOffset = baseOffset;
        // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
        // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
        // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
        var identifier = new Uint8Array(this.arrayBuffer, this.baseOffset, 12);
        if (identifier[0] !== 0xab || identifier[1] !== 0x4b || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xbb || identifier[8] !== 0x0d || identifier[9] !== 0x0a || identifier[10] !== 0x1a || identifier[11] !== 0x0a) {
            throw new Error("Texture missing KTX identifier.");
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(this.arrayBuffer, this.baseOffset + 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
        // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
        this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);
        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
            logger.warn("Only 2D textures currently supported.");
            return;
        }
        if (this.numberOfArrayElements !== 0) {
            logger.warn("Texture arrays not currently supported.");
            return;
        }
        if (this.numberOfFaces !== facesExpected) {
            logger.warn("Number of faces expected " + facesExpected + ", but found " + this.numberOfFaces + ".");
            return;
        }
        // we now have a completely validated file, so could use existence of loadType as success
        // would need to make this more elaborate & adjust checks above to support more than one load type
        if (this.glType === 0) {
            this.loadType = COMPRESSED_2D;
        } else {
            this.loadType = TEX_2D;
        }
    }
    var _proto = KTXTexture.prototype;
    _proto.mipmaps = function mipmaps(loadMipmaps) {
        var mipmaps = [];
        // initialize width & height for level 1
        var dataOffset = HEADER_LEN + this.bytesOfKeyValueData;
        var width = this.pixelWidth;
        var height = this.pixelHeight;
        var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;
        for(var level = 0; level < mipmapCount; level++){
            var imageSize = new Int32Array(this.arrayBuffer, this.baseOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
            for(var face = 0; face < this.numberOfFaces; face++){
                var data = new Uint8Array(this.arrayBuffer, this.baseOffset + dataOffset + 4, imageSize);
                mipmaps.push({
                    data: data,
                    width: width,
                    height: height
                });
                dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field
                dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
            }
            width = Math.max(1.0, width * 0.5);
            height = Math.max(1.0, height * 0.5);
        }
        return mipmaps;
    };
    return KTXTexture;
}();
function getKTXTextureOptions(data) {
    var tex = new KTXTexture(data, 1);
    var numberOfMipmapLevels = tex.numberOfMipmapLevels, pixelWidth = tex.pixelWidth, pixelHeight = tex.pixelHeight, glType = tex.glType, numberOfFaces = tex.numberOfFaces, glInternalFormat = tex.glInternalFormat, glFormat = tex.glFormat;
    var useMipmaps = numberOfMipmapLevels >= Math.floor(Math.log2(Math.max(pixelWidth, pixelHeight)) + 1);
    return {
        sourceType: exports.TextureSourceType.compressed,
        type: glType,
        target: numberOfFaces === 6 ? glContext.TEXTURE_CUBE_MAP : glContext.TEXTURE_2D,
        internalFormat: glInternalFormat,
        format: glFormat,
        mipmaps: tex.mipmaps(useMipmaps)
    };
}

var TextureFactory = /*#__PURE__*/ function() {
    function TextureFactory() {
        this.reloadPending = {};
    }
    var _proto = TextureFactory.prototype;
    _proto.reload = function reload(texture) {
        var _this = this;
        return _async_to_generator(function() {
            var id, sourceOpts;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        id = texture.id;
                        if (_this.reloadPending[id]) {
                            return [
                                2
                            ];
                        }
                        if (!texture.sourceFrom) return [
                            3,
                            2
                        ];
                        _this.reloadPending[id] = true;
                        return [
                            4,
                            _this.loadSource(texture.sourceFrom)
                        ];
                    case 1:
                        sourceOpts = _state.sent();
                        texture.updateSource(sourceOpts);
                        _this.reloadPending[id] = false;
                        return [
                            3,
                            3
                        ];
                    case 2:
                        throw new Error("No source from.");
                    case 3:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto.canOffloadTexture = function canOffloadTexture(sourceFrom) {
        if (sourceFrom) {
            var type = sourceFrom.type;
            if (type === exports.TextureSourceType.compressed || type === exports.TextureSourceType.image) {
                var target = sourceFrom.target, map = sourceFrom.map;
                var url = sourceFrom.url;
                if (target === glContext.TEXTURE_CUBE_MAP) {
                    return typeof map === "object" && !!map;
                }
                return isString(url) && url.length > 0;
            }
            if (type === exports.TextureSourceType.mipmaps) {
                var bin = sourceFrom.bin, mipmaps = sourceFrom.mipmaps;
                var target1 = sourceFrom.target, maps = sourceFrom.maps;
                var urls = sourceFrom.urls;
                if (bin) {
                    return mipmaps.length > 0;
                }
                if (target1 === glContext.TEXTURE_CUBE_MAP) {
                    return maps.every(function(map) {
                        return typeof map === "object" && map;
                    });
                }
                return urls.every(function(url) {
                    return isString(url) && url.length > 0;
                });
            }
        }
        return false;
    };
    _proto.loadSource = function loadSource(sourceFrom, config) {
        var _this = this;
        return _async_to_generator(function() {
            var type, target, map, url, bin, mipmaps, urls, maps, cube, image, video, buffer, data, newTarget, newMipmaps, loadedMipmaps, loadedMipmaps1, loadedMipmaps2;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        type = sourceFrom.type, target = sourceFrom.target;
                        map = sourceFrom.map;
                        url = sourceFrom.url;
                        bin = sourceFrom.bin, mipmaps = sourceFrom.mipmaps;
                        urls = sourceFrom.urls;
                        maps = sourceFrom.maps;
                        if (!(target === glContext.TEXTURE_CUBE_MAP && type !== exports.TextureSourceType.mipmaps)) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            _this.loadCubeMap(map)
                        ];
                    case 1:
                        cube = _state.sent();
                        return [
                            2,
                            _extends({}, config, {
                                cube: cube,
                                target: glContext.TEXTURE_CUBE_MAP,
                                sourceType: exports.TextureSourceType.image,
                                sourceFrom: {
                                    type: exports.TextureSourceType.image,
                                    map: _extends({}, map),
                                    target: glContext.TEXTURE_CUBE_MAP
                                }
                            })
                        ];
                    case 2:
                        if (!(type === exports.TextureSourceType.image)) return [
                            3,
                            4
                        ];
                        return [
                            4,
                            loadImage(url)
                        ];
                    case 3:
                        image = _state.sent();
                        return [
                            2,
                            _extends({}, config, {
                                image: image,
                                sourceType: exports.TextureSourceType.image,
                                sourceFrom: {
                                    type: type,
                                    url: url,
                                    target: glContext.TEXTURE_2D
                                }
                            })
                        ];
                    case 4:
                        if (!(type === exports.TextureSourceType.video)) return [
                            3,
                            6
                        ];
                        return [
                            4,
                            loadVideo(url)
                        ];
                    case 5:
                        video = _state.sent();
                        return [
                            2,
                            _extends({}, config, {
                                video: video,
                                sourceType: exports.TextureSourceType.video
                            })
                        ];
                    case 6:
                        if (!(type === exports.TextureSourceType.compressed)) return [
                            3,
                            8
                        ];
                        return [
                            4,
                            loadBinary(url)
                        ];
                    case 7:
                        buffer = _state.sent();
                        return [
                            2,
                            _extends({}, getKTXTextureOptions(buffer), config, {
                                sourceFrom: {
                                    url: url,
                                    type: exports.TextureSourceType.compressed
                                }
                            })
                        ];
                    case 8:
                        if (!(type === exports.TextureSourceType.mipmaps)) return [
                            3,
                            17
                        ];
                        if (!bin) return [
                            3,
                            13
                        ];
                        return [
                            4,
                            loadBinary(bin)
                        ];
                    case 9:
                        data = _state.sent();
                        newTarget = target != null ? target : glContext.TEXTURE_2D;
                        newMipmaps = newTarget === glContext.TEXTURE_2D ? mipmaps.slice() : mipmaps.map(function(s) {
                            return s.slice();
                        });
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [
                            3,
                            11
                        ];
                        return [
                            4,
                            Promise.all(mipmaps.map(function(mipmap) {
                                return _this.loadMipmapImages(mipmap, data);
                            }))
                        ];
                    case 10:
                        loadedMipmaps = _state.sent();
                        return [
                            3,
                            12
                        ];
                    case 11:
                        loadedMipmaps = _this.loadMipmapImages(mipmaps, data);
                        _state.label = 12;
                    case 12:
                        return [
                            2,
                            _extends({}, config, {
                                mipmaps: loadedMipmaps,
                                target: newTarget,
                                sourceType: exports.TextureSourceType.mipmaps,
                                sourceFrom: {
                                    bin: bin,
                                    mipmaps: newMipmaps,
                                    target: newTarget,
                                    type: exports.TextureSourceType.mipmaps
                                }
                            })
                        ];
                    case 13:
                        if (!(target === glContext.TEXTURE_2D || !target)) return [
                            3,
                            15
                        ];
                        return [
                            4,
                            Promise.all(urls.map(function(url) {
                                return loadImage(url);
                            }))
                        ];
                    case 14:
                        loadedMipmaps1 = _state.sent();
                        return [
                            2,
                            _extends({}, config, {
                                mipmaps: loadedMipmaps1,
                                target: glContext.TEXTURE_2D,
                                sourceType: exports.TextureSourceType.mipmaps,
                                sourceFrom: {
                                    type: type,
                                    urls: urls.slice(),
                                    target: glContext.TEXTURE_2D
                                }
                            })
                        ];
                    case 15:
                        if (!(target === glContext.TEXTURE_CUBE_MAP)) return [
                            3,
                            17
                        ];
                        return [
                            4,
                            Promise.all(maps.map(function(map) {
                                return _this.loadCubeMap(map);
                            }))
                        ];
                    case 16:
                        loadedMipmaps2 = _state.sent();
                        return [
                            2,
                            _extends({}, config, {
                                mipmaps: loadedMipmaps2,
                                target: glContext.TEXTURE_CUBE_MAP,
                                sourceType: exports.TextureSourceType.mipmaps,
                                sourceFrom: {
                                    type: type,
                                    maps: maps.map(function(map) {
                                        return _extends({}, map);
                                    }),
                                    target: glContext.TEXTURE_CUBE_MAP
                                }
                            })
                        ];
                    case 17:
                        throw new Error("Invalid resource type: " + type + ".");
                }
            });
        })();
    };
    _proto.loadMipmapImages = function loadMipmapImages(pointers, bin) {
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    Promise.all(pointers.map(function(pointer) {
                        var blob = new douyin.Blob([
                            new Uint8Array(bin, pointer[0], pointer[1])
                        ]);
                        return loadImage(blob);
                    }))
                ];
            });
        })();
    };
    _proto.loadCubeMap = function loadCubeMap(cubemap) {
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    Promise.all(cubemap.map(function(key) {
                        return loadImage(key);
                    }))
                ];
            });
        })();
    };
    return TextureFactory;
}();
var g;
function getDefaultTextureFactory() {
    if (!g) {
        g = new TextureFactory();
    }
    return g;
}
function setDefaultTextureFactory(factory) {
    g = factory;
}

/**
 * 引擎接入暂时不需要实现
 */ var MaterialDataBlock = /*#__PURE__*/ function() {
    function MaterialDataBlock(props) {
        this.destroyed = false;
        var _props_name = props.name, name = _props_name === void 0 ? "defaultDataBlock" : _props_name;
        this.name = name;
    }
    var _proto = MaterialDataBlock.prototype;
    _proto.setUniformValues = function setUniformValues(uniformValue) {
        var _this = this;
        Object.keys(uniformValue).forEach(function(key) {
            _this.setUniformValue(key, uniformValue[key]);
        });
    };
    _proto.invalidAllFlags = function invalidAllFlags() {
    // OVERRIDE
    };
    _proto.updateUniformSubData = function updateUniformSubData(name, start, count) {
    // OVERRIDE
    };
    return MaterialDataBlock;
}();
function isUniformStruct(value) {
    return typeof value === "object" && value && value.length === undefined && _instanceof1(value, Texture);
}
function isUniformStructArray(value) {
    return value && value.length !== undefined && isUniformStruct(value[0]);
}

exports.MaterialRenderType = void 0;
(function(MaterialRenderType) {
    MaterialRenderType[MaterialRenderType["normal"] = 0] = "normal";
    MaterialRenderType[MaterialRenderType["transformFeedback"] = 1] = "transformFeedback";
})(exports.MaterialRenderType || (exports.MaterialRenderType = {}));
/**
 * 用于设置材质默认名称的自增序号
 * @internal
 */ var seed$b = 1;
/**
 * Material 抽象类
 */ var Material = /*#__PURE__*/ function(EffectsObject) {
    _inherits(Material, EffectsObject);
    function Material(engine, props) {
        var _this;
        _this = EffectsObject.call(this, engine) || this;
        _this.stringTags = {};
        _this.enabledMacros = {};
        _this.destroyed = false;
        _this.initialized = false;
        if (props) {
            var _props_name = props.name, name = _props_name === void 0 ? "Material" + seed$b++ : _props_name, _props_renderType = props.renderType, renderType = _props_renderType === void 0 ? 0 : _props_renderType, shader = props.shader, uniformSemantics = props.uniformSemantics;
            _this.name = name;
            _this.renderType = renderType; // TODO 没有地方用到
            _this.shaderSource = shader;
            _this.props = props;
            _this.uniformSemantics = _extends({}, uniformSemantics); // TODO 废弃，待移除
        } else {
            _this.name = "Material" + seed$b++;
            _this.renderType = 0;
        }
        return _this;
    }
    var _proto = Material.prototype;
    /**
   * 初始化 GPU 资源
   * @override
   */ _proto.initialize = function initialize() {
    // OVERRIDE
    };
    _proto.createShaderVariant = function createShaderVariant() {
    // OVERRIDE
    };
    _proto.use = function use(render, globalUniforms) {
    // OVERRIDE
    };
    _create_class(Material, [
        {
            key: "blending",
            set: /******** effects-core 中会调用 引擎必须实现 ***********************/ /**
   * 设置 Material 的颜色融合开关
   * @param blending - 是否开启混合效果
   */ function set(blending) {}
        },
        {
            key: "blendFunction",
            set: /**
   * 分别指定 Material 的颜色混合函数乘数
   * @param func - 混合函数参数
   */ function set(func) {}
        },
        {
            key: "blendEquation",
            set: /**
   * 分别指定 Material 的颜色混合方式
   * @param equation - 混合方程参数
   */ function set(equation) {}
        },
        {
            key: "depthTest",
            set: /**
   * 设置 Material 的深度测试开关
   * @param value - 是否开启深度测试
   */ function set(value) {}
        },
        {
            key: "depthMask",
            set: /**
   * 设置 Material 的写入深度缓冲开关
   * @param value - 是否开启深度写入
   */ function set(value) {}
        },
        {
            key: "stencilTest",
            set: /**
   * 设置 Material 的模板测试开关
   * @param value - 是否开启模板测试
   */ function set(value) {}
        },
        {
            key: "stencilRef",
            set: /**
   * 分别指定 Material 的模板测试参考值
   * @param value  - 模板测试参考值参数
   */ function set(value) {}
        },
        {
            key: "stencilFunc",
            set: /**
   * 分别指定 Material 的模板测试函数
   * @param value - 模板测试函数参数
   */ function set(value) {}
        },
        {
            key: "stencilOpZPass",
            set: /**
   * 分别指定 Material 的模板测试和深度测试都通过时使用的函数
   * @param value - 模板测试深度测试通过时的操作参数
   */ function set(value) {}
        },
        {
            key: "culling",
            set: /**
   * 设置 Material 的正反面剔除开关
   * @param value - 是否开启剔除
   */ function set(value) {}
        },
        {
            key: "frontFace",
            set: /**
   * 设置 Material 的正反面计算方向
   * @param value
   */ function set(value) {}
        },
        {
            key: "cullFace",
            set: /**
   * 设置 Material 要剔除的面
   * @param value - 剔除面参数
   */ function set(value) {}
        },
        {
            key: "blendColor",
            set: /***************************************************/ /******** effects-core 中暂无调用 引擎可以先不实现 ***********************/ /**
   * 设置 Material 的源和目标混合因子
   * @param color
   */ function set(color) {}
        },
        {
            key: "depthRange",
            set: /**
   * 设置 Material 的深度映射范围
   * @param value
   */ function set(value) {}
        },
        {
            key: "depthFunc",
            set: /**
   * 设置 Material 的深度比较函数
   * @param value - 深度测试函数参数
   */ function set(value) {}
        },
        {
            key: "polygonOffsetFill",
            set: /**
   * 设置 Material 的多边形偏移（实现类似深度偏移的效果）
   * @param value - 多边形偏移参数
   */ function set(value) {}
        },
        {
            key: "polygonOffset",
            set: /**
   * 指定 Material 计算深度值的比例因子 factor 和单位 units
   * @param value
   */ function set(value) {}
        },
        {
            key: "sampleAlphaToCoverage",
            set: /**
   * 设置 Material 的通过 alpha 值决定临时覆盖值计算的开关
   * @param value - 是否开启 alpha 抖动
   */ function set(value) {}
        },
        {
            key: "colorMask",
            set: /**
   * 设置 Material 颜色缓冲区的写入开关
   * @param value
   */ function set(value) {}
        },
        {
            key: "stencilMask",
            set: /**
   * 分别指定 Material 的模板测试掩码
   * @param value - 模板测试写入掩码参数
   */ function set(value) {}
        },
        {
            key: "stencilOpFail",
            set: /**
   * 分别指定 Material 模板测试失败时要使用的函数
   * @param value - 模板测试失败时的操作参数
   */ function set(value) {}
        },
        {
            key: "stencilOpZFail",
            set: /**
   * 分别指定 Material 模板测试通过但深度测试失败时要使用的函数
   * @param value - 模板测试深度测试失败时的操作参数
   */ function set(value) {}
        }
    ]);
    return Material;
}(EffectsObject);

var toHalf = function() {
    var floatView = new Float32Array(1);
    var int32View = new Int32Array(floatView.buffer);
    /* This method is faster than the OpenEXR implementation (very often
   * used, eg. in Ogre), with the additional benefit of rounding, inspired
   * by James Tursa?s half-precision code. */ return function toHalf(val) {
        floatView[0] = val;
        var x = int32View[0];
        var bits = x >> 16 & 0x8000; /* Get the sign */ 
        var m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */ 
        var e = x >> 23 & 0xff; /* Using int is faster here */ 
        /* If zero, or denormal, or exponent underflows too much for a denormal
     * half, return signed zero. */ if (e < 103) {
            return bits;
        }
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
            bits |= 0x7c00;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
       * not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
            m |= 0x0800;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
       * to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
        }
        bits |= e - 112 << 10 | m >> 1;
        /* Extra rounding. An overflow will set mantissa to 0 and increment
     * the exponent, which is OK. */ bits += m & 1;
        return bits;
    };
}();
var Float16ArrayWrapper = /*#__PURE__*/ function() {
    function Float16ArrayWrapper(num) {
        if (Number.isInteger(num)) {
            this.data = new Uint16Array(num);
        } else if (num && typeof num === "object" && Number.isInteger(num.length)) {
            var data = this.data = new Uint16Array(num.length);
            for(var i = 0; i < data.length; i++){
                data[i] = toHalf(num[i]);
            }
        }
    }
    var _proto = Float16ArrayWrapper.prototype;
    _proto.set = function set(number, startIndex) {
        for(var i = 0; i < number.length; i++){
            this.data[i + startIndex] = toHalf(number[i]);
        }
    };
    return Float16ArrayWrapper;
}();

function translatePoint(x, y) {
    var origin = [
        -.5,
        .5,
        -.5,
        -.5,
        .5,
        .5,
        .5,
        -.5
    ];
    for(var i = 0; i < 8; i += 2){
        origin[i] += x;
        origin[i + 1] += y;
    }
    return origin;
}
var tempEuler$1 = new Euler();
var tempMat4$3 = new Matrix4$1();
function calculateTranslation(out, target, acc, time, duration, posData, velData) {
    var ret = out;
    var lifetime = time / duration;
    var speedIntegrate = time;
    var speedOverLifetime = target.speedOverLifetime;
    if (speedOverLifetime) {
        speedIntegrate = speedOverLifetime.getIntegrateValue(0, time, duration);
    }
    var d = target.gravityModifier ? target.gravityModifier.getIntegrateByTime(0, time) : 0;
    ret.copyFrom(posData);
    ret.addScaledVector(velData, speedIntegrate);
    ret.addScaledVector(acc, d);
    var linearVelocityOverLifetime = target.linearVelOverLifetime || {};
    var orbVelOverLifetime = target.orbitalVelOverLifetime || {};
    var map = [
        "x",
        "y",
        "z"
    ];
    if (orbVelOverLifetime.enabled) {
        var center = new Vector3();
        if (orbVelOverLifetime.center) {
            center.setFromArray(orbVelOverLifetime.center);
        }
        var pos = ret.clone().subtract(center);
        var asRotation = orbVelOverLifetime.asRotation;
        var orbVel = map.map(function(pro) {
            var value = orbVelOverLifetime[pro];
            if (value) {
                return asRotation ? value.getValue(lifetime) : value.getIntegrateValue(0, time, duration);
            }
            return 0;
        });
        tempEuler$1.setFromArray(orbVel).negate();
        tempMat4$3.setFromEuler(tempEuler$1);
        var rot = tempMat4$3.transformPoint(pos);
        ret.addVectors(center, rot);
    }
    if (linearVelocityOverLifetime.enabled) {
        var asMovement = linearVelocityOverLifetime.asMovement;
        var velocityXCurve = linearVelocityOverLifetime.x;
        var velocityYCurve = linearVelocityOverLifetime.y;
        var velocityZCurve = linearVelocityOverLifetime.z;
        if (velocityXCurve) {
            var curveValue = asMovement ? velocityXCurve.getValue(lifetime) : velocityXCurve.getIntegrateValue(0, time, duration);
            ret.x = ret.x + curveValue;
        }
        if (velocityYCurve) {
            var curveValue1 = asMovement ? velocityYCurve.getValue(lifetime) : velocityYCurve.getIntegrateValue(0, time, duration);
            ret.y = ret.y + curveValue1;
        }
        if (velocityZCurve) {
            var curveValue2 = asMovement ? velocityZCurve.getValue(lifetime) : velocityZCurve.getIntegrateValue(0, time, duration);
            ret.z = ret.z + curveValue2;
        }
    }
    return ret;
}

function ensureVec3(num) {
    return Array.isArray(num) ? [
        num[0],
        num[1],
        num[2]
    ] : [
        0,
        0,
        0
    ];
}
function vecFill(out, number) {
    for(var i = 0, len = out.length; i < len; i++){
        out[i] = number;
    }
    return out;
}
function vecMulCombine(out, a, b) {
    if (a && b) {
        for(var i = 0, len = a.length; i < len; i++){
            out[i] = a[i] * b[i];
        }
    } else if (a) {
        if (out !== a) {
            for(var i1 = 0; i1 < a.length; i1++){
                out[i1] = a[i1];
            }
        }
    } else if (b) {
        if (out !== b) {
            for(var i2 = 0; i2 < b.length; i2++){
                out[i2] = b[i2];
            }
        }
    }
    return out;
}
var _obj$9;
var particleOriginTranslateMap$1 = (_obj$9 = {}, _obj$9[ParticleOrigin.PARTICLE_ORIGIN_CENTER] = [
    0,
    0
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_CENTER_BOTTOM] = [
    0,
    -0.5
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_CENTER_TOP] = [
    0,
    0.5
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_LEFT_TOP] = [
    -0.5,
    0.5
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_LEFT_CENTER] = [
    -0.5,
    0
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_LEFT_BOTTOM] = [
    -0.5,
    -0.5
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_CENTER] = [
    0.5,
    0
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_BOTTOM] = [
    0.5,
    -0.5
], _obj$9[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_TOP] = [
    0.5,
    0.5
], _obj$9);
function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
}
function setRayFromCamera(x, y, camera) {
    var origin = camera.position;
    var direction = new Vector3(x, y, 0);
    var dir = new Vector3();
    var mat = camera.getInverseViewProjectionMatrix();
    mat.projectPoint(direction, dir);
    dir.subtract(origin);
    return new Ray(origin, dir);
}
function trianglesFromRect(position, halfWidth, halfHeight) {
    var x = position.x, y = position.y, z = position.z;
    var p0 = new Vector3(x - halfWidth, y + halfHeight, z);
    var p1 = new Vector3(x - halfWidth, y - halfHeight, z);
    var p2 = new Vector3(x + halfWidth, y - halfHeight, z);
    var p3 = new Vector3(x + halfWidth, y + halfHeight, z);
    return [
        {
            p0: p0,
            p1: p1,
            p2: p2
        },
        {
            p0: p0.clone(),
            p1: p2.clone(),
            p2: p3
        }
    ];
}
function decimalEqual(a, b, epsilon) {
    if (epsilon === void 0) epsilon = 0.000001;
    return Math.abs(a - b) < epsilon;
}
function numberToFix(a, fixed) {
    if (fixed === void 0) fixed = 2;
    var base = Math.pow(10, fixed);
    return Math.floor(a * base) / base;
}

function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}

var keyframeInfo = {
    /**
   * 根据不同关键帧类型，获取位于曲线上的点
   */ getPointInCurve: function getPointInCurve(keyframe) {
        keyframe[0]; var data = keyframe[1];
        var _this_getPointIndexInCurve = this.getPointIndexInCurve(keyframe), xIndex = _this_getPointIndexInCurve.xIndex, yIndex = _this_getPointIndexInCurve.yIndex;
        var time = data[xIndex];
        var value = data[yIndex];
        return new Vector2(time, value);
    },
    /**
   * 根据不同关键帧类型，获取位于曲线上的点的索引
   */ getPointIndexInCurve: function getPointIndexInCurve(keyframe) {
        var type = keyframe[0], markType = keyframe[2];
        // 不同类型，存放的时间不同
        var index = type === BezierKeyframeType.LINE ? 0 : type === BezierKeyframeType.EASE_OUT ? 0 : type === BezierKeyframeType.EASE_IN ? 2 : type === BezierKeyframeType.EASE ? 2 : type === BezierKeyframeType.HOLD ? markType === BezierKeyframeType.EASE_IN ? 2 : 0 : 0;
        return {
            xIndex: index,
            yIndex: index + 1
        };
    },
    /**
   * 关键帧左侧是否为缓动类型（否则为线段）
   */ isLeftSideEase: function isLeftSideEase(keyframe) {
        var keyframeType = keyframe[0]; keyframe[1]; var markType = keyframe[2];
        // 定格关键帧的左侧类型，需要借助markType判断
        if (keyframeType === BezierKeyframeType.HOLD && this.isKeyframeTypeLeftSideEase(markType)) {
            return true;
        }
        return this.isKeyframeTypeLeftSideEase(keyframeType);
    },
    /**
   * 关键帧右侧是否为缓动类型（否则为线段）
   */ isRightSideEase: function isRightSideEase(keyframe) {
        var keyframeType = keyframe[0]; keyframe[1]; var markType = keyframe[2];
        // 定格关键帧的右侧类型，需要借助markType判断
        if (keyframeType === BezierKeyframeType.HOLD && this.isKeyframeTypeRightSideEase(markType)) {
            return true;
        }
        return this.isKeyframeTypeRightSideEase(keyframeType);
    },
    /**
   * 关键帧左侧是否为缓动类型（否则为线段）
   */ isKeyframeTypeLeftSideEase: function isKeyframeTypeLeftSideEase(keyframeType) {
        return [
            BezierKeyframeType.EASE,
            BezierKeyframeType.EASE_IN,
            BezierKeyframeType.AUTO
        ].includes(keyframeType);
    },
    /**
   * 关键帧右侧是否为缓动类型（否则为线段）
   */ isKeyframeTypeRightSideEase: function isKeyframeTypeRightSideEase(keyframeType) {
        return [
            BezierKeyframeType.EASE,
            BezierKeyframeType.EASE_OUT,
            BezierKeyframeType.AUTO
        ].includes(keyframeType);
    },
    /**
   * 是否为定格进关键帧
   */ isHoldInKeyframe: function isHoldInKeyframe(keyframe) {
        var keyframeType = keyframe[0]; keyframe[1]; var leftSubType = keyframe[2];
        return keyframeType === BezierKeyframeType.HOLD && [
            BezierKeyframeType.HOLD,
            BezierKeyframeType.LINE_OUT,
            BezierKeyframeType.EASE_OUT
        ].includes(leftSubType);
    },
    /**
   * 是否为定格出关键帧
   */ isHoldOutKeyframe: function isHoldOutKeyframe(keyframe) {
        var keyframeType = keyframe[0]; keyframe[1]; var leftSubType = keyframe[2];
        return keyframeType === BezierKeyframeType.HOLD && [
            BezierKeyframeType.HOLD,
            BezierKeyframeType.LINE,
            BezierKeyframeType.EASE_IN
        ].includes(leftSubType);
    }
};

var BezierLengthData = function BezierLengthData(points, totalLength) {
    this.points = points;
    this.totalLength = totalLength;
};
var BezierMap = {};
var BezierDataMap = {};
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var CURVE_SEGMENTS = 300;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
function A(a1, a2) {
    return 1.0 - 3.0 * a2 + 3.0 * a1;
}
function B(a1, a2) {
    return 3.0 * a2 - 6.0 * a1;
}
function C(a1) {
    return 3.0 * a1;
}
// A * t ^ 3 + B * t ^ 2 + C * t
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(t, a1, a2) {
    return ((A(a1, a2) * t + B(a1, a2)) * t + C(a1)) * t;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(t, a1, a2) {
    return 3.0 * A(a1, a2) * t * t + 2.0 * B(a1, a2) * t + C(a1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        } else {
            aA = currentT;
        }
    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for(var i = 0; i < NEWTON_ITERATIONS; ++i){
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
// de Casteljau算法构建曲线
/**
 * @param p1 起始点
 * @param p2 终点
 * @param p3 起始控制点
 * @param p4 终止控制点
 * @returns
 */ function buildBezierData(p1, p2, p3, p4) {
    // 使用平移后的终点、控制点作为key
    var s1 = numberToFix(p2.x - p1.x, 3) + "_" + numberToFix(p2.y - p1.y, 3) + "_" + numberToFix(p2.z - p1.z, 3);
    var s2 = numberToFix(p3.x - p1.x, 3) + "_" + numberToFix(p3.y - p1.y, 3) + "_" + numberToFix(p3.z - p1.z, 3);
    var s3 = numberToFix(p4.x - p1.x, 3) + "_" + numberToFix(p4.y - p1.y, 3) + "_" + numberToFix(p4.z - p1.z, 3);
    var str = s1 + "&" + s2 + "&" + s3;
    if (BezierDataMap[str]) {
        return {
            data: BezierDataMap[str],
            interval: p1
        };
    } else {
        var samples = [];
        var lastPoint = null, addedLength = 0, ptDistance = 0;
        var curveSegments = CURVE_SEGMENTS;
        for(var k = 0; k < curveSegments; k += 1){
            var point = new Vector3();
            var perc = k / (curveSegments - 1);
            ptDistance = 0;
            point.x = 3 * Math.pow(1 - perc, 2) * perc * (p3.x - p1.x) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.x - p1.x) + Math.pow(perc, 3) * (p2.x - p1.x);
            point.y = 3 * Math.pow(1 - perc, 2) * perc * (p3.y - p1.y) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.y - p1.y) + Math.pow(perc, 3) * (p2.y - p1.y);
            point.z = 3 * Math.pow(1 - perc, 2) * perc * (p3.z - p1.z) + 3 * (1 - perc) * Math.pow(perc, 2) * (p4.z - p1.z) + Math.pow(perc, 3) * (p2.z - p1.z);
            if (lastPoint !== null) {
                ptDistance += Math.pow(point.x - lastPoint.x, 2);
                ptDistance += Math.pow(point.y - lastPoint.y, 2);
                ptDistance += Math.pow(point.z - lastPoint.z, 2);
            }
            lastPoint = point;
            ptDistance = Math.sqrt(ptDistance);
            addedLength += ptDistance;
            samples[k] = {
                partialLength: ptDistance,
                point: point
            };
        }
        var data = new BezierLengthData(samples, addedLength);
        BezierDataMap[str] = data;
        return {
            data: data,
            interval: new Vector3(p1.x, p1.y, p1.z)
        };
    }
}
var BezierPath = /*#__PURE__*/ function() {
    function BezierPath(p1, p2, p3, p4) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
        this.p4 = p4;
        this.catching = {
            lastPoint: 0,
            lastAddedLength: 0
        };
        var _buildBezierData = buildBezierData(p1, p2, p3, p4), data = _buildBezierData.data, interval = _buildBezierData.interval;
        this.lengthData = data;
        this.interval = interval;
        this.totalLength = data.totalLength;
    }
    var _proto = BezierPath.prototype;
    /**
   * 获取路径在指定比例长度上点的坐标
   * @param percent 路径长度的比例
   */ _proto.getPointInPercent = function getPointInPercent(percent) {
        var bezierData = this.lengthData;
        if (percent === 0) {
            return bezierData.points[0].point.clone().add(this.interval);
        }
        if (decimalEqual(1 - percent, 0)) {
            return bezierData.points[CURVE_SEGMENTS - 1].point.clone().add(this.interval);
        }
        if (decimalEqual(bezierData.totalLength, 0)) {
            return this.p1.clone();
        }
        var point = new Vector3();
        var segmentLength = numberToFix(bezierData.totalLength * percent, 4);
        var addedLength = this.catching.lastAddedLength;
        var j = this.catching.lastPoint;
        if (decimalEqual(addedLength, segmentLength)) {
            return bezierData.points[j].point.clone().add(this.interval);
        }
        var flag = true;
        var dir = 1;
        if (segmentLength < addedLength) {
            dir = -1;
        }
        while(flag){
            if (segmentLength >= addedLength) {
                if (j === CURVE_SEGMENTS - 1) {
                    point.x = bezierData.points[j].point.x;
                    point.y = bezierData.points[j].point.y;
                    point.z = bezierData.points[j].point.z;
                    break;
                }
                if (segmentLength < addedLength + bezierData.points[j + 1].partialLength) {
                    var segmentPerc = (segmentLength - addedLength) / bezierData.points[j + 1].partialLength;
                    point.x = bezierData.points[j].point.x + (bezierData.points[j + 1].point.x - bezierData.points[j].point.x) * segmentPerc;
                    point.y = bezierData.points[j].point.y + (bezierData.points[j + 1].point.y - bezierData.points[j].point.y) * segmentPerc;
                    point.z = bezierData.points[j].point.z + (bezierData.points[j + 1].point.z - bezierData.points[j].point.z) * segmentPerc;
                    break;
                }
            }
            if (dir > 0 && j < CURVE_SEGMENTS - 1) {
                j += dir;
                addedLength += numberToFix(bezierData.points[j].partialLength, 5);
            } else if (dir < 0 && j > 0) {
                addedLength -= numberToFix(bezierData.points[j].partialLength, 5);
                j += dir;
            } else {
                flag = false;
            }
        }
        this.catching.lastPoint = j;
        this.catching.lastAddedLength = addedLength;
        point.add(this.interval);
        return point;
    };
    return BezierPath;
}();
var BezierQuat = /*#__PURE__*/ function() {
    function BezierQuat(p1, p2, p3, p4) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
        this.p4 = p4;
        this.temp = new Quaternion();
        this.totalLength = 0;
    }
    var _proto = BezierQuat.prototype;
    /**
   * 获取路径在指定比例长度上点的坐标
   * @param percent 路径长度的比例
   */ _proto.getPointInPercent = function getPointInPercent(percent) {
        if (percent === 0) {
            return this.temp.copyFrom(this.p1);
        }
        if (decimalEqual(1 - percent, 0)) {
            return this.temp.copyFrom(this.p2);
        }
        QuaternionInner.slerpFlat(this.temp, this.p1, this.p2, percent);
        return this.temp;
    };
    return BezierQuat;
}();
var BezierEasing = /*#__PURE__*/ function() {
    function BezierEasing(mX1, mY1, mX2, mY2) {
        this.mX1 = mX1;
        this.mY1 = mY1;
        this.mX2 = mX2;
        this.mY2 = mY2;
        this.precomputed = false;
        this.mSampleValues = new Array(kSplineTableSize);
    }
    var _proto = BezierEasing.prototype;
    _proto.precompute = function precompute() {
        this.precomputed = true;
        if (this.mX1 !== this.mY1 || this.mX2 !== this.mY2) {
            this.calcSampleValues();
        }
    };
    _proto.getValue = function getValue(x) {
        if (this.mX1 === this.mY1 && this.mX2 === this.mY2) {
            return x;
        }
        if (isNaN(this.mY1) || isNaN(this.mY2)) {
            return 0;
        }
        if (x === 0 || x === 1) {
            return x;
        }
        if (!this.precomputed) {
            this.precompute();
        }
        var value = calcBezier(this.getTForX(x), this.mY1, this.mY2);
        return value;
    };
    _proto.calcSampleValues = function calcSampleValues() {
        for(var i = 0; i < kSplineTableSize; ++i){
            this.mSampleValues[i] = calcBezier(i * kSampleStepSize, this.mX1, this.mX2);
        }
    };
    _proto.getTForX = function getTForX(aX) {
        var mSampleValues = this.mSampleValues, lastSample = kSplineTableSize - 1;
        var intervalStart = 0, currentSample = 1;
        for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, this.mX1, this.mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, this.mX1, this.mX2);
        }
        if (initialSlope === 0.0) {
            return guessForT;
        }
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, this.mX1, this.mX2);
    };
    return BezierEasing;
}();
function buildEasingCurve(leftKeyframe, rightKeyframe) {
    // 获取控制点和曲线类型
    var _getControlPoints = getControlPoints(leftKeyframe, rightKeyframe, true), p0 = _getControlPoints.p0, p1 = _getControlPoints.p1, p2 = _getControlPoints.p2, p3 = _getControlPoints.p3;
    assertExist(p2);
    assertExist(p3);
    var timeInterval = p3.x - p0.x;
    var valueInterval = p3.y - p0.y;
    var y1, y2;
    var x1 = numberToFix((p1.x - p0.x) / timeInterval, 5);
    var x2 = numberToFix((p2.x - p0.x) / timeInterval, 5);
    if (decimalEqual(valueInterval, 0)) {
        y1 = y2 = NaN;
    } else {
        y1 = numberToFix((p1.y - p0.y) / valueInterval, 5);
        y2 = numberToFix((p2.y - p0.y) / valueInterval, 5);
    }
    if (x1 < 0) {
        console.error("Invalid bezier points, x1 < 0", p0, p1, p2, p3);
        x1 = 0;
    }
    if (x2 < 0) {
        console.error("Invalid bezier points, x2 < 0", p0, p1, p2, p3);
        x2 = 0;
    }
    if (x1 > 1) {
        console.error("Invalid bezier points, x1 >= 1", p0, p1, p2, p3);
        x1 = 1;
    }
    if (x2 > 1) {
        console.error("Invalid bezier points, x2 >= 1", p0, p1, p2, p3);
        x2 = 1;
    }
    var str = ("bez_" + x1 + "_" + y1 + "_" + x2 + "_" + y2).replace(/\./g, "p");
    var bezEasing;
    if (BezierMap[str]) {
        bezEasing = BezierMap[str];
    } else {
        bezEasing = new BezierEasing(x1, y1, x2, y2);
        BezierMap[str] = bezEasing;
    }
    return {
        points: [
            p0,
            p1,
            p2,
            p3
        ],
        timeInterval: timeInterval,
        valueInterval: valueInterval,
        curve: bezEasing
    };
}
/**
 * 根据关键帧类型获取贝塞尔曲线上的关键点
 */ function getControlPoints(leftKeyframe, rightKeyframe, lineToBezier) {
    var leftValue = leftKeyframe[1];
    var leftHoldLine = keyframeInfo.isHoldOutKeyframe(leftKeyframe);
    var rightHoldLine = keyframeInfo.isHoldInKeyframe(rightKeyframe);
    var leftEase = !rightHoldLine && keyframeInfo.isRightSideEase(leftKeyframe);
    var rightEase = !leftHoldLine && keyframeInfo.isLeftSideEase(rightKeyframe);
    // 1. 左边为ease，右边为line（补充右边的控制点，该点在曲线上的点的偏左边位置）
    if (leftEase && !rightEase && !rightHoldLine) {
        var p0 = new Vector2(leftValue[leftValue.length - 4], leftValue[leftValue.length - 3]);
        var p1 = new Vector2(leftValue[leftValue.length - 2], leftValue[leftValue.length - 1]);
        var rightPoint = keyframeInfo.getPointInCurve(rightKeyframe);
        var p3 = new Vector2(rightPoint.x, rightPoint.y);
        var p2 = new Vector2(p3.x - (p3.x - p0.x) / 10, p3.y);
        return {
            type: "ease",
            p0: p0,
            p1: p1,
            p2: p2,
            p3: p3
        };
    }
    // 2. 左边为line，右边为ease（补充左边的控制点，该点在曲线上的点的偏右边位置）
    if (!leftEase && rightEase && !leftHoldLine) {
        var rightValue = rightKeyframe[1];
        var leftPoint = keyframeInfo.getPointInCurve(leftKeyframe);
        var p01 = new Vector2(leftPoint.x, leftPoint.y);
        var p21 = new Vector2(rightValue[0], rightValue[1]);
        var p31 = new Vector2(rightValue[2], rightValue[3]);
        var p11 = new Vector2(p01.x + (p31.x - p01.x) / 10, p01.y);
        return {
            type: "ease",
            p0: p01,
            p1: p11,
            p2: p21,
            p3: p31
        };
    }
    // 3. 左边为ease，右边为ease
    if (leftEase && rightEase) {
        var rightValue1 = rightKeyframe[1];
        var p02 = new Vector2(leftValue[leftValue.length - 4], leftValue[leftValue.length - 3]);
        var p12 = new Vector2(leftValue[leftValue.length - 2], leftValue[leftValue.length - 1]);
        var p22 = new Vector2(rightValue1[0], rightValue1[1]);
        var p32 = new Vector2(rightValue1[2], rightValue1[3]);
        return {
            type: "ease",
            p0: p02,
            p1: p12,
            p2: p22,
            p3: p32
        };
    }
    // 4. 左边为line，右边为line
    var p03 = keyframeInfo.getPointInCurve(leftKeyframe);
    var p13 = keyframeInfo.getPointInCurve(rightKeyframe);
    if (leftHoldLine) {
        p13.y = p03.y; // 定格关键帧使用相同的点
    } else if (rightHoldLine) {
        p03.y = p13.y;
    }
    if (lineToBezier) {
        // 补上两个在直线上的控制点
        var p23 = new Vector2((p13.x - p03.x) / 3 + p03.x, (p13.y - p03.y) / 3 + p03.y);
        var p33 = new Vector2((p13.x - p03.x) / 3 * 2 + p03.x, (p13.y - p03.y) / 3 * 2 + p03.y);
        return {
            type: "ease",
            p0: p03,
            p1: p23,
            p2: p33,
            p3: p13,
            isHold: leftHoldLine || rightHoldLine,
            leftHoldLine: leftHoldLine,
            rightHoldLine: rightHoldLine
        };
    } else {
        return {
            type: "line",
            p0: p03,
            p1: p13,
            isHold: leftHoldLine || rightHoldLine,
            leftHoldLine: leftHoldLine,
            rightHoldLine: rightHoldLine
        };
    }
}
var QuaternionInner = /*#__PURE__*/ function() {
    function QuaternionInner() {}
    QuaternionInner.slerpFlat = function slerpFlat(dst, src0, src1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        var x0 = src0.x;
        var y0 = src0.y;
        var z0 = src0.z;
        var w0 = src0.w;
        var x1 = src1.x;
        var y1 = src1.y;
        var z1 = src1.z;
        var w1 = src1.w;
        if (t === 0) {
            dst.x = x0;
            dst.y = y0;
            dst.z = z0;
            dst.w = w0;
            return;
        }
        if (t === 1) {
            dst.x = x1;
            dst.y = y1;
            dst.z = z1;
            dst.w = w1;
            return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            var s = 1 - t;
            var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
            var dir = cos >= 0 ? 1 : -1;
            var sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                var sin = Math.sqrt(sqrSin);
                var len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            var tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst.x = x0;
        dst.y = y0;
        dst.z = z0;
        dst.w = w0;
    };
    return QuaternionInner;
}();

var CURVE_PRO_TIME = 0;
var CURVE_PRO_VALUE = 1;
var CURVE_PRO_IN_TANGENT = 2;
var CURVE_PRO_OUT_TANGENT = 3;
var NOT_IMPLEMENT = "not_implement";
var ValueGetter = /*#__PURE__*/ function() {
    function ValueGetter(arg) {
        this.onCreate(arg);
    }
    var _proto = ValueGetter.prototype;
    _proto.onCreate = function onCreate(props) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.getIntegrateValue = function getIntegrateValue(t0, t1, timeScale) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.getIntegrateByTime = function getIntegrateByTime(t0, time) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.getValue = function getValue(time) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.getMaxTime = function getMaxTime() {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.toUniform = function toUniform(meta) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.map = function map(func) {
        throw new Error(NOT_IMPLEMENT);
    };
    _proto.scaleXCoord = function scaleXCoord(scale) {
        return this;
    };
    _proto.toData = function toData() {
        throw new Error(NOT_IMPLEMENT);
    };
    ValueGetter.getAllData = function getAllData(meta, halfFloat) {
        var ret = new (halfFloat ? Float16ArrayWrapper : Float32Array)(meta.index * 4);
        for(var i = 0, cursor = 0, curves = meta.curves; i < curves.length; i++){
            var data = curves[i].toData();
            ret.set(data, cursor);
            cursor += data.length;
        }
        return halfFloat ? ret.data : ret;
    };
    return ValueGetter;
}();
var StaticValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(StaticValue, ValueGetter);
    function StaticValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = StaticValue.prototype;
    _proto.onCreate = function onCreate(arg) {
        this.value = arg;
    };
    _proto.getIntegrateValue = function getIntegrateValue(t0, t1, ts) {
        return this.value * (t1 - t0);
    };
    _proto.getIntegrateByTime = function getIntegrateByTime(t0, t1) {
        return 0.5 * this.value * (t1 * t1 - t0 * t0);
    };
    _proto.getValue = function getValue(time) {
        return this.value;
    };
    _proto.toUniform = function toUniform() {
        return new Float32Array([
            0,
            this.value,
            0,
            0
        ]);
    };
    _proto.map = function map(func) {
        var val = this.value;
        this.value = func(val);
        return this;
    };
    _proto.getMaxTime = function getMaxTime() {
        return 0;
    };
    return StaticValue;
}(ValueGetter);
var RandomSetValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(RandomSetValue, ValueGetter);
    function RandomSetValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = RandomSetValue.prototype;
    _proto.onCreate = function onCreate(arg) {
        this.items = arg;
    };
    _proto.getValue = function getValue(t) {
        var items = this.items;
        return items[Math.floor(Math.random() * items.length)];
    };
    _proto.map = function map(func) {
        this.items = this.items.map(func);
        return this;
    };
    return RandomSetValue;
}(ValueGetter);
var RandomValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(RandomValue, ValueGetter);
    function RandomValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = RandomValue.prototype;
    _proto.onCreate = function onCreate(props) {
        this.min = props[0];
        this.max = props[1];
    };
    _proto.getValue = function getValue(time) {
        return randomInRange(this.min, this.max);
    };
    _proto.toUniform = function toUniform() {
        return new Float32Array([
            4,
            this.min,
            this.max,
            0
        ]);
    };
    _proto.map = function map(func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    return RandomValue;
}(ValueGetter);
var RandomVectorValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(RandomVectorValue, ValueGetter);
    function RandomVectorValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = RandomVectorValue.prototype;
    _proto.onCreate = function onCreate(props) {
        this.min = props[0];
        this.max = props[1];
    };
    _proto.getValue = function getValue(time) {
        var min = this.min;
        var max = this.max;
        var ret = [];
        for(var i = 0; i < min.length; i++){
            var t = Math.random();
            ret[i] = min[i] * (1 - t) + max[i] * t;
        }
        return ret;
    };
    // TODO:
    _proto.map = function map(func) {
        this.min = this.min.map(func);
        this.max = this.max.map(func);
        return this;
    };
    return RandomVectorValue;
}(ValueGetter);
var LinearValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(LinearValue, ValueGetter);
    function LinearValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = LinearValue.prototype;
    _proto.onCreate = function onCreate(props) {
        this.min = props[0];
        this.max = props[1];
        this.xCoord = 1;
    };
    _proto.getValue = function getValue(t) {
        t /= this.xCoord;
        return this.min * (1 - t) + this.max * t;
    };
    _proto.toUniform = function toUniform() {
        return new Float32Array([
            1,
            this.min,
            this.max,
            this.xCoord
        ]);
    };
    _proto.getIntegrateValue = function getIntegrateValue(t0, t1, timeScale) {
        if (timeScale === void 0) timeScale = 1;
        var min = this.min;
        var max = this.max;
        var ts = this.xCoord * timeScale;
        var v1 = min + (max - min) * (t1 / ts);
        var v0 = min + (max - min) * (t0 / ts);
        return ((v1 + min) * t1 - (v0 + min) * t0) / 2;
    };
    _proto.getIntegrateByTime = function getIntegrateByTime(t0, t1) {
        return lineSegIntegrateByTime(t1, 0, this.xCoord, this.min, this.max) - lineSegIntegrateByTime(t0, 0, this.xCoord, this.min, this.max);
    };
    _proto.map = function map(func) {
        this.min = func(this.min);
        this.max = func(this.max);
        return this;
    };
    _proto.scaleXCoord = function scaleXCoord(scale) {
        this.xCoord = scale;
        return this;
    };
    return LinearValue;
}(ValueGetter);
var GradientValue = /*#__PURE__*/ function(ValueGetter) {
    _inherits(GradientValue, ValueGetter);
    function GradientValue() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = GradientValue.prototype;
    _proto.onCreate = function onCreate(props) {
        this.stops = colorStopsFromGradient(props);
    };
    _proto.getStops = function getStops() {
        return this.stops;
    };
    _proto.getValue = function getValue(time) {
        var stops = this.stops;
        var last = stops.length - 1;
        for(var i = 0; i < last; i++){
            var a = stops[i];
            var b = stops[i + 1];
            if (a.stop <= time && b.stop > time) {
                var t = (time - a.stop) / (b.stop - a.stop);
                return interpolateColor(a.color, b.color, t, true);
            }
        }
        return stops[last].color.slice();
    };
    return GradientValue;
}(ValueGetter);
var LineSegments = /*#__PURE__*/ function(ValueGetter) {
    _inherits(LineSegments, ValueGetter);
    function LineSegments() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = LineSegments.prototype;
    _proto.onCreate = function onCreate(props) {
        this.keys = props.map(function(p) {
            if (p.slice) {
                return p.slice(0, 2);
            }
            return [
                p.time,
                p.value
            ];
        }).sort(function(a, b) {
            return a[0] - b[0];
        });
        var last = this.keys[this.keys.length - 1];
        if (last[0] < 1) {
            this.keys.push([
                1,
                last[1]
            ]);
        }
        var first = this.keys[0];
        if (first[0] > 0) {
            this.keys.unshift([
                0,
                first[1]
            ]);
        }
        this.isLineSeg = true;
    };
    _proto.getValue = function getValue(time) {
        var keys = this.keys;
        if (time < keys[0][0]) {
            return keys[0][1];
        }
        var end = keys.length - 1;
        for(var i = 0; i < end; i++){
            var key = keys[i];
            var k2 = keys[i + 1];
            var x0 = key[0];
            var x1 = k2[0];
            if (time >= x0 && time <= x1) {
                var p = (time - x0) / (x1 - x0);
                var y0 = key[1];
                return y0 + p * (k2[1] - y0);
            }
        }
        return keys[end][1];
    };
    _proto.getIntegrateValue = function getIntegrateValue(t0, t1, ts) {
        if (ts === void 0) ts = 1;
        return (this.integrate(t1, false) - this.integrate(t0, false)) * ts;
    };
    _proto.getIntegrateByTime = function getIntegrateByTime(t0, t1) {
        return this.integrate(t1, true) - this.integrate(t0, true);
    };
    _proto.integrate = function integrate(time, byTime) {
        var keys = this.keys;
        if (time <= keys[0][0]) {
            return 0;
        }
        var ret = 0;
        var end = keys.length - 1;
        var func = byTime ? lineSegIntegrateByTime : lineSegIntegrate;
        for(var i = 0; i < end; i++){
            var k1 = keys[i];
            var k2 = keys[i + 1];
            var t0 = k1[0];
            var t1 = k2[0];
            if (time > t0 && time <= t1) {
                return ret + func(time, t0, t1, k1[1], k2[1]);
            } else {
                ret += func(t1, t0, t1, k1[1], k2[1]);
            }
        }
        return ret;
    };
    _proto.toData = function toData() {
        var keys = this.keys;
        var data = new Float32Array(Math.ceil(keys.length / 2) * 4);
        for(var i = 0, cursor = 0; i < keys.length; i++, cursor += 2){
            data.set(keys[i], cursor);
        }
        data.set(keys[keys.length - 1], data.length - 2);
        return data;
    };
    _proto.toUniform = function toUniform(meta) {
        var index = meta.index;
        var keys = this.keys;
        var uniformCount = Math.ceil(keys.length / 2);
        meta.lineSegCount += uniformCount;
        meta.curves.push(this);
        meta.index += uniformCount;
        meta.max = Math.max(meta.max, uniformCount);
        return new Float32Array([
            3,
            index,
            uniformCount,
            0
        ]);
    };
    _proto.map = function map(func) {
        this.keys.forEach(function(k) {
            return k[1] = func(k[1]);
        });
        return this;
    };
    _proto.scaleXCoord = function scaleXCoord(scale) {
        this.keys.forEach(function(k) {
            return k[0] = scale * k[0];
        });
        return this;
    };
    return LineSegments;
}(ValueGetter);
var BezierCurve = /*#__PURE__*/ function(ValueGetter) {
    _inherits(BezierCurve, ValueGetter);
    function BezierCurve() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = BezierCurve.prototype;
    _proto.onCreate = function onCreate(props) {
        var keyframes = props;
        this.curveMap = {};
        this.keys = [];
        for(var i = 0; i < keyframes.length - 1; i++){
            var leftKeyframe = keyframes[i];
            var rightKeyframe = keyframes[i + 1];
            var _buildEasingCurve = buildEasingCurve(leftKeyframe, rightKeyframe), points = _buildEasingCurve.points, curve = _buildEasingCurve.curve, timeInterval = _buildEasingCurve.timeInterval, valueInterval = _buildEasingCurve.valueInterval;
            var s = points[0];
            var e = points[points.length - 1];
            this.keys.push([].concat(s.toArray(), points[1].toArray()));
            this.keys.push([].concat(e.toArray(), points[2].toArray()));
            this.curveMap[s.x + "&" + e.x] = {
                points: points,
                timeInterval: timeInterval,
                valueInterval: valueInterval,
                curve: curve
            };
        }
    };
    _proto.getValue = function getValue(time) {
        var result = 0;
        var keyTimeData = Object.keys(this.curveMap);
        var keyTimeStart = Number(keyTimeData[0].split("&")[0]);
        var keyTimeEnd = Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
        if (time <= keyTimeStart) {
            return this.getCurveValue(keyTimeData[0], keyTimeStart);
        }
        if (time >= keyTimeEnd) {
            return this.getCurveValue(keyTimeData[keyTimeData.length - 1], keyTimeEnd);
        }
        for(var i = 0; i < keyTimeData.length; i++){
            var _keyTimeData_i_split = keyTimeData[i].split("&"), xMin = _keyTimeData_i_split[0], xMax = _keyTimeData_i_split[1];
            if (time >= Number(xMin) && time < Number(xMax)) {
                result = this.getCurveValue(keyTimeData[i], time);
                break;
            }
        }
        return result;
    };
    _proto.getIntegrateValue = function getIntegrateValue(t0, t1, ts) {
        if (ts === void 0) ts = 1;
        var time = (t1 - t0) / ts;
        var result = 0;
        var keyTimeData = Object.keys(this.curveMap);
        var keyTimeStart = Number(keyTimeData[0].split("&")[0]);
        if (time <= keyTimeStart) {
            return 0;
        }
        for(var i = 0; i < keyTimeData.length; i++){
            var _keyTimeData_i_split = keyTimeData[i].split("&"), xMin = _keyTimeData_i_split[0], xMax = _keyTimeData_i_split[1];
            if (time >= Number(xMax)) {
                result += ts * this.getCurveIntegrateValue(keyTimeData[i], Number(xMax));
            }
            if (time >= Number(xMin) && time < Number(xMax)) {
                result += ts * this.getCurveIntegrateValue(keyTimeData[i], time);
                break;
            }
        }
        return result;
    };
    _proto.getIntegrateByTime = function getIntegrateByTime(t0, t1) {
        return this.getIntegrateValue(0, t1) - this.getIntegrateValue(0, t0);
    };
    // 速度变化曲线面板移除后下线
    _proto.getCurveIntegrateValue = function getCurveIntegrateValue(curveKey, time) {
        var curveInfo = this.curveMap[curveKey];
        var _curveInfo_points = curveInfo.points, p0 = _curveInfo_points[0];
        var timeInterval = curveInfo.timeInterval;
        var valueInterval = curveInfo.valueInterval;
        var segments = 20;
        var total = 0;
        var h = (time - p0.x) / segments;
        for(var i = 0; i <= segments; i++){
            var t = i * h;
            var normalizeTime = t / timeInterval;
            var y = p0.y + valueInterval * curveInfo.curve.getValue(normalizeTime);
            if (i === 0 || i === segments) {
                total += y;
            } else if (i % 2 === 1) {
                total += 4 * y;
            } else {
                total += 2 * y;
            }
        }
        total *= h / 3;
        return total;
    };
    _proto.getCurveValue = function getCurveValue(curveKey, time) {
        var curveInfo = this.curveMap[curveKey];
        var _curveInfo_points = curveInfo.points, p0 = _curveInfo_points[0];
        var timeInterval = curveInfo.timeInterval;
        var valueInterval = curveInfo.valueInterval;
        var normalizeTime = (time - p0.x) / timeInterval;
        var value = curveInfo.curve.getValue(normalizeTime);
        return p0.y + valueInterval * value;
    };
    _proto.toUniform = function toUniform(meta) {
        var index = meta.index;
        var count = this.keys.length;
        meta.curves.push(this);
        meta.index = index + count;
        // 兼容 WebGL1
        meta.max = Math.max(meta.max, count);
        meta.curveCount += count;
        return new Float32Array([
            5,
            index + 1 / count,
            index,
            count
        ]);
    };
    _proto.toData = function toData() {
        var keys = this.keys;
        var data = new Float32Array(keys.length * 4);
        for(var i = 0, cursor = 0; i < keys.length; i++, cursor += 4){
            data.set(keys[i], cursor);
        }
        return data;
    };
    _proto.getMaxTime = function getMaxTime() {
        var keyTimeData = Object.keys(this.curveMap);
        return Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
    };
    return BezierCurve;
}(ValueGetter);
var PathSegments = /*#__PURE__*/ function(ValueGetter) {
    _inherits(PathSegments, ValueGetter);
    function PathSegments() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = PathSegments.prototype;
    _proto.onCreate = function onCreate(props) {
        this.keys = props[0];
        this.values = props[1];
    };
    _proto.getValue = function getValue(time) {
        var keys = this.keys;
        var values = this.values;
        for(var i = 0; i < keys.length - 1; i++){
            var k0 = keys[i];
            var k1 = keys[i + 1];
            if (k0[0] <= time && k1[0] >= time) {
                var dis = k1[1] - k0[1];
                var dt = void 0;
                if (dis === 0) {
                    dt = (time - k0[0]) / (k1[0] - k0[0]);
                } else {
                    var val = curveValueEvaluate(time, k0, k1);
                    dt = (val - k0[1]) / dis;
                }
                return this.calculateVec(i, dt);
            }
        }
        if (time <= keys[0][0]) {
            return values[0].slice();
        }
        return values[values.length - 1].slice();
    };
    _proto.calculateVec = function calculateVec(i, dt) {
        var vec0 = this.values[i];
        var vec1 = this.values[i + 1];
        var ret = [
            0,
            0,
            0
        ];
        for(var j = 0; j < vec0.length; j++){
            ret[j] = vec0[j] * (1 - dt) + vec1[j] * dt;
        }
        return ret;
    };
    return PathSegments;
}(ValueGetter);
var BezierCurvePath = /*#__PURE__*/ function(ValueGetter) {
    _inherits(BezierCurvePath, ValueGetter);
    function BezierCurvePath() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = BezierCurvePath.prototype;
    _proto.onCreate = function onCreate(props) {
        var keyframes = props[0], points = props[1], controlPoints = props[2];
        this.curveSegments = {};
        if (!controlPoints.length) {
            return;
        }
        for(var i = 0; i < keyframes.length - 1; i++){
            var leftKeyframe = keyframes[i];
            var rightKeyframe = keyframes[i + 1];
            var ps1 = new Vector3(points[i][0], points[i][1], points[i][2]), ps2 = new Vector3(points[i + 1][0], points[i + 1][1], points[i + 1][2]);
            var cp1 = new Vector3(controlPoints[2 * i][0], controlPoints[2 * i][1], controlPoints[2 * i][2]), cp2 = new Vector3(controlPoints[2 * i + 1][0], controlPoints[2 * i + 1][1], controlPoints[2 * i + 1][2]);
            var _buildEasingCurve = buildEasingCurve(leftKeyframe, rightKeyframe), ps = _buildEasingCurve.points, easingCurve = _buildEasingCurve.curve, timeInterval = _buildEasingCurve.timeInterval, valueInterval = _buildEasingCurve.valueInterval;
            var s = ps[0];
            var e = ps[ps.length - 1];
            var pathCurve = new BezierPath(ps1, ps2, cp1, cp2);
            this.curveSegments[s.x + "&" + e.x] = {
                points: ps,
                timeInterval: timeInterval,
                valueInterval: valueInterval,
                easingCurve: easingCurve,
                pathCurve: pathCurve
            };
        }
    };
    _proto.getValue = function getValue(time) {
        var t = numberToFix(time, 5);
        var perc = 0, point = new Vector3();
        var keyTimeData = Object.keys(this.curveSegments);
        if (!keyTimeData.length) {
            return point;
        }
        var keyTimeStart = Number(keyTimeData[0].split("&")[0]);
        var keyTimeEnd = Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
        if (t <= keyTimeStart) {
            var pathCurve = this.curveSegments[keyTimeData[0]].pathCurve;
            point = pathCurve.getPointInPercent(0);
            return point;
        }
        if (t >= keyTimeEnd) {
            var pathCurve1 = this.curveSegments[keyTimeData[keyTimeData.length - 1]].pathCurve;
            point = pathCurve1.getPointInPercent(1);
            return point;
        }
        for(var i = 0; i < keyTimeData.length; i++){
            var _keyTimeData_i_split = keyTimeData[i].split("&"), xMin = _keyTimeData_i_split[0], xMax = _keyTimeData_i_split[1];
            if (t >= Number(xMin) && t < Number(xMax)) {
                var bezierPath = this.curveSegments[keyTimeData[i]].pathCurve;
                perc = this.getPercValue(keyTimeData[i], t);
                point = bezierPath.getPointInPercent(perc);
            }
        }
        return point;
    };
    _proto.getPercValue = function getPercValue(curveKey, time) {
        var curveInfo = this.curveSegments[curveKey];
        var _curveInfo_points = curveInfo.points, p0 = _curveInfo_points[0];
        var timeInterval = curveInfo.timeInterval;
        var normalizeTime = numberToFix((time - p0.x) / timeInterval, 4);
        var value = curveInfo.easingCurve.getValue(normalizeTime);
        // TODO 测试用 编辑器限制值域后移除clamp
        return clamp$1(value, 0, 1);
    };
    _proto.getMaxTime = function getMaxTime() {
        var keyTimeData = Object.keys(this.curveSegments);
        return Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
    };
    return BezierCurvePath;
}(ValueGetter);
var BezierCurveQuat = /*#__PURE__*/ function(ValueGetter) {
    _inherits(BezierCurveQuat, ValueGetter);
    function BezierCurveQuat() {
        return ValueGetter.apply(this, arguments);
    }
    var _proto = BezierCurveQuat.prototype;
    _proto.onCreate = function onCreate(props) {
        var keyframes = props[0], points = props[1], controlPoints = props[2];
        this.curveSegments = {};
        if (!controlPoints.length) {
            return;
        }
        for(var i = 0; i < keyframes.length - 1; i++){
            var leftKeyframe = keyframes[i];
            var rightKeyframe = keyframes[i + 1];
            var ps1 = Quaternion.fromArray(points[i]);
            var ps2 = Quaternion.fromArray(points[i + 1]);
            var cp1 = Quaternion.fromArray(controlPoints[2 * i]);
            var cp2 = Quaternion.fromArray(controlPoints[2 * i + 1]);
            var _buildEasingCurve = buildEasingCurve(leftKeyframe, rightKeyframe), ps = _buildEasingCurve.points, easingCurve = _buildEasingCurve.curve, timeInterval = _buildEasingCurve.timeInterval, valueInterval = _buildEasingCurve.valueInterval;
            var s = ps[0];
            var e = ps[ps.length - 1];
            var pathCurve = new BezierQuat(ps1, ps2, cp1, cp2);
            this.curveSegments[s.x + "&" + e.x] = {
                points: ps,
                timeInterval: timeInterval,
                valueInterval: valueInterval,
                easingCurve: easingCurve,
                pathCurve: pathCurve
            };
        }
    };
    _proto.getValue = function getValue(time) {
        var perc = 0;
        var t = numberToFix(time, 5);
        var keyTimeData = Object.keys(this.curveSegments);
        var keyTimeStart = Number(keyTimeData[0].split("&")[0]);
        var keyTimeEnd = Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
        if (t <= keyTimeStart) {
            var pathCurve = this.curveSegments[keyTimeData[0]].pathCurve;
            return pathCurve.getPointInPercent(0);
        }
        if (t >= keyTimeEnd) {
            var pathCurve1 = this.curveSegments[keyTimeData[keyTimeData.length - 1]].pathCurve;
            return pathCurve1.getPointInPercent(1);
        }
        for(var i = 0; i < keyTimeData.length; i++){
            var _keyTimeData_i_split = keyTimeData[i].split("&"), xMin = _keyTimeData_i_split[0], xMax = _keyTimeData_i_split[1];
            if (t >= Number(xMin) && t < Number(xMax)) {
                var pathCurve2 = this.curveSegments[keyTimeData[i]].pathCurve;
                perc = this.getPercValue(keyTimeData[i], t);
                return pathCurve2.getPointInPercent(perc);
            }
        }
        var pathCurve3 = this.curveSegments[keyTimeData[0]].pathCurve;
        return pathCurve3.getPointInPercent(0);
    };
    _proto.getPercValue = function getPercValue(curveKey, time) {
        var curveInfo = this.curveSegments[curveKey];
        var _curveInfo_points = curveInfo.points, p0 = _curveInfo_points[0];
        var timeInterval = curveInfo.timeInterval;
        var normalizeTime = numberToFix((time - p0.x) / timeInterval, 4);
        var value = curveInfo.easingCurve.getValue(normalizeTime);
        // TODO 测试用 编辑器限制值域后移除clamp
        return clamp$1(value, 0, 1);
    };
    _proto.getMaxTime = function getMaxTime() {
        var keyTimeData = Object.keys(this.curveSegments);
        return Number(keyTimeData[keyTimeData.length - 1].split("&")[1]);
    };
    return BezierCurveQuat;
}(ValueGetter);
var _obj$8;
var map$2 = (_obj$8 = {}, _obj$8[ValueType.RANDOM] = function(props) {
    if (_instanceof1(props[0], Array)) {
        return new RandomVectorValue(props);
    }
    return new RandomValue(props);
}, _obj$8[ValueType.CONSTANT] = function(props) {
    return new StaticValue(props);
}, _obj$8[ValueType.CONSTANT_VEC2] = function(props) {
    return new StaticValue(props);
}, _obj$8[ValueType.CONSTANT_VEC3] = function(props) {
    return new StaticValue(props);
}, _obj$8[ValueType.CONSTANT_VEC4] = function(props) {
    return new StaticValue(props);
}, _obj$8[ValueType.RGBA_COLOR] = function(props) {
    return new StaticValue(props);
}, _obj$8[ValueType.COLORS] = function(props) {
    return new RandomSetValue(props.map(function(c) {
        return colorToArr$1(c, false);
    }));
}, _obj$8[ValueType.LINE] = function(props) {
    if (props.length === 2 && props[0][0] === 0 && props[1][0] === 1) {
        return new LinearValue([
            props[0][1],
            props[1][1]
        ]);
    }
    return new LineSegments(props);
}, _obj$8[ValueType.GRADIENT_COLOR] = function(props) {
    return new GradientValue(props);
}, _obj$8[ValueType.LINEAR_PATH] = function(pros) {
    return new PathSegments(pros);
}, _obj$8[ValueType.BEZIER_CURVE] = function(props) {
    if (props.length === 1) {
        return new StaticValue(props[0][1][1]);
    }
    return new BezierCurve(props);
}, _obj$8[ValueType.BEZIER_CURVE_PATH] = function(props) {
    if (props[0].length === 1) {
        return new StaticValue(_construct(Vector3, [].concat(props[1][0])));
    }
    return new BezierCurvePath(props);
}, _obj$8[ValueType.BEZIER_CURVE_QUAT] = function(props) {
    if (props[0].length === 1) {
        return new StaticValue(_construct(Quaternion, [].concat(props[1][0])));
    }
    return new BezierCurveQuat(props);
}, _obj$8);
function createValueGetter(args) {
    if (!args || !isNaN(+args)) {
        return new StaticValue(args || 0);
    }
    if (_instanceof1(args, ValueGetter)) {
        return args;
    }
    if (isFunction(map$2[args[0]])) {
        return map$2[args[0]](args[1]);
    } else {
        throw new Error("ValueType: " + args[0] + " is not supported, see " + HELP_LINK$1["ValueType: 21/22 is not supported"] + ".");
    }
}
function lineSegIntegrate(t, t0, t1, y0, y1) {
    var h = t - t0;
    return (y0 + y0 + (y1 - y0) * h / (t1 - t0)) * h / 2;
}
function lineSegIntegrateByTime(t, t0, t1, y0, y1) {
    var t2 = t * t;
    var t3 = t2 * t;
    var t02 = t0 * t0;
    var t03 = t02 * t0;
    return (2 * t3 * (y0 - y1) + 3 * t2 * (t0 * y1 - t1 * y0) - t03 * (2 * y0 + y1) + 3 * t02 * t1 * y0) / (6 * (t0 - t1));
}
function curveValueEvaluate(time, keyframe0, keyframe1) {
    var dt = keyframe1[CURVE_PRO_TIME] - keyframe0[CURVE_PRO_TIME];
    var m0 = keyframe0[CURVE_PRO_OUT_TANGENT] * dt;
    var m1 = keyframe1[CURVE_PRO_IN_TANGENT] * dt;
    var t = (time - keyframe0[CURVE_PRO_TIME]) / dt;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    //(2*v0+m0+m1-2*v1)*(t-t0)^3/k^3+(3*v1-3*v0-2*m0-m1)*(t-t0)^2/k^2+m0 *(t-t0)/k+v0
    return a * keyframe0[CURVE_PRO_VALUE] + b * m0 + c * m1 + d * keyframe1[CURVE_PRO_VALUE];
}
function getKeyFrameMetaByRawValue(meta, value) {
    if (value) {
        var type = value[0];
        var keys = value[1];
        if (type === ValueType.CURVE) {
            meta.curves.push(keys);
            var keyLen = keys.length;
            if (keys[0][0] > 0) {
                keyLen++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen++;
            }
            meta.index += keyLen;
            meta.max = Math.max(meta.max, keyLen);
            meta.curveCount += keyLen;
        } else if (type === ValueType.LINE) {
            var keyLen1 = keys.length;
            if (keyLen1 === 2 && keys[0][0] === 0 && keys[1][0] === 1) {
                return;
            }
            if (keys[0][0] > 0) {
                keyLen1++;
            }
            if (keys[keys.length - 1][0] < 1) {
                keyLen1++;
            }
            var uniformCount = Math.ceil(keyLen1 / 2);
            meta.lineSegCount += uniformCount;
            meta.curves.push(keys);
            meta.index += uniformCount;
            meta.max = Math.max(meta.max, uniformCount);
        } else if (type === ValueType.BEZIER_CURVE) {
            var keyLen2 = keys.length - 1;
            meta.index += 2 * keyLen2;
            meta.curves.push(keys);
            meta.max = Math.max(meta.max, 2 * keyLen2);
            meta.curveCount += 2 * keyLen2;
        }
    }
}
function createKeyFrameMeta() {
    return {
        curves: [],
        index: 0,
        max: 0,
        lineSegCount: 0,
        curveCount: 0
    };
}

exports.ShaderCompileResultStatus = void 0;
(function(ShaderCompileResultStatus) {
    ShaderCompileResultStatus[ShaderCompileResultStatus["noShader"] = 0] = "noShader";
    ShaderCompileResultStatus[ShaderCompileResultStatus["success"] = 1] = "success";
    ShaderCompileResultStatus[ShaderCompileResultStatus["fail"] = 2] = "fail";
    ShaderCompileResultStatus[ShaderCompileResultStatus["compiling"] = 3] = "compiling";
})(exports.ShaderCompileResultStatus || (exports.ShaderCompileResultStatus = {}));
exports.GLSLVersion = void 0;
(function(GLSLVersion) {
    GLSLVersion["GLSL1"] = "100";
    GLSLVersion["GLSL3"] = "300 es";
})(exports.GLSLVersion || (exports.GLSLVersion = {}));
var ShaderVariant = /*#__PURE__*/ function(EffectsObject) {
    _inherits(ShaderVariant, EffectsObject);
    function ShaderVariant(engine, source) {
        var _this;
        _this = EffectsObject.call(this, engine) || this;
        _this.source = source;
        return _this;
    }
    return ShaderVariant;
}(EffectsObject);
exports.Shader = /*#__PURE__*/ function(EffectsObject) {
    _inherits(Shader, EffectsObject);
    function Shader() {
        return EffectsObject.apply(this, arguments);
    }
    var _proto = Shader.prototype;
    _proto.createVariant = function createVariant(macros) {
        var shaderMacros = [];
        if (macros) {
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(macros)), _step; !(_step = _iterator()).done;){
                var key = _step.value;
                shaderMacros.push([
                    key,
                    macros[key]
                ]);
            }
        }
        var shaderVariant = this.engine.getShaderLibrary().createShader(this.shaderData, shaderMacros);
        shaderVariant.shader = this;
        return shaderVariant;
    };
    _proto.fromData = function fromData(data) {
        EffectsObject.prototype.fromData.call(this, data);
        this.shaderData = data;
    };
    return Shader;
}(EffectsObject);
exports.Shader = __decorate([
    effectsClass("Shader")
], exports.Shader);

var EFFECTS_COPY_MESH_NAME = "effects-internal-copy";
var COPY_MESH_SHADER_ID = "effects-internal-copy-mesh";
var COPY_VERTEX_SHADER = "\nprecision highp float;\nattribute vec2 aPos;\nvarying vec2 vTex;\nvoid main(){\n    gl_Position = vec4(aPos,0.,1.0);\n    vTex = (aPos + vec2(1.0))/2.;\n}";
var COPY_FRAGMENT_SHADER = "precision mediump float;\nvarying vec2 vTex;\n\n#ifdef DEPTH_TEXTURE\nuniform sampler2D uDepth;\n#extension GL_EXT_frag_depth : enable\n#endif\nvoid main(){\n    #ifdef DEPTH_TEXTURE\n    gl_FragDepthEXT = texture2D(uDepth,vTex).r;\n    #endif\n}\n";
function createCopyShader(level, writeDepth) {
    var webgl2 = level === 2;
    return {
        name: EFFECTS_COPY_MESH_NAME,
        vertex: COPY_VERTEX_SHADER,
        fragment: COPY_FRAGMENT_SHADER,
        glslVersion: webgl2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1,
        macros: [
            [
                "DEPTH_TEXTURE",
                !!writeDepth
            ]
        ],
        // @ts-expect-error
        cacheId: COPY_MESH_SHADER_ID + +writeDepth
    };
}

var def = {
    format: glContext.RGBA,
    type: glContext.UNSIGNED_BYTE,
    minFilter: glContext.LINEAR,
    magFilter: glContext.LINEAR,
    wrapS: glContext.CLAMP_TO_EDGE,
    wrapT: glContext.CLAMP_TO_EDGE
};
var disposeSymbol = Symbol("dispose");
var PassTextureCache = /*#__PURE__*/ function() {
    function PassTextureCache(engine) {
        this.textureCache = {};
        this.textureRef = {};
        this.engine = engine;
    }
    var _proto = PassTextureCache.prototype;
    _proto.requestColorAttachmentTexture = function requestColorAttachmentTexture(request) {
        var _this = this;
        var width = request.width, height = request.height, name = request.name;
        var options = {
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: width,
                height: height
            },
            name: name
        };
        var keys = [
            name
        ];
        Object.getOwnPropertyNames(def).forEach(function(name) {
            var _request_name;
            var value = (_request_name = request[name]) != null ? _request_name : def[name];
            options[name] = value;
            keys.push(name, value);
        });
        var cacheId = keys.join(":");
        var tex = this.textureCache[cacheId];
        if (tex) {
            this.textureRef[cacheId]++;
        } else {
            var engine = this.engine;
            assertExist(engine);
            tex = Texture.create(engine, options);
            this.textureCache[cacheId] = tex;
            this.textureRef[cacheId] = 1;
            // @ts-expect-error
            tex[disposeSymbol] = tex.dispose;
            tex.dispose = function() {
                return _this.removeTexture(cacheId);
            };
        }
        return tex;
    };
    _proto.removeTexture = function removeTexture(id) {
        var refCount = this.textureRef[id];
        if (refCount <= 1) {
            if (refCount < 0) {
                console.error("Ref count < 0.");
            }
            var tex = this.textureCache[id];
            if (tex) {
                // @ts-expect-error
                tex[disposeSymbol]();
                // @ts-expect-error
                tex.dispose = tex[disposeSymbol];
            }
            delete this.textureCache[id];
            delete this.textureRef[id];
        } else {
            this.textureRef[id] = refCount - 1;
        }
    };
    _proto.dispose = function dispose() {
        var _this = this;
        Object.keys(this.textureCache).forEach(function(key) {
            var texture = _this.textureCache[key];
            // @ts-expect-error
            texture[disposeSymbol]();
            // @ts-expect-error
            texture.dispose = texture[disposeSymbol];
        });
        this.textureCache = {};
        this.textureRef = {};
        this.engine = undefined;
    };
    return PassTextureCache;
}();

var SemanticMap = /*#__PURE__*/ function() {
    function SemanticMap(semantics) {
        if (semantics === void 0) semantics = {};
        this.semantics = _extends({}, semantics);
    }
    var _proto = SemanticMap.prototype;
    _proto.toObject = function toObject() {
        return _extends({}, this.semantics);
    };
    _proto.setSemantic = function setSemantic(name, value) {
        if (value === undefined) {
            delete this.semantics[name];
        } else {
            this.semantics[name] = value;
        }
    };
    _proto.getSemanticValue = function getSemanticValue(name, state) {
        var ret = this.semantics[name];
        if (isFunction(ret)) {
            return ret(state);
        }
        return ret;
    };
    _proto.hasSemanticValue = function hasSemanticValue(name) {
        return name in this.semantics;
    };
    _proto.dispose = function dispose() {
        var _this = this;
        Object.keys(this.semantics).forEach(function(name) {
            delete _this.semantics[name];
        });
    };
    return SemanticMap;
}();

var _obj$7;
var BYTES_TYPE_MAP = (_obj$7 = {}, _obj$7[glContext.FLOAT] = Float32Array.BYTES_PER_ELEMENT, _obj$7[glContext.INT] = Int32Array.BYTES_PER_ELEMENT, _obj$7[glContext.SHORT] = Int16Array.BYTES_PER_ELEMENT, _obj$7[glContext.BYTE] = Int8Array.BYTES_PER_ELEMENT, _obj$7);
/**
 * Geometry 抽象类
 */ var Geometry = /*#__PURE__*/ function(EffectsObject) {
    _inherits(Geometry, EffectsObject);
    function Geometry() {
        return EffectsObject.apply(this, arguments);
    }
    var _proto = Geometry.prototype;
    /**
   * 初始化 GPU 资源
   * @override
   */ _proto.initialize = function initialize() {
    // OVERRIDE
    };
    /**
   * 几何数据刷新
   */ _proto.flush = function flush() {
    // OVERRIDE
    };
    return Geometry;
}(EffectsObject);
function generateEmptyTypedArray(type) {
    if (type === glContext.INT) {
        return new Int32Array(0);
    }
    if (type === glContext.SHORT) {
        return new Int16Array(0);
    }
    return new Float32Array(0);
}

var seed$a = 1;
/**
 * Mesh 抽象类
 */ var Mesh = /*#__PURE__*/ function(RendererComponent) {
    _inherits(Mesh, RendererComponent);
    function Mesh(engine, props) {
        var _this;
        _this = RendererComponent.call(this, engine) || this;
        _this.destroyed = false;
        _this.visible = true;
        if (props) {
            var material = props.material, geometry = props.geometry, _props_name = props.name, name = _props_name === void 0 ? "<unnamed>" : _props_name, _props_priority = props.priority, priority = _props_priority === void 0 ? 0 : _props_priority, _props_worldMatrix = props.worldMatrix, worldMatrix = _props_worldMatrix === void 0 ? Matrix4$1.fromIdentity() : _props_worldMatrix;
            _this.id = "Mesh" + seed$a++;
            _this.name = name;
            _this.geometry = geometry;
            _this.material = material;
            _this.priority = priority;
            _this.worldMatrix = worldMatrix;
        } else {
            _this.id = "Mesh" + seed$a++;
            _this.name = "<unnamed>";
            _this.worldMatrix = Matrix4$1.fromIdentity();
            _this._priority = 0;
        }
        return _this;
    }
    var _proto = Mesh.prototype;
    /**
   * 设置当前 Mesh 的可见性。
   * @param visible - true：可见，false：不可见
   */ _proto.setVisible = function setVisible(visible) {
        this.visible = visible;
    };
    /**
   * 获取当前 Mesh 的可见性。
   */ _proto.getVisible = function getVisible() {
        return this.visible;
    };
    _proto.render = function render(renderer) {
        if (this.isDestroyed) {
            // console.error(`mesh ${mesh.name} destroyed`, mesh);
            return;
        }
        if (!this.getVisible()) {
            return;
        }
        if (renderer.renderingData.currentFrame.globalUniforms) {
            renderer.setGlobalMatrix("effects_ObjectToWorld", this.worldMatrix);
        }
        renderer.drawGeometry(this.geometry, this.material);
    };
    /**
   * 获取当前 Mesh 的第一个 geometry。
   */ _proto.firstGeometry = function firstGeometry() {
        return this.geometry;
    };
    /**
   * 设置当前 Mesh 的材质
   * @param material - 要设置的材质
   * @param destroy - 可选的材质销毁选项
   */ _proto.setMaterial = function setMaterial(material, destroy) {
        if (destroy !== exports.DestroyOptions.keep) {
            this.material.dispose(destroy);
        }
        this.material = material;
    };
    _proto.restore = function restore() {};
    /**
   * 销毁当前资源
   * @param options - 可选的销毁选项
   */ _proto.dispose = function dispose(options) {
        if (this.destroyed) {
            //console.error('call mesh.destroy multiple times', this);
            return;
        }
        if ((options == null ? void 0 : options.geometries) !== exports.DestroyOptions.keep) {
            this.geometry.dispose();
        }
        var materialDestroyOption = options == null ? void 0 : options.material;
        if (materialDestroyOption !== exports.DestroyOptions.keep) {
            this.material.dispose(materialDestroyOption);
        }
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMesh(this);
            // @ts-expect-error
            this.engine = undefined;
        }
    };
    _create_class(Mesh, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return Mesh;
}(RendererComponent);

var RenderPassPriorityPrepare = 0;
var RenderPassPriorityNormal = 1000;
var RenderPassPriorityPostprocess = 3000;
exports.RenderPassAttachmentStorageType = void 0;
(function(RenderPassAttachmentStorageType) {
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["none"] = 0] = "none";
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["color"] = 1] = "color";
    //stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["stencil_8_opaque"] = 2] = "stencil_8_opaque";
    //stencil 16 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_opaque"] = 3] = "depth_16_opaque";
    //depth 16 & stencil 8 render buffer
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_stencil_opaque"] = 4] = "depth_stencil_opaque";
    //depth 16 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_16_texture"] = 5] = "depth_16_texture";
    //depth 24 texture, need gpu.capability.readableDepthStencilTextures
    RenderPassAttachmentStorageType[RenderPassAttachmentStorageType["depth_24_stencil_8_texture"] = 6] = "depth_24_stencil_8_texture";
})(exports.RenderPassAttachmentStorageType || (exports.RenderPassAttachmentStorageType = {}));
exports.TextureStoreAction = void 0;
(function(TextureStoreAction) {
    /**
   * 不清除 Attachment
   */ TextureStoreAction[TextureStoreAction["store"] = 0] = "store";
    /**
   * 清除 Attachment
   */ TextureStoreAction[TextureStoreAction["clear"] = 2] = "clear";
})(exports.TextureStoreAction || (exports.TextureStoreAction = {}));
var RenderTargetHandle = /*#__PURE__*/ function() {
    function RenderTargetHandle(engine, options) {
        this.destroyed = false;
        if (!options) {
            return;
        }
        var texture = options.texture, size = options.size;
        if (_instanceof1(texture, Texture)) {
            this.texture = texture;
            this.externalTexture = true;
        } else if (texture) {
            var wrapT = texture.wrapT, wrapS = texture.wrapS, minFilter = texture.minFilter, magFilter = texture.magFilter, internalFormat = texture.internalFormat, _texture_format = texture.format, format = _texture_format === void 0 ? glContext.RGBA : _texture_format, _texture_type = texture.type, type = _texture_type === void 0 ? glContext.UNSIGNED_BYTE : _texture_type;
            this.externalTexture = false;
            this.textureOptions = {
                size: size,
                format: format,
                type: type,
                internalFormat: internalFormat || format,
                wrapT: wrapT,
                wrapS: wrapS,
                minFilter: minFilter,
                magFilter: magFilter,
                name: options.name
            };
            this.texture = Texture.create(engine, _extends({}, this.textureOptions, {
                sourceType: exports.TextureSourceType.framebuffer,
                data: {
                    width: size[0],
                    height: size[1]
                }
            }));
        } else ;
    }
    var _proto = RenderTargetHandle.prototype;
    _proto.dispose = function dispose() {
        if (this.destroyed) {
            return;
        }
        this.texture.dispose();
        this.destroyed = true;
    };
    _create_class(RenderTargetHandle, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        },
        {
            key: "storageType",
            get: function get() {
                return 1;
            }
        },
        {
            key: "size",
            get: function get() {
                var tex = this.texture;
                return tex ? [
                    tex.getWidth(),
                    tex.getHeight()
                ] : [
                    0,
                    0
                ];
            }
        },
        {
            key: "width",
            get: function get() {
                return this.texture.getWidth() || 0;
            }
        },
        {
            key: "height",
            get: function get() {
                return this.texture.getHeight() || 0;
            }
        }
    ]);
    return RenderTargetHandle;
}();
exports.RenderPassDestroyAttachmentType = void 0;
(function(RenderPassDestroyAttachmentType) {
    /**
   * 强制销毁
   */ RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["force"] = 0] = "force";
    /**
   * 保留，不销毁
   */ RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keep"] = 1] = "keep";
    /**
   * 如果是外部传入的 Attachment，就不销毁
   */ RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["keepExternal"] = 2] = "keepExternal";
    /**
   * 强制销毁
   */ RenderPassDestroyAttachmentType[RenderPassDestroyAttachmentType["destroy"] = 0] = "destroy";
})(exports.RenderPassDestroyAttachmentType || (exports.RenderPassDestroyAttachmentType = {}));
var seed$9 = 1;
/**
 * RenderPass 抽象类
 */ var RenderPass = /*#__PURE__*/ function() {
    function RenderPass(renderer, options) {
        /**
   * ColorAttachment 数组
   */ this.attachments = [];
        this.destroyed = false;
        this.initialized = false;
        var _options_name = options.name, name = _options_name === void 0 ? "RenderPass_" + seed$9++ : _options_name, clearAction = options.clearAction, semantics = options.semantics, depthStencilAttachment = options.depthStencilAttachment, storeAction = options.storeAction, _options_priority = options.priority, priority = _options_priority === void 0 ? 0 : _options_priority, _options_meshOrder = options.meshOrder, meshOrder = _options_meshOrder === void 0 ? exports.OrderType.ascending : _options_meshOrder, _options_meshes = options.meshes, meshes = _options_meshes === void 0 ? [] : _options_meshes, _options_delegate = options.delegate, delegate = _options_delegate === void 0 ? {} : _options_delegate;
        this.name = name;
        this.renderer = renderer;
        this.priority = priority;
        this.meshOrder = meshOrder;
        this.meshes = sortByOrder(meshes.slice(), this.meshOrder);
        this.depthStencilType = (depthStencilAttachment == null ? void 0 : depthStencilAttachment.storageType) || 0;
        this.clearAction = _extends({}, clearAction);
        this.storeAction = _extends({
            colorAction: 0,
            depthAction: 0,
            stencilAction: 0
        }, storeAction);
        this.semantics = new SemanticMap(semantics);
        this.options = options;
        this.delegate = delegate;
        this.setViewportOptions(options);
    }
    var _proto = RenderPass.prototype;
    _proto.addMesh = function addMesh(mesh) {
        addByOrder(this.meshes, mesh, this.meshOrder);
    };
    _proto.removeMesh = function removeMesh(mesh) {
        removeItem(this.meshes, mesh);
    };
    _proto.setMeshes = function setMeshes(meshes) {
        var _this_meshes;
        this.meshes.length = 0;
        (_this_meshes = this.meshes).splice.apply(_this_meshes, [].concat([
            0,
            0
        ], meshes));
        sortByOrder(this.meshes, this.meshOrder);
        return this.meshes;
    };
    /**
   * 获取当前 Attachment 数组，注意 RenderPass 可能没有创建完成
   */ _proto.getInitAttachments = function getInitAttachments() {
        if (this.attachments.length > 0) {
            return this.attachments;
        } else {
            return this.options.attachments;
        }
    };
    // TODO 所有pass在子类配置
    /**
   * 配置当前pass的RT，在每帧渲染前调用
   */ _proto.configure = function configure(renderer) {
        if (this.framebuffer) {
            renderer.setFramebuffer(this.framebuffer);
        } else {
            var _this_getViewport = this.getViewport(), x = _this_getViewport[0], y = _this_getViewport[1], width = _this_getViewport[2], height = _this_getViewport[3];
            renderer.setViewport(x, y, width, height);
        }
    };
    /**
   * 执行当前pass，每帧调用一次
   */ _proto.execute = function execute(renderer) {
        renderer.clear(this.clearAction);
        renderer.renderMeshes(this.meshes);
        renderer.clear(this.storeAction);
    };
    /**
   * 每帧所有的pass渲染完后调用，通常用于清空临时的RT资源
   */ _proto.frameCleanup = function frameCleanup(renderer) {};
    /**
   * 重置 ColorAttachment 数组，会直接替换掉
   * @param colors - 纹理数组，作为新的 ColorAttachment
   */ _proto.resetColorAttachments = function resetColorAttachments(colors) {
        var _this = this;
        if (!colors.length) {
            this.resetAttachments({
                attachments: []
            });
        }
        if (!this.attachments.length) {
            this.resetAttachments({
                attachments: colors.map(function(t) {
                    return {
                        texture: t
                    };
                })
            });
        } else {
            var attachments = colors.map(function(texture) {
                texture.updateSource({
                    sourceType: exports.TextureSourceType.framebuffer
                });
                return new RenderTargetHandle(_this.renderer.engine, {
                    texture: texture
                });
            });
            this.attachments.forEach(function(att) {
                return !att.externalTexture && att.dispose();
            });
            this.attachments = attachments;
            if (this.framebuffer) {
                this.framebuffer.bind();
                this.framebuffer.resetColorTextures(colors.map(function(color) {
                    return color;
                }));
            }
        }
    };
    /**
   * 重置所有 Attachment，会替换掉所有 Attachment
   * @param options - Attachment 和视口数据
   */ _proto.resetAttachments = function resetAttachments(options) {
        this.options = options;
        this.setViewportOptions(options);
        if (this.renderer) {
            this._resetAttachments();
        }
    };
    _proto.setViewportOptions = function setViewportOptions(options) {
        if (options.viewport) {
            this.isCustomViewport = true;
            this.viewportScale = 1;
            this.customViewport = options.viewport.slice(0, 4);
            if (this.framebuffer) {
                var vp = this.customViewport;
                // TODO 为什么framebuffer和renderpass的isCustomViewport不一样？
                this.framebuffer.isCustomViewport = false;
                this.framebuffer.resize(vp[0], vp[1], vp[2], vp[3]);
            }
        } else {
            this.isCustomViewport = false;
            this.viewportScale = options.viewportScale || 1;
            if (this.framebuffer) {
                this.framebuffer.isCustomViewport = true;
                this.framebuffer.viewportScale = this.viewportScale;
            }
        }
    };
    _proto._resetAttachments = function _resetAttachments() {
        var _this = this;
        var _options_attachments;
        var renderer = this.renderer;
        var options = this.options;
        if (this.attachments.length) {
            var _this_framebuffer;
            this.attachments.forEach(function(att) {
                return !att.externalTexture && att.dispose();
            });
            this.attachments.length = 0;
            (_this_framebuffer = this.framebuffer) == null ? void 0 : _this_framebuffer.dispose({
                depthStencilAttachment: 2
            });
            this.framebuffer = null;
        }
        var vs = this.viewportScale;
        // renderpass 的 viewport 相关参数都需要动态的修改
        var viewport = this.isCustomViewport ? this.customViewport : [
            0,
            0,
            renderer.getWidth() * vs,
            renderer.getHeight() * vs
        ];
        var size = [
            viewport[2],
            viewport[3]
        ];
        var name = this.name;
        if ((_options_attachments = options.attachments) == null ? void 0 : _options_attachments.length) {
            var attachments = options.attachments.map(function(attr, index) {
                var _attr_texture;
                var attachment = new RenderTargetHandle(_this.renderer.engine, _extends({
                    size: size,
                    name: ((_attr_texture = attr.texture) == null ? void 0 : _attr_texture.name) || name + "##color_" + index
                }, attr));
                return attachment;
            });
            this.attachments = attachments;
            var framebuffer = Framebuffer.create({
                storeAction: this.storeAction,
                name: name,
                viewport: viewport,
                viewportScale: this.viewportScale,
                isCustomViewport: this.isCustomViewport,
                attachments: attachments.map(function(att) {
                    return att.texture;
                }),
                depthStencilAttachment: options.depthStencilAttachment || {
                    storageType: 0
                }
            }, renderer);
            framebuffer.bind();
            framebuffer.unbind();
            this.framebuffer = framebuffer;
        } else {
            this.attachments.length = 0;
        }
    };
    /**
   * 获取当前视口大小，格式：[x偏移，y偏移，宽度，高度]
   */ _proto.getViewport = function getViewport() {
        var _this_framebuffer;
        var ret = ((_this_framebuffer = this.framebuffer) == null ? void 0 : _this_framebuffer.viewport) || this.customViewport;
        if (ret) {
            return ret;
        }
        var renderer = this.renderer;
        var vs = this.viewportScale;
        return renderer ? [
            0,
            0,
            renderer.getWidth() * vs,
            renderer.getHeight() * vs
        ] : [
            0,
            0,
            0,
            0
        ];
    };
    /**
   * 获取深度 Attachment，可能没有
   */ _proto.getDepthAttachment = function getDepthAttachment() {
        var framebuffer = this.framebuffer;
        if (framebuffer) {
            var depthTexture = framebuffer.getDepthTexture();
            var texture = depthTexture ? this.getDepthTexture(depthTexture, framebuffer.externalStorage) : undefined;
            return {
                storageType: framebuffer.depthStencilStorageType,
                storage: framebuffer.depthStorage,
                texture: texture
            };
        }
    };
    /**
   * 获取蒙版 Attachment，可能没有
   */ _proto.getStencilAttachment = function getStencilAttachment() {
        var framebuffer = this.framebuffer;
        if (framebuffer) {
            var stencilTexture = framebuffer.getStencilTexture();
            var texture = stencilTexture ? this.getDepthTexture(stencilTexture, framebuffer.externalStorage) : undefined;
            return {
                storageType: framebuffer.depthStencilStorageType,
                storage: framebuffer.stencilStorage,
                texture: texture
            };
        }
    };
    _proto.getDepthTexture = function getDepthTexture(texture, external) {
        if (!this.depthTexture) {
            var _this_options_depthStencilAttachment;
            var outTex = (_this_options_depthStencilAttachment = this.options.depthStencilAttachment) == null ? void 0 : _this_options_depthStencilAttachment.texture;
            var tex = texture === outTex ? outTex : texture;
            // TODO 为什么要initialize？
            //tex.initialize(this.renderer.glRenderer.pipelineContext);
            if (!external) {
                this.depthTexture = tex;
            }
            return tex;
        }
        return this.depthTexture;
    };
    _proto.getStencilTexture = function getStencilTexture(texture, external) {
        if (!this.stencilTexture) {
            var _this_options_depthStencilAttachment;
            var outTex = (_this_options_depthStencilAttachment = this.options.depthStencilAttachment) == null ? void 0 : _this_options_depthStencilAttachment.texture;
            var tex = texture === outTex ? outTex : texture;
            if (!external) {
                this.stencilTexture = tex;
            }
            return tex;
        }
        return this.stencilTexture;
    };
    // 生成并初始化帧缓冲
    _proto.initialize = function initialize(renderer) {
        if (!this.initialized) {
            this._resetAttachments();
            this.initialized = true;
        }
        return this;
    };
    /**
   * 销毁 RenderPass
   * @param options - 有选择销毁内部对象
   */ _proto.dispose = function dispose(options) {
        if (this.destroyed) {
            return;
        }
        var destroyMeshOption = (options == null ? void 0 : options.meshes) || undefined;
        if (destroyMeshOption !== exports.DestroyOptions.keep) {
            this.meshes.forEach(function(mesh) {
                mesh.dispose(destroyMeshOption);
            });
        }
        this.meshes.length = 0;
        var colorOpt = (options == null ? void 0 : options.colorAttachment) ? options.colorAttachment : 0;
        this.attachments.forEach(function(att) {
            var keep = att.externalTexture && colorOpt === 2 || colorOpt === 1;
            if (!keep) {
                att.dispose();
            }
        });
        this.attachments.length = 0;
        if ((options == null ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        this.destroyed = true;
        var depthStencilOpt = (options == null ? void 0 : options.depthStencilAttachment) ? options.depthStencilAttachment : 0;
        var fbo = this.framebuffer;
        if (fbo) {
            fbo.dispose({
                depthStencilAttachment: depthStencilOpt
            });
            var keep = fbo.externalStorage && depthStencilOpt === 2 || depthStencilOpt === 1;
            if (!keep) {
                var _this_stencilTexture, _this_depthTexture;
                (_this_stencilTexture = this.stencilTexture) == null ? void 0 : _this_stencilTexture.dispose();
                (_this_depthTexture = this.depthTexture) == null ? void 0 : _this_depthTexture.dispose();
            }
        }
        // @ts-expect-error safe to assign
        this.options = this.renderer = null;
        this.initialize = throwDestroyedError;
    };
    _create_class(RenderPass, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        },
        {
            key: "viewport",
            get: function get() {
                return this.getViewport();
            }
        },
        {
            key: "stencilAttachment",
            get: function get() {
                return this.getStencilAttachment();
            }
        },
        {
            key: "depthAttachment",
            get: function get() {
                return this.getDepthAttachment();
            }
        }
    ]);
    return RenderPass;
}();

var blend = "vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;float alpha=ret.a;if(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}";

var itemFrameFrag = "#version 100\nprecision highp float;vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;float alpha=ret.a;if(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}varying vec4 vColor;varying vec4 vTexCoord;varying highp vec2 vParams;uniform vec3 uFrameColor;void main(){gl_FragColor=vec4(uFrameColor.xyz,1.0);}";

var integrate = "float calculateMovement(float t,vec2 p1,vec2 p2,vec2 p3,vec2 p4){float movement=0.0;float h=(t-p1.x)*0.05;for(int i=0;i<=20;i++){float t=float(i)*h;float nt=binarySearchT(t,p1.x,p2.x,p3.x,p4.x);float y=cubicBezier(nt,p1.y,p2.y,p3.y,p4.y);float weight=(i==0||i==20)? 1.0 :(mod(float(i),2.)!=0.)? 4.0 : 2.0;movement+=weight*y;}movement*=h/3.;return movement;}float integrateFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i+=2){vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return ret;}vec2 p1=vec2(k0.x,k0.y);vec2 p2=vec2(k0.z,k0.w);vec2 p3=vec2(k1.z,k1.w);vec2 p4=vec2(k1.x,k1.y);if(time>=k1.x){ret+=calculateMovement(k1.x,p1,p2,p3,p4);}if(time>=k0.x&&time<k1.x){return ret+calculateMovement(time,p1,p2,p3,p4);}}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;vec4 tSqr=vec4(t,t,t0,t0);tSqr=tSqr*tSqr;vec4 a=vec4(2.*t,3.,-t0,3.)*tSqr;float t1y0=t1*y0;vec4 b=vec4(y0-y1,t0*y1-t1y0,2.*y0+y1,t1y0);float r=dot(a,b);return r/(t0-t1)*0.16666667;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w);}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w)-integrateFromBezierCurveFrames(t0,value.z,value.w);}return 0.;}";

var itemVert = "precision highp float;attribute vec2 atlasOffset;attribute vec3 aPos;varying vec2 vTexCoord;varying vec3 vParams;varying vec4 vColor;uniform vec2 _Size;uniform vec4 _Color;uniform vec4 _TexParams;uniform vec4 _TexOffset;uniform mat4 effects_MatrixVP;uniform mat4 effects_MatrixInvV;uniform mat4 effects_ObjectToWorld;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvoid main(){vec4 texParams=_TexParams;vTexCoord=vec2(atlasOffset.xy*_TexOffset.zw+_TexOffset.xy);vColor=_Color;vParams=vec3(0.0,texParams.y,texParams.x);vec4 pos=vec4(aPos.xy*_Size,aPos.z,1.0);gl_Position=effects_MatrixVP*effects_ObjectToWorld*pos;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}";

var itemFrag = "precision highp float;varying vec4 vColor;varying vec2 vTexCoord;varying vec3 vParams;uniform sampler2D uSampler0;vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;float alpha=ret.a;if(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}void main(){vec4 color=vec4(0.);vec4 texColor=texture2D(uSampler0,vTexCoord.xy);color=blendColor(texColor,vColor,floor(0.5+vParams.y));if(vParams.z==0.&&color.a<0.04){discard;}color.a=clamp(color.a,0.0,1.0);gl_FragColor=color;}";

var particleFrag = "#version 100\nprecision mediump float;vec4 blendColor(vec4 color,vec4 vc,float mode){vec4 ret=color*vc;float alpha=ret.a;if(mode==1.){ret.rgb*=alpha;}else if(mode==2.){ret.rgb*=alpha;ret.a=dot(ret.rgb,vec3(0.33333333));}else if(mode==3.){alpha=color.r*alpha;ret=vec4(vc.rgb*alpha,alpha);}return ret;}\n#define PATICLE_SHADER 1\nvarying float vLife;varying vec2 vTexCoord;varying vec4 vColor;uniform vec3 emissionColor;uniform float emissionIntensity;uniform sampler2D uMaskTex;uniform vec4 uColorParams;uniform vec2 uTexOffset;\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#ifdef USE_SPRITE\nvarying vec4 vTexCoordBlend;\n#endif\nvarying float vSeed;\n#ifdef PREVIEW_BORDER\nuniform vec4 uPreviewColor;\n#endif\n#ifdef USE_SPRITE\nvec4 getTextureColor(sampler2D tex,vec2 texCoord){if(vTexCoordBlend.w>0.){return mix(texture2D(tex,texCoord),texture2D(tex,vTexCoordBlend.xy+texCoord),vTexCoordBlend.z);}return texture2D(tex,texCoord);}\n#else\n#define getTextureColor texture2D\n#endif\n#ifndef WEBGL2\n#define round(a) floor(0.5+a)\n#endif\n#ifdef PREVIEW_BORDER\nvoid main(){gl_FragColor=uPreviewColor;}\n#else\nvoid main(){vec4 color=vec4(1.0);vec4 tempColor=vColor;vec2 texOffset=uTexOffset;if(vLife<0.){discard;}if(uColorParams.x>0.0){color=getTextureColor(uMaskTex,vTexCoord);}\n#ifdef COLOR_OVER_LIFETIME\n#ifndef ENABLE_VERTEX_TEXTURE\ntempColor*=texture2D(uColorOverLifetime,vec2(vLife,0.));\n#endif\n#endif\ncolor=blendColor(color,tempColor,round(uColorParams.y));if(color.a<=0.01&&uColorParams.w>0.){float _at=texture2D(uMaskTex,vTexCoord+texOffset).a+texture2D(uMaskTex,vTexCoord+texOffset*-1.).a;if(_at<=0.02){discard;}}vec3 emission=emissionColor*pow(2.0,emissionIntensity);color=vec4(pow(pow(color.rgb,vec3(2.2))+emission,vec3(1.0/2.2)),color.a);gl_FragColor=color;}\n#endif\n";

var particleVert = "#version 100\nprecision mediump float;\n#define SHADER_VERTEX 1\n#define PATICLE_SHADER 1\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nattribute float aSeed;varying float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}float calculateMovement(float t,vec2 p1,vec2 p2,vec2 p3,vec2 p4){float movement=0.0;float h=(t-p1.x)*0.05;for(int i=0;i<=20;i++){float t=float(i)*h;float nt=binarySearchT(t,p1.x,p2.x,p3.x,p4.x);float y=cubicBezier(nt,p1.y,p2.y,p3.y,p4.y);float weight=(i==0||i==20)? 1.0 :(mod(float(i),2.)!=0.)? 4.0 : 2.0;movement+=weight*y;}movement*=h/3.;return movement;}float integrateFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i+=2){vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return ret;}vec2 p1=vec2(k0.x,k0.y);vec2 p2=vec2(k0.z,k0.w);vec2 p3=vec2(k1.z,k1.w);vec2 p4=vec2(k1.x,k1.y);if(time>=k1.x){ret+=calculateMovement(k1.x,p1,p2,p3,p4);}if(time>=k0.x&&time<k1.x){return ret+calculateMovement(time,p1,p2,p3,p4);}}return ret;}float integrateByTimeLineSeg(float t,vec2 p0,vec2 p1){float t0=p0.x;float t1=p1.x;float y0=p0.y;float y1=p1.y;vec4 tSqr=vec4(t,t,t0,t0);tSqr=tSqr*tSqr;vec4 a=vec4(2.*t,3.,-t0,3.)*tSqr;float t1y0=t1*y0;vec4 b=vec4(y0-y1,t0*y1-t1y0,2.*y0+y1,t1y0);float r=dot(a,b);return r/(t0-t1)*0.16666667;}float integrateLineSeg(float time,vec2 p0,vec2 p1){float h=time-p0.x;float y0=p0.y;return(y0+y0+(p1.y-y0)*h/(p1.x-p0.x))*h/2.;}float integrateFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateLineSeg(time,k0,k1);}ret+=integrateLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateLineSeg(time,k1,k2);}ret+=integrateLineSeg(k2.x,k1,k2);}return ret;}float integrateByTimeFromLineSeg(float time,float frameStart,float frameCount){if(time==0.){return 0.;}int start=int(frameStart);int count=int(frameCount-1.);float ret=0.;for(int i=0;i<ITR_END;i++){if(i>count){return ret;}vec4 ks=lookup_curve(i+start);vec2 k0=ks.xy;vec2 k1=ks.zw;if(time>k0.x&&time<=k1.x){return ret+integrateByTimeLineSeg(time,k0,k1);}ret+=integrateByTimeLineSeg(k1.x,k0,k1);vec2 k2=lookup_curve(i+start+1).xy;if(time>k1.x&&time<=k2.x){return ret+integrateByTimeLineSeg(time,k1,k2);}ret+=integrateByTimeLineSeg(k2.x,k1,k2);}return ret;}float getIntegrateFromTime0(float t1,vec4 value){float type=value.x;if(type==0.){return value.y*t1;}if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateLineSeg(t1,p0,p1);}if(type==3.){return integrateFromLineSeg(t1,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*t1;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w);}return 0.;}float getIntegrateByTimeFromTime(float t0,float t1,vec4 value){float type=value.x;if(type==0.){return value.y*(t1*t1-t0*t0)/2.;}else if(type==1.){vec2 p0=vec2(0.,value.y);vec2 p1=vec2(value.w,value.z);return integrateByTimeLineSeg(t1,p0,p1)-integrateByTimeLineSeg(t0,p0,p1);}if(type==3.){return integrateByTimeFromLineSeg(t1,value.y,value.z)-integrateByTimeFromLineSeg(t0,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed)*(t1*t1-t0*t0)/2.;}if(type==5.){return integrateFromBezierCurveFrames(t1,value.z,value.w)-integrateFromBezierCurveFrames(t0,value.z,value.w);}return 0.;}const float d2r=3.141592653589793/180.;attribute vec3 aPos;attribute vec4 aOffset;attribute vec3 aVel;attribute vec3 aRot;attribute vec4 aColor;attribute vec3 aDirX;attribute vec3 aDirY;\n#ifdef USE_SPRITE\nattribute vec3 aSprite;uniform vec4 uSprite;struct UVDetail{vec2 uv0;vec3 uv1;};UVDetail getSpriteUV(vec2 uv,float lifeTime);varying vec4 vTexCoordBlend;\n#endif\n#ifdef FINAL_TARGET\nuniform vec3 uFinalTarget;uniform vec4 uForceCurve;\n#endif\nuniform mat4 effects_ObjectToWorld;uniform mat4 effects_MatrixV;uniform mat4 effects_MatrixVP;uniform vec4 uParams;uniform vec4 uAcceleration;uniform vec4 uGravityModifierValue;uniform vec4 uOpacityOverLifetimeValue;\n#ifdef ROT_X_LIFETIME\nuniform vec4 uRXByLifeTimeValue;\n#endif\n#ifdef ROT_Y_LIFETIME\nuniform vec4 uRYByLifeTimeValue;\n#endif\n#ifdef ROT_Z_LIFETIME\nuniform vec4 uRZByLifeTimeValue;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n#if LINEAR_VEL_X\nuniform vec4 uLinearXByLifetimeValue;\n#endif\n#if LINEAR_VEL_Y\nuniform vec4 uLinearYByLifetimeValue;\n#endif\n#if LINEAR_VEL_Z\nuniform vec4 uLinearZByLifetimeValue;\n#endif\n#endif\n#ifdef SPEED_OVER_LIFETIME\nuniform vec4 uSpeedLifetimeValue;\n#endif\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n#if ORB_VEL_X\nuniform vec4 uOrbXByLifetimeValue;\n#endif\n#if ORB_VEL_Y\nuniform vec4 uOrbYByLifetimeValue;\n#endif\n#if ORB_VEL_Z\nuniform vec4 uOrbZByLifetimeValue;\n#endif\nuniform vec3 uOrbCenter;\n#endif\nuniform vec4 uSizeByLifetimeValue;\n#ifdef SIZE_Y_BY_LIFE\nuniform vec4 uSizeYByLifetimeValue;\n#endif\nvarying float vLife;varying vec4 vColor;varying vec2 vTexCoord;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvec3 calOrbitalMov(float _life,float _dur){vec3 orb=vec3(0.0);\n#ifdef AS_ORBITAL_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if ORB_VEL_X\norb.x=FUNC(uOrbXByLifetimeValue);\n#endif\n#if ORB_VEL_Y\norb.y=FUNC(uOrbYByLifetimeValue);\n#endif\n#if ORB_VEL_Z\norb.z=FUNC(uOrbZByLifetimeValue);\n#endif\n#undef FUNC\nreturn orb;}vec3 calLinearMov(float _life,float _dur){vec3 mov=vec3(0.0);\n#ifdef AS_LINEAR_MOVEMENT\n#define FUNC(a) getValueFromTime(_life,a)\n#else\n#define FUNC(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#if LINEAR_VEL_X\nmov.x=FUNC(uLinearXByLifetimeValue);\n#endif\n#if LINEAR_VEL_Y\nmov.y=FUNC(uLinearYByLifetimeValue);\n#endif\n#if LINEAR_VEL_Z\nmov.z=FUNC(uLinearZByLifetimeValue);\n#endif\n#undef FUNC\nreturn mov;}mat3 mat3FromRotation(vec3 rotation){vec3 sinR=sin(rotation*d2r);vec3 cosR=cos(rotation*d2r);return mat3(cosR.z,-sinR.z,0.,sinR.z,cosR.z,0.,0.,0.,1.)*mat3(cosR.y,0.,sinR.y,0.,1.,0.,-sinR.y,0,cosR.y)*mat3(1.,0.,0.,0,cosR.x,-sinR.x,0.,sinR.x,cosR.x);}\n#ifdef USE_SPRITE\nUVDetail getSpriteUV(vec2 uv,float lifeTime){float t=fract(clamp((lifeTime-aSprite.x)/aSprite.y,0.0,1.)*aSprite.z);float frame=uSprite.z*t;float frameIndex=max(ceil(frame)-1.,0.);float row=floor((frameIndex+0.1)/uSprite.x);float col=frameIndex-row*uSprite.x;vec2 retUV=(vec2(col,row)+uv)/uSprite.xy;UVDetail ret;if(uSprite.w>0.){float blend=frame-frameIndex;float frameIndex1=min(ceil(frame),uSprite.z-1.);float row1=floor((frameIndex1+0.1)/uSprite.x);float col1=frameIndex1-row1*uSprite.x;vec2 coord=(vec2(col1,row1)+uv)/uSprite.xy-retUV;ret.uv1=vec3(coord.x,1.-coord.y,blend);}ret.uv0=vec2(retUV.x,1.-retUV.y);return ret;}\n#endif\nvec3 calculateTranslation(vec3 vel,float t0,float t1,float dur){float dt=t1-t0;float d=getIntegrateByTimeFromTime(0.,dt,uGravityModifierValue);vec3 acc=uAcceleration.xyz*d;\n#ifdef SPEED_OVER_LIFETIME\nreturn vel*getIntegrateFromTime0(dt/dur,uSpeedLifetimeValue)*dur+acc;\n#endif\nreturn vel*dt+acc;}mat3 transformFromRotation(vec3 rot,float _life,float _dur){vec3 rotation=rot;\n#ifdef ROT_LIFETIME_AS_MOVEMENT\n#define FUNC1(a) getValueFromTime(_life,a)\n#else\n#define FUNC1(a) getIntegrateFromTime0(_life,a) * _dur\n#endif\n#ifdef ROT_X_LIFETIME\nrotation.x+=FUNC1(uRXByLifeTimeValue);\n#endif\n#ifdef ROT_Y_LIFETIME\nrotation.y+=FUNC1(uRYByLifeTimeValue);\n#endif\n#ifdef ROT_Z_LIFETIME\nrotation.z+=FUNC1(uRZByLifeTimeValue);\n#endif\nif(dot(rotation,rotation)==0.0){return mat3(1.0);}\n#undef FUNC1\nreturn mat3FromRotation(rotation);}void main(){float time=uParams.x-aOffset.z;float dur=aOffset.w;if(time<0.||time>dur){gl_Position=vec4(-3.,-3.,-3.,1.);}else{float life=clamp(time/dur,0.0,1.0);vLife=life;\n#ifdef USE_SPRITE\nUVDetail uvD=getSpriteUV(aOffset.xy,time);vTexCoord=uvD.uv0;vTexCoordBlend=vec4(uvD.uv1,uSprite.w);\n#else\nvTexCoord=aOffset.xy;\n#endif\nvColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(life,0.));\n#endif\n#endif\nvColor.a*=clamp(getValueFromTime(life,uOpacityOverLifetimeValue),0.,1.);vec3 size=vec3(vec2(getValueFromTime(life,uSizeByLifetimeValue)),1.0);\n#ifdef SIZE_Y_BY_LIFE\nsize.y=getValueFromTime(life,uSizeYByLifetimeValue);\n#endif\nvec3 point=transformFromRotation(aRot,life,dur)*(aDirX*size.x+aDirY*size.y);vec3 pt=calculateTranslation(aVel,aOffset.z,uParams.x,dur);vec3 _pos=aPos+pt;\n#if ORB_VEL_X + ORB_VEL_Y + ORB_VEL_Z\n_pos=mat3FromRotation(calOrbitalMov(life,dur))*(_pos-uOrbCenter);_pos+=uOrbCenter;\n#endif\n#if LINEAR_VEL_X + LINEAR_VEL_Y + LINEAR_VEL_Z\n_pos.xyz+=calLinearMov(life,dur);\n#endif\n#ifdef FINAL_TARGET\nfloat force=getValueFromTime(life,uForceCurve);vec4 pos=vec4(mix(_pos,uFinalTarget,force),1.);\n#else\nvec4 pos=vec4(_pos,1.0);\n#endif\n#if RENDER_MODE == 1\npos.xyz+=point;pos=effects_ObjectToWorld*pos;\n#elif RENDER_MODE == 3\npos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixV[0].xyz*point.x+effects_MatrixV[2].xyz*point.y;\n#elif RENDER_MODE == 2\npos=effects_ObjectToWorld*pos;pos.xy+=point.xy;\n#elif RENDER_MODE == 0\npos=effects_ObjectToWorld*pos;pos.xyz+=effects_MatrixV[0].xyz*point.x+effects_MatrixV[1].xyz*point.y;\n#endif\ngl_Position=effects_MatrixVP*pos;vSeed=aSeed;gl_PointSize=6.0;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}}";

var trailVert = "#version 100\nprecision mediump float;\n#define SHADER_VERTEX 1\n#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nattribute float aSeed;varying float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}attribute vec4 aPos;attribute vec3 aDir;attribute vec3 aInfo;attribute vec4 aColor;attribute float aTime;\n#ifdef ATTR_TRAIL_START\nattribute float aTrailStart;\n#else\nuniform float uTrailStart[64];attribute float aTrailStartIndex;\n#endif\nuniform mat4 effects_MatrixInvV;uniform mat4 effects_ObjectToWorld;uniform mat4 effects_MatrixVP;uniform vec4 uTextureMap;uniform float uTime;uniform vec4 uParams;uniform vec4 uColorParams;uniform vec4 uOpacityOverLifetimeValue;uniform vec4 uWidthOverTrail;\n#ifdef COLOR_OVER_TRAIL\nuniform sampler2D uColorOverTrail;\n#endif\n#ifdef COLOR_OVER_LIFETIME\nuniform sampler2D uColorOverLifetime;\n#endif\nvarying float vLife;varying vec2 vTexCoord;varying vec4 vColor;\n#ifdef ENV_EDITOR\nuniform vec4 uEditorTransform;\n#endif\nvoid main(){vec4 _pa=effects_MatrixVP*vec4(aPos.xyz,1.);vec4 _pb=effects_MatrixVP*vec4(aPos.xyz+aDir,1.);vec2 dir=normalize(_pb.xy/_pb.w-_pa.xy/_pa.w);vec2 screen_xy=vec2(-dir.y,dir.x);vec4 pos=effects_ObjectToWorld*vec4(aPos.xyz,1.);\n#ifdef ATTR_TRAIL_START\nfloat ts=aTrailStart;\n#else\nfloat ts=uTrailStart[int(aTrailStartIndex)];\n#endif\nfloat trail=(ts-aInfo.y)/uParams.y;float width=aPos.w*getValueFromTime(trail,uWidthOverTrail)/max(abs(screen_xy.x),abs(screen_xy.y));pos.xyz+=(effects_MatrixInvV[0].xyz*screen_xy.x+effects_MatrixInvV[1].xyz*screen_xy.y)*width;float time=min((uTime-aTime)/aInfo.x,1.0);gl_Position=effects_MatrixVP*pos;vColor=aColor;\n#ifdef COLOR_OVER_LIFETIME\n#ifdef ENABLE_VERTEX_TEXTURE\nvColor*=texture2D(uColorOverLifetime,vec2(time,0.));\n#endif\n#endif\n#ifdef COLOR_OVER_TRAIL\nvColor*=texture2D(uColorOverTrail,vec2(trail,0.));\n#endif\nvColor.a*=clamp(getValueFromTime(time,uOpacityOverLifetimeValue),0.,1.);vLife=time;vTexCoord=uTextureMap.xy+vec2(trail,aInfo.z)*uTextureMap.zw;vSeed=aSeed;\n#ifdef ENV_EDITOR\ngl_Position=vec4(gl_Position.xy*uEditorTransform.xy+uEditorTransform.zw*gl_Position.w,gl_Position.zw);\n#endif\n}";

var value = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n#define NONE_CONST_INDEX 1\n#ifdef SHADER_VERTEX\nattribute float aSeed;varying float vSeed;\n#endif\n#ifdef SHADER_VERTEX\n#define MAX_C VERT_MAX_KEY_FRAME_COUNT\n#else\n#define MAX_C FRAG_MAX_KEY_FRAME_COUNT\n#endif\nmat4 cubicBezierMatrix=mat4(1.0,-3.0,3.0,-1.0,0.0,3.0,-6.0,3.0,0.0,0.0,3.0,-3.0,0.0,0.0,0.0,1.0);float cubicBezier(float t,float y1,float y2,float y3,float y4){vec4 tVec=vec4(1.0,t,t*t,t*t*t);vec4 yVec=vec4(y1,y2,y3,y4);vec4 result=tVec*cubicBezierMatrix*yVec;return result.x+result.y+result.z+result.w;}float binarySearchT(float x,float x1,float x2,float x3,float x4){float left=0.0;float right=1.0;float mid=0.0;float computedX;for(int i=0;i<8;i++){mid=(left+right)*0.5;computedX=cubicBezier(mid,x1,x2,x3,x4);if(abs(computedX-x)<0.0001){break;}else if(computedX>x){right=mid;}else{left=mid;}}return mid;}float valueFromBezierCurveFrames(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);for(int i=0;i<ITR_END;i+=2){if(i>=count){break;}vec4 k0=lookup_curve(i+start);vec4 k1=lookup_curve(i+1+start);if(i==0&&time<k0.x){return k0.y;}if(i==int(frameCount-2.)&&time>=k1.x){return k1.y;}if(time>=k0.x&&time<=k1.x){float t=(time-k0.x)/(k1.x-k0.x);float nt=binarySearchT(time,k0.x,k0.z,k1.z,k1.x);return cubicBezier(nt,k0.y,k0.w,k1.w,k1.y);}}}float evaluteLineSeg(float t,vec2 p0,vec2 p1){return p0.y+(p1.y-p0.y)*(t-p0.x)/(p1.x-p0.x);}float valueFromLineSegs(float time,float frameStart,float frameCount){int start=int(frameStart);int count=int(frameCount-1.);int end=start+count;for(int i=0;i<ITR_END;i++){if(i>count){return lookup_curve(i).w;}vec4 seg=lookup_curve(i+start);vec2 p0=seg.xy;vec2 p1=seg.zw;if(time>=p0.x&&time<=p1.x){return evaluteLineSeg(time,p0,p1);}vec2 p2=lookup_curve(i+start+1).xy;if(time>p1.x&&time<=p2.x){return evaluteLineSeg(time,p1,p2);}}return lookup_curve(0).y;}float getValueFromTime(float time,vec4 value){float type=value.x;if(type==0.){return value.y;}if(type==1.){return mix(value.y,value.z,time/value.w);}if(type==3.){return valueFromLineSegs(time,value.y,value.z);}if(type==4.){return mix(value.y,value.z,aSeed);}if(type==5.){return valueFromBezierCurveFrames(time,value.z,value.w);}return 0.;}";

var valueDefine = "#ifdef SHADER_VERTEX\n#define CURVE_VALUE_TEXTURE uVCurveValueTexture\n#define CURVE_VALUE_ARRAY uVCurveValues\n#define CURVE_VALUE_COUNT VERT_CURVE_VALUE_COUNT\n#define FRAG_CURVE_VALUE_COUNT 0\n#else\n#define CURVE_VALUE_TEXTURE uFCurveValueTexture\n#define CURVE_VALUE_ARRAY uFCurveValues\n#define CURVE_VALUE_COUNT FRAG_CURVE_VALUE_COUNT\n#define VERT_CURVE_VALUE_COUNT 0\n#endif\n#if CURVE_VALUE_COUNT > 0\n#if LOOKUP_TEXTURE_CURVE\nuniform sampler2D CURVE_VALUE_TEXTURE;const float uCurveCount=1./float(CURVE_VALUE_COUNT);\n#define lookup_curve(i) texture2D(CURVE_VALUE_TEXTURE,vec2(float(i) * uCurveCount,0.))\n#else\nuniform vec4 CURVE_VALUE_ARRAY[CURVE_VALUE_COUNT];\n#define lookup_curve(i) CURVE_VALUE_ARRAY[i]\n#endif\n#else\n#define lookup_curve(i) vec4(0.)\n#endif\n#ifdef WEBGL2\n#define ITR_END (count + 1)\n#else\n#define ITR_END MAX_C\n#endif\n";

var screenMeshVert = "precision highp float;attribute vec2 aPos;varying vec2 uv;void main(){gl_Position=vec4(aPos,0.,1.0);uv=(aPos+vec2(1.0))/2.;}";

var colorGradingFrag = "precision highp float;\n#define HALF_MAX 60000.0\n#define ACEScc_MIDGRAY 0.4135884\nvarying vec2 uv;uniform sampler2D _GaussianTex;uniform sampler2D _SceneTex;uniform float _BloomIntensity;uniform float _Brightness;uniform float _Saturation;uniform float _Contrast;uniform bool _UseBloom;uniform bool _UseToneMapping;uniform vec3 _VignetteColor;uniform vec2 _VignetteCenter;uniform float _VignetteIntensity;uniform float _VignetteSmoothness;uniform float _VignetteRoundness;mat3 LinearToACES=mat3(0.59719,0.07600,0.02840,0.35458,0.90834,0.13383,0.04823,0.01566,0.83777);mat3 ACESToLinear=mat3(1.60475,-0.10208,-0.00327,-0.53108,1.10813,-0.07276,-0.07367,-0.00605,1.07602);float log10(float x){return log(x)/log(10.0);}vec3 log10(vec3 v){return vec3(log10(v.x),log10(v.y),log10(v.z));}vec3 LinearToLogC(vec3 x){return 0.244161*log10(5.555556*x+0.047996)+0.386036;}vec3 LogCToLinear(vec3 x){return(pow(vec3(10.0),(x-0.386036)/0.244161)-0.047996)/5.555556;}vec3 rrt_and_odt_fit(vec3 col){vec3 a=col*(col+0.0245786)-0.000090537;vec3 b=col*(0.983729*col+0.4329510)+0.238081;return a/b;}vec3 ACESToneMapping(vec3 col){vec3 aces=LinearToACES*col;aces=rrt_and_odt_fit(aces);col=ACESToLinear*aces;return col;}vec3 LinearToSrgb(vec3 c){return mix(1.055*pow(c,vec3(1./2.4))-0.055,12.92*c,step(c,vec3(0.0031308)));}vec3 GammaCorrection(vec3 c){return pow(c,vec3(1.0/2.2));}vec3 ApplyVignette(vec3 inputColor,vec2 uv,vec2 center,float intensity,float roundness,float smoothness,vec3 color){vec2 dist=abs(uv-center)*intensity;dist.x*=roundness;float vfactor=pow(clamp((1.0-dot(dist,dist)),0.0,1.0),smoothness);return inputColor*mix(color,vec3(1.0),vfactor);}void main(){vec4 hdrColor=texture2D(_SceneTex,uv);hdrColor*=hdrColor.a;hdrColor.rgb=pow(hdrColor.rgb,vec3(2.2));vec3 finalColor=hdrColor.rgb;if(_UseBloom){vec4 bloomColor=texture2D(_GaussianTex,uv);bloomColor.rgb*=_BloomIntensity;finalColor+=bloomColor.rgb;}if(_VignetteIntensity>0.0){finalColor=ApplyVignette(finalColor,uv,_VignetteCenter,_VignetteIntensity,_VignetteRoundness,_VignetteSmoothness,_VignetteColor);}finalColor=finalColor*_Brightness;vec3 colorLog=LinearToLogC(finalColor);colorLog=(colorLog-ACEScc_MIDGRAY)*_Contrast+ACEScc_MIDGRAY;finalColor=LogCToLinear(colorLog);finalColor=max(finalColor,0.0);float luminance=0.2125*finalColor.r+0.7154*finalColor.g+0.0721*finalColor.b;vec3 luminanceColor=vec3(luminance,luminance,luminance);finalColor=(finalColor-luminanceColor)*_Saturation+luminanceColor;finalColor=max(finalColor,0.0);if(_UseToneMapping){finalColor=max(vec3(0.0),ACESToneMapping(finalColor));}gl_FragColor=vec4(clamp(GammaCorrection(finalColor),0.0,1.0),1.0);}";

var gaussianDown_frag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;float GaussWeight2D(float x,float y,float sigma){float PI=3.14159265358;float E=2.71828182846;float sigma_2=pow(sigma,2.0);float a=-(x*x+y*y)/(2.0*sigma_2);return pow(E,a)/(2.0*PI*sigma_2);}vec3 GaussNxN(sampler2D tex,vec2 uv,vec2 stride,float sigma){vec3 color=vec3(0.,0.,0.);const int r=5/2;float weight=0.0;for(int i=-r;i<=r;i++){for(int j=-r;j<=r;j++){float w=GaussWeight2D(float(i),float(j),sigma);vec2 coord=uv+vec2(i,j)*stride;color+=texture2D(tex,coord).rgb*w;weight+=w;}}color/=weight;return color;}void main(){vec4 mainColor=texture2D(_MainTex,uv);vec3 color=mainColor.rgb;color=GaussNxN(_MainTex,uv,1.0/_TextureSize,1.0);gl_FragColor=vec4(color,1.0);}";

var gaussianDownHFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;vec3 GaussH(sampler2D tex,vec2 uv){vec3 color=vec3(0.0);float offsets[9];offsets[0]=-4.0;offsets[1]=-3.0;offsets[2]=-2.0;offsets[3]=-1.0;offsets[4]=0.0;offsets[5]=1.0;offsets[6]=2.0;offsets[7]=3.0;offsets[8]=4.0;float weights[9];weights[0]=0.01621622;weights[1]=0.05405405;weights[2]=0.12162162;weights[3]=0.19459459;weights[4]=0.22702703;weights[5]=0.19459459;weights[6]=0.12162162;weights[7]=0.05405405;weights[8]=0.01621622;for(int i=0;i<9;i++){vec2 offset=vec2(offsets[i]*2.0*(1.0/_TextureSize.x),0);color+=texture2D(tex,uv+offset).rgb*weights[i];}return color;}void main(){vec3 color=GaussH(_MainTex,uv);gl_FragColor=vec4(color,1.0);}";

var gaussianDownVFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform vec2 _TextureSize;vec3 GaussV(sampler2D tex,vec2 uv){vec3 color=vec3(0.0);float offsets[5];offsets[0]=-3.23076923;offsets[1]=-1.38461538;offsets[2]=0.0;offsets[3]=1.38461538;offsets[4]=3.23076923;float weights[5];weights[0]=0.07027027;weights[1]=0.31621622;weights[2]=0.22702703;weights[3]=0.31621622;weights[4]=0.07027027;for(int i=0;i<5;i++){vec2 offset=vec2(0,offsets[i]*(1.0/_TextureSize.y));color+=texture2D(tex,uv+offset).rgb*weights[i];}return color;}void main(){vec3 color=GaussV(_MainTex,uv);gl_FragColor=vec4(color,1.0);}";

var gaussianUpFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform sampler2D _GaussianDownTex;uniform vec2 _GaussianDownTextureSize;float GaussWeight2D(float x,float y,float sigma){float PI=3.14159265358;float E=2.71828182846;float sigma_2=pow(sigma,2.0);float a=-(x*x+y*y)/(2.0*sigma_2);return pow(E,a)/(2.0*PI*sigma_2);}vec3 GaussNxN(sampler2D tex,vec2 uv,vec2 stride,float sigma){vec3 color=vec3(0.,0.,0.);const int r=1;float weight=0.0;for(int i=-r;i<=r;i++){for(int j=-r;j<=r;j++){float w=GaussWeight2D(float(i),float(j),sigma);vec2 coord=uv+vec2(i,j)*stride;color+=texture2D(tex,coord).rgb*w;weight+=w;}}color/=weight;return color;}void main(){vec3 lowResColor=GaussNxN(_MainTex,uv,0.5/_GaussianDownTextureSize,1.0);vec3 highResColor=GaussNxN(_GaussianDownTex,uv,1.0/_GaussianDownTextureSize,1.0);vec3 color=mix(highResColor,lowResColor,0.7);gl_FragColor=vec4(color,1.0);}";

var thresholdFrag = "precision highp float;varying vec2 uv;uniform sampler2D _MainTex;uniform float _Threshold;void main(){vec4 mainTex=texture2D(_MainTex,uv);mainTex.rgb=pow(mainTex.rgb,vec3(2.2));float brightness=max(mainTex.r,max(mainTex.g,mainTex.b));float w=max(0.0,brightness-_Threshold)/max(brightness,0.00001);mainTex.rgb*=w;mainTex.rgb*=mainTex.a;gl_FragColor=vec4(mainTex.rgb,1.0);}";

var shaderLib = {};
var ShaderFactory = /*#__PURE__*/ function() {
    function ShaderFactory() {}
    ShaderFactory.registerInclude = function registerInclude(includeName, includeSource) {
        if (shaderLib[includeName]) {
            logger.warn('The "' + includeName + '" shader include already exist.');
        }
        shaderLib[includeName] = includeSource;
    };
    ShaderFactory.unRegisterInclude = function unRegisterInclude(includeName) {
        delete shaderLib[includeName];
    };
    ShaderFactory.unRegisterAllIncludes = function unRegisterAllIncludes() {
        Object.keys(shaderLib).forEach(function(key) {
            ShaderFactory.unRegisterInclude(key);
        });
    };
    /**
   * 生成 shader，检测到 WebGL1 上下文会降级
   * @param macros - 宏定义数组
   * @param shader - 原始 shader 文本
   * @param shaderType - shader 类型
   * @return 去除版本号的 shader 文本
   */ ShaderFactory.genFinalShaderCode = function genFinalShaderCode(options) {
        var level = options.level, shaderType = options.shaderType, shader = options.shader, macros = options.macros, removeVersion = options.removeVersion;
        var macroString = ShaderFactory.genMacroString(level, macros);
        var versionString = ShaderFactory.genShaderVersion(level);
        var source = ShaderFactory.parseIncludes(shader);
        var isVersion300 = ShaderFactory.isVersion300(source);
        source = ShaderFactory.removeWebGLVersion(source);
        if (level === 2 && !isVersion300) {
            source = ShaderFactory.convertTo300(source, shaderType === exports.ShaderType.fragment);
        }
        if (removeVersion) {
            return macroString + source;
        }
        return versionString + macroString + source;
    };
    /**
   * Convert lower GLSL version to GLSL 300 es.
   * @param source - code
   * @param isFragment - Whether it is a fragment shader.
   * */ ShaderFactory.convertTo300 = function convertTo300(source, isFragment) {
        source = source.replace(/\bvarying\b/g, isFragment ? "in" : "out");
        source = source.replace(/\btexture(2D|Cube)\b/g, "texture");
        // Remove extensions
        var regex = /#extension.+(GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
        source = source.replace(regex, "");
        if (isFragment) {
            source = source.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
            source = source.replace(/\btexture(2D|Cube)GradEXT\b/g, "textureGrad");
            source = source.replace(/\bgl_FragDepthEXT\b/g, "gl_FragDepth");
            if (!ShaderFactory.has300Output(source)) {
                var isMRT = /\bgl_FragData\[.+?\]/g.test(source);
                if (isMRT) {
                    source = source.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
                    var result = source.match(/\bgl_FragData\[.+?\]/g);
                    if (result) {
                        source = ShaderFactory.replaceMRTShader(source, result);
                    }
                } else {
                    source = source.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
                    source = source.replace(/\bgl_FragColor\b/g, "glFragColor");
                }
            }
        } else {
            source = source.replace(/\battribute\b/g, "in");
        }
        return source;
    };
    ShaderFactory.parseIncludes = function parseIncludes(source, regex) {
        if (regex === void 0) regex = /#include <(.+)>/gm;
        var match;
        while((match = regex.exec(source)) !== null){
            var shaderName = match[1];
            var replace = shaderLib[shaderName];
            if (replace === undefined) {
                throw new Error("Can't find include shader name " + shaderName);
            }
            source = source.replace(match[0], replace);
        }
        return source;
    };
    ShaderFactory.genMacroString = function genMacroString(level, macros, addRuntimeMacro) {
        if (addRuntimeMacro === void 0) addRuntimeMacro = true;
        var macroList = [];
        var webGLVersion = "WEBGL" + level;
        macroList.push("#ifndef " + webGLVersion);
        macroList.push("#define " + webGLVersion);
        macroList.push("#endif");
        if (addRuntimeMacro) {
            macroList.push("#define GE_RUNTIME");
        }
        if (macros && macros.length) {
            macros.forEach(function(param) {
                var key = param[0], value = param[1];
                if (value === true) {
                    macroList.push("#define " + key);
                } else if (Number.isFinite(value)) {
                    macroList.push("#define " + key + " " + value);
                }
            });
        }
        if (macroList.length) {
            return macroList.join("\n") + "\n";
        }
        return "";
    };
    ShaderFactory.genShaderVersion = function genShaderVersion(level) {
        if (level === 1) {
            return "#version 100\n";
        }
        return "#version 300 es\n";
    };
    ShaderFactory.isVersion300 = function isVersion300(source) {
        var versionTag = /#version\s+\b\d{3}\b\s*(es)?/;
        var match = source.match(versionTag);
        var version = match ? match[0] : "";
        return version.includes("300");
    };
    ShaderFactory.removeWebGLVersion = function removeWebGLVersion(source) {
        var versionTag = /#version\s+\b\d{3}\b\s*(es)?/;
        var match = source.match(versionTag);
        if (match) {
            return source.replace(match[0], "");
        }
        return source;
    };
    ShaderFactory.has300Output = function has300Output(fragmentShader) {
        // [layout(location = 0)] out [highp] vec4 [color];
        var fragReg = /\bout\s+(?:\w+\s+)?(?:vec4)\s+(?:\w+)\s*;/;
        return fragReg.test(fragmentShader);
    };
    ShaderFactory.replaceMRTShader = function replaceMRTShader(source, result) {
        var mrtIndexSet = new Set();
        var declaration = "";
        for(var i = 0; i < result.length; i++){
            var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
            if (res) {
                mrtIndexSet.add(res[1]);
            }
        }
        mrtIndexSet.forEach(function(index) {
            declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
        });
        declaration += "void main(";
        source = source.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
        source = source.replace(/void\s+?main\s*\(/g, declaration);
        return source;
    };
    return ShaderFactory;
}();

// Bloom 阈值 Pass
var BloomThresholdPass = /*#__PURE__*/ function(RenderPass) {
    _inherits(BloomThresholdPass, RenderPass);
    function BloomThresholdPass(renderer, option) {
        var _this;
        _this = RenderPass.call(this, renderer, option) || this;
        var engine = _this.renderer.engine;
        var geometry = Geometry.create(engine, {
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var material = Material.create(engine, {
            shader: {
                vertex: screenMeshVert,
                fragment: thresholdFrag,
                glslVersion: exports.GLSLVersion.GLSL1
            }
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            geometry: geometry,
            material: material,
            priority: 0
        });
        _this.priority = 5000;
        return _this;
    }
    var _proto = BloomThresholdPass.prototype;
    _proto.configure = function configure(renderer) {
        this.mainTexture = renderer.getFramebuffer().getColorTextures()[0];
        this.sceneTextureHandle.texture = this.mainTexture;
        renderer.setFramebuffer(this.framebuffer);
    };
    _proto.execute = function execute(renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear
        });
        this.screenMesh.material.setTexture("_MainTex", this.mainTexture);
        var threshold = renderer.renderingData.currentFrame.globalVolume.threshold;
        this.screenMesh.material.setFloat("_Threshold", threshold);
        renderer.renderMeshes([
            this.screenMesh
        ]);
    };
    return BloomThresholdPass;
}(RenderPass);
var HQGaussianDownSamplePass = /*#__PURE__*/ function(RenderPass) {
    _inherits(HQGaussianDownSamplePass, RenderPass);
    function HQGaussianDownSamplePass(renderer, type, options) {
        var _this;
        _this = RenderPass.call(this, renderer, options) || this;
        _this.type = type;
        var engine = _this.renderer.engine;
        var name = "PostProcess";
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var fragment = type == "H" ? gaussianDownHFrag : gaussianDownVFrag;
        var shader = {
            vertex: screenMeshVert,
            fragment: fragment,
            glslVersion: exports.GLSLVersion.GLSL1
        };
        var material = Material.create(engine, {
            name: name,
            shader: shader
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0
        });
        _this.priority = 5000;
        return _this;
    }
    var _proto = HQGaussianDownSamplePass.prototype;
    _proto.configure = function configure(renderer) {
        this.mainTexture = renderer.getFramebuffer().getColorTextures()[0];
        renderer.setFramebuffer(this.framebuffer);
    };
    _proto.execute = function execute(renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear
        });
        this.screenMesh.material.setTexture("_MainTex", this.mainTexture);
        this.screenMesh.material.setVector2("_TextureSize", getTextureSize(this.mainTexture));
        renderer.renderMeshes([
            this.screenMesh
        ]);
        if (this.type === "V") {
            this.gaussianResult.texture = renderer.getFramebuffer().getColorTextures()[0];
        }
    };
    return HQGaussianDownSamplePass;
}(RenderPass);
var HQGaussianUpSamplePass = /*#__PURE__*/ function(RenderPass) {
    _inherits(HQGaussianUpSamplePass, RenderPass);
    function HQGaussianUpSamplePass(renderer, options) {
        var _this;
        _this = RenderPass.call(this, renderer, options) || this;
        var name = "PostProcess";
        var engine = _this.renderer.engine;
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var shader = {
            vertex: screenMeshVert,
            fragment: gaussianUpFrag
        };
        var material = Material.create(engine, {
            name: name,
            shader: shader
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0
        });
        _this.priority = 5000;
        return _this;
    }
    var _proto = HQGaussianUpSamplePass.prototype;
    _proto.configure = function configure(renderer) {
        this.mainTexture = renderer.getFramebuffer().getColorTextures()[0];
        renderer.setFramebuffer(this.framebuffer);
    };
    _proto.execute = function execute(renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear
        });
        this.screenMesh.material.setTexture("_MainTex", this.mainTexture);
        this.screenMesh.material.setTexture("_GaussianDownTex", this.gaussianDownSampleResult.texture);
        this.screenMesh.material.setVector2("_GaussianDownTextureSize", getTextureSize(this.gaussianDownSampleResult.texture));
        renderer.renderMeshes([
            this.screenMesh
        ]);
    };
    return HQGaussianUpSamplePass;
}(RenderPass);
// 合并Bloom的高斯模糊结果，并应用ACES Tonemapping
var ToneMappingPass = /*#__PURE__*/ function(RenderPass) {
    _inherits(ToneMappingPass, RenderPass);
    function ToneMappingPass(renderer, sceneTextureHandle) {
        var _this;
        _this = RenderPass.call(this, renderer, {}) || this;
        var name = "PostProcess";
        var engine = _this.renderer.engine;
        _this.sceneTextureHandle = sceneTextureHandle ? sceneTextureHandle : new RenderTargetHandle(engine);
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var material = Material.create(engine, {
            name: name,
            shader: {
                vertex: screenMeshVert,
                fragment: colorGradingFrag,
                glslVersion: exports.GLSLVersion.GLSL1
            }
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        _this.screenMesh = Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0
        });
        _this.priority = 5000;
        return _this;
    }
    var _proto = ToneMappingPass.prototype;
    _proto.configure = function configure(renderer) {
        this.mainTexture = renderer.getFramebuffer().getColorTextures()[0];
        if (!this.sceneTextureHandle.texture) {
            this.sceneTextureHandle.texture = this.mainTexture;
        }
        renderer.setFramebuffer(null);
    };
    _proto.execute = function execute(renderer) {
        renderer.clear({
            colorAction: exports.TextureStoreAction.clear,
            depthAction: exports.TextureStoreAction.clear,
            stencilAction: exports.TextureStoreAction.clear
        });
        var _renderer_renderingData_currentFrame_globalVolume = renderer.renderingData.currentFrame.globalVolume, useBloom = _renderer_renderingData_currentFrame_globalVolume.useBloom, bloomIntensity = _renderer_renderingData_currentFrame_globalVolume.bloomIntensity, brightness = _renderer_renderingData_currentFrame_globalVolume.brightness, saturation = _renderer_renderingData_currentFrame_globalVolume.saturation, contrast = _renderer_renderingData_currentFrame_globalVolume.contrast, useToneMapping = _renderer_renderingData_currentFrame_globalVolume.useToneMapping, vignetteIntensity = _renderer_renderingData_currentFrame_globalVolume.vignetteIntensity, vignetteSmoothness = _renderer_renderingData_currentFrame_globalVolume.vignetteSmoothness, vignetteRoundness = _renderer_renderingData_currentFrame_globalVolume.vignetteRoundness;
        this.screenMesh.material.setTexture("_SceneTex", this.sceneTextureHandle.texture);
        this.screenMesh.material.setFloat("_Brightness", brightness);
        this.screenMesh.material.setFloat("_Saturation", saturation);
        this.screenMesh.material.setFloat("_Contrast", contrast);
        this.screenMesh.material.setInt("_UseBloom", Number(useBloom));
        if (useBloom) {
            this.screenMesh.material.setTexture("_GaussianTex", this.mainTexture);
            this.screenMesh.material.setFloat("_BloomIntensity", bloomIntensity);
        }
        if (vignetteIntensity > 0) {
            this.screenMesh.material.setFloat("_VignetteIntensity", vignetteIntensity);
            this.screenMesh.material.setFloat("_VignetteSmoothness", vignetteSmoothness);
            this.screenMesh.material.setFloat("_VignetteRoundness", vignetteRoundness);
            this.screenMesh.material.setVector2("_VignetteCenter", new Vector2(0.5, 0.5));
            this.screenMesh.material.setVector3("_VignetteColor", new Vector3(0.0, 0.0, 0.0));
        }
        this.screenMesh.material.setInt("_UseToneMapping", Number(useToneMapping));
        renderer.renderMeshes([
            this.screenMesh
        ]);
    };
    return ToneMappingPass;
}(RenderPass);

var RENDER_PASS_NAME_PREFIX = "_effects_default_";
var seed$8 = 1;
/**
 * RenderFrame 抽象类
 */ var RenderFrame = /*#__PURE__*/ function() {
    function RenderFrame(options) {
        var _this_renderer_getShaderLibrary;
        // TODO: 是否有用
        this.renderQueue = [];
        this.destroyed = false;
        this.renderPassInfoMap = new WeakMap();
        var camera = options.camera, keepColorBuffer = options.keepColorBuffer, renderer = options.renderer, _options_editorTransform = options.editorTransform, editorTransform = _options_editorTransform === void 0 ? [
            1,
            1,
            0,
            0
        ] : _options_editorTransform, globalVolume = options.globalVolume, _options_clearAction = options.clearAction, clearAction = _options_clearAction === void 0 ? {
            colorAction: exports.TextureLoadAction.whatever,
            stencilAction: exports.TextureLoadAction.clear,
            depthAction: exports.TextureLoadAction.whatever
        } : _options_clearAction;
        var engine = renderer.engine;
        if (globalVolume) {
            this.globalVolume = globalVolume;
        }
        this.globalUniforms = new GlobalUniforms();
        var attachments = []; //渲染场景物体Pass的RT
        var depthStencilAttachment;
        var drawObjectPassClearAction = {};
        this.renderer = renderer;
        if (this.globalVolume) {
            var useHDR = this.globalVolume.useHDR;
            // 使用HDR浮点纹理，FLOAT在IOS上报错，使用HALF_FLOAT
            var textureType = useHDR ? glContext.HALF_FLOAT : glContext.UNSIGNED_BYTE;
            attachments = [
                {
                    texture: {
                        format: glContext.RGBA,
                        type: textureType,
                        magFilter: glContext.LINEAR,
                        minFilter: glContext.LINEAR
                    }
                }
            ];
            depthStencilAttachment = {
                storageType: exports.RenderPassAttachmentStorageType.depth_stencil_opaque
            };
            drawObjectPassClearAction = {
                colorAction: exports.TextureLoadAction.clear,
                stencilAction: exports.TextureLoadAction.clear,
                depthAction: exports.TextureLoadAction.clear
            };
        }
        // 创建 drawObjectPass
        var renderPasses = [
            new RenderPass(renderer, {
                name: RENDER_PASS_NAME_PREFIX,
                priority: RenderPassPriorityNormal,
                meshOrder: exports.OrderType.ascending,
                depthStencilAttachment: depthStencilAttachment,
                attachments: attachments,
                clearAction: drawObjectPassClearAction
            })
        ];
        this.setRenderPasses(renderPasses);
        if (this.globalVolume) {
            var sceneTextureHandle = new RenderTargetHandle(engine); //保存后处理前的屏幕图像
            var gaussianStep = 7; // 高斯模糊的迭代次数，次数越高模糊范围越大
            var viewport = [
                0,
                0,
                this.renderer.getWidth() / 2,
                this.renderer.getHeight() / 2
            ];
            var gaussianDownResults = new Array(gaussianStep); //存放多个高斯Pass的模糊结果，用于Bloom
            var textureType1 = this.globalVolume.useHDR ? glContext.HALF_FLOAT : glContext.UNSIGNED_BYTE;
            var bloomThresholdPass = new BloomThresholdPass(renderer, {
                name: "BloomThresholdPass",
                attachments: [
                    {
                        texture: {
                            format: glContext.RGBA,
                            type: textureType1,
                            minFilter: glContext.LINEAR,
                            magFilter: glContext.LINEAR
                        }
                    }
                ]
            });
            bloomThresholdPass.sceneTextureHandle = sceneTextureHandle;
            this.addRenderPass(bloomThresholdPass);
            for(var i = 0; i < gaussianStep; i++){
                gaussianDownResults[i] = new RenderTargetHandle(engine);
                var gaussianDownHPass = new HQGaussianDownSamplePass(renderer, "H", {
                    name: "GaussianDownPassH" + i,
                    viewport: viewport,
                    attachments: [
                        {
                            texture: {
                                format: glContext.RGBA,
                                type: textureType1,
                                minFilter: glContext.LINEAR,
                                magFilter: glContext.LINEAR
                            }
                        }
                    ]
                });
                var gaussianDownVPass = new HQGaussianDownSamplePass(renderer, "V", {
                    name: "GaussianDownPassV" + i,
                    viewport: viewport,
                    attachments: [
                        {
                            texture: {
                                format: glContext.RGBA,
                                type: textureType1,
                                minFilter: glContext.LINEAR,
                                magFilter: glContext.LINEAR
                            }
                        }
                    ]
                });
                gaussianDownVPass.gaussianResult = gaussianDownResults[i];
                this.addRenderPass(gaussianDownHPass);
                this.addRenderPass(gaussianDownVPass);
                viewport[2] /= 2;
                viewport[3] /= 2;
            // TODO 限制最大迭代
            }
            viewport[2] *= 4;
            viewport[3] *= 4;
            for(var i1 = 0; i1 < gaussianStep - 1; i1++){
                var gaussianUpPass = new HQGaussianUpSamplePass(renderer, {
                    name: "GaussianUpPass" + i1,
                    viewport: viewport,
                    attachments: [
                        {
                            texture: {
                                format: glContext.RGBA,
                                type: textureType1,
                                minFilter: glContext.LINEAR,
                                magFilter: glContext.LINEAR
                            }
                        }
                    ]
                });
                gaussianUpPass.gaussianDownSampleResult = gaussianDownResults[gaussianStep - 2 - i1];
                this.addRenderPass(gaussianUpPass);
                viewport[2] *= 2;
                viewport[3] *= 2;
            }
            var postProcessPass = new ToneMappingPass(renderer, sceneTextureHandle);
            this.addRenderPass(postProcessPass);
        }
        this.semantics = new SemanticMap(options.semantics);
        this.clearAction = clearAction;
        this.name = "RenderFrame" + seed$8++;
        var firstRP = renderPasses[0];
        this.emptyTexture = generateWhiteTexture(engine);
        this.transparentTexture = generateTransparentTexture(engine);
        this.camera = camera;
        this.keepColorBuffer = keepColorBuffer;
        this.renderPassInfoMap.set(firstRP, {
            listStart: 0,
            listEnd: 0,
            renderPass: firstRP,
            intermedia: false
        });
        this.editorTransform = Vector4$1.fromArray(editorTransform);
        if (!options.clearAction) {
            this.resetClearActions();
        }
        this.passTextureCache = new PassTextureCache(engine);
        // FIXME: addShader是为了性能考虑，如果影响不大，下面代码可以删除
        var _engine_gpuCapability = engine.gpuCapability, detail = _engine_gpuCapability.detail, level = _engine_gpuCapability.level;
        var writeDepth = detail.readableDepthStencilTextures && detail.writableFragDepth;
        var shader = createCopyShader(level, writeDepth);
        (_this_renderer_getShaderLibrary = this.renderer.getShaderLibrary()) == null ? void 0 : _this_renderer_getShaderLibrary.addShader(shader);
    }
    var _proto = RenderFrame.prototype;
    /**
   * 根据 Mesh 优先级添加到 RenderPass
   * @param mesh - 要添加的 Mesh 对象
   */ _proto.addMeshToDefaultRenderPass = function addMeshToDefaultRenderPass(mesh) {
        if (!mesh) {
            return;
        }
        this.renderPasses[0].addMesh(mesh);
    // const renderPasses = this.renderPasses;
    // const infoMap = this.renderPassInfoMap;
    // const { priority } = mesh;
    // for (let i = 1; i < renderPasses.length; i++) {
    //   const renderPass = renderPasses[i - 1];
    //   const info = infoMap.get(renderPasses[i])!;
    //   if (info && info.listStart > priority && (priority > infoMap.get(renderPass)!.listEnd || i === 1)) {
    //     return this.addToRenderPass(renderPass, mesh);
    //   }
    // }
    // // TODO: diff逻辑待优化，有时会添加进找不到的元素
    // let last = renderPasses[renderPasses.length - 1];
    // // TODO: 是否添加mesh到pass的判断方式需要优化，先通过长度判断是否有postprocess
    // for (const pass of renderPasses) {
    //   if (!(pass instanceof HQGaussianDownSamplePass
    //     || pass instanceof BloomThresholdPass
    //     || pass instanceof ToneMappingPass
    //     || pass instanceof HQGaussianUpSamplePass
    //     || pass.name === 'mars-final-copy')) {
    //     last = pass;
    //   }
    // }
    // // if (priority > infoMap.get(last)!.listStart || renderPasses.length === 1) {
    // //   return this.addToRenderPass(last, mesh);
    // // }
    // return this.addToRenderPass(last, mesh);
    // if (false) {
    //   throw Error('render pass not found');
    // }
    };
    /**
   * 把 Mesh 从 RenderPass 中移除，
   * 如果 renderPass 中没有 mesh，此 renderPass 会被删除
   * @param mesh - 要删除的 Mesh 对象
   */ _proto.removeMeshFromDefaultRenderPass = function removeMeshFromDefaultRenderPass(mesh) {
    // const renderPasses = this.renderPasses;
    // const infoMap = this.renderPassInfoMap;
    // for (let i = renderPasses.length - 1; i >= 0; i--) {
    //   const renderPass = renderPasses[i];
    //   const info = infoMap.get(renderPass)!;
    //   // 只有渲染场景物体的pass才有 info
    //   if (!info) {
    //     continue;
    //   }
    //   if (info.listStart <= mesh.priority && info.listEnd >= mesh.priority) {
    //     const idx = renderPass.meshes.indexOf(mesh);
    //     if (idx === -1) {
    //       return;
    //     }
    //     // TODO hack: 现在的除了rp1和finalcopy pass，所有renderpass的meshes是一个copy加上一个filter mesh，这里的判断当filter mesh被删除后当前pass需不需要删除，
    //     // 判断需要更鲁棒。
    //     const shouldRestoreRenderPass = idx === 1 && renderPass.meshes[0].name === MARS_COPY_MESH_NAME;
    //     renderPass.removeMesh(mesh);
    //     if (shouldRestoreRenderPass) {
    //       const nextRenderPass = renderPasses[i + 1];
    //       const meshes = renderPass.meshes;
    //       if (!info.intermedia) {
    //         info.preRenderPass?.resetColorAttachments([]);
    //         //this.renderer.extension.resetColorAttachments?.(info.preRenderPass, []);
    //       }
    //       for (let j = 1; j < meshes.length; j++) {
    //         info.preRenderPass?.addMesh(meshes[j]);
    //       }
    //       const cp = renderPass.attachments[0]?.texture;
    //       const keepColor = cp === this.resource.color_a || cp === this.resource.color_b;
    //       renderPass.dispose({
    //         meshes: DestroyOptions.keep,
    //         colorAttachment: keepColor ? RenderPassDestroyAttachmentType.keep : RenderPassDestroyAttachmentType.destroy,
    //         depthStencilAttachment: RenderPassDestroyAttachmentType.keep,
    //       });
    //       removeItem(renderPasses, renderPass);
    //       this.removeRenderPass(renderPass);
    //       infoMap.delete(renderPass);
    //       if (nextRenderPass) {
    //         this.updateRenderInfo(nextRenderPass);
    //       }
    //       if (info.preRenderPass) {
    //         this.updateRenderInfo(info.preRenderPass);
    //       }
    //       if (info.prePasses) {
    //         info.prePasses.forEach(rp => {
    //           this.removeRenderPass(rp.pass);
    //           if (rp?.destroyOptions !== false) {
    //             rp.pass.attachments.forEach(c => {
    //               if (c.texture !== this.resource.color_b || c.texture !== this.resource.color_a) {
    //                 c.texture.dispose();
    //               }
    //             });
    //             const options: RenderPassDestroyOptions = {
    //               ...(rp?.destroyOptions ? rp.destroyOptions as RenderPassDestroyOptions : {}),
    //               depthStencilAttachment: RenderPassDestroyAttachmentType.keep,
    //             };
    //             rp.pass.dispose(options);
    //           }
    //         });
    //       }
    //       this.resetRenderPassDefaultAttachment(renderPasses, Math.max(i - 1, 0));
    //       if (renderPasses.length === 1) {
    //         renderPasses[0].resetColorAttachments([]);
    //         //this.renderer.extension.resetColorAttachments?.(renderPasses[0], []);
    //         this.removeRenderPass(this.resource.finalCopyRP);
    //       }
    //     }
    //     return this.resetClearActions();
    //   }
    // }
    };
    // /**
    //  * 将 Mesh 所有在 RenderPass 进行切分
    //  * @param mesh - 目标 Mesh 对象
    //  * @param options - 切分选项，包含 RenderPass 相关的 Attachment 等数据
    //  */
    // splitDefaultRenderPassByMesh (mesh: Mesh, options: RenderPassSplitOptions): RenderPass {
    //   const index = this.findMeshRenderPassIndex(mesh);
    //   const renderPass = this.renderPasses[index];
    //   if (false) {
    //     if (!renderPass) {
    //       throw Error('RenderPassNotFound');
    //     }
    //   }
    //   this.createResource();
    //   const meshIndex = renderPass.meshes.indexOf(mesh);
    //   const ms0 = renderPass.meshes.slice(0, meshIndex);
    //   const ms1 = renderPass.meshes.slice(meshIndex);
    //   const infoMap = this.renderPassInfoMap;
    //   // TODO 为什么要加这个判断？
    //   // if (renderPass.attachments[0] && this.renderPasses[index + 1] !== this.resource.finalCopyRP) {
    //   //   throw Error('not implement');
    //   // } else {
    //   if (!options.attachments?.length) {
    //     throw Error('should include at least one color attachment');
    //   }
    //   const defRPS = this.renderPasses;
    //   const defIndex = defRPS.indexOf(renderPass);
    //   const lastDefRP = defRPS[defIndex - 1];
    //   removeItem(defRPS, renderPass);
    //   const lastInfo = infoMap.get(renderPass);
    //   infoMap.delete(renderPass);
    //   const filter = GPUCapability.getInstance().level === 2 ? glContext.LINEAR : glContext.NEAREST;
    //   const rp0 = new RenderPass({
    //     name: RENDER_PASS_NAME_PREFIX + defIndex,
    //     priority: renderPass.priority,
    //     attachments: [{
    //       texture: {
    //         sourceType: TextureSourceType.framebuffer,
    //         format: glContext.RGBA,
    //         name: 'frame_a',
    //         minFilter: filter,
    //         magFilter: filter,
    //       },
    //     }],
    //     clearAction: renderPass.clearAction || { colorAction: TextureLoadAction.clear },
    //     storeAction: renderPass.storeAction,
    //     depthStencilAttachment: this.resource.depthStencil,
    //     meshes: ms0,
    //     meshOrder: OrderType.ascending,
    //   });
    //   ms1.unshift(this.createCopyMesh());
    //   const renderPasses = this.renderPasses;
    //   renderPasses[index] = rp0;
    //   const prePasses: RenderPass[] = [];
    //   const restMeshes = ms1.slice();
    //   if (options.prePasses) {
    //     options.prePasses.forEach((pass, i) => {
    //       pass.priority = renderPass.priority + 1 + i;
    //       pass.setMeshes(ms1);
    //       prePasses.push(pass);
    //     });
    //     renderPasses.splice(index + 1, 0, ...prePasses);
    //     restMeshes.splice(0, 2);
    //   }
    //   const copyRP = this.resource.finalCopyRP;
    //   if (!renderPasses.includes(copyRP)) {
    //     renderPasses.push(copyRP);
    //   }
    //   // let sourcePass = (prePasses.length && !options.useLastDefaultPassColor) ? prePasses[prePasses.length - 1] : rp0;
    //   const finalFilterPass = prePasses[prePasses.length - 1];
    //   finalFilterPass.initialize(this.renderer);
    //   // 不切RT，接着上一个pass的渲染结果渲染
    //   const rp1 = new RenderPass({
    //     name: RENDER_PASS_NAME_PREFIX + (defIndex + 1),
    //     priority: renderPass.priority + 1 + (options.prePasses?.length || 0),
    //     meshes: restMeshes,
    //     meshOrder: OrderType.ascending,
    //     depthStencilAttachment: this.resource.depthStencil,
    //     storeAction: options.storeAction,
    //     clearAction: {
    //       depthAction: TextureLoadAction.whatever,
    //       stencilAction: TextureLoadAction.whatever,
    //       colorAction: TextureLoadAction.whatever,
    //     },
    //   });
    //   renderPasses.splice(index + 1 + (options.prePasses?.length || 0), 0, rp1);
    //   this.setRenderPasses(renderPasses);
    //   this.updateRenderInfo(finalFilterPass);
    //   this.updateRenderInfo(rp0);
    //   this.updateRenderInfo(rp1);
    //   // 目的是删除滤镜元素后，把之前滤镜用到的prePass给删除，逻辑有些复杂，考虑优化
    //   infoMap.get(rp0)!.prePasses = lastInfo!.prePasses;
    //   prePasses.pop();
    //   infoMap.get(finalFilterPass)!.prePasses = prePasses.map((pass, i) => {
    //     return { pass, destroyOptions: false };
    //   });
    //   this.resetClearActions();
    //   return finalFilterPass;
    // }
    /**
   * 销毁 RenderFrame
   * @param options - 可以有选择销毁一些对象
   */ _proto.dispose = function dispose(options) {
        if ((options == null ? void 0 : options.semantics) !== exports.DestroyOptions.keep) {
            this.semantics.dispose();
        }
        var pass = (options == null ? void 0 : options.passes) ? options.passes : undefined;
        if (pass !== exports.DestroyOptions.keep) {
            this._renderPasses.forEach(function(renderPass) {
                renderPass.dispose(pass);
            });
        }
        this.passTextureCache.dispose();
        this._renderPasses.length = 0;
        this.emptyTexture.dispose();
        this.transparentTexture.dispose();
        if (this.resource) {
            var _this_resource_depthStencil_texture, _this_resource_depthStencil;
            this.resource.color_a.dispose();
            this.resource.color_b.dispose();
            (_this_resource_depthStencil = this.resource.depthStencil) == null ? void 0 : (_this_resource_depthStencil_texture = _this_resource_depthStencil.texture) == null ? void 0 : _this_resource_depthStencil_texture.dispose();
            this.resource.finalCopyRP.dispose();
            this.resource.resRP.dispose();
            // @ts-expect-error
            this.resource = null;
        }
        this.destroyed = true;
    };
    /**
   * 重置 RenderPass ColorAttachment，解决 Framebuffer 即读又写的问题
   * @param renderPasses - RenderPass 对象数组
   * @param startIndex - 开始重置的索引
   */ _proto.resetRenderPassDefaultAttachment = function resetRenderPassDefaultAttachment(renderPasses, startIndex) {
        var pre;
        var _this_resource = this.resource, color_a = _this_resource.color_a, color_b = _this_resource.color_b;
        for(var i = startIndex; i < renderPasses.length; i++){
            var _rp_attachments_, _rp_attachments_1;
            var rp = renderPasses[i];
            var tex = (_rp_attachments_ = rp.attachments[0]) == null ? void 0 : _rp_attachments_.texture;
            // @ts-expect-error
            if (tex && pre === tex) {
                var next = tex === color_a ? color_b : color_a;
                rp.resetColorAttachments([
                    next
                ]);
            //this.renderer.extension.resetColorAttachments?.(rp as GLRenderPass, [next as GLTexture]);
            }
            tex = (_rp_attachments_1 = rp.attachments[0]) == null ? void 0 : _rp_attachments_1.texture;
            if (tex) {
                pre = tex;
            }
        }
    };
    /**
   * 查找 Mesh 所在的 RenderPass 索引，没找到是-1
   * @param mesh - 需要查找的 Mesh
   */ _proto.findMeshRenderPassIndex = function findMeshRenderPassIndex(mesh) {
        var index = -1;
        this.renderPasses.every(function(rp, idx) {
            if (rp.name.startsWith(RENDER_PASS_NAME_PREFIX) && rp.meshes.includes(mesh)) {
                index = idx;
                return false;
            }
            return true;
        });
        return index;
    };
    _proto.addToRenderPass = function addToRenderPass(renderPass, mesh) {
        var info = this.renderPassInfoMap.get(renderPass);
        var priority = mesh.priority;
        if (!info) {
            return;
        }
        if (renderPass.meshes.length === 0) {
            info.listStart = info.listEnd = priority;
        } else {
            if (priority < info.listStart) {
                info.listStart = priority;
            } else if (priority > info.listEnd) {
                info.listEnd = priority;
            }
        }
        renderPass.addMesh(mesh);
    };
    _proto.getRPAttachments = function getRPAttachments(attachments, preRP) {
        if ((attachments == null ? void 0 : attachments.length) === 1) {
            var _attachments_ = attachments[0], texture = _attachments_.texture, persistent = _attachments_.persistent;
            var format = texture.format;
            var _preRP_getInitAttachments;
            var previousAttachmens = (_preRP_getInitAttachments = preRP == null ? void 0 : preRP.getInitAttachments()) != null ? _preRP_getInitAttachments : [];
            if (format === glContext.RGBA && !persistent) {
                var texA = this.resource.color_a;
                if (previousAttachmens.length === 0) {
                    return [
                        {
                            texture: texA
                        }
                    ];
                }
                var texture1 = previousAttachmens[0].texture === texA ? this.resource.color_b : texA;
                return [
                    {
                        texture: texture1
                    }
                ];
            }
        }
        return attachments;
    };
    _proto.resetClearActions = function resetClearActions() {
        var action = this.renderPasses.length > 1 ? exports.TextureLoadAction.clear : exports.TextureLoadAction.whatever;
        this.clearAction.stencilAction = action;
        this.clearAction.depthAction = action;
        this.clearAction.colorAction = action;
        if (this.keepColorBuffer) {
            this.clearAction.colorAction = exports.TextureLoadAction.whatever;
        }
    };
    // protected updateRenderInfo (renderPass: RenderPass): RenderPassInfo {
    //   const map = this.renderPassInfoMap;
    //   const passes = this.renderPasses;
    //   let info: RenderPassInfo;
    //   if (!map.has(renderPass)) {
    //     info = {
    //       intermedia: false,
    //       renderPass: renderPass,
    //       listStart: 0,
    //       listEnd: 0,
    //     };
    //     map.set(renderPass, info);
    //   } else {
    //     info = map.get(renderPass)!;
    //   }
    //   info.intermedia = renderPass.attachments.length > 0;
    //   const meshes = renderPass.meshes;
    //   if (meshes[0]) {
    //     info.listStart = (meshes[0].name === MARS_COPY_MESH_NAME ? meshes[1] : meshes[0]).priority;
    //     info.listEnd = meshes[meshes.length - 1].priority;
    //   } else {
    //     info.listStart = 0;
    //     info.listEnd = 0;
    //   }
    //   const index = passes.indexOf(renderPass);
    //   const depthStencilActon = index === 0 ? TextureLoadAction.clear : TextureLoadAction.whatever;
    //   if (index === 0) {
    //     renderPass.clearAction.colorAction = TextureLoadAction.clear;
    //   }
    //   renderPass.clearAction.depthAction = depthStencilActon;
    //   renderPass.clearAction.stencilAction = depthStencilActon;
    //   if (index > -1) {
    //     renderPass.semantics.setSemantic('EDITOR_TRANSFORM', () => this.editorTransform);
    //   } else {
    //     renderPass.semantics.setSemantic('EDITOR_TRANSFORM', undefined);
    //   }
    //   info.preRenderPass = passes[index - 1];
    //   return info;
    // }
    /**
   * 设置 RenderPass 数组，直接修改内部的 RenderPass 数组
   * @param passes - RenderPass 数组
   */ _proto.setRenderPasses = function setRenderPasses(passes) {
        var _this = this;
        if (this.renderer !== undefined) {
            passes.forEach(function(pass) {
                return pass.initialize(_this.renderer);
            });
        }
        this._renderPasses = passes.slice();
    };
    /**
   * 添加 RenderPass
   * @param pass - 需要添加的 RenderPass
   */ _proto.addRenderPass = function addRenderPass(pass) {
        if (this.renderer !== undefined) {
            pass.initialize(this.renderer);
        }
        this._renderPasses.push(pass);
    };
    /**
   * 创建 RenderPass 切分时需要的 GPU 资源
   */ _proto.createResource = function createResource() {
        var engine = this.renderer.engine;
        if (!this.resource) {
            var _resRP_getDepthAttachment;
            var _engine_gpuCapability = engine.gpuCapability, detail = _engine_gpuCapability.detail, level = _engine_gpuCapability.level;
            var width = this.renderer.getWidth();
            var height = this.renderer.getHeight();
            var filter = level === 2 ? glContext.LINEAR : glContext.NEAREST;
            var texA = Texture.create(engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                name: "frame_a",
                minFilter: filter,
                magFilter: filter
            });
            var texB = Texture.create(engine, {
                sourceType: exports.TextureSourceType.framebuffer,
                format: glContext.RGBA,
                data: {
                    width: width,
                    height: height
                },
                minFilter: filter,
                magFilter: filter,
                name: "frame_b"
            });
            var depthStencilType = detail.readableDepthStencilTextures && detail.writableFragDepth ? exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture : exports.RenderPassAttachmentStorageType.depth_stencil_opaque;
            var resRP = new RenderPass(this.renderer, {
                depthStencilAttachment: {
                    storageType: depthStencilType
                },
                attachments: [
                    {
                        texture: texA
                    }
                ]
            }).initialize(this.renderer);
            var finalCopyRP = new FinalCopyRP(this.renderer, {
                name: "effects-final-copy",
                priority: RenderPassPriorityNormal + 600,
                clearAction: {
                    depthAction: exports.TextureLoadAction.clear,
                    stencilAction: exports.TextureLoadAction.clear,
                    colorAction: exports.TextureLoadAction.clear
                },
                meshOrder: exports.OrderType.ascending,
                meshes: [
                    this.createCopyMesh({
                        blend: true,
                        depthTexture: (_resRP_getDepthAttachment = resRP.getDepthAttachment()) == null ? void 0 : _resRP_getDepthAttachment.texture
                    })
                ]
            });
            this.resource = {
                color_a: resRP.attachments[0].texture,
                color_b: texB,
                finalCopyRP: finalCopyRP,
                depthStencil: resRP.depthAttachment,
                resRP: resRP
            };
        }
    };
    // TODO tex和size没有地方用到。
    /**
   * 创建拷贝 RenderPass 用到的 Mesh 对象
   * @param semantics - RenderPass 渲染时 Framebuffer 的颜色和深度纹理、大小和是否混合
   */ _proto.createCopyMesh = function createCopyMesh(semantics) {
        var // FIXME: 如果不把shader添加进shaderLibrary，这里可以移到core中，有性能上的考虑
        _this_renderer_getShaderLibrary;
        var name = EFFECTS_COPY_MESH_NAME;
        var engine = this.renderer.engine;
        var geometry = Geometry.create(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var shader = createCopyShader(engine.gpuCapability.level, !!(semantics == null ? void 0 : semantics.depthTexture));
        (_this_renderer_getShaderLibrary = this.renderer.getShaderLibrary()) == null ? void 0 : _this_renderer_getShaderLibrary.addShader(shader);
        var material = Material.create(engine, {
            uniformValues: {
                // @ts-expect-error
                uDepth: semantics == null ? void 0 : semantics.depthTexture
            },
            name: name,
            shader: shader
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        if (semantics == null ? void 0 : semantics.blend) {
            material.blending = true;
            material.blendFunction = [
                glContext.SRC_ALPHA,
                glContext.ONE_MINUS_SRC_ALPHA,
                glContext.SRC_ALPHA,
                glContext.ONE_MINUS_SRC_ALPHA
            ];
        }
        return Mesh.create(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0
        });
    };
    /**
   * 移除 RenderPass
   * @param pass - 需要移除的 RenderPass
   */ _proto.removeRenderPass = function removeRenderPass(pass) {
        removeItem(this._renderPasses, pass);
    };
    _create_class(RenderFrame, [
        {
            key: "renderPasses",
            get: function get() {
                return this._renderPasses.slice();
            }
        },
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return RenderFrame;
}();
function getTextureSize(tex) {
    return tex ? new Vector2(tex.getWidth(), tex.getHeight()) : new Vector2();
}
function findPreviousRenderPass(renderPasses, renderPass) {
    var index = renderPasses.indexOf(renderPass);
    return renderPasses[index - 1];
}
var FinalCopyRP = /*#__PURE__*/ function(RenderPass) {
    _inherits(FinalCopyRP, RenderPass);
    function FinalCopyRP() {
        return RenderPass.apply(this, arguments);
    }
    var _proto = FinalCopyRP.prototype;
    _proto.configure = function configure(renderer) {
        var framebuffer = renderer.getFramebuffer();
        if (framebuffer) {
            this.prePassTexture = framebuffer.getColorTextures()[0];
        }
        renderer.setFramebuffer(null);
    };
    _proto.execute = function execute(renderer) {
        renderer.clear(this.clearAction);
        this.meshes[0].material.setTexture("uFilterSource", this.prePassTexture);
        this.meshes[0].material.setVector2("uFilterSourceSize", getTextureSize(this.prePassTexture));
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
    };
    return FinalCopyRP;
}(RenderPass);
var GlobalUniforms = function GlobalUniforms() {
    this.floats = {};
    this.ints = {};
    // vector3s: Record<string, vec3> = {};
    this.vector4s = {};
    this.matrices = {};
    //...
    this.samplers = [] // 存放的sampler名称。
    ;
    this.uniforms = [] // 存放的uniform名称（不包括sampler）。
    ;
};

var Renderbuffer = /*#__PURE__*/ function() {
    function Renderbuffer(props) {
        this.size = [
            0,
            0
        ];
        this.multiSample = 1;
        this.destroyed = false;
        var storageType = props.storageType, format = props.format, attachment = props.attachment;
        this.storageType = storageType;
        this.format = format;
        this.attachment = attachment;
    }
    _create_class(Renderbuffer, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return Renderbuffer;
}();

var isWebGL2Available = typeof douyin.WebGL2RenderingContext === "function";
var GPUCapability = /*#__PURE__*/ function() {
    function GPUCapability(gl) {
        this.setupCapability(gl);
    }
    var _proto = GPUCapability.prototype;
    _proto.setupCapability = function setupCapability(gl) {
        var _gl_getExtension;
        var level = isWebGL2Available && _instanceof1(gl, douyin.WebGL2RenderingContext) ? 2 : 1;
        var level2 = level === 2;
        var textureAnisotropicExt = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        var depthTextureExtension = gl.getExtension("WEBGL_depth_texture");
        var halfFloatLinear = !!gl.getExtension("OES_texture_half_float_linear");
        var floatLinear = !!gl.getExtension("OES_texture_float_linear");
        this.level = level;
        this.type = level2 ? "webgl2" : "webgl";
        this.vaoExt = gl.getExtension("OES_vertex_array_object");
        this.glAsyncCompileExt = gl.getExtension("KHR_parallel_shader_compile");
        this.UNSIGNED_INT_24_8 = gl.UNSIGNED_INT_24_8;
        this.drawBufferExtension = gl.getExtension("WEBGL_draw_buffers");
        if (depthTextureExtension) {
            this.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
        }
        if (level2 && !halfFloatLinear) {
            halfFloatLinear = checkLinearTextureFilter(gl, gl.HALF_FLOAT);
        }
        if (level2 && !floatLinear) {
            floatLinear = checkLinearTextureFilter(gl, gl.FLOAT);
        }
        this.internalFormatDepth16 = level2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT;
        this.internalFormatDepth24_stencil8 = level2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL;
        var floatTexture = level2 || gl.getExtension("OES_texture_float") ? gl.FLOAT : 0;
        var halfFloatTexture = level2 ? douyin.WebGL2RenderingContext.HALF_FLOAT : ((_gl_getExtension = gl.getExtension("OES_texture_half_float")) == null ? void 0 : _gl_getExtension.HALF_FLOAT_OES) || 0;
        var detail = {
            floatTexture: floatTexture,
            halfFloatTexture: halfFloatTexture,
            maxSample: level2 ? gl.getParameter(gl.MAX_SAMPLES) : 1,
            maxVertexUniforms: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
            maxVertexTextures: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            maxFragmentUniforms: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
            maxFragmentTextures: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
            floatColorAttachment: level2 ? !!gl.getExtension("EXT_color_buffer_float") : floatTexture > 0 && !!gl.getExtension("WEBGL_color_buffer_float"),
            halfFloatColorAttachment: level2 ? !!gl.getExtension("EXT_color_buffer_float") : halfFloatTexture > 0 && !!gl.getExtension("EXT_color_buffer_half_float"),
            maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
            maxShaderTexCount: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            compressedTexture: registerCompressedTexture(gl),
            halfFloatLinear: halfFloatLinear,
            floatLinear: floatLinear,
            maxTextureAnisotropy: textureAnisotropicExt ? gl.getParameter(textureAnisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
            shaderTextureLod: level2 || !!gl.getExtension("EXT_shader_texture_lod"),
            instanceDraw: level2 || !!gl.getExtension("ANGLE_instanced_arrays"),
            drawBuffers: level2 || !!this.drawBufferExtension,
            asyncShaderCompile: !!gl.getExtension("KHR_parallel_shader_compile"),
            intIndexElementBuffer: !!gl.getExtension("OES_element_index_uint"),
            standardDerivatives: level2 || !!gl.getExtension("OES_standard_derivatives"),
            readableDepthStencilTextures: level2 || !!depthTextureExtension,
            writableFragDepth: level2 || !!gl.getExtension("EXT_frag_depth")
        };
        this["detail"] = detail;
        if (textureAnisotropicExt) {
            this.textureMaxAnisotropyExt = textureAnisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT;
        }
    };
    _proto.framebufferTexture2D = function framebufferTexture2D(gl, target, index, textarget, texture) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext && index > 0) {
            throw new Error("Draw multiple color buffers not available.");
        }
        var attachment = ext ? ext["COLOR_ATTACHMENT" + index + "_WEBGL"] : gl["COLOR_ATTACHMENT" + index];
        if (attachment) {
            gl.framebufferTexture2D(target, attachment, textarget, texture, 0);
        } else {
            console.error("Invalid color attachment index: " + index + ".");
        }
    };
    _proto.drawBuffers = function drawBuffers(gl, bufferStates) {
        var ext = this.drawBufferExtension;
        if (this.level === 1 && !ext) {
            if (bufferStates.length > 1) {
                throw new Error("Draw buffers not available.");
            } else {
                return;
            }
        }
        var buffers = bufferStates.map(function(enabled, index) {
            if (enabled) {
                return ext ? ext["COLOR_ATTACHMENT" + index + "_WEBGL"] : gl["COLOR_ATTACHMENT" + index];
            }
            return gl.NONE;
        });
        if (ext) {
            ext.drawBuffersWEBGL(buffers);
        } else {
            gl.drawBuffers(buffers);
        }
    };
    _proto.setTextureAnisotropic = function setTextureAnisotropic(gl, target, level) {
        var maxTextureAnisotropy = this.detail.maxTextureAnisotropy;
        if (maxTextureAnisotropy) {
            gl.texParameterf(target, this.textureMaxAnisotropyExt, Math.min(maxTextureAnisotropy, level || 4));
        }
    };
    return GPUCapability;
}();
function checkLinearTextureFilter(gl, type) {
    var tex = gl.createTexture();
    var ret = false;
    gl.getError();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.R16F, 1, 1, 0, gl.RED, type, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    if (!gl.getError()) {
        ret = true;
    }
    gl.deleteTexture(tex);
    return ret;
}
exports.COMPRESSED_TEXTURE = void 0;
(function(COMPRESSED_TEXTURE) {
    COMPRESSED_TEXTURE[COMPRESSED_TEXTURE["NONE"] = 0] = "NONE";
    COMPRESSED_TEXTURE[COMPRESSED_TEXTURE["PVRTC"] = 1] = "PVRTC";
    COMPRESSED_TEXTURE[COMPRESSED_TEXTURE["ASTC"] = 2] = "ASTC";
})(exports.COMPRESSED_TEXTURE || (exports.COMPRESSED_TEXTURE = {}));
function registerCompressedTexture(gl) {
    if (gl.getExtension("WEBGL_compressed_texture_astc")) {
        return 2;
    }
    if (gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")) {
        return 1;
    }
    return 0;
}

exports.FilterMode = void 0;
(function(FilterMode) {
    FilterMode[FilterMode["Nearest"] = 0] = "Nearest";
    FilterMode[FilterMode["Linear"] = 1] = "Linear";
})(exports.FilterMode || (exports.FilterMode = {}));
exports.RenderTextureFormat = void 0;
(function(RenderTextureFormat) {
    RenderTextureFormat[RenderTextureFormat["RGBA32"] = 0] = "RGBA32";
    RenderTextureFormat[RenderTextureFormat["RGBAHalf"] = 1] = "RGBAHalf";
})(exports.RenderTextureFormat || (exports.RenderTextureFormat = {}));
/**
 *
 */ var Framebuffer = /*#__PURE__*/ function() {
    function Framebuffer() {}
    var _proto = Framebuffer.prototype;
    _proto.resize = function resize(x, y, width, height) {
    // OVERRIDE
    };
    _proto.resetColorTextures = function resetColorTextures(textures) {
    // OVERRIDE
    };
    _proto.unbind = function unbind() {
    // OVERRIDE
    };
    _proto.bind = function bind() {
    // OVERRIDE
    };
    _proto.getDepthTexture = function getDepthTexture() {
        // OVERRIDE
        return undefined;
    };
    _proto.getStencilTexture = function getStencilTexture() {
        // OVERRIDE
        return undefined;
    };
    _proto.getColorTextures = function getColorTextures() {
        // OVERRIDE
        return [];
    };
    _proto.dispose = function dispose(options) {
    // OVERRIDE
    };
    _create_class(Framebuffer, [
        {
            key: "stencilStorage",
            get: function get() {
                // OVERRIDE
                return undefined;
            }
        },
        {
            key: "depthStorage",
            get: function get() {
                // OVERRIDE
                return undefined;
            }
        }
    ]);
    return Framebuffer;
}();

var Renderer = /*#__PURE__*/ function() {
    function Renderer() {}
    var _proto = Renderer.prototype;
    _proto.setGlobalFloat = function setGlobalFloat(name, value) {
    // OVERRIDE
    };
    _proto.setGlobalInt = function setGlobalInt(name, value) {
    // OVERRIDE
    };
    _proto.setGlobalVector4 = function setGlobalVector4(name, value) {
    // OVERRIDE
    };
    _proto.setGlobalMatrix = function setGlobalMatrix(name, value) {
    // OVERRIDE
    };
    _proto.getFramebuffer = function getFramebuffer() {
        // OVERRIDE
        return null;
    };
    _proto.setFramebuffer = function setFramebuffer(framebuffer) {
    // OVERRIDE
    };
    _proto.setViewport = function setViewport(x, y, width, height) {
    // OVERRIDE
    };
    _proto.resize = function resize(canvasWidth, canvasHeight) {
    // OVERRIDE
    };
    _proto.clear = function clear(action) {
    // OVERRIDE
    };
    _proto.getWidth = function getWidth() {
        // OVERRIDE
        return 0;
    };
    _proto.getHeight = function getHeight() {
        // OVERRIDE
        return 0;
    };
    /**
   * 添加 webglcontextlost 事件回调
   * @override
   * @param lostHandler
   */ _proto.addLostHandler = function addLostHandler(lostHandler) {
    // OVERRIDE
    };
    /**
   * 添加 webglContextrestored 事件的回调
   * @override
   * @param restoreHandler
   */ _proto.addRestoreHandler = function addRestoreHandler(restoreHandler) {
    // OVERRIDE
    };
    /**
   * @override
   * @param e
   */ _proto.lost = function lost(e) {
    // OVERRIDE
    };
    /**
   * @override
   */ _proto.restore = function restore() {
    // OVERRIDE
    };
    /**
   *
   * @override
   * @returns
   */ _proto.getShaderLibrary = function getShaderLibrary() {
        // OVERRIDE
        return undefined;
    };
    _proto.renderRenderFrame = function renderRenderFrame(renderFrame) {
    // OVERRIDE
    };
    _proto.renderMeshes = function renderMeshes(meshes) {
    // OVERRIDE
    };
    _proto.drawGeometry = function drawGeometry(geometry, material, subMeshIndex) {
    // OVERRIDE
    };
    _proto.getTemporaryRT = function getTemporaryRT(name, width, height, depthBuffer, filter, format) {
        // OVERRIDE
        return null;
    };
    _proto.dispose = function dispose(haltGL) {
    // OVERRIDE
    };
    return Renderer;
}();

/**
 * 后处理配置
 */ var defaultGlobalVolume = {
    useHDR: false,
    /***** Material Uniform *****/ // Bloom
    useBloom: true,
    threshold: 1.0,
    bloomIntensity: 1.0,
    // ColorAdjustments
    brightness: 1.0,
    saturation: 1.0,
    contrast: 1.0,
    // Vignette
    // vignetteColor: new math.Color(0, 0, 0, 1),
    // vignetteCenter: new math.Vector2(0.5, 0.5),
    vignetteIntensity: 0.2,
    vignetteSmoothness: 0.4,
    vignetteRoundness: 1.0,
    // ToneMapping
    useToneMapping: true
};

var vertex = "\nprecision highp float;\n\nattribute vec2 aPoint;\nuniform vec4 uPos;\nuniform vec2 uSize;\nuniform vec4 uQuat;\nuniform vec4 uColor;\nuniform mat4 effects_ObjectToWorld;\nuniform mat4 effects_MatrixInvV;\nuniform mat4 effects_MatrixVP;\nvarying vec4 vColor;\n#ifdef ENV_EDITOR\n  uniform vec4 uEditorTransform;\n#endif\n\nvec3 rotateByQuat(vec3 a, vec4 quat){\n  vec3 qvec = quat.xyz;\n  vec3 uv = cross(qvec, a);\n  vec3 uuv = cross(qvec, uv) * 2.;\n  return a +(uv * 2. * quat.w + uuv);\n}\n\nvoid main() {\n  vec4 _pos = uPos;\n  vec3 point = rotateByQuat(vec3(aPoint.xy * uSize, 0.),uQuat);\n  vec4 pos = vec4(_pos.xyz, 1.0);\n  pos = effects_ObjectToWorld * pos;\n  pos.xyz += effects_MatrixInvV[0].xyz * point.x+ effects_MatrixInvV[1].xyz * point.y;\n  gl_Position = effects_MatrixVP * pos;\n  vColor = uColor;\n  #ifdef ENV_EDITOR\n    gl_Position = vec4(gl_Position.xy * uEditorTransform.xy + uEditorTransform.zw * gl_Position.w, gl_Position.zw);\n  #endif\n}\n";
var fragment = "\nprecision highp float;\n\n#define fragColor gl_FragColor\n\nvarying vec4 vColor;\nvoid main() {\n  gl_FragColor = vColor*vColor.a;\n}\n";
var seed$7 = 1;
var InteractMesh = /*#__PURE__*/ function() {
    function InteractMesh(props, rendererOptions, transform, engine) {
        this.transform = transform;
        this.engine = engine;
        this.color = props.options.previewColor;
        var material = this.createMaterial(rendererOptions);
        var geometry = this.createGeometry();
        this.mesh = this.createMesh(geometry, material);
        this.updateMesh();
    }
    var _proto = InteractMesh.prototype;
    _proto.updateMesh = function updateMesh() {
        var material = this.mesh.material;
        var uSize = material.getVector2("uSize").clone();
        var uPos = material.getVector4("uPos").clone();
        var tempPos = new Vector3();
        var tempQuat = new Quaternion();
        var tempScale = this.transform.scale.clone();
        this.transform.assignWorldTRS(tempPos, tempQuat, tempScale);
        uSize.x = tempScale.x;
        uSize.y = tempScale.y;
        uPos.x = tempPos.x;
        uPos.y = tempPos.y;
        uPos.z = tempPos.z;
        material.setVector2("uSize", uSize);
        material.setVector4("uPos", uPos);
        material.setQuaternion("uQuat", tempQuat);
    };
    _proto.createMaterial = function createMaterial(rendererOptions) {
        var _this_engine_renderer;
        var macros = [
            [
                "ENV_EDITOR",
                ((_this_engine_renderer = this.engine.renderer) == null ? void 0 : _this_engine_renderer.env) === PLAYER_OPTIONS_ENV_EDITOR
            ]
        ];
        var color = createValueGetter(this.color).getValue(0);
        var materialProps = {
            shader: {
                vertex: vertex,
                fragment: fragment,
                glslVersion: exports.GLSLVersion.GLSL1,
                cacheId: "" + rendererOptions.cachePrefix + "_effects_interact",
                macros: macros
            },
            uniformSemantics: {
                effects_MatrixVP: "VIEWPROJECTION",
                effects_MatrixInvV: "VIEWINVERSE",
                effects_ObjectToWorld: "MODEL",
                uEditorTransform: "EDITOR_TRANSFORM"
            }
        };
        var material = Material.create(this.engine, materialProps);
        material.blending = true;
        material.depthTest = false;
        material.setVector4("uPos", new Vector4$1(0, 0, 0, 0));
        material.setVector2("uSize", new Vector2(1, 1));
        material.setVector4("uColor", new Vector4$1(color[0] / 255, color[1] / 255, color[2] / 255, color[3]));
        material.setQuaternion("uQuat", new Quaternion(0, 0, 0, 0));
        return material;
    };
    _proto.createGeometry = function createGeometry() {
        var indexData = new Uint8Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0
        ]);
        return Geometry.create(this.engine, {
            attributes: {
                aPoint: {
                    size: 2,
                    offset: 0,
                    stride: 2 * Float32Array.BYTES_PER_ELEMENT,
                    data: new Float32Array([
                        -0.5,
                        0.5,
                        0.5,
                        0.5,
                        0.5,
                        -0.5,
                        -0.5,
                        -0.5
                    ])
                }
            },
            drawCount: indexData.length,
            indices: {
                data: indexData
            },
            mode: glContext.LINES,
            maxVertex: 4
        });
    };
    _proto.createMesh = function createMesh(geometry, material) {
        return Mesh.create(this.engine, {
            name: "Interact_preview" + seed$7++,
            priority: 0,
            worldMatrix: Matrix4$1.fromIdentity(),
            geometry: geometry,
            material: material
        });
    };
    return InteractMesh;
}();

exports.InteractComponent = /*#__PURE__*/ function(RendererComponent) {
    _inherits(InteractComponent, RendererComponent);
    function InteractComponent() {
        var _this;
        _this = RendererComponent.apply(this, arguments) || this;
        /**
   * 拖拽的惯性衰减系数，范围[0, 1], 越大惯性越强
   */ _this.downgrade = 0.95;
        /**
   * 拖拽的距离映射系数，越大越容易拖动
   */ _this.dragRatio = [
            1,
            1
        ];
        /** 是否响应点击和拖拽交互事件 */ _this._interactive = true;
        _this.hasBeenAddedToComposition = false;
        _this.getHitTestParams = function(force) {
            if (!_this.clickable) {
                return;
            }
            var behavior = _this.item.props.content.options.behavior;
            var area = _this.getBoundingBox();
            if (area) {
                return {
                    type: area.type,
                    triangles: area.area,
                    behavior: behavior
                };
            }
        };
        return _this;
    }
    var _proto = InteractComponent.prototype;
    _proto.start = function start() {
        var _this = this;
        var options = this.item.props.content.options;
        var env = this.item.engine.renderer.env;
        var composition = this.item.composition;
        var _this_interactData_options = this.interactData.options, type = _this_interactData_options.type, showPreview = _this_interactData_options.showPreview;
        if (type === InteractType.CLICK) {
            this.clickable = true;
            if (showPreview && env === PLAYER_OPTIONS_ENV_EDITOR) {
                var rendererOptions = composition == null ? void 0 : composition.getRendererOptions();
                if (rendererOptions !== undefined) {
                    this.previewContent = new InteractMesh(this.item.props.content, rendererOptions, this.transform, this.engine);
                }
            }
        }
        if (options.type === InteractType.DRAG) {
            if (env !== PLAYER_OPTIONS_ENV_EDITOR || options.enableInEditor) {
                (composition == null ? void 0 : composition.event) && this.beginDragTarget(options, composition.event);
            }
        }
        if (this.previewContent) {
            this.previewContent.mesh.item = this.item;
            this.materials = this.previewContent.mesh.materials;
        }
        this.item.getHitTestParams = this.getHitTestParams;
        this.item.onEnd = function() {
            if (_this.item && _this.item.composition) {
                var _this_previewContent;
                _this.item.composition.removeInteractiveItem(_this.item, _this.item.props.content.options.type);
                _this.clickable = false;
                _this.hasBeenAddedToComposition = false;
                (_this_previewContent = _this.previewContent) == null ? void 0 : _this_previewContent.mesh.dispose();
                _this.endDragTarget();
            }
        };
    };
    _proto.update = function update(dt) {
        var _this_previewContent;
        (_this_previewContent = this.previewContent) == null ? void 0 : _this_previewContent.updateMesh();
        if (!this.hasBeenAddedToComposition && this.item.composition) {
            var options = this.item.props.content.options;
            this.item.composition.addInteractiveItem(this.item, options.type);
            this.hasBeenAddedToComposition = true;
        }
        if (!this.dragEvent || !this.bouncingArg) {
            return;
        }
        this.bouncingArg.vx *= this.downgrade;
        this.bouncingArg.vy *= this.downgrade;
        this.bouncingArg.dy += this.bouncingArg.vy;
        this.bouncingArg.dx += this.bouncingArg.vx;
        if (shouldIgnoreBouncing(this.bouncingArg)) {
            this.dragEvent = null;
            this.bouncingArg = null;
        } else {
            this.handleDragMove(this.dragEvent, this.bouncingArg);
        }
    };
    _proto.render = function render(renderer) {
        if (this.previewContent) {
            this.previewContent.mesh.render(renderer);
        }
    };
    _proto.onDestroy = function onDestroy() {};
    _proto.endDragTarget = function endDragTarget() {
    // OVERRIDE
    };
    _proto.handleDragMove = function handleDragMove(evt, event) {
        if (!(evt == null ? void 0 : evt.cameraParam) || !this.canInteract() || !this.item.composition) {
            return;
        }
        var options = this.item.props.content.options;
        var _evt_cameraParam = evt.cameraParam, position = _evt_cameraParam.position, fov = _evt_cameraParam.fov;
        var dy = event.dy;
        var dx = event.dx * event.width / event.height;
        var depth = position[2];
        var sp = Math.tan(fov * Math.PI / 180 / 2) * Math.abs(depth);
        var height = dy * sp;
        var width = dx * sp;
        var nx = position[0] - this.dragRatio[0] * width;
        var ny = position[1] - this.dragRatio[1] * height;
        if (options.dxRange) {
            var _options_dxRange = options.dxRange, min = _options_dxRange[0], max = _options_dxRange[1];
            nx = clamp$1(nx, min, max);
            if (nx !== min && nx !== max && min !== max) {
                var _event_origin;
                (_event_origin = event.origin) == null ? void 0 : _event_origin.preventDefault();
            }
        }
        if (options.dyRange) {
            var _options_dyRange = options.dyRange, min1 = _options_dyRange[0], max1 = _options_dyRange[1];
            ny = clamp$1(ny, min1, max1);
            if (ny !== min1 && ny !== max1 && min1 !== max1) {
                var _event_origin1;
                (_event_origin1 = event.origin) == null ? void 0 : _event_origin1.preventDefault();
            }
        }
        this.item.composition.camera.position = new Vector3(nx, ny, depth);
    };
    _proto.beginDragTarget = function beginDragTarget(options, eventSystem) {
        var _this = this;
        if (options.target !== "camera") {
            return;
        }
        var dragEvent;
        var handlerMap = {
            touchstart: function(event) {
                var _this_item_composition;
                if (!_this.canInteract()) {
                    return;
                }
                _this.dragEvent = null;
                _this.bouncingArg = null;
                var camera = (_this_item_composition = _this.item.composition) == null ? void 0 : _this_item_composition.camera;
                dragEvent = {
                    x: event.x,
                    y: event.y,
                    cameraParam: {
                        position: (camera == null ? void 0 : camera.position.toArray()) || [
                            0,
                            0,
                            8
                        ],
                        fov: (camera == null ? void 0 : camera.fov) || 60
                    }
                };
            },
            touchmove: function(event) {
                _this.handleDragMove(dragEvent, event);
                _this.bouncingArg = event;
            },
            touchend: function(event) {
                if (!_this.canInteract()) {
                    return;
                }
                var bouncingArg = _this.bouncingArg;
                if (!shouldIgnoreBouncing(bouncingArg, 3) && bouncingArg) {
                    var speed = 5;
                    bouncingArg.vx *= speed;
                    bouncingArg.vy *= speed;
                    _this.dragEvent = _extends({}, dragEvent);
                }
                dragEvent = null;
            }
        };
        Object.keys(handlerMap).forEach(function(name) {
            eventSystem.addEventListener(name, handlerMap[name]);
        });
        handlerMap.touchmove({
            dx: 0,
            dy: 0,
            width: 1,
            height: 1
        });
        this.item.getComponent(InteractComponent).endDragTarget = function() {
            Object.keys(handlerMap).forEach(function(name) {
                eventSystem.removeEventListener(name, handlerMap[name]);
            });
        };
    };
    _proto.getBoundingBox = function getBoundingBox() {
        var worldMatrix = this.transform.getWorldMatrix();
        var triangles = trianglesFromRect(Vector3.ZERO, 0.5 * this.transform.size.x, 0.5 * this.transform.size.y);
        triangles.forEach(function(triangle) {
            worldMatrix.transformPoint(triangle.p0);
            worldMatrix.transformPoint(triangle.p1);
            worldMatrix.transformPoint(triangle.p2);
        });
        return {
            type: exports.HitTestType.triangle,
            area: triangles
        };
    };
    _proto.fromData = function fromData(data) {
        RendererComponent.prototype.fromData.call(this, data);
        this.interactData = data;
    };
    _proto.canInteract = function canInteract() {
        var _this_item_composition;
        return Boolean((_this_item_composition = this.item.composition) == null ? void 0 : _this_item_composition.interactive) && this._interactive;
    };
    _create_class(InteractComponent, [
        {
            key: "interactive",
            get: function get() {
                return this._interactive;
            },
            set: function set(enable) {
                this._interactive = enable;
                if (!enable) {
                    // 立刻停止惯性滑动
                    this.bouncingArg = null;
                }
            }
        }
    ]);
    return InteractComponent;
}(RendererComponent);
exports.InteractComponent = __decorate([
    effectsClass(DataType.InteractComponent)
], exports.InteractComponent);
function shouldIgnoreBouncing(arg, mul) {
    var threshold = 0.00001 * (mul || 1);
    return arg && Math.abs(arg.vx || 0) < threshold && Math.abs(arg.vy || 0) < threshold;
}

exports.maxSpriteMeshItemCount = 8;
function setSpriteMeshMaxItemCountByGPU(gpuCapability) {
    if (gpuCapability.maxVertexUniforms >= 256) {
        return exports.maxSpriteMeshItemCount = 32;
    } else if (gpuCapability.maxVertexUniforms >= 128) {
        return exports.maxSpriteMeshItemCount = 16;
    }
}
function getImageItemRenderInfo(item) {
    var renderer = item.renderer;
    var blending = renderer.blending, side = renderer.side, occlusion = renderer.occlusion, mask = renderer.mask, maskMode = renderer.maskMode, order = renderer.order;
    var blendingCache = +blending;
    var cachePrefix = item.cachePrefix || "-";
    return {
        side: side,
        occlusion: occlusion,
        blending: blending,
        mask: mask,
        maskMode: maskMode,
        cachePrefix: cachePrefix,
        cacheId: cachePrefix + "." + +side + "+" + +occlusion + "+" + blendingCache + "+" + order + "+" + maskMode + "." + mask
    };
}
function spriteMeshShaderFromFilter(level, options) {
    var _ref = options != null ? options : {}, _ref_env = _ref.env, env = _ref_env === void 0 ? "" : _ref_env, wireframe = _ref.wireframe;
    var macros = [
        [
            "ENV_EDITOR",
            env === PLAYER_OPTIONS_ENV_EDITOR
        ]
    ];
    var fragment = wireframe ? itemFrameFrag : itemFrag;
    var vertex = itemVert;
    return {
        fragment: fragment,
        vertex: vertex,
        glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
        macros: macros,
        shared: true
    };
}
function spriteMeshShaderIdFromRenderInfo(renderInfo, count) {
    return renderInfo.cachePrefix + "_effects_sprite_" + count;
}
function spriteMeshShaderFromRenderInfo(renderInfo, count, level, env) {
    var wireframe = renderInfo.wireframe;
    var shader = spriteMeshShaderFromFilter(level, {
        wireframe: wireframe,
        env: env
    });
    shader.shared = true;
    if (!wireframe) {
        shader.cacheId = spriteMeshShaderIdFromRenderInfo(renderInfo, count);
    }
    return shader;
}
// TODO: 只有单测用
function setMaxSpriteMeshItemCount(count) {
    exports.maxSpriteMeshItemCount = count;
}

var defRenderInfo = {
    blending: 0,
    cacheId: "-",
    mask: 0,
    maskMode: 0,
    occlusion: false,
    side: 0,
    cachePrefix: "-"
};
var SpriteLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(SpriteLoader, AbstractPlugin);
    function SpriteLoader() {
        var _this;
        _this = AbstractPlugin.apply(this, arguments) || this;
        _this.name = "sprite";
        return _this;
    }
    SpriteLoader.precompile = function precompile(compositions, render, options) {
        var shaderLibrary = render.getShaderLibrary();
        var _render_engine_gpuCapability = render.engine.gpuCapability, level = _render_engine_gpuCapability.level, detail = _render_engine_gpuCapability.detail;
        var env = (options != null ? options : {}).env;
        if (!(shaderLibrary == null ? void 0 : shaderLibrary.shaderResults[spriteMeshShaderIdFromRenderInfo(defRenderInfo, 2)])) {
            shaderLibrary == null ? void 0 : shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, 2, 1, env));
            shaderLibrary == null ? void 0 : shaderLibrary.addShader(spriteMeshShaderFromRenderInfo(defRenderInfo, exports.maxSpriteMeshItemCount, 1, env));
            if (detail.writableFragDepth) {
                shaderLibrary == null ? void 0 : shaderLibrary.addShader(createCopyShader(level, true));
            }
        }
        return Promise.resolve();
    };
    return SpriteLoader;
}(AbstractPlugin);

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}

/**
 * 动画图，负责更新所有的动画节点
 * @since 2.0.0
 * @internal
 */ var PlayableGraph = /*#__PURE__*/ function() {
    function PlayableGraph() {
        this.playableOutputs = [];
        this.playables = [];
    }
    var _proto = PlayableGraph.prototype;
    _proto.evaluate = function evaluate(dt) {
        // 初始化节点状态
        for(var _iterator = _create_for_of_iterator_helper_loose(this.playables), _step; !(_step = _iterator()).done;){
            var playable = _step.value;
            this.updatePlayableTime(playable, dt);
        }
        // 初始化输出节点状态
        for(var _iterator1 = _create_for_of_iterator_helper_loose(this.playableOutputs), _step1; !(_step1 = _iterator1()).done;){
            var playableOutput = _step1.value;
            playableOutput.context.deltaTime = dt;
        }
        // 执行生命周期函数
        for(var _iterator2 = _create_for_of_iterator_helper_loose(this.playableOutputs), _step2; !(_step2 = _iterator2()).done;){
            var playableOutput1 = _step2.value;
            this.prepareFrameWithRoot(playableOutput1);
        }
        for(var _iterator3 = _create_for_of_iterator_helper_loose(this.playableOutputs), _step3; !(_step3 = _iterator3()).done;){
            var playableOutput2 = _step3.value;
            this.processFrameWithRoot(playableOutput2);
        }
    };
    _proto.connect = function connect(source, sourceOutputPort, destination, destinationInputPort) {
        destination.connectInput(destinationInputPort, source, sourceOutputPort);
    };
    _proto.addOutput = function addOutput(output) {
        this.playableOutputs.push(output);
    };
    _proto.addPlayable = function addPlayable(playable) {
        this.playables.push(playable);
    };
    _proto.processFrameWithRoot = function processFrameWithRoot(output) {
        output.sourcePlayable.processFrameRecursive(output.context, output.getSourceOutputPort());
        output.processFrame();
    };
    _proto.prepareFrameWithRoot = function prepareFrameWithRoot(output) {
        output.sourcePlayable.prepareFrameRecursive(output.context, output.getSourceOutputPort());
        output.prepareFrame();
    };
    _proto.updatePlayableTime = function updatePlayableTime(playable, deltaTime) {
        if (playable.getPlayState() !== 0) {
            return;
        }
        if (playable.overrideTimeNextEvaluation) {
            playable.overrideTimeNextEvaluation = false;
        } else {
            playable.setTime(playable.getTime() + deltaTime);
        }
    };
    return PlayableGraph;
}();
/**
 * 动画图可播放节点对象
 * @since 2.0.0
 * @internal
 */ var Playable = /*#__PURE__*/ function() {
    function Playable(graph, inputCount) {
        if (inputCount === void 0) inputCount = 0;
        this.onPlayablePlayFlag = true;
        this.onPlayablePauseFlag = false;
        this.overrideTimeNextEvaluation = false;
        this.destroyed = false;
        this.inputs = [];
        this.inputOuputPorts = [];
        this.inputWeight = [];
        this.outputs = [];
        this.playState = 0;
        this.traversalMode = 0;
        graph.addPlayable(this);
        this.inputs = new Array(inputCount);
        this.inputOuputPorts = new Array(inputCount);
        this.inputWeight = new Array(inputCount);
    }
    var _proto = Playable.prototype;
    _proto.play = function play() {
        switch(this.playState){
            case 0:
                break;
            case 1:
                this.playState = 0;
                this.onPlayablePlayFlag = true;
                this.onPlayablePauseFlag = false;
                break;
        }
    };
    _proto.pause = function pause() {
        switch(this.playState){
            case 0:
                this.playState = 1;
                this.onPlayablePauseFlag = true;
                this.onPlayablePlayFlag = false;
                break;
        }
    };
    _proto.connectInput = function connectInput(inputPort, sourcePlayable, sourceOutputPort, weight) {
        if (weight === void 0) weight = 1.0;
        this.setInput(sourcePlayable, inputPort);
        this.setInputWeight(inputPort, weight);
        sourcePlayable.setOutput(this, sourceOutputPort);
        if (this.inputOuputPorts.length < inputPort + 1) {
            this.inputOuputPorts.length = inputPort + 1;
        }
        this.inputOuputPorts[inputPort] = sourceOutputPort;
    };
    _proto.addInput = function addInput(sourcePlayable, sourceOutputPort, weight) {
        if (weight === void 0) weight = 1.0;
        this.connectInput(this.getInputCount(), sourcePlayable, sourceOutputPort, weight);
    };
    _proto.getInputCount = function getInputCount() {
        return this.inputs.length;
    };
    _proto.getInputs = function getInputs() {
        return this.inputs;
    };
    _proto.getInput = function getInput(index) {
        return this.inputs[index];
    };
    _proto.getOutputCount = function getOutputCount() {
        return this.outputs.length;
    };
    _proto.getOutputs = function getOutputs() {
        return this.outputs;
    };
    _proto.getOutput = function getOutput(index) {
        return this.outputs[index];
    };
    _proto.getInputWeight = function getInputWeight(inputIndex) {
        return this.inputWeight[inputIndex];
    };
    _proto.setInputWeight = function setInputWeight(playableOrIndex, weight) {
        if (_instanceof1(playableOrIndex, Playable)) {
            for(var i = 0; i < this.inputs.length; i++){
                if (this.inputs[i] === playableOrIndex) {
                    this.inputWeight[i] = weight;
                    return;
                }
            }
        } else {
            if (this.inputWeight.length < playableOrIndex + 1) {
                this.inputWeight.length = playableOrIndex + 1;
            }
            this.inputWeight[playableOrIndex] = weight;
        }
    };
    _proto.setTime = function setTime(time) {
        this.time = time;
        this.overrideTimeNextEvaluation = true;
    };
    _proto.getTime = function getTime() {
        return this.time;
    };
    _proto.getPlayState = function getPlayState() {
        return this.playState;
    };
    _proto.setTraversalMode = function setTraversalMode(mode) {
        this.traversalMode = mode;
    };
    _proto.getTraversalMode = function getTraversalMode() {
        return this.traversalMode;
    };
    // onGraphStart () {
    // }
    // onGraphStop () {
    // }
    _proto.onPlayablePlay = function onPlayablePlay(context) {};
    _proto.onPlayablePause = function onPlayablePause(context) {};
    _proto.prepareFrame = function prepareFrame(context) {};
    _proto.processFrame = function processFrame(context) {};
    _proto.onPlayableDestroy = function onPlayableDestroy() {};
    _proto.dispose = function dispose() {
        if (this.destroyed) {
            return;
        }
        this.onPlayableDestroy();
        // TODO 将节点从动画图中移除
        this.destroyed = true;
    };
    /**
   * @internal
   */ _proto.prepareFrameRecursive = function prepareFrameRecursive(context, passthroughPort) {
        if (this.destroyed || this.playState !== 0) {
            return;
        }
        if (this.onPlayablePlayFlag) {
            this.onPlayablePlay(context);
            this.onPlayablePlayFlag = false;
        }
        if (this.onPlayablePauseFlag) {
            this.onPlayablePause(context);
            this.onPlayablePauseFlag = false;
        }
        if (passthroughPort === 0) {
            this.prepareFrame(context);
        }
        // 前序遍历，用于设置节点的初始状态，weight etc.
        switch(this.getTraversalMode()){
            case 0:
                for(var i = 0; i < this.getInputCount(); i++){
                    var input = this.getInput(i);
                    input.prepareFrameRecursive(context, this.inputOuputPorts[i]);
                }
                break;
            case 1:
                {
                    var input1 = this.getInput(passthroughPort);
                    input1.prepareFrameRecursive(context, this.inputOuputPorts[passthroughPort]);
                    break;
                }
        }
    };
    /**
   * @internal
   */ _proto.processFrameRecursive = function processFrameRecursive(context, passthroughPort) {
        if (this.destroyed || this.playState !== 0) {
            return;
        }
        // 后序遍历，保证 playable 拿到的 input 节点的估计数据是最新的
        switch(this.getTraversalMode()){
            case 0:
                {
                    for(var i = 0; i < this.getInputCount(); i++){
                        var input = this.getInput(i);
                        input.processFrameRecursive(context, this.inputOuputPorts[i]);
                    }
                    break;
                }
            case 1:
                {
                    var input1 = this.getInput(passthroughPort);
                    input1.processFrameRecursive(context, this.inputOuputPorts[passthroughPort]);
                    break;
                }
        }
        this.processFrame(context);
    };
    _proto.setOutput = function setOutput(outputPlayable, outputPort) {
        if (this.outputs.length < outputPort + 1) {
            this.outputs.length = outputPort + 1;
        }
        this.outputs[outputPort] = outputPlayable;
    };
    _proto.setInput = function setInput(inputPlayable, inputPort) {
        if (this.inputs.length < inputPort + 1) {
            this.inputs.length = inputPort + 1;
        }
        this.inputs[inputPort] = inputPlayable;
    };
    return Playable;
}();
/**
 * 动画图输出节点对象，将动画数据采样到绑定的元素属性上
 * @since 2.0.0
 * @internal
 */ var PlayableOutput = /*#__PURE__*/ function() {
    function PlayableOutput() {
        this.sourceOutputPort = 0;
        this.context = {
            deltaTime: 0,
            output: this
        };
    }
    var _proto = PlayableOutput.prototype;
    _proto.setSourcePlayeble = function setSourcePlayeble(playable, port) {
        if (port === void 0) port = 0;
        this.sourcePlayable = playable;
        this.sourceOutputPort = port;
    };
    _proto.getSourceOutputPort = function getSourceOutputPort() {
        return this.sourceOutputPort;
    };
    _proto.setUserData = function setUserData(value) {
        this.userData = value;
    };
    _proto.getUserData = function getUserData() {
        return this.userData;
    };
    // onGraphStart () {
    // }
    _proto.prepareFrame = function prepareFrame() {};
    _proto.processFrame = function processFrame() {};
    return PlayableOutput;
}();
var PlayableAsset = /*#__PURE__*/ function(EffectsObject) {
    _inherits(PlayableAsset, EffectsObject);
    function PlayableAsset() {
        return EffectsObject.apply(this, arguments);
    }
    return PlayableAsset;
}(EffectsObject);
var PlayState;
(function(PlayState) {
    PlayState[PlayState["Playing"] = 0] = "Playing";
    PlayState[PlayState["Paused"] = 1] = "Paused";
})(PlayState || (PlayState = {}));
var PlayableTraversalMode;
(function(PlayableTraversalMode) {
    PlayableTraversalMode[PlayableTraversalMode["Mix"] = 0] = "Mix";
    PlayableTraversalMode[PlayableTraversalMode["Passthrough"] = 1] = "Passthrough";
})(PlayableTraversalMode || (PlayableTraversalMode = {}));

var singleSplits = [
    [
        0,
        0,
        1,
        1,
        undefined
    ]
];
var tempColor = [
    1,
    1,
    1,
    1
];
var seed$6 = 0;
var SpriteColorPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(SpriteColorPlayable, Playable);
    function SpriteColorPlayable() {
        var _this;
        _this = Playable.apply(this, arguments) || this;
        _this.renderColor = [
            1,
            1,
            1,
            1
        ];
        return _this;
    }
    var _proto = SpriteColorPlayable.prototype;
    _proto.processFrame = function processFrame(context) {
        var boundObject = context.output.getUserData();
        if (!_instanceof1(boundObject, exports.VFXItem)) {
            return;
        }
        if (!this.spriteComponent) {
            this.spriteComponent = boundObject.getComponent(exports.SpriteComponent);
        }
        if (!this.spriteMaterial) {
            this.spriteMaterial = this.spriteComponent.material;
            var startColor = this.spriteMaterial.getVector4("_Color");
            if (startColor) {
                this.startColor = startColor.toArray();
            }
        }
        this.spriteComponent.setAnimationTime(this.time);
        var colorInc = vecFill(tempColor, 1);
        var colorChanged;
        var life = this.time / boundObject.duration;
        var opacityOverLifetime = this.opacityOverLifetime;
        var colorOverLifetime = this.colorOverLifetime;
        if (colorOverLifetime) {
            colorInc = getColorFromGradientStops(colorOverLifetime, life, true);
            colorChanged = true;
        }
        if (opacityOverLifetime) {
            colorInc[3] *= opacityOverLifetime.getValue(life);
            colorChanged = true;
        }
        if (colorChanged) {
            var _this_spriteMaterial_getVector4;
            vecMulCombine(this.renderColor, colorInc, this.startColor);
            (_this_spriteMaterial_getVector4 = this.spriteMaterial.getVector4("_Color")) == null ? void 0 : _this_spriteMaterial_getVector4.setFromArray(this.renderColor);
        }
    };
    _proto.create = function create(clipData) {
        this.clipData = clipData;
        var colorOverLifetime = clipData.colorOverLifetime;
        if (colorOverLifetime) {
            var _colorOverLifetime_opacity;
            this.opacityOverLifetime = createValueGetter((_colorOverLifetime_opacity = colorOverLifetime.opacity) != null ? _colorOverLifetime_opacity : 1);
            if (colorOverLifetime.color && colorOverLifetime.color[0] === ValueType.GRADIENT_COLOR) {
                this.colorOverLifetime = colorStopsFromGradient(colorOverLifetime.color[1]);
            }
        }
        return this;
    };
    return SpriteColorPlayable;
}(Playable);
exports.SpriteColorPlayableAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(SpriteColorPlayableAsset, PlayableAsset);
    function SpriteColorPlayableAsset() {
        return PlayableAsset.apply(this, arguments);
    }
    var _proto = SpriteColorPlayableAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        var spriteColorPlayable = new SpriteColorPlayable(graph);
        spriteColorPlayable.create(this.data);
        return spriteColorPlayable;
    };
    _proto.fromData = function fromData(data) {
        this.data = data;
    };
    return SpriteColorPlayableAsset;
}(PlayableAsset);
exports.SpriteColorPlayableAsset = __decorate([
    effectsClass("SpriteColorPlayableAsset")
], exports.SpriteColorPlayableAsset);
exports.SpriteComponent = /*#__PURE__*/ function(RendererComponent) {
    _inherits(SpriteComponent, RendererComponent);
    function SpriteComponent(engine, props) {
        var _this;
        _this = RendererComponent.call(this, engine) || this;
        _this.cachePrefix = "-";
        _this.frameAnimationLoop = false;
        _this.color = [
            1,
            1,
            1,
            1
        ];
        _this.visible = true;
        _this.isManualTimeSet = false;
        _this.frameAnimationTime = 0;
        _this.getHitTestParams = function(force) {
            var ui = _this.interaction;
            if (force || ui) {
                var area = _this.getBoundingBox();
                if (area) {
                    var _this_interaction;
                    return {
                        behavior: ((_this_interaction = _this.interaction) == null ? void 0 : _this_interaction.behavior) || 0,
                        type: area.type,
                        triangles: area.area,
                        backfaceCulling: _this.renderer.side === SideMode.FRONT
                    };
                }
            }
        };
        _this.name = "MSprite" + seed$6++;
        _this.renderer = {
            renderMode: RenderMode.BILLBOARD,
            blending: BlendingMode.ALPHA,
            texture: _this.engine.emptyTexture,
            occlusion: false,
            transparentOcclusion: false,
            side: SideMode.DOUBLE,
            mask: 0,
            maskMode: MaskMode.NONE,
            order: 0
        };
        _this.emptyTexture = _this.engine.emptyTexture;
        _this.splits = singleSplits;
        _this.renderInfo = getImageItemRenderInfo(_assert_this_initialized(_this));
        var geometry = _this.createGeometry(glContext.TRIANGLES);
        var material = _this.createMaterial(_this.renderInfo, 2);
        _this.worldMatrix = Matrix4$1.fromIdentity();
        _this.material = material;
        _this.geometry = geometry;
        _this.material.setVector4("_Color", new Vector4$1().setFromArray([
            1,
            1,
            1,
            1
        ]));
        _this.material.setVector4("_TexOffset", new Vector4$1().setFromArray([
            0,
            0,
            1,
            1
        ]));
        _this.setItem();
        if (props) {
            _this.fromData(props);
        }
        return _this;
    }
    var _proto = SpriteComponent.prototype;
    /**
   * 设置当前 Mesh 的可见性。
   * @param visible - true：可见，false：不可见
   */ _proto.setVisible = function setVisible(visible) {
        this.visible = visible;
    };
    /**
   * 获取当前 Mesh 的可见性。
   */ _proto.getVisible = function getVisible() {
        return this.visible;
    };
    /**
   * 设置当前图层的颜色
   * > Tips: 透明度也属于颜色的一部分，当有透明度/颜色 K 帧变化时，该 API 会失效
   * @since 2.0.0
   * @param color - 颜色值
   */ _proto.setColor = function setColor(color) {
        this.color = color;
        this.material.setVector4("_Color", new Vector4$1().setFromArray(color));
    };
    /**
   * 设置当前 Mesh 的纹理
   * @since 2.0.0
   * @param texture - 纹理对象
   */ _proto.setTexture = function setTexture(texture) {
        this.renderer.texture = texture;
        this.material.setTexture("uSampler0", texture);
    };
    /**
   * @internal
   */ _proto.setAnimationTime = function setAnimationTime(time) {
        this.frameAnimationTime = time;
        this.isManualTimeSet = true;
    };
    _proto.render = function render(renderer) {
        if (!this.getVisible()) {
            return;
        }
        var material = this.material;
        var geo = this.geometry;
        if (renderer.renderingData.currentFrame.globalUniforms) {
            renderer.setGlobalMatrix("effects_ObjectToWorld", this.transform.getWorldMatrix());
        }
        this.material.setVector2("_Size", this.transform.size);
        renderer.drawGeometry(geo, material);
    };
    _proto.start = function start() {
        this.item.getHitTestParams = this.getHitTestParams;
    };
    _proto.update = function update(dt) {
        if (!this.isManualTimeSet) {
            this.frameAnimationTime += dt / 1000;
            this.isManualTimeSet = false;
        }
        var time = this.frameAnimationTime;
        var duration = this.item.duration;
        if (time > duration && this.frameAnimationLoop) {
            time = time % duration;
        }
        var life = Math.min(Math.max(time / duration, 0.0), 1.0);
        var ta = this.textureSheetAnimation;
        if (ta) {
            var _this_material_getVector4;
            var total = ta.total || ta.row * ta.col;
            var texRectX = 0;
            var texRectY = 0;
            var texRectW = 1;
            var texRectH = 1;
            var flip;
            if (this.splits) {
                var sp = this.splits[0];
                flip = sp[4];
                texRectX = sp[0];
                texRectY = sp[1];
                if (flip) {
                    texRectW = sp[3];
                    texRectH = sp[2];
                } else {
                    texRectW = sp[2];
                    texRectH = sp[3];
                }
            }
            var dx, dy;
            if (flip) {
                dx = 1 / ta.row * texRectW;
                dy = 1 / ta.col * texRectH;
            } else {
                dx = 1 / ta.col * texRectW;
                dy = 1 / ta.row * texRectH;
            }
            var texOffset;
            if (ta.animate) {
                var frameIndex = Math.round(life * (total - 1));
                var yIndex = Math.floor(frameIndex / ta.col);
                var xIndex = frameIndex - yIndex * ta.col;
                texOffset = flip ? [
                    dx * yIndex,
                    dy * (ta.col - xIndex)
                ] : [
                    dx * xIndex,
                    dy * (1 + yIndex)
                ];
            } else {
                texOffset = [
                    0,
                    dy
                ];
            }
            (_this_material_getVector4 = this.material.getVector4("_TexOffset")) == null ? void 0 : _this_material_getVector4.setFromArray([
                texRectX + texOffset[0],
                texRectH + texRectY - texOffset[1],
                dx,
                dy
            ]);
        }
    };
    _proto.onDestroy = function onDestroy() {
        if (this.item && this.item.composition) {
            this.item.composition.destroyTextures(this.getTextures());
        }
    };
    _proto.getItemInitData = function getItemInitData() {
        this.geoData = this.getItemGeometryData();
        var _this_geoData = this.geoData, index = _this_geoData.index, atlasOffset = _this_geoData.atlasOffset;
        var idxCount = index.length;
        // @ts-expect-error
        var indexData = this.wireframe ? new Uint8Array([
            0,
            1,
            1,
            3,
            2,
            3,
            2,
            0
        ]) : new index.constructor(idxCount);
        if (!this.wireframe) {
            for(var i = 0; i < idxCount; i++){
                indexData[i] = 0 + index[i];
            }
        }
        return {
            atlasOffset: atlasOffset,
            index: indexData
        };
    };
    _proto.setItem = function setItem() {
        var textures = [];
        var texture = this.renderer.texture;
        if (texture) {
            addItem(textures, texture);
        }
        texture = this.renderer.texture;
        var data = this.getItemInitData();
        var renderer = this.renderer;
        var texParams = this.material.getVector4("_TexParams");
        if (texParams) {
            texParams.x = renderer.occlusion ? +renderer.transparentOcclusion : 1;
            texParams.y = +this.preMultiAlpha;
            texParams.z = renderer.renderMode;
        }
        var attributes = {
            atlasOffset: new Float32Array(data.atlasOffset.length),
            index: new Uint16Array(data.index.length)
        };
        attributes.atlasOffset.set(data.atlasOffset);
        attributes.index.set(data.index);
        var _this = this, material = _this.material, geometry = _this.geometry;
        var indexData = attributes.index;
        geometry.setIndexData(indexData);
        geometry.setAttributeData("atlasOffset", attributes.atlasOffset);
        geometry.setDrawCount(data.index.length);
        for(var i = 0; i < textures.length; i++){
            var texture1 = textures[i];
            material.setTexture("uSampler" + i, texture1);
        }
        // FIXME: 内存泄漏的临时方案，后面再调整
        var emptyTexture = this.emptyTexture;
        for(var k = textures.length; k < exports.maxSpriteMeshItemCount; k++){
            material.setTexture("uSampler" + k, emptyTexture);
        }
    };
    _proto.createGeometry = function createGeometry(mode) {
        var maxVertex = 12 * this.splits.length;
        return Geometry.create(this.engine, {
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 3,
                    data: new Float32Array([
                        -0.5,
                        0.5,
                        0,
                        -0.5,
                        -0.5,
                        0,
                        0.5,
                        0.5,
                        0,
                        0.5,
                        -0.5,
                        0
                    ])
                },
                atlasOffset: {
                    size: 2,
                    offset: 0,
                    releasable: true,
                    type: glContext.FLOAT,
                    data: new Float32Array(0)
                }
            },
            indices: {
                data: new Uint16Array(0),
                releasable: true
            },
            mode: mode,
            maxVertex: maxVertex
        });
    };
    _proto.createMaterial = function createMaterial(renderInfo, count) {
        var side = renderInfo.side, occlusion = renderInfo.occlusion, blending = renderInfo.blending, maskMode = renderInfo.maskMode, mask = renderInfo.mask;
        var materialProps = {
            shader: spriteMeshShaderFromRenderInfo(renderInfo, count, 1)
        };
        this.preMultiAlpha = getPreMultiAlpha(blending);
        var material = Material.create(this.engine, materialProps);
        var states = {
            side: side,
            blending: true,
            blendMode: blending,
            mask: mask,
            maskMode: maskMode,
            depthTest: true,
            depthMask: occlusion
        };
        material.blending = states.blending;
        material.stencilRef = states.mask !== undefined ? [
            states.mask,
            states.mask
        ] : undefined;
        material.depthTest = states.depthTest;
        material.depthMask = states.depthMask;
        setBlendMode(material, states.blendMode);
        setMaskMode(material, states.maskMode);
        setSideMode(material, states.side);
        material.shader.shaderData.properties = 'uSampler0("uSampler0",2D) = "white" {}';
        if (!material.hasUniform("_Color")) {
            material.setVector4("_Color", new Vector4$1(0, 0, 0, 1));
        }
        if (!material.hasUniform("_TexOffset")) {
            material.setVector4("_TexOffset", new Vector4$1());
        }
        if (!material.hasUniform("_TexParams")) {
            material.setVector4("_TexParams", new Vector4$1());
        }
        return material;
    };
    _proto.getItemGeometryData = function getItemGeometryData() {
        var _this = this, splits = _this.splits, renderer = _this.renderer, textureSheetAnimation = _this.textureSheetAnimation;
        var sx = 1, sy = 1;
        if (renderer.shape) {
            var _renderer_shape = renderer.shape, _renderer_shape_index = _renderer_shape.index, index = _renderer_shape_index === void 0 ? [] : _renderer_shape_index, _renderer_shape_aPoint = _renderer_shape.aPoint, aPoint = _renderer_shape_aPoint === void 0 ? [] : _renderer_shape_aPoint;
            var point = new Float32Array(aPoint);
            var position = [];
            var atlasOffset = [];
            for(var i = 0; i < point.length; i += 6){
                point[i] *= sx;
                point[i + 1] *= sy;
                atlasOffset.push(aPoint[i + 2], aPoint[i + 3]);
                position.push(point[i], point[i + 1], 0.0);
            }
            this.geometry.setAttributeData("aPos", new Float32Array(position));
            return {
                index: index,
                atlasOffset: atlasOffset
            };
        }
        var originData = [
            -.5,
            .5,
            -.5,
            -.5,
            .5,
            .5,
            .5,
            -.5
        ];
        var atlasOffset1 = [];
        var index1 = [];
        var col = 2;
        var row = 2;
        if (splits.length === 1) {
            col = 1;
            row = 1;
        }
        var position1 = [];
        for(var x = 0; x < col; x++){
            for(var y = 0; y < row; y++){
                var base = (y * 2 + x) * 4;
                // @ts-expect-error
                var split = textureSheetAnimation ? [
                    0,
                    0,
                    1,
                    1,
                    splits[0][4]
                ] : splits[y * 2 + x];
                var texOffset = split[4] ? [
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    1,
                    1
                ] : [
                    0,
                    1,
                    0,
                    0,
                    1,
                    1,
                    1,
                    0
                ];
                var dw = ((x + x + 1) / col - 1) / 2;
                var dh = ((y + y + 1) / row - 1) / 2;
                var tox = split[0];
                var toy = split[1];
                var tsx = split[4] ? split[3] : split[2];
                var tsy = split[4] ? split[2] : split[3];
                var origin = [
                    originData[0] / col + dw,
                    originData[1] / row + dh,
                    originData[2] / col + dw,
                    originData[3] / row + dh,
                    originData[4] / col + dw,
                    originData[5] / row + dh,
                    originData[6] / col + dw,
                    originData[7] / row + dh
                ];
                atlasOffset1.push(texOffset[0] * tsx + tox, texOffset[1] * tsy + toy, texOffset[2] * tsx + tox, texOffset[3] * tsy + toy, texOffset[4] * tsx + tox, texOffset[5] * tsy + toy, texOffset[6] * tsx + tox, texOffset[7] * tsy + toy);
                position1.push(origin[0] * sx, origin[1] * sy, 0.0, origin[2] * sx, origin[3] * sy, 0.0, origin[4] * sx, origin[5] * sy, 0.0, origin[6] * sx, origin[7] * sy, 0.0);
                index1.push(base, 1 + base, 2 + base, 2 + base, 1 + base, 3 + base);
            }
        }
        this.geometry.setAttributeData("aPos", new Float32Array(position1));
        return {
            index: index1,
            atlasOffset: atlasOffset1
        };
    };
    _proto.getTextures = function getTextures() {
        var ret = [];
        var tex = this.renderer.texture;
        if (tex) {
            ret.push(tex);
        }
        return ret;
    };
    /**
   * 获取图层包围盒的类型和世界坐标
   * @returns
   */ _proto.getBoundingBox = function getBoundingBox() {
        if (!this.item) {
            return;
        }
        var worldMatrix = this.transform.getWorldMatrix();
        var triangles = trianglesFromRect(Vector3.ZERO, 0.5 * this.transform.size.x, 0.5 * this.transform.size.y);
        triangles.forEach(function(triangle) {
            worldMatrix.transformPoint(triangle.p0);
            worldMatrix.transformPoint(triangle.p1);
            worldMatrix.transformPoint(triangle.p2);
        });
        return {
            type: exports.HitTestType.triangle,
            area: triangles
        };
    };
    // TODO: [1.31] @十弦 https://github.com/galacean/effects-runtime/commit/fe8736540b9a461d8e96658f4d755ff8089a263b#diff-a3618f4527c5fe6e842f20d67d5c82984568502c6bf6fdfcbd24f69e2894ca90
    _proto.fromData = function fromData(data) {
        RendererComponent.prototype.fromData.call(this, data);
        var interaction = data.interaction, options = data.options, _data_listIndex = data.listIndex, listIndex = _data_listIndex === void 0 ? 0 : _data_listIndex;
        var renderer = data.renderer;
        if (!renderer) {
            //@ts-expect-error
            renderer = {};
        }
        this.interaction = interaction;
        var _renderer_renderMode, _renderer_blending, _renderer_texture, _renderer_side, _renderer_mask, _renderer_maskMode;
        this.renderer = {
            renderMode: (_renderer_renderMode = renderer.renderMode) != null ? _renderer_renderMode : RenderMode.BILLBOARD,
            blending: (_renderer_blending = renderer.blending) != null ? _renderer_blending : BlendingMode.ALPHA,
            texture: (_renderer_texture = renderer.texture) != null ? _renderer_texture : this.engine.emptyTexture,
            occlusion: !!renderer.occlusion,
            transparentOcclusion: !!renderer.transparentOcclusion || renderer.maskMode === MaskMode.MASK,
            side: (_renderer_side = renderer.side) != null ? _renderer_side : SideMode.DOUBLE,
            shape: renderer.shape,
            mask: (_renderer_mask = renderer.mask) != null ? _renderer_mask : 0,
            maskMode: (_renderer_maskMode = renderer.maskMode) != null ? _renderer_maskMode : MaskMode.NONE,
            order: listIndex
        };
        this.emptyTexture = this.engine.emptyTexture;
        this.splits = data.splits || singleSplits;
        this.textureSheetAnimation = data.textureSheetAnimation;
        this.cachePrefix = "-";
        this.renderInfo = getImageItemRenderInfo(this);
        var geometry = this.createGeometry(glContext.TRIANGLES);
        var material = this.createMaterial(this.renderInfo, 2);
        this.worldMatrix = Matrix4$1.fromIdentity();
        this.material = material;
        this.geometry = geometry;
        var startColor = options.startColor || [
            1,
            1,
            1,
            1
        ];
        this.material.setVector4("_Color", new Vector4$1().setFromArray(startColor));
        this.material.setVector4("_TexOffset", new Vector4$1().setFromArray([
            0,
            0,
            1,
            1
        ]));
        this.setItem();
    };
    _proto.toData = function toData() {
        RendererComponent.prototype.toData.call(this);
    };
    return SpriteComponent;
}(RendererComponent);
exports.SpriteComponent = __decorate([
    effectsClass(DataType.SpriteComponent)
], exports.SpriteComponent);

var RUNTIME_ENV = "runtime_env";
var RENDER_PREFER_LOOKUP_TEXTURE = "lookup_texture";
// 文本元素使用 offscreen canvas 绘制
var TEMPLATE_USE_OFFSCREEN_CANVAS = "offscreen_canvas";
// 后处理配置相关
var POST_PROCESS_SETTINGS = "post_process_settings";
var config = {};
function getConfig(name) {
    return config[name];
}
function setConfig(name, value) {
    return config[name] = value;
}

var tempQuat$1 = new Quaternion();
var seed$5 = 1;
// TODO 继承 Component
var Transform = /*#__PURE__*/ function() {
    function Transform(props, parent) {
        if (props === void 0) props = {};
        this.taggedProperties = {};
        /**
   * 自身位移
   */ this.position = new Vector3(0, 0, 0);
        /**
   * 自身旋转对应的四元数，右手坐标系，旋转正方向左手螺旋（轴向的顺时针），旋转欧拉角的顺序为 ZYX
   */ this.quat = new Quaternion(0, 0, 0, 1);
        /**
   * 自身旋转角度
   */ this.rotation = new Euler(0, 0, 0);
        /**
   * 自身缩放
   */ this.scale = new Vector3(1, 1, 1);
        /**
   * 自身锚点
   */ this.anchor = new Vector3(0, 0, 0);
        /**
   * 元素矩形宽高
   */ this.size = new Vector2(1, 1);
        /**
   * 子变换，可以有多个
   */ this.children = [];
        /**
   * 包含父变换的最终模型矩阵
   */ this.worldMatrix = Matrix4$1.fromIdentity();
        /**
   * 仅包含自身变换的模型矩阵
   */ this.localMatrix = Matrix4$1.fromIdentity();
        /**
   * 变换是否需要生效，不生效返回的模型矩阵为单位矩阵，需要随元素生命周期改变
   */ this.valid = true;
        /**
   * 数据变化标志位
   */ this.dirtyFlags = {
            /* 自身变换是否有修改，若修改，localMatrix 需要更新 */ localData: false,
            /* localMatrix 是否有修改，若修改，WorldMatrix 需要更新 */ localMatrix: false,
            /* worldMatrix 是否有修改，若修改，worldTRS 需要更新 */ worldMatrix: false,
            /* parentMatrix 是否有修改，若修改，WorldMatrix需要更新 */ parentMatrix: false
        };
        /**
   * 最终模型矩阵对应变换的缓存，当自身矩阵或父矩阵有修改时需要更新
   */ this.worldTRSCache = {
            position: new Vector3(0, 0, 0),
            quat: new Quaternion(0, 0, 0, 1),
            scale: new Vector3(1, 1, 1)
        };
        this.name = "transform_" + seed$5++;
        if (props) {
            this.setTransform(props);
        }
        if (parent) {
            this.parentTransform = parent;
        }
        if (props.valid !== undefined) {
            this.setValid(props.valid);
        }
    }
    var _proto = Transform.prototype;
    // /**
    //  * 自身数据修改 /  父变换修改 / 父变换的数据修改
    //  * @returns
    //  */
    // get traceDirty (): boolean {
    //   if (this.dirty || this.parentDirty) {
    //     return true;
    //   }
    //
    //   return !!(this.parent && this.parent.traceDirty);
    // }
    /**
   * 设置位置
   * @param x
   * @param y
   * @param z
   */ _proto.setPosition = function setPosition(x, y, z) {
        if (this.position.x !== x || this.position.y !== y || this.position.z !== z) {
            this.position.x = x;
            this.position.y = y;
            this.position.z = z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 在当前位置的基础上添加位置偏移
   * @param x
   * @param y
   * @param z
   */ _proto.translate = function translate(x, y, z) {
        if (x !== 0 || y !== 0 || z !== 0) {
            this.position.x += x;
            this.position.y += y;
            this.position.z += z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 设置旋转
   * @param x
   * @param y
   * @param z
   */ _proto.setRotation = function setRotation(x, y, z) {
        if (this.rotation.x !== x || this.rotation.y !== y || this.rotation.z !== z) {
            this.rotation.x = x;
            this.rotation.y = y;
            this.rotation.z = z;
            this.quat.setFromEuler(this.rotation);
            this.quat.conjugate();
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 设置四元数
   * @param x
   * @param y
   * @param z
   * @param w
   * @private
   */ _proto.setQuaternion = function setQuaternion(x, y, z, w) {
        if (this.quat.x !== x || this.quat.y !== y || this.quat.z !== z || this.quat.w !== w) {
            this.quat.x = x;
            this.quat.y = y;
            this.quat.z = z;
            this.quat.w = w;
            this.rotation.setFromQuaternion(this.quat);
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 设置缩放
   * @param x
   * @param y
   * @param z
   */ _proto.setScale = function setScale(x, y, z) {
        if (this.scale.x !== x || this.scale.y !== y || this.scale.z !== z) {
            this.scale.x = x;
            this.scale.y = y;
            this.scale.z = z;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    _proto.setSize = function setSize(x, y) {
        if (this.size.x !== x || this.size.y !== y) {
            this.size.x = x;
            this.size.y = y;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 在当前旋转的基础上使用四元素添加旋转
   * @param quat
   */ _proto.rotateByQuat = function rotateByQuat(quat) {
        this.quat.multiply(quat);
        this.rotation.setFromQuaternion(this.quat);
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
   * 在当前缩放基础上设置缩放系数
   * @param x
   * @param y
   * @param z
   */ _proto.scaleBy = function scaleBy(x, y, z) {
        this.scale.x *= x;
        this.scale.y *= y;
        this.scale.z *= z;
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
   * 设置锚点
   * @param x
   * @param y
   */ _proto.setAnchor = function setAnchor(x, y) {
        if (this.anchor.x !== x || this.anchor.y !== y) {
            this.anchor.x = x;
            this.anchor.y = y;
            this.dirtyFlags.localData = true;
            this.dispatchValueChange();
        }
    };
    /**
   * 批量设置 transform 属性
   * @param props - 要设置的属性
   * @param reverseEuler - 设置 rotation时，欧拉角是否需要取负值
   */ _proto.setTransform = function setTransform(props, reverseEuler) {
        var position = props.position, rotation = props.rotation, scale = props.scale, size = props.size, quat = props.quat, name = props.name, anchor = props.anchor;
        if (name) {
            this.name = name;
        }
        if (position) {
            if (_instanceof1(position, Vector3)) {
                this.setPosition(position.x, position.y, position.z);
            } else {
                this.setPosition(position[0], position[1], position[2]);
            }
        }
        if (quat) {
            if (_instanceof1(quat, Quaternion)) {
                this.setQuaternion(quat.x, quat.y, quat.z, quat.w);
            } else {
                this.setQuaternion(quat[0], quat[1], quat[2], quat[3]);
            }
        } else if (rotation) {
            var mul = reverseEuler ? -1 : 1;
            if (_instanceof1(rotation, Euler)) {
                this.setRotation(rotation.x * mul, rotation.y * mul, rotation.z * mul);
            } else {
                this.setRotation(rotation[0] * mul, rotation[1] * mul, rotation[2] * mul);
            }
        }
        if (scale) {
            if (_instanceof1(scale, Vector3)) {
                this.setScale(scale.x, scale.y, scale.z);
            } else {
                this.setScale(scale[0], scale[1], scale[2]);
            }
        }
        if (size) {
            this.setSize(size.x, size.y);
        }
        if (anchor) {
            if (_instanceof1(anchor, Vector2)) {
                this.setAnchor(anchor.x, anchor.y);
            } else {
                this.setAnchor(anchor[0], anchor[1]);
            }
        }
    };
    /**
   * 添加子变换
   * @param child - 要添加的子变换
   */ _proto.addChild = function addChild(child) {
        addItem(this.children, child);
    };
    /**
   * 移除子变换
   */ _proto.removeChild = function removeChild(child) {
        removeItem(this.children, child);
    };
    /**
   * 获取当前的旋转量
   * @returns
   */ _proto.getRotation = function getRotation() {
        return Transform.getRotation(this.quat, new Euler());
    };
    /**
   * 获取当前的四元数
   * @returns
   */ _proto.getQuaternion = function getQuaternion() {
        return this.quat;
    };
    /**
   * 更新元素自身变换矩阵
   */ _proto.updateLocalMatrix = function updateLocalMatrix() {
        if (this.valid) {
            if (this.dirtyFlags.localData) {
                this.localMatrix.compose(this.position, this.quat, this.scale, this.anchor);
                this.dirtyFlags.localMatrix = true;
            }
            this.dirtyFlags.localData = false;
        } else {
            if (!this.localMatrix.isIdentity()) {
                this.localMatrix.identity();
                this.dirtyFlags.localMatrix = true;
            }
        }
    };
    /**
   * 获取自身变换对应的模型矩阵
   * 数据修改且需要生效时更新自身矩阵
   * 当变换不需要生效时返回单位矩阵
   * @returns
   */ _proto.getMatrix = function getMatrix() {
        this.updateLocalMatrix();
        return this.localMatrix;
    };
    /**
   * 获取父矩阵，如果有多级父节点，返回整体变换
   * @returns
   */ _proto.getParentMatrix = function getParentMatrix() {
        if (this.parent) {
            this.parentMatrix = this.parent.getWorldMatrix();
            this.dirtyFlags.parentMatrix = this.dirtyFlags.parentMatrix || this.parent.dirtyFlags.localMatrix || this.parent.dirtyFlags.worldMatrix;
        }
        return this.parentMatrix;
    };
    /**
   * 获取包含自身变换和父变换的模型变换矩阵
   * @returns
   */ _proto.getWorldMatrix = function getWorldMatrix() {
        var localMatrix = this.getMatrix();
        var parentMatrix = this.getParentMatrix();
        if (this.dirtyFlags.localMatrix || this.dirtyFlags.parentMatrix) {
            if (parentMatrix) {
                this.worldMatrix.multiplyMatrices(parentMatrix, localMatrix);
            } else {
                this.worldMatrix.copyFrom(localMatrix);
            }
            this.dirtyFlags.worldMatrix = true;
            this.dirtyFlags.localMatrix = false;
            this.dirtyFlags.parentMatrix = false;
        }
        return this.worldMatrix;
    };
    /**
   * 获取联合变换后的最终缩放因子
   * @returns
   */ _proto.getWorldScale = function getWorldScale() {
        var cache = this.worldTRSCache;
        if (this.dirtyFlags.worldMatrix) {
            var mat = this.getWorldMatrix();
            mat.decompose(cache.position, cache.quat, cache.scale);
            this.dirtyFlags.worldMatrix = false;
        }
        return this.worldTRSCache.scale.clone();
    };
    /**
   * 获取联合变换后的最终位置
   * @returns
   */ _proto.getWorldPosition = function getWorldPosition() {
        this.updateTRSCache();
        return this.worldTRSCache.position.clone();
    };
    /**
   * 获取联合变换后的最终旋转量
   * @returns
   */ _proto.getWorldRotation = function getWorldRotation() {
        this.updateTRSCache();
        return Transform.getRotation(this.worldTRSCache.quat, new Euler());
    };
    /**
   * 根据世界变换矩阵计算位移、旋转、缩放向量
   * @param position
   * @param quat
   * @param scale
   */ _proto.assignWorldTRS = function assignWorldTRS(position, quat, scale) {
        this.updateTRSCache();
        if (position) {
            position.copyFrom(this.worldTRSCache.position);
        }
        if (quat) {
            quat.copyFrom(this.worldTRSCache.quat);
        }
        if (scale) {
            scale.copyFrom(this.worldTRSCache.scale);
        }
    };
    /**
   * 拆解并复制指定矩阵到自身变换
   * @param m4
   * @param scale
   * @returns
   */ _proto.cloneFromMatrix = function cloneFromMatrix(m4, scale) {
        m4.decompose(this.position, this.quat, this.scale);
        if (scale) {
            scale.copyFrom(this.scale);
        }
        this.dirtyFlags.localData = true;
        this.dispatchValueChange();
    };
    /**
   * 设置 Transform 生效 / 失效， 默认元素生命周期开始后生效，结束后失效
   */ _proto.setValid = function setValid(val) {
        if (this.valid !== val) {
            this.valid = val;
            if (!val) {
                this.localMatrix.identity();
                this.dirtyFlags.localMatrix = true;
            } else {
                this.dirtyFlags.localData = true;
            }
            this.dispatchValueChange();
        }
    };
    /**
   * 获取 Transform 是否生效
   */ _proto.getValid = function getValid() {
        return this.valid;
    };
    _proto.toData = function toData() {
        var transformData = this.taggedProperties;
        transformData.position = this.position.clone();
        transformData.eulerHint = {
            x: this.rotation.x,
            y: this.rotation.y,
            z: this.rotation.z
        };
        transformData.scale = this.scale.clone();
        return transformData;
    };
    _proto.fromData = function fromData(data) {
        var transformData = {
            position: new Vector3().copyFrom(data.position),
            rotation: new Euler(data.eulerHint.x, data.eulerHint.y, data.eulerHint.z),
            scale: new Vector3().copyFrom(data.scale)
        };
        this.setTransform(transformData);
    };
    _proto.dispose = function dispose() {};
    _proto.updateTRSCache = function updateTRSCache() {
        var worldMatrix = this.getWorldMatrix();
        if (this.dirtyFlags.worldMatrix) {
            var cache = this.worldTRSCache;
            worldMatrix.decompose(cache.position, cache.quat, cache.scale);
            this.dirtyFlags.worldMatrix = false;
        }
    };
    _proto.dispatchValueChange = function dispatchValueChange() {
        this.children.forEach(function(c) {
            c.parentMatrixDirty = true;
        });
    };
    /**
   * 转换右手坐标系左手螺旋对应的四元数到对应的旋转角
   * @param quat - 四元数
   * @param out - 欧拉角
   * @returns
   */ Transform.getRotation = function getRotation(quat, out) {
        var newQuat = tempQuat$1.copyFrom(quat);
        newQuat.conjugate();
        return out.setFromQuaternion(newQuat);
    };
    _create_class(Transform, [
        {
            key: "parentTransform",
            get: function get() {
                return this.parent;
            },
            set: function set(transform) {
                if (!transform || this.parent === transform || this === transform) {
                    return;
                }
                if (this.parent) {
                    this.parent.removeChild(this);
                }
                transform.addChild(this);
                this.parent = transform;
                this.parentMatrixDirty = true;
            }
        },
        {
            key: "parentMatrixDirty",
            get: function get() {
                return this.dirtyFlags.parentMatrix;
            },
            set: function set(val) {
                if (this.dirtyFlags.parentMatrix !== val) {
                    this.dirtyFlags.parentMatrix = val;
                    this.dispatchValueChange();
                }
            }
        }
    ]);
    return Transform;
}();

var Cone = /*#__PURE__*/ function() {
    function Cone(props) {
        var _this = this;
        Object.keys(props).forEach(function(key) {
            _this[key] = props[key];
        });
    }
    var _proto = Cone.prototype;
    _proto.generate = function generate(opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt);
        var a = arc * DEG2RAD;
        var x = Math.cos(a) * this.radius;
        var y = Math.sin(a) * this.radius;
        var position = new Vector3(x, y, 0);
        var l = Math.tan(this.angle * DEG2RAD);
        var dir = position.clone().multiply(l);
        // dir + [0,0,1]
        dir.z += 1;
        return {
            position: position.multiply(randomInRange(0, 1)),
            direction: dir.normalize()
        };
    };
    return Cone;
}();
function getArcAngle(arc, arcMode, opt) {
    if (arcMode === ShapeArcMode.RANDOM) {
        arc = randomInRange(0, arc);
    } else if (arcMode === ShapeArcMode.UNIDIRECTIONAL_CYCLE) {
        var d = opt.index % (opt.total + 1);
        arc = arc / opt.total * d;
    } else if (arcMode === ShapeArcMode.BIDIRECTIONAL_CYCLE) {
        var d1 = opt.index / (opt.total + 1);
        var i = d1 - Math.floor(d1);
        arc = arc * (Math.floor(d1) % 2 ? 1 - i : i);
    } else if (arcMode === ShapeArcMode.UNIFORM_BURST) {
        arc = arc * opt.burstIndex / opt.burstCount;
    }
    return arc;
}

var Circle = /*#__PURE__*/ function() {
    function Circle(props) {
        var _this = this;
        Object.keys(props).forEach(function(key) {
            _this[key] = props[key];
        });
    }
    var _proto = Circle.prototype;
    _proto.generate = function generate(opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = new Vector3(Math.cos(arc), Math.sin(arc), 0);
        var radius = this.radius;
        return {
            direction: direction,
            position: direction.clone().multiply(radius)
        };
    };
    return Circle;
}();
var Rectangle = /*#__PURE__*/ function() {
    function Rectangle(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
    }
    var _proto = Rectangle.prototype;
    _proto.generate = function generate(opt) {
        var x = randomInRange(-this._d, this._d);
        var y = randomInRange(-this._h, this._h);
        return {
            direction: new Vector3(0, 0, 1),
            position: new Vector3(x, y, 0)
        };
    };
    return Rectangle;
}();
var RectangleEdge = /*#__PURE__*/ function() {
    function RectangleEdge(arg) {
        this._d = (arg.width || 1) / 2;
        this._h = (arg.height || 1) / 2;
        this.arcMode = arg.arcMode;
        this.arc = arg.arc;
    }
    var _proto = RectangleEdge.prototype;
    _proto.generate = function generate(opt) {
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var direction = new Vector3(Math.cos(arc), Math.sin(arc), 0);
        var w = this._d;
        var h = this._h;
        var r0 = Math.atan2(h, w);
        var tan = Math.tan(arc);
        var position = new Vector3();
        if (arc < r0) {
            position.set(w, w * tan, 0);
        } else if (arc >= r0 && arc < Math.PI - r0) {
            position.set(h / tan, h, 0);
        } else if (arc < Math.PI + r0) {
            position.set(-w, -w * tan, 0);
        } else if (arc < Math.PI * 2 - r0) {
            position.set(-h / tan, -h, 0);
        } else {
            position.set(w, w * tan, 0);
        }
        return {
            direction: direction,
            position: position
        };
    };
    return RectangleEdge;
}();
var Edge = /*#__PURE__*/ function() {
    function Edge(args) {
        this._d = args.width || 1;
        this.arcMode = args.arcMode;
    }
    var _proto = Edge.prototype;
    _proto.generate = function generate(options) {
        var x = this.arcMode === ShapeArcMode.UNIFORM_BURST ? options.burstIndex % options.burstCount / (options.burstCount - 1) : randomInRange(0, 1);
        return {
            direction: new Vector3(0, 1, 0),
            position: new Vector3(this._d * (x - 0.5), 0, 0)
        };
    };
    return Edge;
}();

var tempMat4$2 = new Matrix4$1();
var Donut = /*#__PURE__*/ function() {
    function Donut(props) {
        var _this = this;
        Object.keys(props).forEach(function(key) {
            _this[key] = props[key];
        });
    }
    var _proto = Donut.prototype;
    _proto.generate = function generate(opt) {
        var dradius = this.donutRadius;
        var center = this.radius - dradius;
        var angle = randomInRange(0, Math.PI * 2);
        var arc = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rot = tempMat4$2.setFromRotationZ(arc);
        var direction = new Vector3(Math.cos(angle), Math.sin(angle), 0);
        var position = new Vector3(center + Math.cos(angle) * dradius, 0, Math.sin(angle) * dradius);
        return {
            direction: rot.transformNormal(direction),
            position: rot.transformPoint(position)
        };
    };
    return Donut;
}();

var tempMat4$1 = new Matrix4$1();
var Sphere = /*#__PURE__*/ function() {
    function Sphere(props) {
        var _this = this;
        Object.keys(props).forEach(function(key) {
            _this[key] = props[key];
        });
    }
    var _proto = Sphere.prototype;
    _proto.getHorizontalAngle = function getHorizontalAngle() {
        return randomInRange(-90, 90);
    };
    _proto.generate = function generate(opt) {
        var rz = getArcAngle(this.arc, this.arcMode, opt) * DEG2RAD;
        var rh = this.getHorizontalAngle() * DEG2RAD;
        var radius = this.radius;
        var point = new Vector3(Math.cos(rh), 0, Math.sin(rh));
        var mat4 = tempMat4$1.setFromRotationZ(rz);
        var p = mat4.transformNormal(point);
        return {
            position: p.clone().multiply(radius),
            direction: p
        };
    };
    return Sphere;
}();
var Hemisphere = /*#__PURE__*/ function(Sphere) {
    _inherits(Hemisphere, Sphere);
    function Hemisphere() {
        return Sphere.apply(this, arguments);
    }
    var _proto = Hemisphere.prototype;
    _proto.getHorizontalAngle = function getHorizontalAngle() {
        return randomInRange(0, 90);
    };
    return Hemisphere;
}(Sphere);

var TextureShape = /*#__PURE__*/ function() {
    function TextureShape(arg) {
        var detail = arg.detail || {
            anchors: [
                0.5,
                0.5
            ],
            block: [
                0,
                0
            ]
        };
        this.anchors = new Float32Array(detail.anchors);
        this.width = arg.width || 1;
        this.height = arg.height || 1;
        this.block = detail.block;
        this.arcMode = arg.arcMode;
        this.random = clamp$1(arg.random || 0, 0, 1);
    }
    var _proto = TextureShape.prototype;
    _proto.generate = function generate(opt) {
        var anchors = this.anchors;
        var pointCount = anchors.length / 2 - 1;
        var index = Math.floor(getArcAngle(pointCount, this.arcMode, opt));
        var pointX = (anchors[index * 2] + this.block[0] * this.random * Math.random()) % 1 - 0.5;
        var pointY = (anchors[index * 2 + 1] + this.block[1] * this.random * Math.random()) % 1 - 0.5;
        var dir = new Vector3(pointX, pointY, 0);
        return {
            position: new Vector3(pointX * this.width, pointY * this.height, 0),
            direction: dir.normalize()
        };
    };
    return TextureShape;
}();

var ShapeNone = /*#__PURE__*/ function() {
    function ShapeNone() {}
    var _proto = ShapeNone.prototype;
    _proto.generate = function generate() {
        return {
            position: new Vector3(),
            direction: new Vector3()
        };
    };
    return ShapeNone;
}();
var _obj$6;
var map$1 = (_obj$6 = {}, _obj$6[ShapeType.NONE] = ShapeNone, _obj$6[ShapeType.CONE] = Cone, _obj$6[ShapeType.SPHERE] = Sphere, _obj$6[ShapeType.HEMISPHERE] = Hemisphere, _obj$6[ShapeType.CIRCLE] = Circle, _obj$6[ShapeType.DONUT] = Donut, _obj$6[ShapeType.RECTANGLE] = Rectangle, _obj$6[ShapeType.EDGE] = Edge, _obj$6[ShapeType.RECTANGLE_EDGE] = RectangleEdge, _obj$6[ShapeType.TEXTURE] = TextureShape, _obj$6);
function createShape(shapeOptions) {
    if (!shapeOptions) {
        return new ShapeNone();
    }
    var options = _extends({
        radius: 1,
        arc: 360,
        angle: 0,
        arcMode: ShapeArcMode.RANDOM
    }, shapeOptions);
    var type = shapeOptions.type;
    var Ctrl = map$1[type];
    if (!Ctrl) {
        throw new Error("Invalid shape: " + type + ".");
    }
    var ctrl = new Ctrl(options);
    if (type !== ShapeType.NONE) {
        var alignSpeedDirection = shapeOptions.alignSpeedDirection, _shapeOptions_upDirection = shapeOptions.upDirection, upDirection = _shapeOptions_upDirection === void 0 ? [
            0,
            0,
            1
        ] : _shapeOptions_upDirection;
        ctrl.alignSpeedDirection = alignSpeedDirection;
        ctrl.upDirection = Vector3.fromArray(upDirection).normalize();
    }
    return ctrl;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
        for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else {
            p = p.next;
        }
    }while (again || p !== end);
    return end;
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode);
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop);
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

var indexBase = 0;
function earcut(data, holeIndices, dim, ib) {
    dim = dim || 2;
    indexBase = ib || 0;
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var outerNode = linkedList(data, 0, outerLen, dim, true);
    var triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) {
        return triangles;
    }
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) {
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    }
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    hackEarcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) {
        return;
    }
    // interlink polygon nodes in z-order
    if (!pass && invSize) {
        indexCurve(ear, minX, minY, invSize);
    }
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim + indexBase);
            triangles.push(ear.i / dim + indexBase);
            triangles.push(next.i / dim + indexBase);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering triangles and slicing again
            if (!pass) {
                hackEarcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = hackCureLocalIntersections(filterPoints(ear), triangles, dim);
                hackEarcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                hackSplitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
        }
    }
}
// go through all polygon nodes and cure small local self-intersections
function hackCureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim + indexBase);
            triangles.push(p.i / dim + indexBase);
            triangles.push(b.i / dim + indexBase);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function hackSplitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear triangles around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                hackEarcutLinked(a, triangles, dim, minX, minY, invSize);
                hackEarcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start);
}

var POINT_INDEX = 2;
function getGeometryTriangles(geometry, options) {
    var s = geometry.s, p = geometry.p;
    var segments = s[1];
    var points = p[1];
    var pointCount = 0;
    for(var i = 0; i < segments.length; i++){
        var segment = segments[i];
        pointCount += segment.length - 1;
    }
    var pointData = new Float32Array(pointCount * SPRITE_VERTEX_STRIDE);
    var _options_indexBase = options.indexBase, indexBase = _options_indexBase === void 0 ? 0 : _options_indexBase, uvTransform = options.uvTransform;
    var index = 0;
    var dx = 0, dy = 0, sw = 1, sh = 1, r;
    if (uvTransform) {
        dx = uvTransform[0];
        dy = uvTransform[1];
        r = uvTransform[4];
        sw = r ? uvTransform[3] : uvTransform[2];
        sh = r ? uvTransform[2] : uvTransform[3];
    }
    var temp = [
        0,
        0
    ];
    var angle = r === 0 ? 0 : -Math.PI / 2;
    for(var i1 = 0; i1 < segments.length; i1++){
        var segment1 = segments[i1];
        var p0 = points[i1];
        var p1 = points[i1 + 1] || points[0];
        var keys = segment1;
        var point = [
            0,
            0
        ];
        for(var j = 0; j < keys.length - 1; j++){
            var key = keys[j];
            getBezier2DValue(point, key, p0, p1, p0[4], p0[5], p1[2], p1[3]);
            setPoint(point[0], point[1]);
        }
    }
    var indices = earcut(Array.from(pointData), null, SPRITE_VERTEX_STRIDE, indexBase);
    return {
        aPoint: pointData,
        index: new Uint16Array(indices)
    };
    function setPoint(x, y) {
        pointData[index++] = x / 2;
        pointData[index++] = y / 2;
        if (uvTransform) {
            temp[0] = x;
            temp[1] = y;
            rotateVec2(temp, temp, angle);
            pointData[index++] = dx + (temp[0] + 1) / 2 * sw;
            pointData[index++] = dy + (temp[1] + 1) / 2 * sh;
        } else {
            pointData[index++] = (x + 1) / 2;
            pointData[index++] = (y + 1) / 2;
        }
        index += POINT_INDEX;
    }
}
/**
 * 根据新老版形状数据获取形状几何数据
 * @param shape 新老版形状数据
 */ function getGeometriesByShapeData(shape) {
    var geometries = [];
    // 该版本的单个形状数据可以包含多个形状，可以加个埋点，五福之后没有就可以下掉
    if (shape.gs) {
        shape.gs.forEach(function(gs) {
            geometries.push({
                p: [
                    ValueType.SHAPE_POINTS,
                    gs.p
                ],
                s: [
                    ValueType.SHAPE_SPLITS,
                    gs.s
                ]
            });
        });
    } else if (shape.g) {
        geometries.push({
            p: [
                ValueType.SHAPE_POINTS,
                shape.g.p
            ],
            s: [
                ValueType.SHAPE_SPLITS,
                shape.g.s
            ]
        });
    } else {
        geometries.push(shape);
    }
    return geometries;
}
function getGeometryByShape(shape, uvTransform) {
    var datas = [];
    // 老数据兼容处理
    var geometries = getGeometriesByShapeData(shape);
    var indexBase = 0;
    var aPoint = 0;
    var index = 0;
    for(var i = 0; i < geometries.length; i++){
        var geometry = geometries[i];
        var data = getGeometryTriangles(geometry, {
            indexBase: indexBase,
            uvTransform: uvTransform
        });
        indexBase += data.aPoint.length / 5;
        datas.push(data);
        aPoint += data.aPoint.length;
        index += data.index.length;
    }
    if (datas.length === 1) {
        return datas[0];
    }
    var aPointData = new Float32Array(aPoint);
    var indexData = new Uint16Array(index);
    // @ts-expect-error
    for(var i1 = 0, pointIndex = 0, idx = 0; i1 < datas[i1]; i1++){
        var data1 = datas[i1];
        aPointData.set(data1.aPoint, pointIndex);
        pointIndex += data1.aPoint.length;
        indexData.set(data1.index, idx);
        idx += data1.index.length;
    }
    return {
        aPoint: aPointData,
        index: indexData
    };
}
function rotateVec2(out, vec2, angleInRad) {
    var c = Math.cos(angleInRad);
    var s = Math.sin(angleInRad);
    var x = vec2[0];
    var y = vec2[1];
    out[0] = c * x + s * y;
    out[1] = -s * x + c * y;
    return out;
}
function getBezier2DValue(out, t, p0, p1, cpx0, cpy0, cpx1, cpy1) {
    var ddt = 1 - t;
    var a = ddt * ddt * ddt;
    var b = 3 * t * ddt * ddt;
    var c = 3 * t * t * ddt;
    var d = t * t * t;
    out[0] = a * p0[0] + b * cpx0 + c * cpx1 + d * p1[0];
    out[1] = a * p0[1] + b * cpy0 + c * cpy1 + d * p1[1];
    return out;
}

var Burst = /*#__PURE__*/ function() {
    function Burst(options) {
        var time = options.time, interval = options.interval, count = options.count, cycles = options.cycles, probability = options.probability;
        this.time = +time || 0;
        this.interval = +interval || 1;
        this.count = _instanceof1(count, ValueGetter) ? count : createValueGetter(count);
        this.cycles = +cycles || Infinity;
        this.probability = isNaN(probability) ? 1 : +probability;
        this.reset();
    }
    var _proto = Burst.prototype;
    _proto.getGeneratorOptions = function getGeneratorOptions(timePassed, lifetime) {
        var dt = timePassed - this.time - this.now;
        if (dt > this.interval * this.index && this.internalCycles > 0) {
            this.internalCycles--;
            this.index++;
            return Math.random() <= this.probability ? {
                index: this.index,
                total: 1 / this.interval,
                count: this.count.getValue(lifetime),
                cycleIndex: this.cycles - this.internalCycles - 1
            } : null;
        }
    };
    _proto.reset = function reset() {
        this.internalCycles = this.cycles;
        this.index = 0;
        this.now = 0;
    };
    _proto.clone = function clone() {
        var options = {
            time: this.time,
            interval: this.interval,
            count: this.count,
            cycles: this.cycles,
            probability: this.probability
        };
        return new Burst(options);
    };
    return Burst;
}();

var LinkNode = function LinkNode(content) {
    this.content = content;
};
var Link = /*#__PURE__*/ function() {
    function Link(sort) {
        this.sort = sort;
        this.length = 0;
    }
    var _proto = Link.prototype;
    _proto.findNodeByContent = function findNodeByContent(filter) {
        var node = this.first;
        if (node) {
            do {
                if (filter(node.content)) {
                    return node;
                }
            // @ts-expect-error
            // eslint-disable-next-line no-cond-assign
            }while (node = node.next);
        }
    };
    _proto.insertNode = function insertNode(a, next) {
        var b = a.next;
        a.next = next;
        next.pre = a;
        next.next = b;
        if (b) {
            b.pre = next;
        }
    // a -> next -> b
    };
    _proto.shiftNode = function shiftNode(content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.first = this.last = node;
        }
        var current = this.first;
        while(current){
            if (this.sort(current.content, node.content) <= 0) {
                if (current.next) {
                    current = current.next;
                } else {
                    this.insertNode(current, node);
                    return this.last = node;
                }
            } else {
                if (current.pre) {
                    this.insertNode(current.pre, node);
                } else {
                    this.first = node;
                    node.next = current;
                    current.pre = node;
                }
                return node;
            }
        }
    };
    _proto.pushNode = function pushNode(content) {
        var node = new LinkNode(content);
        this.length++;
        if (this.length === 1) {
            return this.last = this.first = node;
        }
        var current = this.last;
        while(current){
            if (this.sort(node.content, current.content) <= 0) {
                if (this.first === current) {
                    current.pre = node;
                    node.next = current;
                    return this.first = node;
                } else {
                    // @ts-expect-error
                    current = current.pre;
                }
            } else {
                this.insertNode(current, node);
                if (current === this.last) {
                    this.last = node;
                }
                return node;
            }
        }
    };
    _proto.removeNode = function removeNode(node) {
        var current = this.first;
        this.length--;
        if (current === node) {
            // @ts-expect-error
            var a = this.first = current.next;
            if (a) {
                a.pre = null;
            }
        } else if ((current = this.last) === node) {
            // @ts-expect-error
            var a1 = this.last = current.pre;
            if (a1) {
                a1.next = null;
            }
        } else if (node) {
            var pre = node.pre;
            var next = node.next;
            // @ts-expect-error
            pre.next = next;
            if (next) {
                next.pre = pre;
            }
        }
        node.pre = null;
        node.next = null;
    };
    _proto.forEach = function forEach(func, thisObj) {
        var node = this.first;
        var i = 0;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i++);
            // @ts-expect-error
            // eslint-disable-next-line no-cond-assign
            }while (node = node.next);
        }
    };
    _proto.forEachReverse = function forEachReverse(func, thisObj) {
        var node = this.last;
        var i = this.length - 1;
        if (node) {
            do {
                func.call(thisObj || this, node.content, i--);
            // @ts-expect-error
            // eslint-disable-next-line no-cond-assign
            }while (node = node.pre);
        }
    };
    _proto.getNodeByIndex = function getNodeByIndex(index) {
        var i = 0, res = this.first;
        if (!res || index >= this.length || index < 0) {
            return null;
        }
        while(i < index){
            res = res.next;
            i++;
        }
        return res;
    };
    return Link;
}();

var tmp0 = new Vector3();
var tmp1 = new Vector3();
var TrailMesh = /*#__PURE__*/ function() {
    function TrailMesh(engine, props) {
        this.pointStart = [];
        var colorOverLifetime = props.colorOverLifetime, colorOverTrail = props.colorOverTrail, maxTrailCount = props.maxTrailCount, _props_opacityOverLifetime = props.opacityOverLifetime, opacityOverLifetime = _props_opacityOverLifetime === void 0 ? createValueGetter(1) : _props_opacityOverLifetime, widthOverTrail = props.widthOverTrail, name = props.name, occlusion = props.occlusion, blending = props.blending, maskMode = props.maskMode, _props_textureMap = props.// order,
        textureMap, textureMap = _props_textureMap === void 0 ? [
            0,
            0,
            1,
            1
        ] : _props_textureMap, texture = props.texture, transparentOcclusion = props.transparentOcclusion, minimumVertexDistance = props.minimumVertexDistance, lifetime = props.lifetime, matrix = props.matrix;
        var _engine_gpuCapability = engine.gpuCapability, detail = _engine_gpuCapability.detail, level = _engine_gpuCapability.level;
        var pointCountPerTrail = Math.max(props.pointCountPerTrail, 2);
        var keyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = detail.maxVertexTextures > 0;
        var _engine_renderer;
        var env = ((_engine_renderer = engine.renderer) != null ? _engine_renderer : {}).env;
        var uniformValues = {};
        // const lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
        var lookUpTexture = 0;
        var macros = [
            [
                "ENABLE_VERTEX_TEXTURE",
                enableVertexTexture
            ],
            [
                "LOOKUP_TEXTURE_CURVE",
                lookUpTexture
            ],
            [
                "ENV_EDITOR",
                env === PLAYER_OPTIONS_ENV_EDITOR
            ]
        ];
        var useAttributeTrailStart = maxTrailCount > 64;
        var shaderCacheId = 0;
        if (colorOverLifetime) {
            macros.push([
                "COLOR_OVER_LIFETIME",
                true
            ]);
            shaderCacheId |= 1;
            uniformValues.uColorOverLifetime = Texture.createWithData(engine, imageDataFromGradient(colorOverLifetime));
        }
        if (colorOverTrail) {
            macros.push([
                "COLOR_OVER_TRAIL",
                true
            ]);
            shaderCacheId |= 1 << 2;
            uniformValues.uColorOverTrail = Texture.createWithData(engine, imageDataFromGradient(colorOverTrail));
        }
        if (useAttributeTrailStart) {
            macros.push([
                "ATTR_TRAIL_START",
                1
            ]);
            shaderCacheId |= 1 << 3;
        } else {
            uniformValues.uTrailStart = new Float32Array(maxTrailCount);
        }
        uniformValues.uOpacityOverLifetimeValue = opacityOverLifetime.toUniform(keyFrameMeta);
        var uWidthOverTrail = widthOverTrail.toUniform(keyFrameMeta);
        macros.push([
            "VERT_CURVE_VALUE_COUNT",
            keyFrameMeta.index
        ], [
            "VERT_MAX_KEY_FRAME_COUNT",
            keyFrameMeta.max
        ]);
        if (enableVertexTexture && lookUpTexture) {
            var tex = generateHalfFloatTexture(engine, ValueGetter.getAllData(keyFrameMeta, true), keyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
        } else {
            uniformValues.uVCurveValues = ValueGetter.getAllData(keyFrameMeta);
        }
        var vertex = trailVert;
        var fragment = particleFrag;
        var mtl = {
            shader: {
                vertex: vertex,
                fragment: fragment,
                macros: macros,
                glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
                shared: true,
                name: "trail#" + name,
                cacheId: "-t:+" + shaderCacheId + "+" + keyFrameMeta.index + "+" + keyFrameMeta.max
            },
            uniformSemantics: {
                effects_MatrixVP: "VIEWPROJECTION",
                effects_MatrixInvV: "VIEWINVERSE",
                effects_ObjectToWorld: "MODEL",
                uEditorTransform: "EDITOR_TRANSFORM"
            }
        };
        var maxVertexCount = pointCountPerTrail * maxTrailCount * 2;
        var maxTriangleCount = (pointCountPerTrail - 1) * maxTrailCount;
        var bpe = Float32Array.BYTES_PER_ELEMENT;
        var v12 = 12 * bpe;
        var geometryOptions = {
            attributes: {
                aColor: {
                    size: 4,
                    stride: v12,
                    data: new Float32Array(maxVertexCount * 12)
                },
                aSeed: {
                    size: 1,
                    stride: v12,
                    offset: 4 * bpe,
                    dataSource: "aColor"
                },
                aInfo: {
                    size: 3,
                    stride: v12,
                    offset: 5 * bpe,
                    dataSource: "aColor"
                },
                aPos: {
                    size: 4,
                    stride: v12,
                    offset: 8 * bpe,
                    dataSource: "aColor"
                },
                //
                aTime: {
                    size: 1,
                    data: new Float32Array(maxVertexCount)
                },
                //
                aDir: {
                    size: 3,
                    data: new Float32Array(maxVertexCount * 3)
                }
            },
            indices: {
                data: new Uint16Array(maxVertexCount * 6)
            },
            drawCount: maxTriangleCount * 6,
            name: "trail#" + name,
            bufferUsage: glContext.DYNAMIC_DRAW
        };
        if (useAttributeTrailStart) {
            geometryOptions.attributes.aTrailStart = {
                size: 1,
                data: new Float32Array(maxVertexCount)
            };
        } else {
            var indexData = new Float32Array(maxVertexCount);
            geometryOptions.attributes.aTrailStartIndex = {
                size: 1,
                data: indexData
            };
            for(var i = 0; i < maxTrailCount; i++){
                var c = pointCountPerTrail * 2;
                var s = i * c;
                for(var j = 0; j < c; j++){
                    indexData[s + j] = i;
                }
            }
        }
        var preMulAlpha = getPreMultiAlpha(blending);
        var material = Material.create(engine, mtl);
        material.blending = true;
        material.depthMask = occlusion;
        material.depthTest = true;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        var mesh = this.mesh = Mesh.create(engine, {
            name: "MTrail_" + name,
            material: material,
            geometry: Geometry.create(engine, geometryOptions)
        });
        var uMaskTex = texture != null ? texture : Texture.createWithData(engine);
        Object.keys(uniformValues).map(function(name) {
            var value = uniformValues[name];
            if (_instanceof1(value, Texture)) {
                material.setTexture(name, value);
            } else if (name === "uTrailStart") {
                material.setFloats("uTrailStart", value);
            } else if (name === "uVCurveValues") {
                var array = [];
                for(var i = 0; i < value.length; i = i + 4){
                    var v = new Vector4$1(value[i], value[i + 1], value[i + 2], value[i + 3]);
                    array.push(v);
                }
                material.setVector4Array(name, array);
            } else {
                material.setVector4(name, Vector4$1.fromArray(value));
            }
        });
        material.setFloat("uTime", 0);
        // TODO: 修改下长度
        material.setVector4("uWidthOverTrail", Vector4$1.fromArray(uWidthOverTrail));
        material.setVector2("uTexOffset", new Vector2(0, 0));
        material.setVector4("uTextureMap", Vector4$1.fromArray(textureMap));
        material.setVector4("uParams", new Vector4$1(0, pointCountPerTrail - 1, 0, 0));
        material.setTexture("uMaskTex", uMaskTex);
        material.setVector4("uColorParams", new Vector4$1(texture ? 1 : 0, +preMulAlpha, 0, +(occlusion && !transparentOcclusion)));
        this.maxTrailCount = maxTrailCount;
        this.pointCountPerTrail = pointCountPerTrail;
        this.checkVertexDistance = minimumVertexDistance > 0;
        this.minimumVertexDistance = Math.pow(minimumVertexDistance || 0.001, 2);
        this.useAttributeTrailStart = useAttributeTrailStart;
        this.lifetime = lifetime;
        if (matrix) {
            this.mesh.worldMatrix = matrix;
        }
        this.geometry = mesh.firstGeometry();
        this.trailCursors = new Uint16Array(maxTrailCount);
    }
    var _proto = TrailMesh.prototype;
    _proto.addPoint = function addPoint(trailIndex, position, opt) {
        opt = opt || {};
        var cursor = this.trailCursors[trailIndex];
        var pointCountPerTrail = this.pointCountPerTrail;
        var geometry = this.geometry;
        var segmentPerTrail = pointCountPerTrail - 1;
        var pointIndex = cursor % pointCountPerTrail;
        var previousIndex = (cursor - 1) % pointCountPerTrail;
        var bpreviousIndex = (cursor - 2) % pointCountPerTrail;
        var previousPoint = this.getTrailPosition(trailIndex, previousIndex, tmp0);
        // point too close
        if (previousPoint && this.checkVertexDistance && (previousPoint == null ? void 0 : previousPoint.distanceSquared(position)) < this.minimumVertexDistance) {
            return;
        }
        var pointStartIndex = trailIndex * pointCountPerTrail + pointIndex;
        var dir = calculateDirection(previousPoint, position);
        var time = opt.time || this.time;
        var info = [
            Math.random(),
            opt.lifetime || this.lifetime,
            cursor
        ];
        var size = opt.size || 1;
        var dirStartIndex = pointStartIndex * 6;
        var dirData = new Float32Array(6);
        dirData.set(dir, 0);
        dirData.set(dir, 3);
        geometry.setAttributeSubData("aDir", dirStartIndex, dirData);
        geometry.setAttributeSubData("aTime", pointStartIndex * 2, new Float32Array([
            time,
            time
        ]));
        var color = opt.color || [
            1,
            1,
            1,
            1
        ];
        var colorData = new Float32Array(24);
        var positionData = position.toArray();
        colorData.set(color, 0);
        colorData.set(info, 4);
        colorData[7] = 0;
        colorData.set(positionData, 8);
        colorData[11] = 0.5 * size;
        colorData.set(color, 12);
        colorData.set(info, 16);
        colorData[19] = 1;
        colorData.set(positionData, 20);
        colorData[23] = -0.5 * size;
        geometry.setAttributeSubData("aColor", pointStartIndex * 24, colorData);
        if (previousIndex >= 0) {
            var bPreviousPoint = this.getTrailPosition(trailIndex, bpreviousIndex, tmp1);
            var previousDir = new Float32Array(calculateDirection(bPreviousPoint, previousPoint, position));
            var previousDirStartIndex = (trailIndex * pointCountPerTrail + previousIndex) * 6;
            geometry.setAttributeSubData("aDir", previousDirStartIndex, previousDir);
            geometry.setAttributeSubData("aDir", previousDirStartIndex + 3, previousDir);
            var indicesStart = trailIndex * pointCountPerTrail * 2;
            var indicesData = new Uint16Array([
                previousIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + indicesStart,
                pointIndex * 2 + indicesStart,
                previousIndex * 2 + 1 + indicesStart,
                pointIndex * 2 + 1 + indicesStart
            ]);
            var start = (trailIndex * segmentPerTrail + (cursor - 1) % segmentPerTrail) * 6;
            geometry.setIndexSubData(start, indicesData);
        }
        cursor = ++this.trailCursors[trailIndex];
        var mtl = this.mesh.material;
        var params = mtl.getVector4("uParams");
        var trailStart = info[2];
        if (this.useAttributeTrailStart) {
            var len = pointCountPerTrail * 2;
            var startData = new Float32Array(len);
            for(var i = 0; i < len; i++){
                startData[i] = trailStart;
            }
            geometry.setAttributeSubData("aTrailStart", trailIndex * startData.length, startData);
        } else {
            var value = mtl.getFloats("uTrailStart");
            if (value != undefined) {
                value[trailIndex] = trailStart;
                mtl.setFloats("uTrailStart", value);
            }
        }
        if (params) {
            params.y = Math.max(params.y, cursor - 1) - Math.max(0, cursor - pointCountPerTrail);
            mtl.setVector4("uParams", params);
        }
    };
    _proto.getTrailPosition = function getTrailPosition(trail, index, out) {
        var pointCountPerTrail = this.pointCountPerTrail;
        if (index >= 0 && index < pointCountPerTrail) {
            var startIndex = (trail * pointCountPerTrail + index) * 24 + 8;
            var data = this.geometry.getAttributeData("aColor");
            assertExist(data);
            out.x = data[startIndex];
            out.y = data[1 + startIndex];
            out.z = data[2 + startIndex];
            return out;
        }
    };
    _proto.clearAllTrails = function clearAllTrails() {
        var indexData = this.geometry.getIndexData();
        assertExist(indexData);
        this.trailCursors = new Uint16Array(this.trailCursors.length);
        this.geometry.setIndexData(new Uint16Array(indexData.length));
    };
    _proto.minusTime = function minusTime(time) {
        var data = this.geometry.getAttributeData("aTime");
        assertExist(data);
        for(var i = 0; i < data.length; i++){
            data[i] -= time;
        }
        this.geometry.setAttributeData("aTime", data);
        this.time -= time;
    };
    _proto.clearTrail = function clearTrail(index) {
        if (this.trailCursors[index] !== 0) {
            var pointCountPerTrail = this.pointCountPerTrail;
            var indicesPerTrail = (pointCountPerTrail - 1) * 6;
            var indices = this.geometry.getIndexData();
            assertExist(indices);
            indices.set(new Uint16Array(indicesPerTrail), index * indicesPerTrail);
            this.geometry.setIndexData(indices);
            this.trailCursors[index] = 0;
        }
    };
    _proto.getPointStartPos = function getPointStartPos(index) {
        return this.pointStart[index];
    };
    _proto.setPointStartPos = function setPointStartPos(index, pos) {
        this.pointStart[index] = pos;
    };
    _proto.onUpdate = function onUpdate(escapeTime) {};
    _create_class(TrailMesh, [
        {
            key: "time",
            get: function get() {
                return this.mesh.material.getFloat("uTime") || 0;
            },
            set: function set(t) {
                this.mesh.material.setFloat("uTime", t != null ? t : 0);
            }
        }
    ]);
    return TrailMesh;
}();
var tempDir$1 = new Vector3();
var tempDa = new Vector3();
var tempDb = new Vector3();
// TODO: prePoint 可选，point 必选，顺序有问题
function calculateDirection(prePoint, point, nextPoint) {
    var dir = tempDir$1;
    if (!prePoint && !nextPoint) {
        return [
            0,
            0,
            0
        ];
    } else if (!prePoint) {
        dir.subtractVectors(nextPoint, point);
    } else if (!nextPoint) {
        dir.subtractVectors(point, prePoint);
    } else {
        tempDa.subtractVectors(point, prePoint).normalize();
        // FIXME: 这里有bug。。。
        tempDa.subtractVectors(nextPoint, point);
        tempDb.copyFrom(tempDa).normalize();
        dir.addVectors(tempDa, tempDb);
    }
    return dir.normalize().toArray();
}
function getTrailMeshShader(trails, particleMaxCount, name, gpuCapability, env) {
    if (env === void 0) env = "";
    var shaderCacheId = 0;
    var lookUpTexture = getConfig(RENDER_PREFER_LOOKUP_TEXTURE) ? 1 : 0;
    var enableVertexTexture = gpuCapability.detail.maxVertexTextures > 0;
    var macros = [
        [
            "ENABLE_VERTEX_TEXTURE",
            enableVertexTexture
        ],
        [
            "LOOKUP_TEXTURE_CURVE",
            lookUpTexture
        ],
        [
            "ENV_EDITOR",
            env === PLAYER_OPTIONS_ENV_EDITOR
        ]
    ];
    var keyFrameMeta = createKeyFrameMeta();
    if (trails.colorOverLifetime) {
        macros.push([
            "COLOR_OVER_LIFETIME",
            true
        ]);
        shaderCacheId |= 1;
    }
    if (trails.colorOverTrail) {
        macros.push([
            "COLOR_OVER_TRAIL",
            true
        ]);
        shaderCacheId |= 1 << 2;
    }
    var useAttributeTrailStart = particleMaxCount > 64;
    if (useAttributeTrailStart) {
        macros.push([
            "ATTR_TRAIL_START",
            1
        ]);
        shaderCacheId |= 1 << 3;
    }
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.opacityOverLifetime);
    getKeyFrameMetaByRawValue(keyFrameMeta, trails.widthOverTrail);
    macros.push([
        "VERT_CURVE_VALUE_COUNT",
        keyFrameMeta.index
    ], [
        "VERT_MAX_KEY_FRAME_COUNT",
        keyFrameMeta.max
    ]);
    return {
        vertex: trailVert,
        fragment: particleFrag,
        macros: macros,
        shared: true,
        name: "trail#" + name,
        cacheId: "-t:+" + shaderCacheId + "+" + keyFrameMeta.index + "+" + keyFrameMeta.max
    };
}

/**
 * @since 2.0.0
 */ var ParticleSystemRenderer = /*#__PURE__*/ function(RendererComponent) {
    _inherits(ParticleSystemRenderer, RendererComponent);
    function ParticleSystemRenderer(engine, particleMeshProps, trailMeshProps) {
        var _this;
        _this = RendererComponent.call(this, engine) || this;
        _this.name = "ParticleSystemRenderer";
        if (particleMeshProps) {
            _this.particleMesh = new ParticleMesh(engine, particleMeshProps);
        }
        if (trailMeshProps) {
            _this.trailMesh = new TrailMesh(engine, trailMeshProps);
        }
        var meshes = [
            _this.particleMesh.mesh
        ];
        _this.materials.push(_this.particleMesh.mesh.material);
        if (_this.trailMesh) {
            meshes.push(_this.trailMesh.mesh);
            _this.materials.push(_this.trailMesh.mesh.material);
        }
        _this.meshes = meshes;
        return _this;
    }
    var _proto = ParticleSystemRenderer.prototype;
    _proto.start = function start() {
        this._priority = this.item.renderOrder;
        this.particleMesh.gravityModifier.scaleXCoord(this.item.duration);
        for(var _iterator = _create_for_of_iterator_helper_loose(this.meshes), _step; !(_step = _iterator()).done;){
            var mesh = _step.value;
            mesh.start();
        }
    };
    _proto.update = function update(dt) {
        var time = this.particleMesh.time;
        this.particleMesh.mesh.material.setVector4("uParams", new Vector4$1(time, this.item.duration, 0, 0));
    };
    _proto.render = function render(renderer) {
        for(var _iterator = _create_for_of_iterator_helper_loose(this.meshes), _step; !(_step = _iterator()).done;){
            var mesh = _step.value;
            mesh.render(renderer);
        }
    };
    _proto.reset = function reset() {
        var _this_trailMesh;
        this.particleMesh.clearPoints();
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.clearAllTrails();
    };
    _proto.updateTime = function updateTime(now, delta) {
        this.particleMesh.time = now;
        if (this.trailMesh) {
            this.trailMesh.time = now;
            this.trailMesh.onUpdate(delta);
        }
    };
    _proto.minusTimeForLoop = function minusTimeForLoop(duration) {
        var _this_trailMesh;
        this.particleMesh.minusTime(duration);
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.minusTime(duration);
    };
    _proto.updateWorldMatrix = function updateWorldMatrix(worldMatrix) {
        this.particleMesh.mesh.worldMatrix = worldMatrix;
        if (this.trailMesh) {
            this.trailMesh.mesh.worldMatrix = worldMatrix;
        }
    };
    _proto.setVisible = function setVisible(visible) {
        var _this_trailMesh;
        this.particleMesh.mesh.setVisible(visible);
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.mesh.setVisible(visible);
    };
    _proto.getTextures = function getTextures() {
        var textures = [];
        // @ts-expect-error textures 是否可以考虑挂在 Material 上
        var particleMeshTextures = this.particleMesh.mesh.material.textures;
        Object.keys(particleMeshTextures).forEach(function(key) {
            textures.push(particleMeshTextures[key]);
        });
        if (this.trailMesh) {
            // @ts-expect-error 同上
            var trailMeshTextures = this.trailMesh.mesh.material.textures;
            Object.keys(trailMeshTextures).forEach(function(key) {
                textures.push(trailMeshTextures[key]);
            });
        }
        return textures;
    };
    _proto.setParticlePoint = function setParticlePoint(index, point) {
        this.particleMesh.setPoint(index, point);
    };
    _proto.removeParticlePoint = function removeParticlePoint(index) {
        this.particleMesh.removePoint(index);
    };
    _proto.getParticlePointColor = function getParticlePointColor(index) {
        return this.particleMesh.getPointColor(index);
    };
    _proto.hasTrail = function hasTrail() {
        return this.trailMesh !== undefined;
    };
    _proto.clearTrail = function clearTrail(pointIndex) {
        var _this_trailMesh;
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.clearTrail(pointIndex);
    };
    _proto.addTrailPoint = function addTrailPoint(index, position, options) {
        var _this_trailMesh;
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.addPoint(index, position, options);
    };
    _proto.setTrailStartPosition = function setTrailStartPosition(index, position) {
        var _this_trailMesh;
        (_this_trailMesh = this.trailMesh) == null ? void 0 : _this_trailMesh.setPointStartPos(index, position);
    };
    _proto.getTrailStartPosition = function getTrailStartPosition(index) {
        return this.trailMesh.getPointStartPos(index);
    };
    return ParticleSystemRenderer;
}(RendererComponent);

exports.ParticleSystem = /*#__PURE__*/ function(Component) {
    _inherits(ParticleSystem, Component);
    function ParticleSystem(engine, props) {
        var _this;
        _this = Component.call(this, engine) || this;
        _this.destroyed = false;
        _this.getHitTestParams = function(force) {
            var interactParams = _this.interaction;
            if (force || interactParams) {
                return {
                    type: exports.HitTestType.custom,
                    collect: function(ray) {
                        return _this.raycast({
                            radius: (interactParams == null ? void 0 : interactParams.radius) || 0.4,
                            multiple: !!(interactParams == null ? void 0 : interactParams.multiple),
                            removeParticle: (interactParams == null ? void 0 : interactParams.behavior) === ParticleInteractionBehavior.removeParticle,
                            ray: ray
                        });
                    }
                };
            }
        };
        if (props) {
            _this.fromData(props);
        }
        return _this;
    }
    var _proto = ParticleSystem.prototype;
    _proto.isFrozen = function isFrozen() {
        return this.frozen;
    };
    _proto.initEmitterTransform = function initEmitterTransform() {
        var position = this.item.transform.position.clone();
        var rotation = this.item.transform.rotation.clone();
        var transformPath = this.props.emitterTransform && this.props.emitterTransform.path;
        var path;
        if (transformPath) {
            if (transformPath[0] === ValueType.CONSTANT_VEC3) {
                position.add(transformPath[1]);
            } else {
                path = createValueGetter(transformPath);
            }
        }
        this.basicTransform = {
            position: position,
            rotation: rotation,
            path: path
        };
        var parentTransform = this.transform.parentTransform;
        var selfPos = position.clone();
        if (path) {
            selfPos.add(path.getValue(0));
        }
        this.transform.setPosition(selfPos.x, selfPos.y, selfPos.z);
        if (this.options.particleFollowParent && parentTransform) {
            var worldMatrix = parentTransform.getWorldMatrix();
            this.renderer.updateWorldMatrix(worldMatrix);
        }
    };
    _proto.updateEmitterTransform = function updateEmitterTransform(time) {
        var parentTransform = this.transform.parentTransform;
        var _this_basicTransform = this.basicTransform, path = _this_basicTransform.path, position = _this_basicTransform.position;
        var selfPos = position.clone();
        if (path) {
            var duration = this.item.duration;
            selfPos.add(path.getValue(time / duration));
        }
        this.transform.setPosition(selfPos.x, selfPos.y, selfPos.z);
        if (this.options.particleFollowParent && parentTransform) {
            var worldMatrix = parentTransform.getWorldMatrix();
            this.renderer.updateWorldMatrix(worldMatrix);
        }
    };
    _proto.addParticle = function addParticle(point, maxCount) {
        var link = this.particleLink;
        var linkContent = [
            point.delay + point.lifetime,
            0,
            point.delay,
            point
        ];
        var pointIndex;
        if (link.length < maxCount) {
            pointIndex = linkContent[1] = link.length;
        } else {
            var first = link.first;
            link.removeNode(first);
            pointIndex = linkContent[1] = first.content[1];
        }
        link.pushNode(linkContent);
        this.renderer.setParticlePoint(pointIndex, point);
        this.clearPointTrail(pointIndex);
        if (this.transform.parentTransform) {
            this.renderer.setTrailStartPosition(pointIndex, this.transform.parentTransform.position.clone());
        }
    };
    _proto.setVisible = function setVisible(visible) {
        this.renderer.setVisible(visible);
    };
    _proto.setOpacity = function setOpacity(opacity) {
        var _material_getVector4;
        var material = this.renderer.particleMesh.mesh.material;
        var geometry = this.renderer.particleMesh.mesh.geometry;
        var originalColor = ((_material_getVector4 = material.getVector4("uOpacityOverLifetimeValue")) == null ? void 0 : _material_getVector4.toArray()) || [
            1,
            1,
            1,
            1
        ];
        material.setVector4("uOpacityOverLifetimeValue", new Vector4$1(originalColor[0], originalColor[1], originalColor[2], opacity));
        var data = geometry.getAttributeData("aColor") || [];
        for(var i = 0; i < data.length; i += 32){
            data[i * 8 + 7] = opacity;
        }
    };
    /**
   * @internal
   */ _proto.setColor = function setColor(r, g, b, a) {
        var _material_getVector4;
        var material = this.renderer.particleMesh.mesh.material;
        var geometry = this.renderer.particleMesh.mesh.geometry;
        var originalColor = ((_material_getVector4 = material.getVector4("uOpacityOverLifetimeValue")) == null ? void 0 : _material_getVector4.toArray()) || [
            1,
            1,
            1,
            1
        ];
        material.setVector4("uOpacityOverLifetimeValue", new Vector4$1(originalColor[0], originalColor[1], originalColor[2], a));
        var data = geometry.getAttributeData("aColor") || [];
        for(var i = 0; i < data.length; i += 32){
            data[i * 8 + 4] = r;
            data[i * 8 + 5] = g;
            data[i * 8 + 6] = b;
            data[i * 8 + 7] = a;
        }
    };
    _proto.setParentTransform = function setParentTransform(transform) {};
    _proto.getTextures = function getTextures() {
        return this.renderer.getTextures();
    };
    _proto.start = function start() {
        if (!this.started || this.ended) {
            this.reset();
            this.started = true;
            this.ended = false;
        }
    };
    _proto.stop = function stop() {
        this.ended = true;
        this.started = false;
    };
    _proto.reset = function reset() {
        this.renderer.reset();
        this.lastUpdate = 0;
        this.loopStartTime = 0;
        this.lastEmitTime = -1 / this.emission.rateOverTime.getValue(0);
        this.generatedCount = 0;
        this.particleLink = new Link(function(a, b) {
            return a[0] - b[0];
        });
        this.emission.bursts.forEach(function(b) {
            return b.reset();
        });
        this.frozen = false;
        this.ended = false;
    };
    _proto.onUpdate = function onUpdate(delta) {
        var _this = this;
        if (this.started && !this.frozen) {
            var now = this.lastUpdate + delta / 1000;
            var options = this.options;
            var loopStartTime = this.loopStartTime;
            var emission = this.emission;
            this.lastUpdate = now;
            this.upDirectionWorld = null;
            this.renderer.updateTime(now, delta);
            var link = this.particleLink;
            var emitterLifetime = (now - loopStartTime) / this.item.duration;
            var timePassed = this.timePassed;
            var trailUpdated = false;
            var updateTrail = function() {
                if (_this.trails && !trailUpdated) {
                    trailUpdated = true;
                    link.forEach(function(param) {
                        var time = param[0], pointIndex = param[1], delay = param[2], point = param[3];
                        if (time < timePassed) {
                            _this.clearPointTrail(pointIndex);
                        } else if (timePassed > delay) {
                            _this.updatePointTrail(pointIndex, emitterLifetime, point, delay);
                        }
                    });
                }
            };
            if (!this.ended) {
                var duration = this.item.duration;
                var lifetime = this.lifetime;
                if (timePassed < duration) {
                    var interval = 1 / emission.rateOverTime.getValue(lifetime);
                    var pointCount = Math.floor((timePassed - this.lastEmitTime) / interval);
                    var maxEmissionCount = pointCount;
                    var timeDelta = interval / pointCount;
                    var meshTime = now;
                    var maxCount = options.maxCount;
                    this.updateEmitterTransform(timePassed);
                    var shouldSkipGenerate = function() {
                        var first = link.first;
                        return _this.emissionStopped || link.length === maxCount && first && first.content[0] - loopStartTime > timePassed;
                    };
                    for(var i = 0; i < maxEmissionCount && i < maxCount; i++){
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var p = this.createPoint(lifetime);
                        p.delay += meshTime + i * timeDelta;
                        this.addParticle(p, maxCount);
                        this.lastEmitTime = timePassed;
                    }
                    var bursts = emission.bursts;
                    for(var j = (bursts == null ? void 0 : bursts.length) - 1, cursor = 0; j >= 0 && cursor < maxCount; j--){
                        if (shouldSkipGenerate()) {
                            break;
                        }
                        var burst = bursts[j];
                        var opts = burst.getGeneratorOptions(timePassed, lifetime);
                        if (opts) {
                            var originVec = [
                                0,
                                0,
                                0
                            ];
                            var offsets = emission.burstOffsets[j];
                            var burstOffset = offsets && offsets[opts.cycleIndex] || originVec;
                            for(var i1 = 0; i1 < opts.count && cursor < maxCount; i1++){
                                var _p_transform;
                                if (shouldSkipGenerate()) {
                                    break;
                                }
                                var p1 = this.initPoint(this.shape.generate({
                                    total: opts.total,
                                    index: opts.index,
                                    burstIndex: i1,
                                    burstCount: opts.count
                                }));
                                p1.delay += meshTime;
                                cursor++;
                                (_p_transform = p1.transform).translate.apply(_p_transform, [].concat(burstOffset));
                                this.addParticle(p1, maxCount);
                            }
                        }
                    }
                } else if (this.item.endBehavior === EndBehavior.restart) {
                    updateTrail();
                    this.loopStartTime = now - duration;
                    this.lastEmitTime -= duration;
                    this.lastUpdate -= duration;
                    emission.bursts.forEach(function(b) {
                        return b.reset();
                    });
                    this.particleLink.forEach(function(content) {
                        content[0] -= duration;
                        content[2] -= duration;
                        content[3].delay -= duration;
                    });
                    this.renderer.minusTimeForLoop(duration);
                } else {
                    this.ended = true;
                    var endBehavior = this.item.endBehavior;
                    if (endBehavior === EndBehavior.freeze) {
                        this.frozen = true;
                    }
                }
            } else if (this.item.endBehavior !== EndBehavior.restart) {
                if (EndBehavior.destroy === this.item.endBehavior) {
                    var node = link.last;
                    if (node && node.content[0] < this.lastUpdate) {
                        this.destroyed = true;
                    }
                }
            }
            updateTrail();
        }
    };
    _proto.onDestroy = function onDestroy() {
        if (this.item && this.item.composition) {
            this.item.composition.destroyTextures(this.getTextures());
            this.meshes.forEach(function(mesh) {
                return mesh.dispose({
                    material: {
                        textures: exports.DestroyOptions.keep
                    }
                });
            });
        }
    };
    _proto.getParticleBoxes = function getParticleBoxes() {
        var link = this.particleLink;
        var renderer = this.renderer;
        var res = [];
        var maxCount = this.particleCount;
        var counter = 0;
        if (!(link && renderer)) {
            return res;
        }
        var node = link.last;
        var finish = false;
        while(!finish){
            var currentTime = node.content[0];
            var point = node.content[3];
            if (currentTime > this.timePassed) {
                var pos = this.getPointPosition(point);
                res.push({
                    center: pos,
                    size: point.transform.scale
                });
                if (node.pre) {
                    node = node.pre;
                } else {
                    finish = true;
                }
            }
            counter++;
            if (counter > maxCount) {
                finish = true;
            }
        }
        return res;
    };
    _proto.raycast = function raycast(options) {
        var link = this.particleLink;
        var renderer = this.renderer;
        if (!(link && renderer)) {
            return;
        }
        var node = link.last;
        var hitPositions = [];
        var temp = new Vector3();
        var finish = false;
        if (node && node.content) {
            do {
                var _node_content = node.content, currentTime = _node_content[0], pointIndex = _node_content[1]; _node_content[2]; var point = _node_content[3];
                if (currentTime > this.timePassed) {
                    var pos = this.getPointPosition(point);
                    var ray = options.ray;
                    var pass = false;
                    if (ray) {
                        pass = !!ray.intersectSphere({
                            center: pos,
                            radius: options.radius
                        }, temp);
                    }
                    if (pass) {
                        if (options.removeParticle) {
                            renderer.removeParticlePoint(pointIndex);
                            this.clearPointTrail(pointIndex);
                            link.removeNode(node); // TODO: 会多移除一个粒子，为了通过帧对比先保留，等 2.0 合到主分支后移除。
                            node.content = [
                                0
                            ];
                        }
                        hitPositions.push(pos);
                        if (!options.multiple) {
                            finish = true;
                        }
                    }
                } else {
                    break;
                }
            // @ts-expect-error
            }while ((node = node.pre) && !finish);
        }
        return hitPositions;
    };
    _proto.clearPointTrail = function clearPointTrail(pointIndex) {
        if (this.trails && this.trails.dieWithParticles) {
            this.renderer.clearTrail(pointIndex);
        }
    };
    _proto.updatePointTrail = function updatePointTrail(pointIndex, emitterLifetime, point, startTime) {
        var renderer = this.renderer;
        if (!renderer.hasTrail()) {
            return;
        }
        var trails = this.trails;
        var position = this.getPointPosition(point);
        var color = trails.inheritParticleColor ? renderer.getParticlePointColor(pointIndex) : [
            1,
            1,
            1,
            1
        ];
        var size = point.transform.getWorldScale().toArray();
        var width = 1;
        var lifetime = trails.lifetime.getValue(emitterLifetime);
        if (trails.sizeAffectsWidth) {
            width *= size[0];
        }
        if (trails.sizeAffectsLifetime) {
            lifetime *= size[0];
        }
        if (trails.parentAffectsPosition && this.transform.parentTransform) {
            position.add(this.transform.parentTransform.position);
            var pos = renderer.getTrailStartPosition(pointIndex);
            if (pos) {
                position.subtract(pos);
            }
        }
        renderer.addTrailPoint(pointIndex, position, {
            color: color,
            lifetime: lifetime,
            size: width,
            time: startTime
        });
    };
    /**
   * 通过索引获取指定index粒子当前时刻的位置
   * @params index - 粒子索引
   */ _proto.getPointPositionByIndex = function getPointPositionByIndex(index) {
        var point = this.particleLink.getNodeByIndex(index);
        if (!point) {
            console.error("Get point error.");
            return null;
        } else {
            return this.getPointPosition(point.content[3]);
        }
    };
    /**
   * 通过粒子参数获取当前时刻粒子的位置
   */ _proto.getPointPosition = function getPointPosition(point) {
        var transform = point.transform, vel = point.vel, lifetime = point.lifetime, delay = point.delay, _point_gravity = point.gravity, gravity = _point_gravity === void 0 ? [] : _point_gravity;
        var forceTarget = this.options.forceTarget;
        var time = this.lastUpdate - delay;
        var tempPos = new Vector3();
        var acc = Vector3.fromArray(gravity);
        transform.assignWorldTRS(tempPos);
        var ret = calculateTranslation(new Vector3(), this.options, acc, time, lifetime, tempPos, vel);
        if (forceTarget) {
            var target = forceTarget.target || [
                0,
                0,
                0
            ];
            var life = forceTarget.curve.getValue(time / lifetime);
            var dl = 1 - life;
            ret.x = ret.x * dl + target[0] * life;
            ret.y = ret.y * dl + target[1] * life;
            ret.z = ret.z * dl + target[2] * life;
        }
        return ret;
    };
    _proto.initPoint = function initPoint(data) {
        var options = this.options;
        var lifetime = this.lifetime;
        var shape = this.shape;
        var speed = options.startSpeed.getValue(lifetime);
        var matrix4 = options.particleFollowParent ? this.transform.getMatrix() : this.transform.getWorldMatrix();
        var pointPosition = data.position;
        // 粒子的位置受发射器的位置影响，自身的旋转和缩放不受影响
        var position = matrix4.transformPoint(pointPosition, new Vector3());
        var transform = new Transform({
            position: position,
            valid: true
        });
        var direction = data.direction;
        direction = matrix4.transformNormal(direction, tempDir).normalize();
        if (options.startTurbulence && options.turbulence) {
            for(var i = 0; i < 3; i++){
                tempVec3.setElement(i, options.turbulence[i].getValue(lifetime));
            }
            tempEuler.setFromVector3(tempVec3.negate());
            var mat4 = tempMat4.setFromEuler(tempEuler);
            mat4.transformNormal(direction).normalize();
        }
        var dirX = tmpDirX;
        var dirY = tmpDirY;
        if (shape.alignSpeedDirection) {
            dirY.copyFrom(direction);
            if (!this.upDirectionWorld) {
                if (shape.upDirection) {
                    this.upDirectionWorld = shape.upDirection.clone();
                } else {
                    this.upDirectionWorld = Vector3.Z.clone();
                }
                matrix4.transformNormal(this.upDirectionWorld);
            }
            dirX.crossVectors(dirY, this.upDirectionWorld).normalize();
            // FIXME: 原先因为有精度问题，这里dirX不是0向量
            if (dirX.isZero()) {
                dirX.set(1, 0, 0);
            }
        } else {
            dirX.set(1, 0, 0);
            dirY.set(0, 1, 0);
        }
        var sprite;
        var tsa = this.textureSheetAnimation;
        if (tsa && tsa.animate) {
            sprite = tempSprite;
            sprite[0] = tsa.animationDelay.getValue(lifetime);
            sprite[1] = tsa.animationDuration.getValue(lifetime);
            sprite[2] = tsa.cycles.getValue(lifetime);
        }
        var rot = tempRot$1;
        if (options.start3DRotation) {
            // @ts-expect-error
            rot.set(options.startRotationX.getValue(lifetime), options.startRotationY.getValue(lifetime), options.startRotationZ.getValue(lifetime));
        } else if (options.startRotation) {
            rot.set(0, 0, options.startRotation.getValue(lifetime));
        } else {
            rot.set(0, 0, 0);
        }
        transform.setRotation(rot.x, rot.y, rot.z);
        var color = options.startColor.getValue(lifetime);
        if (color.length === 3) {
            color[3] = 1;
        }
        var size = tempSize$1;
        if (options.start3DSize) {
            size.x = options.startSizeX.getValue(lifetime);
            size.y = options.startSizeY.getValue(lifetime);
        } else {
            var n = options.startSize.getValue(lifetime);
            var aspect = options.sizeAspect.getValue(lifetime);
            size.x = n;
            // 兼容aspect为0的情况
            size.y = aspect === 0 ? 0 : n / aspect;
        // size[1] = n / aspect;
        }
        var vel = direction.clone();
        vel.multiply(speed);
        // 粒子的大小受发射器父节点的影响
        if (!options.particleFollowParent) {
            var tempScale = new Vector3();
            this.transform.assignWorldTRS(undefined, undefined, tempScale);
            size.x *= tempScale.x;
            size.y *= tempScale.y;
        }
        transform.setScale(size.x, size.y, 1);
        return {
            size: size,
            vel: vel,
            color: color,
            delay: options.startDelay.getValue(lifetime),
            lifetime: options.startLifetime.getValue(lifetime),
            uv: randomArrItem(this.uvs, true),
            gravity: options.gravity,
            sprite: sprite,
            dirY: dirY,
            dirX: dirX,
            transform: transform
        };
    };
    _proto.addBurst = function addBurst(burst, offsets) {
        var willAdd = false;
        if (!this.emission.bursts.includes(burst)) {
            this.emission.bursts.push(burst);
            willAdd = true;
        }
        if (willAdd && _instanceof1(offsets, Array)) {
            var index = this.emission.bursts.indexOf(burst);
            this.emission.burstOffsets[index] = offsets;
            return index;
        }
        return -1;
    };
    _proto.removeBurst = function removeBurst(index) {
        if (index < this.emission.bursts.length) {
            this.emission.burstOffsets[index] = null;
            this.emission.bursts.splice(index, 1);
        }
    };
    _proto.createPoint = function createPoint(lifetime) {
        var generator = {
            total: this.emission.rateOverTime.getValue(lifetime),
            index: this.generatedCount,
            burstIndex: 0,
            burstCount: 0
        };
        this.generatedCount++;
        return this.initPoint(this.shape.generate(generator));
    };
    _proto.stopParticleEmission = function stopParticleEmission() {
        this.emissionStopped = true;
    };
    _proto.resumeParticleEmission = function resumeParticleEmission() {
        this.emissionStopped = false;
    };
    _proto.getBoundingBox = function getBoundingBox() {
        var area = this.getParticleBoxes();
        return {
            type: exports.HitTestType.sphere,
            area: area
        };
    };
    _proto.fromData = function fromData(data) {
        Component.prototype.fromData.call(this, data);
        var props = data;
        this.props = props;
        this.destroyed = false;
        var cachePrefix = "";
        var options = props.options, _props_positionOverLifetime = props.positionOverLifetime, positionOverLifetime = _props_positionOverLifetime === void 0 ? {} : _props_positionOverLifetime, shape = props.shape;
        var gravityModifier = positionOverLifetime == null ? void 0 : positionOverLifetime.gravityOverLifetime;
        var gravity = ensureVec3(positionOverLifetime == null ? void 0 : positionOverLifetime.gravity);
        var _textureSheetAnimation = props.textureSheetAnimation;
        var textureSheetAnimation = _textureSheetAnimation ? {
            animationDelay: createValueGetter(_textureSheetAnimation.animationDelay || 0),
            animationDuration: createValueGetter(_textureSheetAnimation.animationDuration || 1),
            cycles: createValueGetter(_textureSheetAnimation.cycles || 1),
            animate: _textureSheetAnimation.animate,
            col: _textureSheetAnimation.col,
            row: _textureSheetAnimation.row,
            total: _textureSheetAnimation.total || _textureSheetAnimation.col * _textureSheetAnimation.row
        } : undefined;
        var startTurbulence = !!(shape && shape.turbulenceX || (shape == null ? void 0 : shape.turbulenceY) || (shape == null ? void 0 : shape.turbulenceZ));
        var turbulence;
        if (startTurbulence) {
            var _shape_turbulenceX, _shape_turbulenceY, _shape_turbulenceZ;
            turbulence = [
                createValueGetter((_shape_turbulenceX = shape.turbulenceX) != null ? _shape_turbulenceX : 0),
                createValueGetter((_shape_turbulenceY = shape.turbulenceY) != null ? _shape_turbulenceY : 0),
                createValueGetter((_shape_turbulenceZ = shape.turbulenceZ) != null ? _shape_turbulenceZ : 0)
            ];
        }
        this.name = "ParticleSystem";
        this.shape = createShape(shape);
        var _props_emission_burstOffsets;
        this.emission = {
            rateOverTime: createValueGetter(props.emission.rateOverTime),
            burstOffsets: getBurstOffsets((_props_emission_burstOffsets = props.emission.burstOffsets) != null ? _props_emission_burstOffsets : []),
            bursts: (props.emission.bursts || []).map(function(c) {
                return new Burst(c);
            })
        };
        this.textureSheetAnimation = textureSheetAnimation;
        var renderer = props.renderer || {};
        var rotationOverLifetime = {};
        var rotOverLt = props.rotationOverLifetime;
        if (rotOverLt) {
            rotationOverLifetime.asRotation = !!rotOverLt.asRotation;
            rotationOverLifetime.z = rotOverLt.z ? createValueGetter(rotOverLt.z) : createValueGetter(0);
            if (rotOverLt.separateAxes) {
                rotationOverLifetime.x = rotOverLt.x && createValueGetter(rotOverLt.x);
                rotationOverLifetime.y = rotOverLt.y && createValueGetter(rotOverLt.y);
            }
        }
        var forceTarget;
        if (positionOverLifetime == null ? void 0 : positionOverLifetime.forceTarget) {
            forceTarget = {
                target: positionOverLifetime.target || [
                    0,
                    0,
                    0
                ],
                curve: createValueGetter(positionOverLifetime.forceCurve || [
                    ValueType.LINE,
                    [
                        [
                            0,
                            0
                        ],
                        [
                            1,
                            1
                        ]
                    ]
                ])
            };
        }
        var linearVelOverLifetime = {
            x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX || 0),
            y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY || 0),
            z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ || 0),
            asMovement: positionOverLifetime.asMovement
        };
        var orbitalVelOverLifetime = {
            x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
            y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
            z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
            center: positionOverLifetime.orbCenter,
            asRotation: positionOverLifetime.asRotation
        };
        var sizeOverLifetime = props.sizeOverLifetime || {};
        var colorOverLifetime = props.colorOverLifetime;
        var shaderCachePrefix = cachePrefix;
        var sizeOverLifetimeGetter = (sizeOverLifetime == null ? void 0 : sizeOverLifetime.separateAxes) ? {
            separateAxes: true,
            x: createValueGetter(sizeOverLifetime.x),
            y: createValueGetter(sizeOverLifetime.y)
        } : {
            separateAxes: false,
            x: createValueGetter(("size" in sizeOverLifetime ? sizeOverLifetime.size : sizeOverLifetime.x) || 1)
        };
        renderer.anchor = renderer.anchor || [
            0,
            0
        ];
        var anchor = Vector2.fromArray(renderer.anchor);
        var _options_maxCount;
        this.options = {
            particleFollowParent: !!options.particleFollowParent,
            startLifetime: createValueGetter(options.startLifetime),
            startDelay: createValueGetter(options.startDelay || 0),
            startSpeed: createValueGetter(positionOverLifetime.startSpeed || 0),
            startColor: createValueGetter(options.startColor),
            // duration:vfxItem.duration || 1,
            looping: false,
            maxCount: (_options_maxCount = options.maxCount) != null ? _options_maxCount : 0,
            gravityModifier: createValueGetter(gravityModifier || 0),
            gravity: gravity,
            start3DSize: !!options.start3DSize,
            startTurbulence: startTurbulence,
            turbulence: turbulence,
            speedOverLifetime: positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime),
            linearVelOverLifetime: linearVelOverLifetime,
            orbitalVelOverLifetime: orbitalVelOverLifetime,
            forceTarget: forceTarget
        };
        if (options.startRotationZ) {
            this.options.startRotation = createValueGetter(options.startRotationZ || 0);
        }
        if (options.startRotationX || options.startRotationY) {
            this.options.start3DRotation = true;
            this.options.startRotationX = createValueGetter(options.startRotationX || 0);
            this.options.startRotationY = createValueGetter(options.startRotationY || 0);
            this.options.startRotationZ = createValueGetter(options.startRotationZ || 0);
        }
        if (options.start3DSize) {
            this.options.startSizeX = createValueGetter(options.startSizeX);
            this.options.startSizeY = createValueGetter(options.startSizeY);
        } else {
            this.options.startSize = createValueGetter(options.startSize);
            this.options.sizeAspect = createValueGetter(options.sizeAspect || 1);
        }
        var _renderer_maskMode;
        var particleMeshProps = {
            // listIndex: vfxItem.listIndex,
            meshSlots: options.meshSlots,
            name: this.name,
            matrix: Matrix4$1.IDENTITY,
            shaderCachePrefix: shaderCachePrefix,
            renderMode: renderer.renderMode || RenderMode.BILLBOARD,
            side: renderer.side || SideMode.DOUBLE,
            gravity: gravity,
            // duration: vfxItem.duration,
            blending: renderer.blending || BlendingMode.ALPHA,
            rotationOverLifetime: rotationOverLifetime,
            gravityModifier: this.options.gravityModifier,
            linearVelOverLifetime: this.options.linearVelOverLifetime,
            orbitalVelOverLifetime: this.options.orbitalVelOverLifetime,
            speedOverLifetime: this.options.speedOverLifetime,
            sprite: textureSheetAnimation,
            occlusion: !!renderer.occlusion,
            transparentOcclusion: !!renderer.transparentOcclusion,
            maxCount: options.maxCount,
            mask: renderer.mask,
            maskMode: (_renderer_maskMode = renderer.maskMode) != null ? _renderer_maskMode : MaskMode.NONE,
            forceTarget: forceTarget,
            diffuse: renderer.texture,
            sizeOverLifetime: sizeOverLifetimeGetter,
            anchor: anchor
        };
        if (colorOverLifetime) {
            var color = colorOverLifetime.color, opacity = colorOverLifetime.opacity;
            particleMeshProps.colorOverLifetime = {};
            if (opacity) {
                particleMeshProps.colorOverLifetime.opacity = createValueGetter(colorOverLifetime.opacity);
            }
            if (color) {
                if (color[0] === ValueType.GRADIENT_COLOR) {
                    particleMeshProps.colorOverLifetime.color = colorOverLifetime.color[1];
                } else if (color[0] === ValueType.RGBA_COLOR) {
                    particleMeshProps.colorOverLifetime.color = Texture.createWithData(this.engine, {
                        data: new Uint8Array(color[1]),
                        width: 1,
                        height: 1
                    });
                } else if (_instanceof1(color, Texture)) {
                    particleMeshProps.colorOverLifetime.color = color;
                }
            }
        }
        var uvs = [];
        var textureMap = [
            0,
            0,
            1,
            1
        ];
        var flip;
        if (props.splits) {
            var s = props.splits[0];
            flip = s[4];
            textureMap = flip ? [
                s[0],
                s[1],
                s[3],
                s[2]
            ] : [
                s[0],
                s[1],
                s[2],
                s[3]
            ];
        }
        if (textureSheetAnimation && !textureSheetAnimation.animate) {
            var col = flip ? textureSheetAnimation.row : textureSheetAnimation.col;
            var row = flip ? textureSheetAnimation.col : textureSheetAnimation.row;
            var total = textureSheetAnimation.total || col * row;
            var index = 0;
            for(var x = 0; x < col; x++){
                for(var y = 0; y < row && index < total; y++, index++){
                    uvs.push([
                        x * textureMap[2] / col + textureMap[0],
                        y * textureMap[3] / row + textureMap[1],
                        textureMap[2] / col,
                        textureMap[3] / row
                    ]);
                }
            }
        } else {
            uvs.push(textureMap);
        }
        this.uvs = uvs;
        // @ts-expect-error
        particleMeshProps.textureFlip = flip;
        var trails = props.trails;
        var trailMeshProps;
        if (trails) {
            this.trails = {
                lifetime: createValueGetter(trails.lifetime),
                dieWithParticles: trails.dieWithParticles !== false,
                sizeAffectsWidth: !!trails.sizeAffectsWidth,
                sizeAffectsLifetime: !!trails.sizeAffectsLifetime,
                inheritParticleColor: !!trails.inheritParticleColor,
                parentAffectsPosition: !!trails.parentAffectsPosition
            };
            trailMeshProps = {
                name: "Trail",
                matrix: Matrix4$1.IDENTITY,
                minimumVertexDistance: trails.minimumVertexDistance || 0.02,
                maxTrailCount: options.maxCount,
                pointCountPerTrail: Math.round(trails.maxPointPerTrail) || 32,
                blending: trails.blending,
                texture: trails.texture,
                opacityOverLifetime: createValueGetter(trails.opacityOverLifetime || 1),
                widthOverTrail: createValueGetter(trails.widthOverTrail || 1),
                // order: vfxItem.listIndex + (trails.orderOffset || 0),
                shaderCachePrefix: shaderCachePrefix,
                lifetime: this.trails.lifetime,
                occlusion: !!trails.occlusion,
                transparentOcclusion: !!trails.transparentOcclusion,
                textureMap: trails.textureMap,
                mask: renderer.mask,
                maskMode: renderer.maskMode
            };
            if (trails.colorOverLifetime && trails.colorOverLifetime[0] === ValueType.GRADIENT_COLOR) {
                trailMeshProps.colorOverLifetime = trails.colorOverLifetime[1];
            }
            if (trails.colorOverTrail && trails.colorOverTrail[0] === ValueType.GRADIENT_COLOR) {
                trailMeshProps.colorOverTrail = trails.colorOverTrail[1];
            }
        }
        this.renderer = new ParticleSystemRenderer(this.engine, particleMeshProps, trailMeshProps);
        this.renderer.item = this.item;
        this.meshes = this.renderer.meshes;
        var interaction = props.interaction;
        if (interaction) {
            var _interaction_radius;
            this.interaction = {
                multiple: interaction.multiple,
                radius: (_interaction_radius = interaction.radius) != null ? _interaction_radius : 0.4,
                behavior: interaction.behavior
            };
        }
        this.item.getHitTestParams = this.getHitTestParams;
        this.item._content = this;
    };
    _create_class(ParticleSystem, [
        {
            key: "timePassed",
            get: function get() {
                return this.lastUpdate - this.loopStartTime;
            }
        },
        {
            key: "lifetime",
            get: function get() {
                return this.timePassed / this.item.duration;
            }
        },
        {
            key: "particleCount",
            get: function get() {
                return this.particleLink.length;
            }
        }
    ]);
    return ParticleSystem;
}(Component);
exports.ParticleSystem = __decorate([
    effectsClass(DataType.ParticleSystem)
], exports.ParticleSystem);
// array performance better for small memory than Float32Array
var tempDir = new Vector3();
var tempSize$1 = new Vector2();
var tempRot$1 = new Euler();
var tmpDirX = new Vector3();
var tmpDirY = new Vector3();
var tempVec3 = new Vector3();
var tempEuler = new Euler();
var tempSprite = [
    0,
    0,
    0
];
var tempMat4 = new Matrix4$1();
function getBurstOffsets(burstOffsets) {
    var ret = {};
    if (Array.isArray(burstOffsets)) {
        burstOffsets.forEach(function(arr) {
            var isArr = _instanceof1(arr, Array);
            var index = isArr ? arr[0] : arr.index;
            var offsets = ret[index];
            if (!offsets) {
                offsets = ret[index] = [];
            }
            if (isArr) {
                offsets.push(arr.slice(1, 4));
            } else {
                offsets.push([
                    +arr.x,
                    +arr.y,
                    +arr.z
                ]);
            }
        });
    }
    return ret;
}
function randomArrItem(arr, keepArr) {
    var index = Math.floor(Math.random() * arr.length);
    var item = arr[index];
    if (!keepArr) {
        arr.splice(index, 1);
    }
    return item;
}

/**
 * @since 2.0.0
 * @internal
 */ var ParticleBehaviourPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(ParticleBehaviourPlayable, Playable);
    function ParticleBehaviourPlayable() {
        var _this;
        _this = Playable.apply(this, arguments) || this;
        _this.lastTime = 0;
        return _this;
    }
    var _proto = ParticleBehaviourPlayable.prototype;
    _proto.start = function start(context) {
        var boundObject = context.output.getUserData();
        if (this.particleSystem || !_instanceof1(boundObject, exports.VFXItem)) {
            return;
        }
        this.particleSystem = boundObject.getComponent(exports.ParticleSystem);
        if (this.particleSystem) {
            this.particleSystem.name = boundObject.name;
            this.particleSystem.start();
            this.particleSystem.initEmitterTransform();
        }
    };
    _proto.processFrame = function processFrame(context) {
        if (this.time >= 0) {
            this.start(context);
        }
        var particleSystem = this.particleSystem;
        if (particleSystem) {
            // TODO: [1.31] @十弦 验证 https://github.com/galacean/effects-runtime/commit/3e7d73d37b7d98c2a25e4544e80e928b17801ccd#diff-fae062f28caf3771cfedd3a20dc22f9749bd054c7541bf2fd50a9a5e413153d4
            // particleSystem.setParentTransform(parentItem.transform);
            particleSystem.setVisible(true);
            var deltaTime = context.deltaTime;
            if (this.time < particleSystem.item.duration && particleSystem.isFrozen()) {
                particleSystem.reset();
            }
            if (Math.abs(this.time - this.lastTime) < 0.001) {
                deltaTime = 0;
            }
            particleSystem.onUpdate(deltaTime);
        }
        this.lastTime = this.time;
    };
    return ParticleBehaviourPlayable;
}(Playable);
var ParticleBehaviourPlayableAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(ParticleBehaviourPlayableAsset, PlayableAsset);
    function ParticleBehaviourPlayableAsset() {
        return PlayableAsset.apply(this, arguments);
    }
    var _proto = ParticleBehaviourPlayableAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        return new ParticleBehaviourPlayable(graph);
    };
    return ParticleBehaviourPlayableAsset;
}(PlayableAsset);
var particleUniformTypeMap = {
    "uSprite": "vec4",
    "uParams": "vec4",
    "uAcceleration": "vec4",
    "uGravityModifierValue": "vec4",
    "uOpacityOverLifetimeValue": "vec4",
    "uRXByLifeTimeValue": "vec4",
    "uRYByLifeTimeValue": "vec4",
    "uRZByLifeTimeValue": "vec4",
    "uLinearXByLifetimeValue": "vec4",
    "uLinearYByLifetimeValue": "vec4",
    "uLinearZByLifetimeValue": "vec4",
    "uSpeedLifetimeValue": "vec4",
    "uOrbXByLifetimeValue": "vec4",
    "uOrbYByLifetimeValue": "vec4",
    "uOrbZByLifetimeValue": "vec4",
    "uSizeByLifetimeValue": "vec4",
    "uSizeYByLifetimeValue": "vec4",
    "uColorParams": "vec4",
    "uFSprite": "vec4",
    "uPreviewColor": "vec4",
    "uVCurveValues": "vec4Array",
    "uFCurveValues": "vec4",
    "uFinalTarget": "vec3",
    "uForceCurve": "vec4",
    "uOrbCenter": "vec3",
    "uTexOffset": "vec2",
    "uPeriodValue": "vec4",
    "uMovementValue": "vec4",
    "uStrengthValue": "vec4",
    "uWaveParams": "vec4"
};

var ParticleMesh = /*#__PURE__*/ function() {
    function ParticleMesh(engine, props) {
        this.particleCount = 0;
        var _engine_renderer;
        var env = ((_engine_renderer = engine.renderer) != null ? _engine_renderer : {}).env;
        var speedOverLifetime = props.speedOverLifetime, colorOverLifetime = props.colorOverLifetime, linearVelOverLifetime = props.linearVelOverLifetime, orbitalVelOverLifetime = props.orbitalVelOverLifetime, sizeOverLifetime = props.sizeOverLifetime, rotationOverLifetime = props.rotationOverLifetime, sprite = props.sprite, gravityModifier = props.gravityModifier, maxCount = props.maxCount, textureFlip = props.textureFlip, useSprite = props.useSprite, name = props.name, gravity = props.gravity, forceTarget = props.forceTarget, side = props.side, occlusion = props.occlusion, anchor = props.anchor, blending = props.blending, maskMode = props.maskMode, mask = props.mask, transparentOcclusion = props.transparentOcclusion, meshSlots = props.meshSlots, _props_renderMode = props.renderMode, renderMode = _props_renderMode === void 0 ? 0 : _props_renderMode, _props_diffuse = props.diffuse, diffuse = _props_diffuse === void 0 ? Texture.createWithData(engine) : _props_diffuse;
        var detail = engine.gpuCapability.detail;
        var halfFloatTexture = detail.halfFloatTexture, maxVertexUniforms = detail.maxVertexUniforms;
        var macros = [
            // spec.RenderMode
            [
                "RENDER_MODE",
                +renderMode
            ],
            [
                "ENV_EDITOR",
                env === PLAYER_OPTIONS_ENV_EDITOR
            ]
        ];
        var level = engine.gpuCapability.level;
        var vertexKeyFrameMeta = createKeyFrameMeta();
        var fragmentKeyFrameMeta = createKeyFrameMeta();
        var enableVertexTexture = maxVertexUniforms > 0;
        var uniformValues = {};
        var vertex_lookup_texture = 0;
        var shaderCacheId = 0;
        var useOrbitalVel;
        this.useSprite = useSprite;
        if (enableVertexTexture) {
            macros.push([
                "ENABLE_VERTEX_TEXTURE",
                true
            ]);
        }
        if (speedOverLifetime) {
            macros.push([
                "SPEED_OVER_LIFETIME",
                true
            ]);
            shaderCacheId |= 1 << 1;
            uniformValues.uSpeedLifetimeValue = speedOverLifetime.toUniform(vertexKeyFrameMeta);
        }
        if (sprite == null ? void 0 : sprite.animate) {
            macros.push([
                "USE_SPRITE",
                true
            ]);
            shaderCacheId |= 1 << 2;
            uniformValues.uFSprite = uniformValues.uSprite = new Float32Array([
                sprite.col,
                sprite.row,
                sprite.total,
                sprite.blend ? 1 : 0
            ]);
            this.useSprite = true;
        }
        if (colorOverLifetime == null ? void 0 : colorOverLifetime.color) {
            macros.push([
                "COLOR_OVER_LIFETIME",
                true
            ]);
            shaderCacheId |= 1 << 4;
            uniformValues.uColorOverLifetime = _instanceof1(colorOverLifetime.color, Texture) ? colorOverLifetime.color : Texture.createWithData(engine, imageDataFromGradient(colorOverLifetime.color));
        }
        if (colorOverLifetime == null ? void 0 : colorOverLifetime.opacity) {
            uniformValues.uOpacityOverLifetimeValue = colorOverLifetime.opacity.toUniform(vertexKeyFrameMeta);
        } else {
            uniformValues.uOpacityOverLifetimeValue = createValueGetter(1).toUniform(vertexKeyFrameMeta);
        }
        [
            "x",
            "y",
            "z"
        ].forEach(function(pro, i) {
            var defL = 0;
            var defO = 0;
            if (linearVelOverLifetime == null ? void 0 : linearVelOverLifetime[pro]) {
                uniformValues["uLinear" + pro.toUpperCase() + "ByLifetimeValue"] = linearVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defL = 1;
                shaderCacheId |= 1 << 7 + i;
                linearVelOverLifetime.enabled = true;
            }
            macros.push([
                "LINEAR_VEL_" + pro.toUpperCase(),
                defL
            ]);
            if (orbitalVelOverLifetime == null ? void 0 : orbitalVelOverLifetime[pro]) {
                uniformValues["uOrb" + pro.toUpperCase() + "ByLifetimeValue"] = orbitalVelOverLifetime[pro].toUniform(vertexKeyFrameMeta);
                defO = 1;
                shaderCacheId |= 1 << 10 + i;
                useOrbitalVel = true;
                orbitalVelOverLifetime.enabled = true;
            }
            macros.push([
                "ORB_VEL_" + pro.toUpperCase(),
                defO
            ]);
        });
        if (linearVelOverLifetime == null ? void 0 : linearVelOverLifetime.asMovement) {
            macros.push([
                "AS_LINEAR_MOVEMENT",
                true
            ]);
            shaderCacheId |= 1 << 5;
        }
        if (useOrbitalVel) {
            if (orbitalVelOverLifetime == null ? void 0 : orbitalVelOverLifetime.asRotation) {
                macros.push([
                    "AS_ORBITAL_MOVEMENT",
                    true
                ]);
                shaderCacheId |= 1 << 6;
            }
            uniformValues.uOrbCenter = new Float32Array((orbitalVelOverLifetime == null ? void 0 : orbitalVelOverLifetime.center) || [
                0,
                0,
                0
            ]);
        }
        uniformValues.uSizeByLifetimeValue = sizeOverLifetime == null ? void 0 : sizeOverLifetime.x.toUniform(vertexKeyFrameMeta);
        if (sizeOverLifetime == null ? void 0 : sizeOverLifetime.separateAxes) {
            var _sizeOverLifetime_y;
            macros.push([
                "SIZE_Y_BY_LIFE",
                1
            ]);
            shaderCacheId |= 1 << 14;
            uniformValues.uSizeYByLifetimeValue = sizeOverLifetime == null ? void 0 : (_sizeOverLifetime_y = sizeOverLifetime.y) == null ? void 0 : _sizeOverLifetime_y.toUniform(vertexKeyFrameMeta);
        }
        if (rotationOverLifetime == null ? void 0 : rotationOverLifetime.z) {
            uniformValues.uRZByLifeTimeValue = rotationOverLifetime.z.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 15;
            macros.push([
                "ROT_Z_LIFETIME",
                1
            ]);
        }
        if (rotationOverLifetime == null ? void 0 : rotationOverLifetime.x) {
            uniformValues.uRXByLifeTimeValue = rotationOverLifetime.x.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 16;
            macros.push([
                "ROT_X_LIFETIME",
                1
            ]);
        }
        if (rotationOverLifetime == null ? void 0 : rotationOverLifetime.y) {
            uniformValues.uRYByLifeTimeValue = rotationOverLifetime.y.toUniform(vertexKeyFrameMeta);
            shaderCacheId |= 1 << 17;
            macros.push([
                "ROT_Y_LIFETIME",
                1
            ]);
        }
        if (rotationOverLifetime == null ? void 0 : rotationOverLifetime.asRotation) {
            macros.push([
                "ROT_LIFETIME_AS_MOVEMENT",
                1
            ]);
            shaderCacheId |= 1 << 18;
        }
        uniformValues.uGravityModifierValue = gravityModifier.toUniform(vertexKeyFrameMeta);
        if (forceTarget) {
            macros.push([
                "FINAL_TARGET",
                true
            ]);
            shaderCacheId |= 1 << 19;
            uniformValues.uFinalTarget = new Float32Array(forceTarget.target || [
                0,
                0,
                0
            ]);
            uniformValues.uForceCurve = forceTarget.curve.toUniform(vertexKeyFrameMeta);
        }
        if (halfFloatTexture && fragmentKeyFrameMeta.max) {
            shaderCacheId |= 1 << 20;
            uniformValues.uFCurveValueTexture = generateHalfFloatTexture(engine, ValueGetter.getAllData(fragmentKeyFrameMeta, true), fragmentKeyFrameMeta.index, 1);
        } else {
            uniformValues.uFCurveValues = ValueGetter.getAllData(fragmentKeyFrameMeta);
        }
        var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
        // if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        //   vertexCurveTexture = true;
        // }
        if (level === 2) {
            vertexKeyFrameMeta.max = -1;
            vertexKeyFrameMeta.index = meshSlots ? meshSlots[0] : getSlot(vertexKeyFrameMeta.index);
            if (fragmentKeyFrameMeta.index > 0) {
                fragmentKeyFrameMeta.max = -1;
                fragmentKeyFrameMeta.index = meshSlots ? meshSlots[1] : getSlot(fragmentKeyFrameMeta.index);
            }
        }
        if (vertexCurveTexture && halfFloatTexture && enableVertexTexture) {
            var tex = generateHalfFloatTexture(engine, ValueGetter.getAllData(vertexKeyFrameMeta, true), vertexKeyFrameMeta.index, 1);
            uniformValues.uVCurveValueTexture = tex;
            vertex_lookup_texture = 1;
        } else {
            uniformValues.uVCurveValues = ValueGetter.getAllData(vertexKeyFrameMeta);
        }
        var shaderCache = [
            "-p:",
            renderMode,
            shaderCacheId,
            vertexKeyFrameMeta.index,
            vertexKeyFrameMeta.max,
            fragmentKeyFrameMeta.index,
            fragmentKeyFrameMeta.max
        ].join("+");
        macros.push([
            "VERT_CURVE_VALUE_COUNT",
            vertexKeyFrameMeta.index
        ], [
            "FRAG_CURVE_VALUE_COUNT",
            fragmentKeyFrameMeta.index
        ], [
            "VERT_MAX_KEY_FRAME_COUNT",
            vertexKeyFrameMeta.max
        ], [
            "FRAG_MAX_KEY_FRAME_COUNT",
            fragmentKeyFrameMeta.max
        ]);
        var fragment = particleFrag;
        var originalVertex = "#define LOOKUP_TEXTURE_CURVE " + vertex_lookup_texture + "\n" + particleVert;
        var vertex = originalVertex;
        var shader = {
            fragment: fragment,
            vertex: vertex,
            glslVersion: level === 1 ? exports.GLSLVersion.GLSL1 : exports.GLSLVersion.GLSL3,
            shared: true,
            cacheId: shaderCache,
            macros: macros,
            name: "particle#" + name
        };
        var mtlOptions = {
            shader: shader,
            uniformSemantics: {
                effects_MatrixV: "VIEW",
                effects_MatrixVP: "VIEWPROJECTION",
                uEditorTransform: "EDITOR_TRANSFORM",
                effects_ObjectToWorld: "MODEL"
            }
        };
        var preMulAlpha = getPreMultiAlpha(blending);
        uniformValues.uTexOffset = new Float32Array(diffuse ? [
            1 / diffuse.getWidth(),
            1 / diffuse.getHeight()
        ] : [
            0,
            0
        ]);
        uniformValues.uMaskTex = diffuse;
        uniformValues.uColorParams = new Float32Array([
            diffuse ? 1 : 0,
            +preMulAlpha,
            0,
            +(!!occlusion && !transparentOcclusion)
        ]);
        uniformValues.uParams = [
            0,
            0,
            0,
            0
        ];
        uniformValues.uAcceleration = [
            (gravity == null ? void 0 : gravity[0]) || 0,
            (gravity == null ? void 0 : gravity[1]) || 0,
            (gravity == null ? void 0 : gravity[2]) || 0,
            0
        ];
        // mtlOptions.uniformValues = uniformValues;
        var material = Material.create(engine, mtlOptions);
        material.blending = true;
        material.depthTest = true;
        material.depthMask = !!occlusion;
        material.stencilRef = mask ? [
            mask,
            mask
        ] : undefined;
        setMaskMode(material, maskMode);
        setBlendMode(material, blending);
        setSideMode(material, side);
        Object.keys(uniformValues).map(function(name) {
            var value = uniformValues[name];
            if (_instanceof1(value, Texture)) {
                material.setTexture(name, value);
                return;
            }
            var res = [];
            switch(particleUniformTypeMap[name]){
                case "vec4":
                    material.setVector4(name, Vector4$1.fromArray(value));
                    break;
                case "vec3":
                    material.setVector3(name, Vector3.fromArray(value));
                    break;
                case "vec2":
                    material.setVector2(name, Vector2.fromArray(value));
                    break;
                case "vec4Array":
                    for(var i = 0; i < value.length; i = i + 4){
                        var v = new Vector4$1(value[i], value[i + 1], value[i + 2], value[i + 3]);
                        res.push(v);
                    }
                    material.setVector4Array(name, res);
                    res.length = 0;
                    break;
                default:
                    console.warn("Uniform " + name + "'s type not in typeMap.");
            }
        });
        material.setVector3("emissionColor", new Vector3(0, 0, 0));
        material.setFloat("emissionIntensity", 0.0);
        var geometry = Geometry.create(engine, generateGeometryProps(maxCount * 4, this.useSprite, "particle#" + name));
        var mesh = Mesh.create(engine, {
            name: "MParticle_" + name,
            // priority: listIndex,
            material: material,
            geometry: geometry
        });
        this.anchor = anchor;
        this.mesh = mesh;
        this.geometry = mesh.firstGeometry();
        this.forceTarget = forceTarget;
        this.sizeOverLifetime = sizeOverLifetime;
        this.speedOverLifetime = speedOverLifetime;
        this.linearVelOverLifetime = linearVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.orbitalVelOverLifetime = orbitalVelOverLifetime;
        this.gravityModifier = gravityModifier;
        this.maxCount = maxCount;
        // this.duration = duration;
        this.textureOffsets = textureFlip ? [
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            1
        ] : [
            0,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ];
        this.time = 0;
    }
    var _proto = ParticleMesh.prototype;
    // get time () {
    //   // const value = this.mesh.material.getVector4('uParams')!;
    //   // return value.x;
    //   return this._time;
    // }
    // set time (value: number) {
    //   this._time = value;
    //   // this.mesh.material.setVector4('uParams', new Vector4(+v, this.duration, 0, 0));
    // }
    _proto.getPointColor = function getPointColor(index) {
        var data = this.geometry.getAttributeData("aRot");
        var i = index * 32 + 4;
        assertExist(data);
        return [
            data[i],
            data[i + 1],
            data[i + 2],
            data[i + 3]
        ];
    };
    _proto.clearPoints = function clearPoints() {
        this.resetGeometryData(this.geometry);
        this.particleCount = 0;
        this.geometry.setDrawCount(0);
        this.maxParticleBufferCount = 0;
    };
    _proto.resetGeometryData = function resetGeometryData(geometry) {
        var names = geometry.getAttributeNames();
        var index = geometry.getIndexData();
        for(var i = 0; i < names.length; i++){
            var name = names[i];
            var data = geometry.getAttributeData(name);
            if (data) {
                // @ts-expect-error
                geometry.setAttributeData(name, new data.constructor(0));
            }
        }
        // @ts-expect-error
        geometry.setIndexData(new index.constructor(0));
    };
    _proto.minusTime = function minusTime(time) {
        var data = this.geometry.getAttributeData("aOffset");
        assertExist(data);
        for(var i = 0; i < data.length; i += 4){
            data[i + 2] -= time;
        }
        this.geometry.setAttributeData("aOffset", data);
        this.time -= time;
    };
    _proto.removePoint = function removePoint(index) {
        if (index < this.particleCount) {
            this.geometry.setAttributeSubData("aOffset", index * 16, new Float32Array(16));
        }
    };
    _proto.setPoint = function setPoint(index, point) {
        var maxCount = this.maxCount;
        if (index < maxCount) {
            var particleCount = index + 1;
            var vertexCount = particleCount * 4;
            var geometry = this.geometry;
            var increaseBuffer = particleCount > this.maxParticleBufferCount;
            var inc = 1;
            if (this.particleCount > 300) {
                inc = (this.particleCount + 100) / this.particleCount;
            } else if (this.particleCount > 100) {
                inc = 1.4;
            } else if (this.particleCount > 0) {
                inc = 2;
            }
            var pointData = {
                aPos: new Float32Array(48),
                aRot: new Float32Array(32),
                aOffset: new Float32Array(16)
            };
            var useSprite = this.useSprite;
            if (useSprite) {
                pointData.aSprite = new Float32Array(12);
            }
            var tempPos = new Vector3();
            var tempQuat = new Quaternion();
            var scale = new Vector3(1, 1, 1);
            point.transform.assignWorldTRS(tempPos, tempQuat, scale);
            var tempEuler = Transform.getRotation(tempQuat, new Euler());
            var position = tempPos.toArray();
            var rotation = tempEuler.toArray();
            var offsets = this.textureOffsets;
            var off = [
                0,
                0,
                point.delay,
                point.lifetime
            ];
            var wholeUV = [
                0,
                0,
                1,
                1
            ];
            var vel = point.vel;
            var color = point.color;
            var sizeOffsets = [
                -.5,
                .5,
                -.5,
                -.5,
                .5,
                .5,
                .5,
                -.5
            ];
            var seed = Math.random();
            var sprite;
            if (useSprite) {
                sprite = point.sprite;
            }
            for(var j = 0; j < 4; j++){
                var offset = j * 2;
                var j3 = j * 3;
                var j4 = j * 4;
                var j12 = j * 12;
                var j8 = j * 8;
                pointData.aPos.set(position, j12);
                vel.fill(pointData.aPos, j12 + 3);
                pointData.aRot.set(rotation, j8);
                pointData.aRot[j8 + 3] = seed;
                pointData.aRot.set(color, j8 + 4);
                if (useSprite) {
                    // @ts-expect-error
                    pointData.aSprite.set(sprite, j3);
                }
                var uv = point.uv || wholeUV;
                if (uv) {
                    var uvy = useSprite ? 1 - offsets[offset + 1] : offsets[offset + 1];
                    off[0] = uv[0] + offsets[offset] * uv[2];
                    off[1] = uv[1] + uvy * uv[3];
                }
                pointData.aOffset.set(off, j4);
                var ji = j + j;
                var sx = (sizeOffsets[ji] - this.anchor.x) * scale.x;
                var sy = (sizeOffsets[ji + 1] - this.anchor.y) * scale.y;
                for(var k = 0; k < 3; k++){
                    pointData.aPos[j12 + 6 + k] = point.dirX.getElement(k) * sx;
                    pointData.aPos[j12 + 9 + k] = point.dirY.getElement(k) * sy;
                }
            }
            var indexData = new Uint16Array([
                0,
                1,
                2,
                2,
                1,
                3
            ].map(function(x) {
                return x + index * 4;
            }));
            if (increaseBuffer) {
                var baseIndexData = geometry.getIndexData();
                var idx = enlargeBuffer(baseIndexData, particleCount * 6, maxCount * 6, inc);
                idx.set(indexData, index * 6);
                geometry.setIndexData(idx);
                this.maxParticleBufferCount = idx.length / 6;
            } else {
                geometry.setIndexSubData(index * 6, indexData);
            }
            Object.keys(pointData).forEach(function(name) {
                var data = pointData[name];
                var attrSize = geometry.getAttributeStride(name) / Float32Array.BYTES_PER_ELEMENT;
                if (increaseBuffer) {
                    var baseData = geometry.getAttributeData(name);
                    assertExist(baseData);
                    var geoData = enlargeBuffer(baseData, vertexCount * attrSize, maxCount * 4 * attrSize, inc);
                    geoData.set(data, data.length * index);
                    geometry.setAttributeData(name, geoData);
                } else {
                    geometry.setAttributeSubData(name, data.length * index, data);
                }
            });
            this.particleCount = Math.max(particleCount, this.particleCount);
            geometry.setDrawCount(this.particleCount * 6);
        }
    };
    return ParticleMesh;
}();
var gl2UniformSlots = [
    10,
    32,
    64,
    160
];
function getSlot(count) {
    for(var w = 0; w < gl2UniformSlots.length; w++){
        var slot = gl2UniformSlots[w];
        if (slot > count) {
            return slot;
        }
    }
    return count || gl2UniformSlots[0];
}
function generateGeometryProps(maxVertex, useSprite, name) {
    var bpe = Float32Array.BYTES_PER_ELEMENT;
    var j12 = bpe * 12;
    var attributes = {
        aPos: {
            size: 3,
            offset: 0,
            stride: j12,
            data: new Float32Array(0)
        },
        aVel: {
            size: 3,
            offset: 3 * bpe,
            stride: j12,
            dataSource: "aPos"
        },
        aDirX: {
            size: 3,
            offset: 6 * bpe,
            stride: j12,
            dataSource: "aPos"
        },
        aDirY: {
            size: 3,
            offset: 9 * bpe,
            stride: j12,
            dataSource: "aPos"
        },
        //
        aRot: {
            size: 3,
            offset: 0,
            stride: 8 * bpe,
            data: new Float32Array(0)
        },
        aSeed: {
            size: 1,
            offset: 3 * bpe,
            stride: 8 * bpe,
            dataSource: "aRot"
        },
        aColor: {
            size: 4,
            offset: 4 * bpe,
            stride: 8 * bpe,
            dataSource: "aRot"
        },
        //
        aOffset: {
            size: 4,
            stride: 4 * bpe,
            data: new Float32Array(0)
        }
    };
    if (useSprite) {
        attributes["aSprite"] = {
            size: 3,
            stride: 3 * bpe,
            data: new Float32Array(0)
        };
    }
    return {
        attributes: attributes,
        indices: {
            data: new Uint16Array(0)
        },
        name: name,
        maxVertex: maxVertex
    };
}
function getParticleMeshShader(item, gpuCapability, env) {
    if (env === void 0) env = "";
    var _props_renderer;
    var props = item.content;
    var renderMode = +(((_props_renderer = props.renderer) == null ? void 0 : _props_renderer.renderMode) || 0);
    var macros = [
        [
            "RENDER_MODE",
            renderMode
        ],
        [
            "ENV_EDITOR",
            env === PLAYER_OPTIONS_ENV_EDITOR
        ]
    ];
    var level = gpuCapability.level, detail = gpuCapability.detail;
    var vertexKeyFrameMeta = createKeyFrameMeta();
    var fragmentKeyFrameMeta = createKeyFrameMeta();
    var enableVertexTexture = detail.maxVertexUniforms > 0;
    var _props_positionOverLifetime;
    var speedOverLifetime = ((_props_positionOverLifetime = props.positionOverLifetime) != null ? _props_positionOverLifetime : {}).speedOverLifetime;
    var vertex_lookup_texture = 0;
    var shaderCacheId = 0;
    if (enableVertexTexture) {
        macros.push([
            "ENABLE_VERTEX_TEXTURE",
            true
        ]);
    }
    if (speedOverLifetime) {
        macros.push([
            "SPEED_OVER_LIFETIME",
            true
        ]);
        shaderCacheId |= 1 << 1;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, speedOverLifetime);
    }
    var sprite = props.textureSheetAnimation;
    if (sprite && sprite.animate) {
        macros.push([
            "USE_SPRITE",
            true
        ]);
        shaderCacheId |= 1 << 2;
    }
    var colorOverLifetime = props.colorOverLifetime;
    if (colorOverLifetime && colorOverLifetime.color) {
        macros.push([
            "COLOR_OVER_LIFETIME",
            true
        ]);
        shaderCacheId |= 1 << 4;
    }
    var opacity = colorOverLifetime && colorOverLifetime.opacity;
    if (opacity) {
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, opacity);
    }
    var positionOverLifetime = props.positionOverLifetime;
    var useOrbitalVel;
    [
        "x",
        "y",
        "z"
    ].forEach(function(pro, i) {
        var defL = 0;
        var linearPro = "linear" + pro.toUpperCase();
        var orbitalPro = "orbital" + pro.toUpperCase();
        if (positionOverLifetime == null ? void 0 : positionOverLifetime[linearPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[linearPro]);
            defL = 1;
            shaderCacheId |= 1 << 7 + i;
        }
        macros.push([
            "LINEAR_VEL_" + pro.toUpperCase(),
            defL
        ]);
        var defO = 0;
        if (positionOverLifetime == null ? void 0 : positionOverLifetime[orbitalPro]) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime[orbitalPro]);
            defO = 1;
            shaderCacheId |= 1 << 10 + i;
            useOrbitalVel = true;
        }
        macros.push([
            "ORB_VEL_" + pro.toUpperCase(),
            defO
        ]);
    });
    if (positionOverLifetime == null ? void 0 : positionOverLifetime.asMovement) {
        macros.push([
            "AS_LINEAR_MOVEMENT",
            true
        ]);
        shaderCacheId |= 1 << 5;
    }
    if (useOrbitalVel) {
        if (positionOverLifetime == null ? void 0 : positionOverLifetime.asRotation) {
            macros.push([
                "AS_ORBITAL_MOVEMENT",
                true
            ]);
            shaderCacheId |= 1 << 6;
        }
    }
    if (props.sizeOverLifetime) {
        var sizeOverLifetime = props.sizeOverLifetime;
        var separateAxes = sizeOverLifetime.separateAxes;
        if (separateAxes) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.x);
            macros.push([
                "SIZE_Y_BY_LIFE",
                1
            ]);
            shaderCacheId |= 1 << 14;
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.y);
        } else {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, sizeOverLifetime.size);
        }
    }
    if (props.rotationOverLifetime) {
        var rot = props.rotationOverLifetime;
        if (rot.z) {
            getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot == null ? void 0 : rot.z);
            shaderCacheId |= 1 << 15;
            macros.push([
                "ROT_Z_LIFETIME",
                1
            ]);
        }
        if (rot.separateAxes) {
            if (rot.x) {
                getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.x);
                shaderCacheId |= 1 << 16;
                macros.push([
                    "ROT_X_LIFETIME",
                    1
                ]);
            }
            if (rot.y) {
                getKeyFrameMetaByRawValue(vertexKeyFrameMeta, rot.y);
                shaderCacheId |= 1 << 17;
                macros.push([
                    "ROT_Y_LIFETIME",
                    1
                ]);
            }
        }
        if (rot == null ? void 0 : rot.asRotation) {
            macros.push([
                "ROT_LIFETIME_AS_MOVEMENT",
                1
            ]);
            shaderCacheId |= 1 << 18;
        }
    }
    getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime == null ? void 0 : positionOverLifetime.gravityOverLifetime);
    var forceOpt = positionOverLifetime == null ? void 0 : positionOverLifetime.forceTarget;
    if (forceOpt) {
        macros.push([
            "FINAL_TARGET",
            true
        ]);
        shaderCacheId |= 1 << 19;
        getKeyFrameMetaByRawValue(vertexKeyFrameMeta, positionOverLifetime.forceCurve);
    }
    var HALF_FLOAT = detail.halfFloatTexture;
    if (HALF_FLOAT && fragmentKeyFrameMeta.max) {
        shaderCacheId |= 1 << 20;
    }
    var maxVertexUniforms = detail.maxVertexUniforms;
    var vertexCurveTexture = vertexKeyFrameMeta.max + vertexKeyFrameMeta.curves.length - 32 > maxVertexUniforms;
    if (getConfig(RENDER_PREFER_LOOKUP_TEXTURE)) {
        vertexCurveTexture = true;
    }
    if (level === 2) {
        vertexKeyFrameMeta.max = -1;
        // vertexKeyFrameMeta.index = getSlot(vertexKeyFrameMeta.index);
        if (fragmentKeyFrameMeta.index > 0) {
            fragmentKeyFrameMeta.max = -1;
        // fragmentKeyFrameMeta.index = getSlot(fragmentKeyFrameMeta.index);
        }
    }
    if (vertexCurveTexture && HALF_FLOAT && enableVertexTexture) {
        vertex_lookup_texture = 1;
    }
    var shaderCache = [
        "-p:",
        renderMode,
        shaderCacheId,
        vertexKeyFrameMeta.index,
        vertexKeyFrameMeta.max,
        fragmentKeyFrameMeta.index,
        fragmentKeyFrameMeta.max
    ].join("+");
    var shader = {
        fragment: particleFrag,
        vertex: "#define LOOKUP_TEXTURE_CURVE " + vertex_lookup_texture + "\n" + particleVert,
        shared: true,
        cacheId: shaderCache,
        macros: macros,
        name: "particle#" + item.name
    };
    macros.push([
        "VERT_CURVE_VALUE_COUNT",
        vertexKeyFrameMeta.index
    ], [
        "FRAG_CURVE_VALUE_COUNT",
        fragmentKeyFrameMeta.index
    ], [
        "VERT_MAX_KEY_FRAME_COUNT",
        vertexKeyFrameMeta.max
    ], [
        "FRAG_MAX_KEY_FRAME_COUNT",
        fragmentKeyFrameMeta.max
    ]);
    return {
        shader: shader,
        vertex: vertexKeyFrameMeta.index,
        fragment: fragmentKeyFrameMeta.index
    };
}
function modifyMaxKeyframeShader(shader, maxVertex, maxFrag) {
    var _shader_cacheId;
    var shaderIds = (_shader_cacheId = shader.cacheId) == null ? void 0 : _shader_cacheId.split("+");
    shaderIds[3] = maxVertex;
    shaderIds[5] = maxFrag;
    shader.cacheId = shaderIds.join("+");
    if (!shader.macros) {
        return;
    }
    for(var i = 0; i < shader.macros.length; i++){
        var marco = shader.macros[i];
        if (marco[0] === "VERT_CURVE_VALUE_COUNT") {
            marco[1] = maxVertex;
        } else if (marco[0] === "FRAG_CURVE_VALUE_COUNT") {
            marco[1] = maxFrag;
            break;
        }
    }
}

var ParticleLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(ParticleLoader, AbstractPlugin);
    function ParticleLoader() {
        return AbstractPlugin.apply(this, arguments);
    }
    ParticleLoader.precompile = function precompile(compositions, renderer, options) {
        var gpuCapability = renderer.engine.gpuCapability;
        var level = gpuCapability.level;
        var env = (options != null ? options : {}).env;
        var shaderLibrary = renderer.getShaderLibrary();
        var items = [];
        var shaders = [];
        var maxFragmentCount = 0;
        var maxVertexCount = 0;
        // 增加预合成中的粒子处理
        compositions.forEach(function(comp) {
            comp.items.forEach(function(item) {
                if (exports.Item.isParticle(item)) {
                    items.push(item);
                }
            });
        });
        items.forEach(function(item) {
            var _getParticleMeshShader = getParticleMeshShader(item, gpuCapability, env), shader = _getParticleMeshShader.shader, fragment = _getParticleMeshShader.fragment, vertex = _getParticleMeshShader.vertex;
            shaders.push(shader);
            maxFragmentCount = Math.max(maxFragmentCount, fragment);
            maxVertexCount = Math.max(maxVertexCount, vertex);
            // TODO 此处add是否有意义？shader变量似乎没有加到this.shaders数组。
            if (item.content.trails) {
                var shader1 = getTrailMeshShader(item.content.trails, item.content.options.maxCount, item.name, gpuCapability, env);
                shader1.glslVersion = level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1;
                shaderLibrary == null ? void 0 : shaderLibrary.addShader(shader1);
            }
        });
        shaders.forEach(function(shader) {
            if (level === 2) {
                modifyMaxKeyframeShader(shader, maxVertexCount, maxFragmentCount);
                shader.glslVersion = exports.GLSLVersion.GLSL3;
            } else {
                shader.glslVersion = exports.GLSLVersion.GLSL1;
            }
            shaderLibrary == null ? void 0 : shaderLibrary.addShader(shader);
        });
        if (level === 2) {
            items.forEach(function(item) {
                item.content.options.meshSlots = [
                    maxVertexCount,
                    maxFragmentCount
                ];
            });
        }
        return Promise.resolve();
    };
    return ParticleLoader;
}(AbstractPlugin);

var CalculateLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(CalculateLoader, AbstractPlugin);
    function CalculateLoader() {
        return AbstractPlugin.apply(this, arguments);
    }
    return CalculateLoader;
}(AbstractPlugin);

var AnimationStream = /*#__PURE__*/ function() {
    function AnimationStream(playable) {
        this.curveValues = {};
        this.playable = playable;
    }
    var _proto = AnimationStream.prototype;
    _proto.setCurveValue = function setCurveValue(componentType, propertyName, value) {
        if (!this.findCurveValue(componentType, propertyName)) {
            this.curveValues[componentType + propertyName] = {
                componentType: componentType,
                propertyName: propertyName,
                value: value
            };
        } else {
            this.curveValues[componentType + propertyName].value = value;
        }
        return this.curveValues[componentType + propertyName];
    };
    _proto.findCurveValue = function findCurveValue(componentType, propertyName) {
        return this.curveValues[componentType + propertyName];
    };
    _proto.getInputStream = function getInputStream(index) {
        var inputPlayable = this.playable.getInput(index);
        if (_instanceof1(inputPlayable, AnimationPlayable)) {
            return inputPlayable.animationStream;
        }
    };
    return AnimationStream;
}();

var AnimationPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(AnimationPlayable, Playable);
    function AnimationPlayable(graph) {
        var _this;
        _this = Playable.call(this, graph) || this;
        _this.animationStream = new AnimationStream(_assert_this_initialized(_this));
        return _this;
    }
    return AnimationPlayable;
}(Playable);

var tempRot = new Euler();
var tempSize = new Vector3(1, 1, 1);
var tempPos = new Vector3();
/**
 * @since 2.0.0
 * @internal
 */ var TransformAnimationPlayable = /*#__PURE__*/ function(AnimationPlayable) {
    _inherits(TransformAnimationPlayable, AnimationPlayable);
    function TransformAnimationPlayable() {
        return AnimationPlayable.apply(this, arguments);
    }
    var _proto = TransformAnimationPlayable.prototype;
    _proto.start = function start() {
        var boundItem = this.binding;
        var scale = boundItem.transform.scale;
        this.originalTransform = {
            position: boundItem.transform.position.clone(),
            rotation: boundItem.transform.getRotation().clone(),
            // TODO 编辑器 scale 没有z轴控制
            scale: new Vector3(scale.x, scale.y, scale.x)
        };
        var positionOverLifetime = this.data.positionOverLifetime;
        var rotationOverLifetime = this.data.rotationOverLifetime;
        var sizeOverLifetime = this.data.sizeOverLifetime;
        // TODO: 没有 K 帧数据的不需要传 positionOverLifetime 空对象
        if (positionOverLifetime && Object.keys(positionOverLifetime).length !== 0) {
            this.positionOverLifetime = positionOverLifetime;
            if (positionOverLifetime.path) {
                this.originalTransform.path = createValueGetter(positionOverLifetime.path);
            }
            var linearVelEnable = positionOverLifetime.linearX || positionOverLifetime.linearY || positionOverLifetime.linearZ;
            if (linearVelEnable) {
                this.linearVelOverLifetime = {
                    x: positionOverLifetime.linearX && createValueGetter(positionOverLifetime.linearX),
                    y: positionOverLifetime.linearY && createValueGetter(positionOverLifetime.linearY),
                    z: positionOverLifetime.linearZ && createValueGetter(positionOverLifetime.linearZ),
                    asMovement: positionOverLifetime.asMovement,
                    enabled: !!linearVelEnable
                };
            }
            var orbitalVelEnable = positionOverLifetime.orbitalX || positionOverLifetime.orbitalY || positionOverLifetime.orbitalZ;
            if (orbitalVelEnable) {
                this.orbitalVelOverLifetime = {
                    x: positionOverLifetime.orbitalX && createValueGetter(positionOverLifetime.orbitalX),
                    y: positionOverLifetime.orbitalY && createValueGetter(positionOverLifetime.orbitalY),
                    z: positionOverLifetime.orbitalZ && createValueGetter(positionOverLifetime.orbitalZ),
                    center: ensureVec3(positionOverLifetime.orbCenter),
                    asRotation: positionOverLifetime.asRotation,
                    enabled: !!orbitalVelEnable
                };
            }
            this.speedOverLifetime = positionOverLifetime.speedOverLifetime && createValueGetter(positionOverLifetime.speedOverLifetime);
        }
        if (sizeOverLifetime) {
            if (sizeOverLifetime.separateAxes) {
                this.sizeSeparateAxes = true;
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.x || 1);
                this.sizeYOverLifetime = createValueGetter(sizeOverLifetime.y || 1);
                this.sizeZOverLifetime = createValueGetter(sizeOverLifetime.z || 1);
            } else {
                this.sizeXOverLifetime = createValueGetter(sizeOverLifetime.size || 1);
            }
        }
        if (rotationOverLifetime) {
            this.rotationOverLifetime = {
                asRotation: rotationOverLifetime.asRotation,
                separateAxes: rotationOverLifetime.separateAxes,
                z: createValueGetter(rotationOverLifetime.z || 0)
            };
            if (rotationOverLifetime.separateAxes) {
                var rotLt = this.rotationOverLifetime;
                rotLt.x = createValueGetter(rotationOverLifetime.x || 0);
                rotLt.y = createValueGetter(rotationOverLifetime.y || 0);
            }
        }
        this.gravity = Vector3.fromArray((positionOverLifetime == null ? void 0 : positionOverLifetime.gravity) || []);
        var _positionOverLifetime_gravityOverLifetime;
        this.gravityModifier = createValueGetter((_positionOverLifetime_gravityOverLifetime = positionOverLifetime == null ? void 0 : positionOverLifetime.gravityOverLifetime) != null ? _positionOverLifetime_gravityOverLifetime : 0);
        this.direction = (positionOverLifetime == null ? void 0 : positionOverLifetime.direction) ? Vector3.fromArray(positionOverLifetime.direction).normalize() : new Vector3();
        this.startSpeed = (positionOverLifetime == null ? void 0 : positionOverLifetime.startSpeed) || 0;
        this.velocity = this.direction.clone();
        this.velocity.multiply(this.startSpeed);
    };
    _proto.processFrame = function processFrame(context) {
        if (!this.binding) {
            var boundObject = context.output.getUserData();
            if (_instanceof1(boundObject, exports.VFXItem)) {
                this.binding = boundObject;
                this.start();
            }
        }
        if (this.binding && this.binding.composition) {
            this.sampleAnimation();
        }
    };
    /**
   * 应用时间轴K帧数据到对象
   */ _proto.sampleAnimation = function sampleAnimation() {
        var _this = this;
        var boundItem = this.binding;
        var duration = boundItem.duration;
        var life = this.time / duration;
        life = life < 0 ? 0 : life > 1 ? 1 : life;
        if (this.sizeXOverLifetime) {
            tempSize.x = this.sizeXOverLifetime.getValue(life);
            if (this.sizeSeparateAxes) {
                tempSize.y = this.sizeYOverLifetime.getValue(life);
                tempSize.z = this.sizeZOverLifetime.getValue(life);
            } else {
                tempSize.z = tempSize.y = tempSize.x;
            }
            var startSize = this.originalTransform.scale;
            boundItem.transform.setScale(tempSize.x * startSize.x, tempSize.y * startSize.y, tempSize.z * startSize.z);
        // this.animationStream.setCurveValue('transform', 'scale.x', tempSize.x * startSize.x);
        // this.animationStream.setCurveValue('transform', 'scale.y', tempSize.y * startSize.y);
        // this.animationStream.setCurveValue('transform', 'scale.z', tempSize.z * startSize.z);
        }
        if (this.rotationOverLifetime) {
            var func = function(v) {
                return _this.rotationOverLifetime.asRotation ? v.getValue(life) : v.getIntegrateValue(0, life, duration);
            };
            var incZ = func(this.rotationOverLifetime.z);
            var separateAxes = this.rotationOverLifetime.separateAxes;
            tempRot.x = separateAxes ? func(this.rotationOverLifetime.x) : 0;
            tempRot.y = separateAxes ? func(this.rotationOverLifetime.y) : 0;
            tempRot.z = incZ;
            var rot = tempRot.addEulers(this.originalTransform.rotation, tempRot);
            boundItem.transform.setRotation(rot.x, rot.y, rot.z);
        // this.animationStream.setCurveValue('transform', 'rotation.x', rot.x);
        // this.animationStream.setCurveValue('transform', 'rotation.y', rot.y);
        // this.animationStream.setCurveValue('transform', 'rotation.z', rot.z);
        }
        if (this.positionOverLifetime) {
            var pos = tempPos;
            calculateTranslation(pos, this, this.gravity, this.time, duration, this.originalTransform.position, this.velocity);
            if (this.originalTransform.path) {
                pos.add(this.originalTransform.path.getValue(life));
            }
            boundItem.transform.setPosition(pos.x, pos.y, pos.z);
        // this.animationStream.setCurveValue('transform', 'position.x', pos.x);
        // this.animationStream.setCurveValue('transform', 'position.y', pos.y);
        // this.animationStream.setCurveValue('transform', 'position.z', pos.z);
        }
    };
    return TransformAnimationPlayable;
}(AnimationPlayable);
exports.TransformPlayableAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(TransformPlayableAsset, PlayableAsset);
    function TransformPlayableAsset() {
        return PlayableAsset.apply(this, arguments);
    }
    var _proto = TransformPlayableAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        var transformAnimationPlayable = new TransformAnimationPlayable(graph);
        transformAnimationPlayable.data = this.transformAnimationData;
        return transformAnimationPlayable;
    };
    _proto.fromData = function fromData(data) {
        this.transformAnimationData = data;
    };
    return TransformPlayableAsset;
}(PlayableAsset);
exports.TransformPlayableAsset = __decorate([
    effectsClass("TransformPlayableAsset")
], exports.TransformPlayableAsset);
/**
 * @since 2.0.0
 * @internal
 */ var ActivationPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(ActivationPlayable, Playable);
    function ActivationPlayable() {
        return Playable.apply(this, arguments);
    }
    var _proto = ActivationPlayable.prototype;
    _proto.processFrame = function processFrame(context) {};
    return ActivationPlayable;
}(Playable);
exports.ActivationPlayableAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(ActivationPlayableAsset, PlayableAsset);
    function ActivationPlayableAsset() {
        return PlayableAsset.apply(this, arguments);
    }
    var _proto = ActivationPlayableAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        return new ActivationPlayable(graph);
    };
    return ActivationPlayableAsset;
}(PlayableAsset);
exports.ActivationPlayableAsset = __decorate([
    effectsClass("ActivationPlayableAsset")
], exports.ActivationPlayableAsset);
exports.AnimationClip = /*#__PURE__*/ function(EffectsObject) {
    _inherits(AnimationClip, EffectsObject);
    function AnimationClip() {
        var _this;
        _this = EffectsObject.apply(this, arguments) || this;
        _this.duration = 0;
        _this.positionCurves = [];
        _this.rotationCurves = [];
        _this.scaleCurves = [];
        _this.floatCurves = [];
        return _this;
    }
    var _proto = AnimationClip.prototype;
    _proto.sampleAnimation = function sampleAnimation(vfxItem, time) {
        var duration = vfxItem.duration;
        var life = time / duration;
        life = life < 0 ? 0 : life > 1 ? 1 : life;
        for(var _iterator = _create_for_of_iterator_helper_loose(this.positionCurves), _step; !(_step = _iterator()).done;){
            var curve = _step.value;
            var value = curve.keyFrames.getValue(life);
            // @ts-expect-error
            var target = this.findTarget(vfxItem, curve.path);
            target == null ? void 0 : target.transform.setPosition(value.x, value.y, value.z);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(this.rotationCurves), _step1; !(_step1 = _iterator1()).done;){
            var curve1 = _step1.value;
            var value1 = curve1.keyFrames.getValue(life);
            // @ts-expect-error
            var target1 = this.findTarget(vfxItem, curve1.path);
            target1 == null ? void 0 : target1.transform.setQuaternion(value1.x, value1.y, value1.z, value1.w);
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(this.scaleCurves), _step2; !(_step2 = _iterator2()).done;){
            var curve2 = _step2.value;
            var value2 = curve2.keyFrames.getValue(life);
            // @ts-expect-error
            var target2 = this.findTarget(vfxItem, curve2.path);
            target2 == null ? void 0 : target2.transform.setScale(value2.x, value2.y, value2.z);
        }
    // TODO float curves 采样
    };
    _proto.fromData = function fromData(data) {
        this.positionCurves.length = 0;
        this.scaleCurves.length = 0;
        this.floatCurves.length = 0;
        for(var _iterator = _create_for_of_iterator_helper_loose(data.positionCurves), _step; !(_step = _iterator()).done;){
            var positionCurveData = _step.value;
            var curve = {
                path: positionCurveData.path,
                keyFrames: createValueGetter(positionCurveData.keyFrames)
            };
            this.duration = Math.max(this.duration, curve.keyFrames.getMaxTime());
            this.positionCurves.push(curve);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(data.rotationCurves), _step1; !(_step1 = _iterator1()).done;){
            var rotationCurveData = _step1.value;
            var curve1 = {
                path: rotationCurveData.path,
                keyFrames: createValueGetter(rotationCurveData.keyFrames)
            };
            this.duration = Math.max(this.duration, curve1.keyFrames.getMaxTime());
            this.rotationCurves.push(curve1);
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(data.scaleCurves), _step2; !(_step2 = _iterator2()).done;){
            var scaleCurvesData = _step2.value;
            var curve2 = {
                path: scaleCurvesData.path,
                keyFrames: createValueGetter(scaleCurvesData.keyFrames)
            };
            this.duration = Math.max(this.duration, curve2.keyFrames.getMaxTime());
            this.scaleCurves.push(curve2);
        }
        for(var _iterator3 = _create_for_of_iterator_helper_loose(data.floatCurves), _step3; !(_step3 = _iterator3()).done;){
            var floatCurveData = _step3.value;
            var curve3 = {
                path: floatCurveData.path,
                keyFrames: createValueGetter(floatCurveData.keyFrames),
                property: floatCurveData.property,
                className: floatCurveData.className
            };
            this.duration = Math.max(this.duration, curve3.keyFrames.getMaxTime());
            this.floatCurves.push(curve3);
        }
    };
    _proto.findTarget = function findTarget(vfxItem, path) {
        var target = vfxItem;
        for(var _iterator = _create_for_of_iterator_helper_loose(path), _step; !(_step = _iterator()).done;){
            var name = _step.value;
            var findTag = false;
            for(var _iterator1 = _create_for_of_iterator_helper_loose(target.children), _step1; !(_step1 = _iterator1()).done;){
                var child = _step1.value;
                if (child.name === name) {
                    target = child;
                    findTag = true;
                    break;
                }
            }
            if (!findTag) {
                return;
            }
        }
        return target;
    };
    return AnimationClip;
}(EffectsObject);
exports.AnimationClip = __decorate([
    effectsClass(DataType.AnimationClip)
], exports.AnimationClip);
var AnimationClipPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(AnimationClipPlayable, Playable);
    function AnimationClipPlayable() {
        return Playable.apply(this, arguments);
    }
    var _proto = AnimationClipPlayable.prototype;
    _proto.processFrame = function processFrame(context) {
        var boundObject = context.output.getUserData();
        if (!_instanceof1(boundObject, exports.VFXItem)) {
            return;
        }
        if (boundObject.composition) {
            this.clip.sampleAnimation(boundObject, this.time);
        }
    };
    return AnimationClipPlayable;
}(Playable);

/**
 * @since 2.0.0
 * @internal
 */ var TimelineClip = /*#__PURE__*/ function() {
    function TimelineClip() {
        this.start = 0;
        this.duration = 0;
    }
    var _proto = TimelineClip.prototype;
    _proto.toLocalTime = function toLocalTime(time) {
        var localTime = time - this.start;
        var duration = this.duration;
        if (localTime - duration > 0.001) {
            if (this.endBehavior === EndBehavior.restart) {
                localTime = localTime % duration;
            } else if (this.endBehavior === EndBehavior.freeze) {
                localTime = Math.min(duration, localTime);
            }
        }
        return localTime;
    };
    return TimelineClip;
}();
exports.TrackAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(TrackAsset, PlayableAsset);
    function TrackAsset() {
        var _this;
        _this = PlayableAsset.apply(this, arguments) || this;
        _this.trackType = 0;
        _this.clipSeed = 0;
        _this.clips = [];
        _this.children = [];
        return _this;
    }
    var _proto = TrackAsset.prototype;
    /**
   * 重写该方法以获取自定义对象绑定
   */ _proto.resolveBinding = function resolveBinding(parentBinding) {
        return parentBinding;
    };
    /**
   * 重写该方法以创建自定义混合器
   */ _proto.createTrackMixer = function createTrackMixer(graph) {
        return new Playable(graph);
    };
    _proto.createOutput = function createOutput() {
        var output = new PlayableOutput();
        return output;
    };
    _proto.createPlayableGraph = function createPlayableGraph(graph, runtimeClips) {
        var mixerPlayable = this.createMixerPlayableGraph(graph, runtimeClips);
        return mixerPlayable;
    };
    _proto.createMixerPlayableGraph = function createMixerPlayableGraph(graph, runtimeClips) {
        var clips = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(this.clips), _step; !(_step = _iterator()).done;){
            var clip = _step.value;
            clips.push(clip);
        }
        var mixerPlayable = this.compileClips(graph, clips, runtimeClips);
        return mixerPlayable;
    };
    _proto.compileClips = function compileClips(graph, timelineClips, runtimeClips) {
        var mixer = this.createTrackMixer(graph);
        for(var _iterator = _create_for_of_iterator_helper_loose(timelineClips), _step; !(_step = _iterator()).done;){
            var timelineClip = _step.value;
            var clipPlayable = this.createClipPlayable(graph, timelineClip);
            var clip = new RuntimeClip(timelineClip, clipPlayable, mixer, this);
            runtimeClips.push(clip);
            mixer.addInput(clipPlayable, 0);
            mixer.setInputWeight(clipPlayable, 0.0);
        }
        return mixer;
    };
    _proto.createPlayable = function createPlayable(graph) {
        return new Playable(graph);
    };
    _proto.getChildTracks = function getChildTracks() {
        return this.children;
    };
    _proto.addChild = function addChild(child) {
        this.children.push(child);
    };
    _proto.createClip = function createClip(classConstructor, name) {
        var newClip = new TimelineClip();
        newClip.asset = new classConstructor(this.engine);
        newClip.name = name ? name : "TimelineClip" + newClip.id;
        this.addClip(newClip);
        return newClip;
    };
    _proto.getClips = function getClips() {
        return this.clips;
    };
    _proto.findClip = function findClip(name) {
        for(var _iterator = _create_for_of_iterator_helper_loose(this.clips), _step; !(_step = _iterator()).done;){
            var clip = _step.value;
            if (clip.name === name) {
                return clip;
            }
        }
    };
    _proto.addClip = function addClip(clip) {
        clip.id = (this.clipSeed++).toString();
        this.clips.push(clip);
    };
    _proto.createClipPlayable = function createClipPlayable(graph, clip) {
        return clip.asset.createPlayable(graph);
    };
    return TrackAsset;
}(PlayableAsset);
__decorate([
    serialize(TimelineClip)
], exports.TrackAsset.prototype, "clips", void 0);
__decorate([
    serialize()
], exports.TrackAsset.prototype, "children", void 0);
exports.TrackAsset = __decorate([
    effectsClass("TrackAsset")
], exports.TrackAsset);
exports.TrackType = void 0;
(function(TrackType) {
    TrackType[TrackType["MasterTrack"] = 0] = "MasterTrack";
    TrackType[TrackType["ObjectTrack"] = 1] = "ObjectTrack";
})(exports.TrackType || (exports.TrackType = {}));
var RuntimeClip = /*#__PURE__*/ function() {
    function RuntimeClip(clip, clipPlayable, parentMixer, track) {
        this.clip = clip;
        this.playable = clipPlayable;
        this.parentMixer = parentMixer;
        this.track = track;
        if (_instanceof1(this.track.binding, exports.VFXItem)) {
            this.particleSystem = this.track.binding.getComponent(exports.ParticleSystem);
        }
    }
    var _proto = RuntimeClip.prototype;
    _proto.evaluateAt = function evaluateAt(localTime) {
        var clip = this.clip;
        var weight = 1.0;
        var ended = false;
        var started = false;
        var boundObject = this.track.binding;
        if (localTime > clip.start + clip.duration + 0.001 && clip.endBehavior === EndBehavior.destroy) {
            if (_instanceof1(boundObject, exports.VFXItem) && exports.VFXItem.isParticle(boundObject) && this.particleSystem && !this.particleSystem.destroyed) {
                weight = 1.0;
            } else {
                weight = 0.0;
                ended = true;
            }
        } else if (localTime - this.clip.start >= 0) {
            weight = 1.0;
            started = true;
        } else if (localTime < clip.start) {
            weight = 0.0;
        }
        if (started && this.playable.getPlayState() !== PlayState.Playing) {
            this.playable.play();
        }
        this.parentMixer.setInputWeight(this.playable, weight);
        // 判断动画是否结束
        if (ended) {
            if (_instanceof1(boundObject, exports.VFXItem) && !boundObject.ended) {
                boundObject.ended = true;
                boundObject.onEnd();
                if (!boundObject.compositionReusable && !boundObject.reusable) {
                    boundObject.dispose();
                    this.playable.dispose();
                }
            }
            if (this.playable.getPlayState() === PlayState.Playing) {
                this.playable.pause();
            }
        }
        var clipTime = clip.toLocalTime(localTime);
        this.playable.setTime(clipTime);
    };
    _create_class(RuntimeClip, [
        {
            key: "enable",
            set: function set(value) {
                if (value) {
                    this.playable.play();
                } else {
                    this.parentMixer.setInputWeight(this.playable, 0);
                    this.playable.pause();
                }
            }
        }
    ]);
    return RuntimeClip;
}();

exports.ObjectBindingTrack = /*#__PURE__*/ function(TrackAsset1) {
    _inherits(ObjectBindingTrack, TrackAsset1);
    function ObjectBindingTrack() {
        return TrackAsset1.apply(this, arguments);
    }
    var _proto = ObjectBindingTrack.prototype;
    _proto.create = function create(timelineAsset) {
        var boundItem = this.binding;
        // 添加粒子动画 clip
        if (boundItem.getComponent(exports.ParticleSystem)) {
            var particleTrack = timelineAsset.createTrack(exports.TrackAsset, this, "ParticleTrack");
            particleTrack.binding = this.binding;
            var particleClip = particleTrack.createClip(ParticleBehaviourPlayableAsset);
            particleClip.start = boundItem.start;
            particleClip.duration = boundItem.duration;
            particleClip.endBehavior = boundItem.endBehavior;
        }
    };
    return ObjectBindingTrack;
}(exports.TrackAsset);
exports.ObjectBindingTrack = __decorate([
    effectsClass("ObjectBindingTrack")
], exports.ObjectBindingTrack);

exports.TransformTrack = /*#__PURE__*/ function(TrackAsset) {
    _inherits(TransformTrack, TrackAsset);
    function TransformTrack() {
        return TrackAsset.apply(this, arguments);
    }
    return TransformTrack;
}(exports.TrackAsset);
exports.TransformTrack = __decorate([
    effectsClass("TransformTrack")
], exports.TransformTrack);

var ActivationMixerPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(ActivationMixerPlayable, Playable);
    function ActivationMixerPlayable() {
        return Playable.apply(this, arguments);
    }
    var _proto = ActivationMixerPlayable.prototype;
    _proto.processFrame = function processFrame(context) {
        var boundObject = context.output.getUserData();
        if (!_instanceof1(boundObject, exports.VFXItem)) {
            return;
        }
        var boundItem = boundObject;
        var hasInput = false;
        for(var i = 0; i < this.getInputCount(); i++){
            if (this.getInputWeight(i) > 0) {
                hasInput = true;
                break;
            }
        }
        if (hasInput) {
            boundItem.transform.setValid(true);
            this.showRendererComponents(boundItem);
        } else {
            boundItem.transform.setValid(false);
            this.hideRendererComponents(boundItem);
        }
    };
    _proto.hideRendererComponents = function hideRendererComponents(item) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.rendererComponents), _step; !(_step = _iterator()).done;){
            var rendererComponent = _step.value;
            if (rendererComponent.enabled) {
                rendererComponent.enabled = false;
            }
        }
    };
    _proto.showRendererComponents = function showRendererComponents(item) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.rendererComponents), _step; !(_step = _iterator()).done;){
            var rendererComponent = _step.value;
            if (!rendererComponent.enabled) {
                rendererComponent.enabled = true;
            }
        }
    };
    return ActivationMixerPlayable;
}(Playable);

exports.ActivationTrack = /*#__PURE__*/ function(TrackAsset) {
    _inherits(ActivationTrack, TrackAsset);
    function ActivationTrack() {
        return TrackAsset.apply(this, arguments);
    }
    var _proto = ActivationTrack.prototype;
    _proto.createTrackMixer = function createTrackMixer(graph) {
        return new ActivationMixerPlayable(graph);
    };
    return ActivationTrack;
}(exports.TrackAsset);
exports.ActivationTrack = __decorate([
    effectsClass("ActivationTrack")
], exports.ActivationTrack);

exports.SpriteColorTrack = /*#__PURE__*/ function(TrackAsset) {
    _inherits(SpriteColorTrack, TrackAsset);
    function SpriteColorTrack() {
        return TrackAsset.apply(this, arguments);
    }
    return SpriteColorTrack;
}(exports.TrackAsset);
exports.SpriteColorTrack = __decorate([
    effectsClass("SpriteColorTrack")
], exports.SpriteColorTrack);

exports.TimelineAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(TimelineAsset, PlayableAsset);
    function TimelineAsset() {
        var _this;
        _this = PlayableAsset.apply(this, arguments) || this;
        _this.tracks = [];
        return _this;
    }
    var _proto = TimelineAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        var timelinePlayable = new TimelinePlayable(graph);
        timelinePlayable.setTraversalMode(PlayableTraversalMode.Passthrough);
        for(var _iterator = _create_for_of_iterator_helper_loose(this.tracks), _step; !(_step = _iterator()).done;){
            var track = _step.value;
            if (_instanceof1(track, exports.ObjectBindingTrack)) {
                track.create(this);
            }
        }
        timelinePlayable.compileTracks(graph, this.tracks);
        return timelinePlayable;
    };
    _proto.createTrack = function createTrack(classConstructor, parent, name) {
        var newTrack = new classConstructor(this.engine);
        newTrack.name = name ? name : classConstructor.name;
        parent.addChild(newTrack);
        return newTrack;
    };
    _proto.fromData = function fromData(data) {};
    return TimelineAsset;
}(PlayableAsset);
__decorate([
    serialize()
], exports.TimelineAsset.prototype, "tracks", void 0);
exports.TimelineAsset = __decorate([
    effectsClass("TimelineAsset")
], exports.TimelineAsset);
var TimelinePlayable = /*#__PURE__*/ function(Playable) {
    _inherits(TimelinePlayable, Playable);
    function TimelinePlayable() {
        var _this;
        _this = Playable.apply(this, arguments) || this;
        _this.clips = [];
        return _this;
    }
    var _proto = TimelinePlayable.prototype;
    _proto.prepareFrame = function prepareFrame(context) {
        this.evaluate();
    };
    _proto.evaluate = function evaluate() {
        var time = this.getTime();
        // TODO search active clips
        for(var _iterator = _create_for_of_iterator_helper_loose(this.clips), _step; !(_step = _iterator()).done;){
            var clip = _step.value;
            clip.evaluateAt(time);
        }
    };
    _proto.compileTracks = function compileTracks(graph, tracks) {
        this.sortTracks(tracks);
        var outputTrack = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(tracks), _step; !(_step = _iterator()).done;){
            var masterTrack = _step.value;
            outputTrack.push(masterTrack);
            this.addSubTracksRecursive(masterTrack, outputTrack);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(outputTrack), _step1; !(_step1 = _iterator1()).done;){
            var track = _step1.value;
            var trackMixPlayable = track.createPlayableGraph(graph, this.clips);
            this.addInput(trackMixPlayable, 0);
            var trackOutput = track.createOutput();
            trackOutput.setUserData(track.binding);
            graph.addOutput(trackOutput);
            trackOutput.setSourcePlayeble(this, this.getInputCount() - 1);
        }
    };
    _proto.sortTracks = function sortTracks(tracks) {
        var sortedTracks = [];
        for(var i = 0; i < tracks.length; i++){
            sortedTracks.push(new TrackSortWrapper(tracks[i], i));
        }
        sortedTracks.sort(compareTracks);
        tracks.length = 0;
        for(var _iterator = _create_for_of_iterator_helper_loose(sortedTracks), _step; !(_step = _iterator()).done;){
            var trackWrapper = _step.value;
            tracks.push(trackWrapper.track);
        }
    };
    _proto.addSubTracksRecursive = function addSubTracksRecursive(track, allTracks) {
        for(var _iterator = _create_for_of_iterator_helper_loose(track.getChildTracks()), _step; !(_step = _iterator()).done;){
            var subTrack = _step.value;
            allTracks.push(subTrack);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(track.getChildTracks()), _step1; !(_step1 = _iterator1()).done;){
            var subTrack1 = _step1.value;
            this.addSubTracksRecursive(subTrack1, allTracks);
        }
    };
    return TimelinePlayable;
}(Playable);
var TrackSortWrapper = function TrackSortWrapper(track, originalIndex) {
    this.track = track;
    this.originalIndex = originalIndex;
};
function isAncestor(ancestorCandidate, descendantCandidate) {
    var current = descendantCandidate.parent;
    while(current){
        if (current === ancestorCandidate) {
            return true;
        }
        current = current.parent;
    }
    return false;
}
function compareTracks(a, b) {
    var bindingA = a.track.binding;
    var bindingB = b.track.binding;
    if (!_instanceof1(bindingA, exports.VFXItem) || !_instanceof1(bindingB, exports.VFXItem)) {
        return a.originalIndex - b.originalIndex;
    }
    if (isAncestor(bindingA, bindingB)) {
        return -1;
    } else if (isAncestor(bindingB, bindingA)) {
        return 1;
    } else {
        return a.originalIndex - b.originalIndex; // 非父子关系的元素保持原始顺序
    }
}

/**
 * @since 2.0.0
 */ var CompositionComponent = /*#__PURE__*/ function(Behaviour) {
    _inherits(CompositionComponent, Behaviour);
    function CompositionComponent() {
        var _this;
        _this = Behaviour.apply(this, arguments) || this;
        _this.time = 0;
        _this.startTime = 0;
        _this.items = [] // 场景的所有元素
        ;
        _this.reusable = false;
        _this.sceneBindings = [];
        _this.graph = new PlayableGraph();
        return _this;
    }
    var _proto = CompositionComponent.prototype;
    _proto.start = function start() {
        var _this_item_props = this.item.props, _this_item_props_startTime = _this_item_props.startTime, startTime = _this_item_props_startTime === void 0 ? 0 : _this_item_props_startTime;
        this.startTime = startTime;
        this.resolveBindings();
        this.timelinePlayable = this.timelineAsset.createPlayable(this.graph);
        // 重播不销毁元素
        if (this.item.endBehavior !== EndBehavior.destroy) {
            this.setReusable(true);
        }
    };
    _proto.setReusable = function setReusable(value) {
        for(var _iterator = _create_for_of_iterator_helper_loose(this.timelineAsset.tracks), _step; !(_step = _iterator()).done;){
            var track = _step.value;
            var binding = track.binding;
            if (_instanceof1(binding, exports.VFXItem)) {
                if (_instanceof1(track, exports.ObjectBindingTrack)) {
                    binding.reusable = value;
                }
                var subCompositionComponent = binding.getComponent(CompositionComponent);
                if (subCompositionComponent) {
                    subCompositionComponent.setReusable(value);
                }
            }
        }
    };
    _proto.getReusable = function getReusable() {
        return this.reusable;
    };
    _proto.update = function update(dt) {
        var time = this.time;
        this.timelinePlayable.setTime(time);
        this.graph.evaluate(dt);
    };
    _proto.createContent = function createContent() {
        var sceneBindings = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(this.data.sceneBindings), _step; !(_step = _iterator()).done;){
            var sceneBindingData = _step.value;
            sceneBindings.push({
                key: this.engine.assetLoader.loadGUID(sceneBindingData.key.id),
                value: this.engine.assetLoader.loadGUID(sceneBindingData.value.id)
            });
        }
        this.sceneBindings = sceneBindings;
        var timelineAsset = this.data.timelineAsset ? this.engine.assetLoader.loadGUID(this.data.timelineAsset.id) : new exports.TimelineAsset(this.engine);
        this.timelineAsset = timelineAsset;
        var items = this.items;
        this.items.length = 0;
        if (this.item.composition) {
            var assetLoader = this.item.engine.assetLoader;
            var itemProps = this.data.items ? this.data.items : [];
            for(var i = 0; i < itemProps.length; i++){
                var item = void 0;
                var itemData = itemProps[i];
                // 设置预合成作为元素时的时长、结束行为和渲染延时
                if (exports.Item.isComposition(itemData)) {
                    var refId = itemData.content.options.refId;
                    var props = this.item.composition.refCompositionProps.get(refId);
                    if (!props) {
                        throw new Error("Referenced precomposition with Id: " + refId + " does not exist.");
                    }
                    // endBehavior 类型需优化
                    props.content = itemData.content;
                    item = assetLoader.loadGUID(itemData.id);
                    item.composition = this.item.composition;
                    var compositionComponent = item.addComponent(CompositionComponent);
                    compositionComponent.data = props;
                    compositionComponent.refId = refId;
                    item.transform.parentTransform = this.transform;
                    this.item.composition.refContent.push(item);
                    if (item.endBehavior === EndBehavior.restart) {
                        this.item.composition.autoRefTex = false;
                    }
                    compositionComponent.createContent();
                    for(var _iterator1 = _create_for_of_iterator_helper_loose(compositionComponent.items), _step1; !(_step1 = _iterator1()).done;){
                        var vfxItem = _step1.value;
                        vfxItem.setInstanceId(generateGUID());
                        for(var _iterator2 = _create_for_of_iterator_helper_loose(vfxItem.components), _step2; !(_step2 = _iterator2()).done;){
                            var component = _step2.value;
                            component.setInstanceId(generateGUID());
                        }
                    }
                } else {
                    item = assetLoader.loadGUID(itemData.id);
                    item.composition = this.item.composition;
                }
                item.parent = this.item;
                // 相机不跟随合成移动
                item.transform.parentTransform = itemData.type === ItemType.camera ? new Transform() : this.transform;
                if (exports.VFXItem.isExtraCamera(item)) {
                    this.item.composition.extraCamera = item;
                }
                items.push(item);
            }
        }
    };
    _proto.onDestroy = function onDestroy() {
        if (this.item.composition) {
            if (this.items) {
                this.items.forEach(function(item) {
                    return item.dispose();
                });
                this.items.length = 0;
            }
        }
    };
    _proto.hitTest = function hitTest(ray, x, y, regions, force, options) {
        var _this, _loop = function(i) {
            var item = _this.items[i];
            if (item.getVisible() && item.transform.getValid() && !item.ended && !exports.VFXItem.isComposition(item) && !skip(item)) {
                var hitParams = item.getHitTestParams(force);
                if (hitParams) {
                    var success = false;
                    var intersectPoint = new Vector3();
                    if (hitParams.type === exports.HitTestType.triangle) {
                        var triangles = hitParams.triangles, backfaceCulling = hitParams.backfaceCulling;
                        for(var j = 0; j < triangles.length; j++){
                            var triangle = triangles[j];
                            if (ray.intersectTriangle(triangle, intersectPoint, backfaceCulling)) {
                                success = true;
                                hitPositions.push(intersectPoint);
                                break;
                            }
                        }
                    } else if (hitParams.type === exports.HitTestType.box) {
                        var center = hitParams.center, size = hitParams.size;
                        var boxMin = center.clone().addScaledVector(size, 0.5);
                        var boxMax = center.clone().addScaledVector(size, -0.5);
                        if (ray.intersectBox({
                            min: boxMin,
                            max: boxMax
                        }, intersectPoint)) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    } else if (hitParams.type === exports.HitTestType.sphere) {
                        var center1 = hitParams.center, radius = hitParams.radius;
                        if (ray.intersectSphere({
                            center: center1,
                            radius: radius
                        }, intersectPoint)) {
                            success = true;
                            hitPositions.push(intersectPoint);
                        }
                    } else if (hitParams.type === exports.HitTestType.custom) {
                        var tempPosition = hitParams.collect(ray, new Vector2(x, y));
                        if (tempPosition && tempPosition.length > 0) {
                            tempPosition.forEach(function(pos) {
                                hitPositions.push(pos);
                            });
                            success = true;
                        }
                    }
                    if (success) {
                        var region = {
                            compContent: _this.item,
                            id: item.id,
                            name: item.name,
                            position: hitPositions[hitPositions.length - 1],
                            parentId: item.parentId,
                            hitPositions: hitPositions,
                            behavior: hitParams.behavior
                        };
                        // 触发单个元素的点击事件
                        item.emit("click", region);
                        regions.push(region);
                        if (stop(region)) {
                            return {
                                v: regions
                            };
                        }
                    }
                }
            }
        };
        var hitPositions = [];
        var stop = (options == null ? void 0 : options.stop) || noop;
        var skip = (options == null ? void 0 : options.skip) || noop;
        var maxCount = (options == null ? void 0 : options.maxCount) || this.items.length;
        for(var i = 0; i < this.items.length && regions.length < maxCount; i++){
            var _ret = (_this = this, _loop(i));
            if (_type_of(_ret) === "object") return _ret.v;
        }
        return regions;
    };
    _proto.fromData = function fromData(data) {};
    _proto.resolveBindings = function resolveBindings() {
        for(var _iterator = _create_for_of_iterator_helper_loose(this.sceneBindings), _step; !(_step = _iterator()).done;){
            var sceneBinding = _step.value;
            sceneBinding.key.binding = sceneBinding.value;
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(this.timelineAsset.tracks), _step1; !(_step1 = _iterator1()).done;){
            var masterTrack = _step1.value;
            this.resolveTrackBindingsWithRoot(masterTrack);
        }
    };
    _proto.resolveTrackBindingsWithRoot = function resolveTrackBindingsWithRoot(track) {
        for(var _iterator = _create_for_of_iterator_helper_loose(track.getChildTracks()), _step; !(_step = _iterator()).done;){
            var subTrack = _step.value;
            subTrack.binding = subTrack.resolveBinding(track.binding);
            this.resolveTrackBindingsWithRoot(subTrack);
        }
    };
    return CompositionComponent;
}(Behaviour);

exports.SubCompositionTrack = /*#__PURE__*/ function(TrackAsset) {
    _inherits(SubCompositionTrack, TrackAsset);
    function SubCompositionTrack() {
        return TrackAsset.apply(this, arguments);
    }
    var _proto = SubCompositionTrack.prototype;
    _proto.resolveBinding = function resolveBinding(parentBinding) {
        if (!_instanceof1(parentBinding, exports.VFXItem)) {
            throw new Error("SubCompositionTrack needs to be set under the VFXItem track.");
        }
        return parentBinding.getComponent(CompositionComponent);
    };
    return SubCompositionTrack;
}(exports.TrackAsset);
exports.SubCompositionTrack = __decorate([
    effectsClass("SubCompositionTrack")
], exports.SubCompositionTrack);

var SubCompositionClipPlayable = /*#__PURE__*/ function(Playable) {
    _inherits(SubCompositionClipPlayable, Playable);
    function SubCompositionClipPlayable() {
        return Playable.apply(this, arguments);
    }
    var _proto = SubCompositionClipPlayable.prototype;
    _proto.processFrame = function processFrame(context) {
        var boundObject = context.output.getUserData();
        if (_instanceof1(boundObject, CompositionComponent)) {
            boundObject.time = this.getTime();
        }
    };
    return SubCompositionClipPlayable;
}(Playable);

exports.SubCompositionPlayableAsset = /*#__PURE__*/ function(PlayableAsset) {
    _inherits(SubCompositionPlayableAsset, PlayableAsset);
    function SubCompositionPlayableAsset() {
        return PlayableAsset.apply(this, arguments);
    }
    var _proto = SubCompositionPlayableAsset.prototype;
    _proto.createPlayable = function createPlayable(graph) {
        return new SubCompositionClipPlayable(graph);
    };
    return SubCompositionPlayableAsset;
}(PlayableAsset);
exports.SubCompositionPlayableAsset = __decorate([
    effectsClass("SubCompositionPlayableAsset")
], exports.SubCompositionPlayableAsset);

function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) return call;
    return _assert_this_initialized(self);
}

var TextLayout = /*#__PURE__*/ function() {
    function TextLayout(options) {
        this.width = 0;
        this.height = 0;
        var _options_textHeight = options.textHeight, textHeight = _options_textHeight === void 0 ? 100 : _options_textHeight, _options_textWidth = options.textWidth, textWidth = _options_textWidth === void 0 ? 100 : _options_textWidth, _options_textOverflow = options.textOverflow, textOverflow = _options_textOverflow === void 0 ? TextOverflow.display : _options_textOverflow, _options_textBaseline = options.textBaseline, textBaseline = _options_textBaseline === void 0 ? TextBaseline.top : _options_textBaseline, _options_textAlign = options.textAlign, textAlign = _options_textAlign === void 0 ? TextAlignment.left : _options_textAlign, text = options.text, _options_letterSpace = options.letterSpace, letterSpace = _options_letterSpace === void 0 ? 0 : _options_letterSpace, _options_autoWidth = options.autoWidth, autoWidth = _options_autoWidth === void 0 ? false : _options_autoWidth, fontSize = options.fontSize, _options_lineHeight = options.lineHeight, lineHeight = _options_lineHeight === void 0 ? fontSize : _options_lineHeight;
        var tempWidth = fontSize + letterSpace;
        this.autoWidth = autoWidth;
        this.maxTextWidth = text.length * tempWidth;
        this.width = textWidth;
        this.height = textHeight;
        this.letterSpace = letterSpace;
        this.overFlow = textOverflow;
        this.textBaseline = textBaseline;
        this.textAlign = textAlign;
        this.lineHeight = lineHeight;
    }
    var _proto = TextLayout.prototype;
    /**
   * 获取初始的行高偏移值
   * @param style - 字体基础数据
   * @param lineCount - 渲染行数
   * @param lineHeight - 渲染时的字体行高
   * @param fontSize - 渲染时的字体大小
   * @returns - 行高偏移值
   */ _proto.getOffsetY = function getOffsetY(style, lineCount, lineHeight, fontSize) {
        var outlineWidth = style.outlineWidth, fontScale = style.fontScale;
        // /3 计算Y轴偏移量，以匹配编辑器行为
        var offsetY = (lineHeight - fontSize) / 3;
        // 计算基础偏移量
        var baseOffset = fontSize + outlineWidth * fontScale;
        var commonCalculation = lineHeight * (lineCount - 1);
        var offsetResult = 0;
        switch(this.textBaseline){
            case TextBaseline.top:
                offsetResult = baseOffset + offsetY;
                break;
            case TextBaseline.middle:
                offsetResult = (this.height * fontScale - commonCalculation + baseOffset) / 2;
                break;
            case TextBaseline.bottom:
                offsetResult = this.height * fontScale - commonCalculation - offsetY;
                break;
        }
        return offsetResult;
    };
    _proto.getOffsetX = function getOffsetX(style, maxWidth) {
        var offsetX = 0;
        switch(this.textAlign){
            case TextAlignment.left:
                offsetX = style.outlineWidth * style.fontScale;
                break;
            case TextAlignment.middle:
                offsetX = (this.width * style.fontScale - maxWidth) / 2;
                break;
            case TextAlignment.right:
                offsetX = this.width * style.fontScale - maxWidth;
                break;
        }
        return offsetX;
    };
    /**
   * 设置文本框的宽度和高度
   * @param width 文本框宽度
   * @param height 文本框高度
   */ _proto.setSize = function setSize(width, height) {
        this.width = width;
        this.height = height;
    };
    return TextLayout;
}();

var TextStyle = function TextStyle(options) {
    /**
   * 是否有下划线（暂时无效）
   */ this.isUnderline = false // ttf
    ;
    /**
   * 下划线高度（暂时无效）
   */ this.underlineHeight = 1 // ttf
    ;
    /**
   * 是否有外描边
   */ this.isOutlined = false // both // ttf & char
    ;
    /**
   * 外描边宽度
   */ this.outlineWidth = 0 // both // ttf & char
    ;
    /**
   * 是否有阴影
   */ this.hasShadow = false // ttf
    ;
    this.fontDesc = "" // both
    ;
    /**
   * 字体倍数
   */ this.fontScale = 2;
    this.fontOffset = 0;
    var _options_textColor = options.textColor, textColor = _options_textColor === void 0 ? [
        1,
        1,
        1,
        1
    ] : _options_textColor, _options_fontSize = options.fontSize, fontSize = _options_fontSize === void 0 ? 40 : _options_fontSize, outline = options.outline, shadow = options.shadow, _options_fontWeight = options.fontWeight, fontWeight = _options_fontWeight === void 0 ? "normal" : _options_fontWeight, _options_fontStyle = options.fontStyle, fontStyle = _options_fontStyle === void 0 ? "normal" : _options_fontStyle, _options_fontFamily = options.fontFamily, fontFamily = _options_fontFamily === void 0 ? "sans-serif" : _options_fontFamily;
    this.textColor = textColor;
    //@ts-expect-error
    this.textWeight = fontWeight;
    //@ts-expect-error
    this.fontStyle = fontStyle;
    this.fontFamily = fontFamily;
    this.fontSize = fontSize; // 暂时取消字号限制 Math.min(fontSize, this.maxFontSize);
    if (outline) {
        this.isOutlined = true;
        var _outline_outlineColor;
        this.outlineColor = (_outline_outlineColor = outline.outlineColor) != null ? _outline_outlineColor : [
            1,
            1,
            1,
            1
        ];
        var _outline_outlineWidth;
        this.outlineWidth = (_outline_outlineWidth = outline.outlineWidth) != null ? _outline_outlineWidth : 1;
        this.fontOffset += this.outlineWidth;
    }
    if (shadow) {
        this.hasShadow = true;
        var _shadow_shadowBlur;
        this.shadowBlur = (_shadow_shadowBlur = shadow.shadowBlur) != null ? _shadow_shadowBlur : 2;
        var _shadow_shadowColor;
        this.shadowColor = (_shadow_shadowColor = shadow.shadowColor) != null ? _shadow_shadowColor : [
            0,
            0,
            0,
            1
        ];
        var _shadow_shadowOffsetX;
        this.shadowOffsetX = (_shadow_shadowOffsetX = shadow.shadowOffsetX) != null ? _shadow_shadowOffsetX : 0;
        var _shadow_shadowOffsetY;
        this.shadowOffsetY = (_shadow_shadowOffsetY = shadow.shadowOffsetY) != null ? _shadow_shadowOffsetY : 0;
    }
    if (this.fontStyle !== FontStyle.normal) {
        // 0.0174532925 = 3.141592653 / 180
        this.fontOffset += this.fontSize * Math.tan(12 * 0.0174532925);
    }
};

var CanvasPool = /*#__PURE__*/ function() {
    function CanvasPool() {
        this.elements = [];
    }
    var _proto = CanvasPool.prototype;
    _proto.dispose = function dispose() {
        this.elements.forEach(function(e) {
            return e.remove();
        });
        // clearing the array
        this.elements.length = 0;
    };
    _proto.getCanvas = function getCanvas() {
        if (this.elements.length !== 0) {
            var canvas = this.elements.shift();
            assertExist(canvas);
            return canvas;
        }
        if (getConfig(TEMPLATE_USE_OFFSCREEN_CANVAS)) {
            return douyin.window._createOffscreenCanvas(10, 10);
        } else {
            // in hongmeng system, create too many canvas will case render error
            var defCanvas = douyin.document.createElement("canvas");
            defCanvas.getContext("2d", {
                willReadFrequently: true
            });
            return defCanvas;
        }
    };
    _proto.saveCanvas = function saveCanvas(canvas) {
        canvas.width = 1;
        canvas.height = 1;
        if (this.elements.length < 3) {
            addItem(this.elements, canvas);
        } else {
            canvas.remove();
        }
    };
    return CanvasPool;
}();
var canvasPool = new CanvasPool();

var DEFAULT_FONTS = [
    "serif",
    "sans-serif",
    "monospace",
    "courier"
];
exports.TextComponent = /*#__PURE__*/ function(SpriteComponent) {
    _inherits(TextComponent, SpriteComponent);
    function TextComponent(engine, props) {
        var _this;
        _this = SpriteComponent.call(this, engine, props) || this;
        _this.isDirty = true;
        /**
   * 文本行数
   */ _this.lineCount = 0;
        _this.canvas = canvasPool.getCanvas();
        canvasPool.saveCanvas(_this.canvas);
        _this.context = _this.canvas.getContext("2d", {
            willReadFrequently: true
        });
        if (!props) {
            return _possible_constructor_return(_this);
        }
        var options = props.options;
        _this.updateWithOptions(options);
        _this.updateTexture();
        return _this;
    }
    var _proto = TextComponent.prototype;
    _proto.update = function update(dt) {
        SpriteComponent.prototype.update.call(this, dt);
        this.updateTexture();
    };
    _proto.fromData = function fromData(data) {
        SpriteComponent.prototype.fromData.call(this, data);
        var options = data.options;
        this.updateWithOptions(options);
        // Text
        this.updateTexture();
    };
    _proto.updateWithOptions = function updateWithOptions(options) {
    // OVERRIDE by mixins
    };
    _proto.updateTexture = function updateTexture(flipY) {
    // OVERRIDE by mixins
    };
    return TextComponent;
}(exports.SpriteComponent);
exports.TextComponent = __decorate([
    effectsClass(DataType.TextComponent)
], exports.TextComponent);
var TextComponentBase = /*#__PURE__*/ function() {
    function TextComponentBase() {}
    var _proto = TextComponentBase.prototype;
    _proto.updateWithOptions = function updateWithOptions(options) {
        this.textStyle = new TextStyle(options);
        this.textLayout = new TextLayout(options);
        this.text = options.text.toString();
        this.lineCount = this.getLineCount(options.text, true);
    };
    _proto.getLineCount = function getLineCount(text, init) {
        var context = this.context;
        var letterSpace = this.textLayout.letterSpace;
        var fontScale = init ? this.textStyle.fontSize / 10 : 1 / this.textStyle.fontScale;
        var width = this.textLayout.width + this.textStyle.fontOffset;
        var lineCount = 1;
        var x = 0;
        for(var i = 0; i < text.length; i++){
            var _context_measureText;
            var str = text[i];
            var _context_measureText_width;
            var textMetrics = ((_context_measureText_width = context == null ? void 0 : (_context_measureText = context.measureText(str)) == null ? void 0 : _context_measureText.width) != null ? _context_measureText_width : 0) * fontScale;
            // 和浏览器行为保持一致
            x += letterSpace;
            if (x + textMetrics > width && i > 0 || str === "\n") {
                lineCount++;
                x = 0;
            }
            if (str !== "\n") {
                x += textMetrics;
            }
        }
        return lineCount;
    };
    /**
   * 设置字号大小
   * @param value - 字号
   * @returns
   */ _proto.setFontSize = function setFontSize(value) {
        if (this.textStyle.fontSize === value) {
            return;
        }
        // 保证字号变化后位置正常
        var diff = this.textStyle.fontSize - value;
        this.textLayout.lineHeight += diff;
        this.textStyle.fontSize = value;
        this.isDirty = true;
    };
    /**
   * 设置字重
   * @param value - 字重类型
   * @returns
   */ _proto.setFontWeight = function setFontWeight(value) {
        if (this.textStyle.textWeight === value) {
            return;
        }
        this.textStyle.textWeight = value;
        this.isDirty = true;
    };
    /**
   * 设置字体类型
   * @param value 字体类型
   * @returns
   */ _proto.setFontStyle = function setFontStyle(value) {
        if (this.textStyle.fontStyle === value) {
            return;
        }
        this.textStyle.fontStyle = value;
        this.isDirty = true;
    };
    /**
   * 设置文本
   * @param value - 文本内容
   * @returns
   */ _proto.setText = function setText(value) {
        if (this.text === value) {
            return;
        }
        this.text = value.toString();
        this.lineCount = this.getLineCount(value, false);
        this.isDirty = true;
    };
    /**
   * 设置文本水平布局
   * @param value - 布局选项
   * @returns
   */ _proto.setTextAlign = function setTextAlign(value) {
        if (this.textLayout.textAlign === value) {
            return;
        }
        this.textLayout.textAlign = value;
        this.isDirty = true;
    };
    /**
   * 设置文本垂直布局
   * @param value - 布局选项
   * @returns
   */ _proto.setTextBaseline = function setTextBaseline(value) {
        if (this.textLayout.textBaseline === value) {
            return;
        }
        this.textLayout.textBaseline = value;
        this.isDirty = true;
    };
    /**
   * 设置文本颜色
   * @param value - 颜色内容
   * @returns
   */ _proto.setTextColor = function setTextColor(value) {
        if (this.textStyle.textColor === value) {
            return;
        }
        this.textStyle.textColor = value;
        this.isDirty = true;
    };
    /**
   * 设置文本字体
   * @param value - 文本字体
   * @returns
   */ _proto.setFontFamily = function setFontFamily(value) {
        if (this.textStyle.fontFamily === value && !isValidFontFamily(value)) {
            console.warn("The font is either the current font or an risky font family.");
            return;
        }
        this.textStyle.fontFamily = value;
        this.isDirty = true;
    };
    /**
   * 设置外描边文本颜色
   * @param value - 颜色内容
   * @returns
   */ _proto.setOutlineColor = function setOutlineColor(value) {
        if (this.textStyle.outlineColor === value) {
            return;
        }
        this.textStyle.outlineColor = value;
        this.isDirty = true;
    };
    /**
   * 设置外描边文本宽度
   * @param value - 外描边宽度
   * @returns
   */ _proto.setOutlineWidth = function setOutlineWidth(value) {
        if (this.textStyle.outlineWidth === value) {
            return;
        }
        this.textStyle.outlineWidth = value;
        this.isDirty = true;
    };
    /**
   * 设置阴影模糊
   * @param value - 阴影模糊强度
   * @returns
   */ _proto.setShadowBlur = function setShadowBlur(value) {
        if (this.textStyle.shadowBlur === value) {
            return;
        }
        this.textStyle.shadowBlur = value;
        this.isDirty = true;
    };
    /**
   * 设置阴影颜色
   * @param value - 阴影颜色
   * @returns
   */ _proto.setShadowColor = function setShadowColor(value) {
        if (this.textStyle.shadowColor === value) {
            return;
        }
        this.textStyle.shadowColor = value;
        this.isDirty = true;
    };
    /**
   * 设置阴影水平偏移距离
   * @param value - 水平偏移距离
   * @returns
   */ _proto.setShadowOffsetX = function setShadowOffsetX(value) {
        if (this.textStyle.shadowOffsetX === value) {
            return;
        }
        this.textStyle.shadowOffsetX = value;
        this.isDirty = true;
    };
    /**
   * 设置阴影水平偏移距离
   * @param value - 水平偏移距离
   * @returns
   */ _proto.setShadowOffsetY = function setShadowOffsetY(value) {
        if (this.textStyle.shadowOffsetY === value) {
            return;
        }
        this.textStyle.shadowOffsetY = value;
        this.isDirty = true;
    };
    /**
   * 设置字体清晰度
   * @param value - 字体清晰度
   * @returns
   */ _proto.setFontScale = function setFontScale(value) {
        if (this.textStyle.fontScale === value) {
            return;
        }
        this.textStyle.fontScale = value;
        this.isDirty = true;
    };
    /**
   * 设置自适应宽高开关
   * @param value - 是否自适应宽高开关
   * @returns
   */ _proto.setAutoWidth = function setAutoWidth(value) {
        if (this.textLayout.autoWidth === value) {
            return;
        }
        this.textLayout.autoWidth = value;
        this.isDirty = true;
    };
    /**
   * 更新文本
   * @returns
   */ _proto.updateTexture = function updateTexture(flipY) {
        if (flipY === void 0) flipY = true;
        if (!this.isDirty || !this.context || !this.canvas) {
            return;
        }
        var context = this.context;
        var style = this.textStyle;
        var layout = this.textLayout;
        var fontScale = style.fontScale;
        var width = (layout.width + style.fontOffset) * fontScale;
        var finalHeight = layout.lineHeight * this.lineCount;
        var fontSize = style.fontSize * fontScale;
        var lineHeight = layout.lineHeight * fontScale;
        this.char = (this.text || "").split("");
        this.canvas.width = width;
        if (layout.autoWidth) {
            this.canvas.height = finalHeight * fontScale;
            this.item.transform.size.set(1, finalHeight / layout.height);
        } else {
            this.canvas.height = layout.height * fontScale;
        }
        var height = this.canvas.height;
        context.clearRect(0, 0, width, height);
        // fix bug 1/255
        context.fillStyle = "rgba(255, 255, 255, 0.0039)";
        if (!flipY) {
            context.translate(0, height);
            context.scale(1, -1);
        }
        context.fillRect(0, 0, width, height);
        style.fontDesc = this.getFontDesc();
        context.font = style.fontDesc;
        if (style.hasShadow) {
            this.setupShadow();
        }
        if (style.isOutlined) {
            this.setupOutline();
        }
        // 文本颜色
        context.fillStyle = "rgba(" + style.textColor[0] + ", " + style.textColor[1] + ", " + style.textColor[2] + ", " + style.textColor[3] + ")";
        var charsInfo = [];
        var x = 0;
        var y = layout.getOffsetY(style, this.lineCount, lineHeight, fontSize);
        var charsArray = [];
        var charOffsetX = [];
        for(var i = 0; i < this.char.length; i++){
            var str = this.char[i];
            var textMetrics = context.measureText(str);
            // 和浏览器行为保持一致
            x += layout.letterSpace * fontScale;
            if (x + textMetrics.width > width && i > 0 || str === "\n") {
                charsInfo.push({
                    y: y,
                    width: x,
                    chars: charsArray,
                    charOffsetX: charOffsetX
                });
                x = 0;
                y += lineHeight;
                charsArray = [];
                charOffsetX = [];
            }
            if (str !== "\n") {
                charsArray.push(str);
                charOffsetX.push(x);
                x += textMetrics.width;
            }
        }
        charsInfo.push({
            y: y,
            width: x,
            chars: charsArray,
            charOffsetX: charOffsetX
        });
        charsInfo.forEach(function(charInfo) {
            var x = layout.getOffsetX(style, charInfo.width);
            charInfo.chars.forEach(function(str, i) {
                if (style.isOutlined) {
                    context.strokeText(str, x + charInfo.charOffsetX[i], charInfo.y);
                }
                context.fillText(str, x + charInfo.charOffsetX[i], charInfo.y);
            });
        });
        if (style.hasShadow) {
            context.shadowColor = "transparent";
        }
        //与 toDataURL() 两种方式都需要像素读取操作
        var imageData = context.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.material.setTexture("uSampler0", Texture.createWithData(this.engine, {
            data: new Uint8Array(imageData.data),
            width: imageData.width,
            height: imageData.height
        }, {
            flipY: flipY,
            magFilter: glContext.LINEAR,
            minFilter: glContext.LINEAR,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE
        }));
        this.isDirty = false;
    };
    _proto.getFontDesc = function getFontDesc() {
        var _this_textStyle = this.textStyle, fontSize = _this_textStyle.fontSize, fontScale = _this_textStyle.fontScale, fontFamily = _this_textStyle.fontFamily, textWeight = _this_textStyle.textWeight, fontStyle = _this_textStyle.fontStyle;
        var fontDesc = "" + (fontSize * fontScale).toString() + "px ";
        if (!DEFAULT_FONTS.includes(fontFamily)) {
            fontDesc += '"' + fontFamily + '"';
        } else {
            fontDesc += fontFamily;
        }
        if (textWeight !== TextWeight.normal) {
            fontDesc = textWeight + " " + fontDesc;
        }
        if (fontStyle !== FontStyle.normal) {
            fontDesc = fontStyle + " " + fontDesc;
        }
        return fontDesc;
    };
    _proto.setupOutline = function setupOutline() {
        var context = this.context;
        var _this_textStyle = this.textStyle, outlineColor = _this_textStyle.outlineColor, outlineWidth = _this_textStyle.outlineWidth;
        var r = outlineColor[0], g = outlineColor[1], b = outlineColor[2], a = outlineColor[3];
        if (context) {
            context.strokeStyle = "rgba(" + r * 255 + ", " + g * 255 + ", " + b * 255 + ", " + a + ")";
            context.lineWidth = outlineWidth * 2;
        }
    };
    _proto.setupShadow = function setupShadow() {
        var context = this.context;
        var _this_textStyle = this.textStyle, outlineColor = _this_textStyle.outlineColor, shadowBlur = _this_textStyle.shadowBlur, shadowOffsetX = _this_textStyle.shadowOffsetX, shadowOffsetY = _this_textStyle.shadowOffsetY;
        var r = outlineColor[0], g = outlineColor[1], b = outlineColor[2], a = outlineColor[3];
        if (context) {
            context.shadowColor = "rgba(" + r * 255 + ", " + g * 255 + ", " + b * 255 + ", " + a + ")";
            context.shadowBlur = shadowBlur;
            context.shadowOffsetX = shadowOffsetX;
            context.shadowOffsetY = -shadowOffsetY;
        }
    };
    return TextComponentBase;
}();
applyMixins(exports.TextComponent, [
    TextComponentBase
]);

// TODO: 注册必须用
var TextLoader = /*#__PURE__*/ function(AbstractPlugin) {
    _inherits(TextLoader, AbstractPlugin);
    function TextLoader() {
        return AbstractPlugin.apply(this, arguments);
    }
    return TextLoader;
}(AbstractPlugin);

exports.EffectComponent = /*#__PURE__*/ function(RendererComponent) {
    _inherits(EffectComponent, RendererComponent);
    function EffectComponent(engine) {
        var _this;
        _this = RendererComponent.call(this, engine) || this;
        /**
   * Mesh 的世界矩阵
   */ _this.worldMatrix = Matrix4$1.fromIdentity();
        _this.triangles = [];
        _this.destroyed = false;
        // TODO 点击测试后续抽象一个 Collider 组件
        _this.getHitTestParams = function(force) {
            var area = _this.getBoundingBox();
            if (area) {
                return {
                    type: area.type,
                    triangles: area.area
                };
            }
        };
        _this.name = "EffectComponent";
        _this._priority = 0;
        return _this;
    }
    var _proto = EffectComponent.prototype;
    _proto.start = function start() {
        this.item.getHitTestParams = this.getHitTestParams;
    };
    _proto.render = function render(renderer) {
        if (renderer.renderingData.currentFrame.globalUniforms) {
            renderer.setGlobalMatrix("effects_ObjectToWorld", this.transform.getWorldMatrix());
        }
        renderer.drawGeometry(this.geometry, this.material);
    };
    /**
   * 设置当前 Mesh 的材质
   * @param material - 要设置的材质
   * @param destroy - 可选的材质销毁选项
   */ _proto.setMaterial = function setMaterial(material, destroy) {
        if (destroy !== exports.DestroyOptions.keep) {
            this.material.dispose(destroy);
        }
        this.material = material;
    };
    _proto.getBoundingBox = function getBoundingBox() {
        var worldMatrix = this.transform.getWorldMatrix();
        if (this.hitTestGeometry !== this.geometry) {
            this.triangles = geometryToTriangles(this.geometry);
            this.hitTestGeometry = this.geometry;
        }
        var area = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(this.triangles), _step; !(_step = _iterator()).done;){
            var triangle = _step.value;
            area.push({
                p0: triangle.p0,
                p1: triangle.p1,
                p2: triangle.p2
            });
        }
        area.forEach(function(triangle) {
            triangle.p0 = worldMatrix.transformPoint(triangle.p0, new Vector3());
            triangle.p1 = worldMatrix.transformPoint(triangle.p1, new Vector3());
            triangle.p2 = worldMatrix.transformPoint(triangle.p2, new Vector3());
        });
        return {
            type: exports.HitTestType.triangle,
            area: area
        };
    };
    _proto.fromData = function fromData(data) {
        RendererComponent.prototype.fromData.call(this, data);
        this.material = this.materials[0];
    };
    _proto.toData = function toData() {
        this.taggedProperties.id = this.guid;
    };
    /**
   * 销毁当前资源
   * @param options - 可选的销毁选项
   */ _proto.dispose = function dispose(options) {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        RendererComponent.prototype.dispose.call(this);
    };
    return EffectComponent;
}(RendererComponent);
__decorate([
    serialize()
], exports.EffectComponent.prototype, "geometry", void 0);
exports.EffectComponent = __decorate([
    effectsClass(DataType.EffectComponent)
], exports.EffectComponent);
function geometryToTriangles(geometry) {
    var _geometry_getIndexData;
    var indices = (_geometry_getIndexData = geometry.getIndexData()) != null ? _geometry_getIndexData : [];
    var _geometry_getAttributeData;
    var vertices = (_geometry_getAttributeData = geometry.getAttributeData("aPos")) != null ? _geometry_getAttributeData : [];
    var res = [];
    for(var i = 0; i < indices.length; i += 3){
        var index0 = indices[i] * 3;
        var index1 = indices[i + 1] * 3;
        var index2 = indices[i + 2] * 3;
        var p0 = {
            x: vertices[index0],
            y: vertices[index0 + 1],
            z: vertices[index0 + 2]
        };
        var p1 = {
            x: vertices[index1],
            y: vertices[index1 + 1],
            z: vertices[index1 + 2]
        };
        var p2 = {
            x: vertices[index2],
            y: vertices[index2 + 1],
            z: vertices[index2 + 2]
        };
        res.push({
            p0: p0,
            p1: p1,
            p2: p2
        });
    }
    return res;
}

exports.PostProcessVolume = /*#__PURE__*/ function(Behaviour) {
    _inherits(PostProcessVolume, Behaviour);
    function PostProcessVolume() {
        var _this;
        _this = Behaviour.apply(this, arguments) || this;
        _this.useHDR = true;
        // Bloom
        _this.useBloom = true;
        _this.threshold = 1.0;
        _this.bloomIntensity = 1.0;
        // ColorAdjustments
        _this.brightness = 1.0;
        _this.saturation = 1.0;
        _this.contrast = 1.0;
        // Vignette
        _this.vignetteIntensity = 0.2;
        _this.vignetteSmoothness = 0.4;
        _this.vignetteRoundness = 1.0;
        // ToneMapping
        _this.useToneMapping = true // 1: true, 0: false
        ;
        return _this;
    }
    var _proto = PostProcessVolume.prototype;
    _proto.start = function start() {
        var composition = this.item.composition;
        if (composition) {
            composition.globalVolume = this;
            composition.createRenderFrame();
        }
    };
    return PostProcessVolume;
}(Behaviour);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "useHDR", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "useBloom", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "threshold", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "bloomIntensity", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "brightness", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "saturation", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "contrast", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "vignetteIntensity", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "vignetteSmoothness", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "vignetteRoundness", void 0);
__decorate([
    serialize()
], exports.PostProcessVolume.prototype, "useToneMapping", void 0);
exports.PostProcessVolume = __decorate([
    effectsClass("PostProcessVolume")
], exports.PostProcessVolume);

var EventEmitter = function EventEmitter() {
    var _this = this;
    var _this1 = this;
    this.listeners = {};
    /**
   * 移除事件监听器
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   * @returns
   */ this.off = function(eventName, listener) {
        if (!_this.listeners[eventName]) {
            return;
        }
        _this.listeners[eventName] = _this.listeners[eventName].filter(function(param) {
            var l = param.listener;
            return l !== listener;
        });
    };
    /**
   * 监听事件
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   * @param options - 事件监听器选项
   * @returns
   */ this.on = function(eventName, listener, options) {
        _this.listeners[eventName] = _this.listeners[eventName] || [];
        _this.listeners[eventName].push({
            listener: listener,
            options: options
        });
        return function() {
            return _this.off(eventName, listener);
        };
    };
    /**
   * 一次性监听事件
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   */ this.once = function(eventName, listener) {
        _this.on(eventName, listener, {
            once: true
        });
    };
    /**
   * 触发事件
   * @param eventName - 事件名称
   * @param args - 事件参数
   */ this.emit = function(eventName) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        var _this_listeners_eventName;
        (_this_listeners_eventName = _this1.listeners[eventName]) == null ? void 0 : _this_listeners_eventName.forEach(function(param) {
            var listener = param.listener, options = param.options;
            listener.apply(void 0, [].concat(args));
            if (options == null ? void 0 : options.once) {
                _this1.off(eventName, listener);
            }
        });
    };
    /**
   * 获取事件名称对应的所有监听器
   * @param eventName - 事件名称
   * @returns - 返回事件名称对应的所有监听器
   */ this.getListeners = function(eventName) {
        var _this_listeners_eventName;
        return ((_this_listeners_eventName = _this.listeners[eventName]) == null ? void 0 : _this_listeners_eventName.map(function(param) {
            var listener = param.listener;
            return listener;
        })) || [];
    };
};

exports.VFXItem = /*#__PURE__*/ function(EffectsObject) {
    _inherits(VFXItem, EffectsObject);
    function VFXItem(engine, props) {
        var _this;
        _this = EffectsObject.call(this, engine) || this;
        _this.children = [];
        /**
   * 元素的变换包含位置、旋转、缩放。
   */ _this.transform = new Transform();
        /**
   * 元素动画的持续时间
   */ _this.duration = 0;
        /**
   * 元素动画的开始时间
   */ _this.start = 0;
        /**
   * 元素动画结束时行为（如何处理元素）
   */ _this.endBehavior = EndBehavior.forward;
        /**
   * 元素是否可用
   */ _this.ended = false;
        _this.reusable = false;
        _this.type = ItemType.base;
        _this.components = [];
        _this.itemBehaviours = [];
        _this.rendererComponents = [];
        /**
   * 元素可见性，该值的改变会触发 `handleVisibleChanged` 回调
   * @protected
   */ _this.visible = true;
        /**
   * 元素动画的速度
   */ _this.speed = 1;
        _this.listIndex = 0;
        _this.eventProcessor = new EventEmitter();
        _this.name = "VFXItem";
        _this.transform.name = _this.name;
        _this.transform.engine = engine;
        if (props) {
            _this.fromData(props);
        }
        return _this;
    }
    var _proto = VFXItem.prototype;
    /**
   * 元素监听事件
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   * @param options - 事件监听器选项
   * @returns
   */ _proto.on = function on(eventName, listener, options) {
        this.eventProcessor.on(eventName, listener, options);
    };
    /**
   * 移除事件监听器
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   * @returns
   */ _proto.off = function off(eventName, listener) {
        this.eventProcessor.off(eventName, listener);
    };
    /**
   * 一次性监听事件
   * @param eventName - 事件名称
   * @param listener - 事件监听器
   */ _proto.once = function once(eventName, listener) {
        this.eventProcessor.once(eventName, listener);
    };
    /**
   * 触发事件
   * @param eventName - 事件名称
   * @param args - 事件参数
   */ _proto.emit = function emit(eventName) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        var _this_eventProcessor;
        (_this_eventProcessor = this.eventProcessor).emit.apply(_this_eventProcessor, [].concat([
            eventName
        ], args));
    };
    /**
   * 获取事件名称对应的所有监听器
   * @param eventName - 事件名称
   * @returns - 返回事件名称对应的所有监听器
   */ _proto.getListeners = function getListeners(eventName) {
        return this.eventProcessor.getListeners(eventName);
    };
    /**
   * 设置元素的动画速度
   * @param speed - 速度
   */ _proto.setSpeed = function setSpeed(speed) {
        this.speed = speed;
    };
    /**
   * 获取元素的动画速度
   * @returns
   */ _proto.getSpeed = function getSpeed() {
        return this.speed;
    };
    /**
   * 添加组件
   * @param classConstructor - 要添加的组件类型
   */ _proto.addComponent = function addComponent(classConstructor) {
        var newComponent = new classConstructor(this.engine);
        this.components.push(newComponent);
        newComponent.item = this;
        newComponent.onAttached();
        return newComponent;
    };
    /**
   * 获取某一类型的组件。如果当前元素绑定了多个同类型的组件只返回第一个
   * @param classConstructor - 要获取的组件类型
   * @returns 查询结果中符合类型的第一个组件
   */ _proto.getComponent = function getComponent(classConstructor) {
        var res;
        for(var _iterator = _create_for_of_iterator_helper_loose(this.components), _step; !(_step = _iterator()).done;){
            var com = _step.value;
            if (_instanceof1(com, classConstructor)) {
                res = com;
                break;
            }
        }
        return res;
    };
    /**
   * 获取某一类型的所有组件
   * @param classConstructor - 要获取的组件
   * @returns 一个组件列表，包含所有符合类型的组件
   */ _proto.getComponents = function getComponents(classConstructor) {
        var res = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(this.components), _step; !(_step = _iterator()).done;){
            var com = _step.value;
            if (_instanceof1(com, classConstructor)) {
                res.push(com);
            }
        }
        return res;
    };
    _proto.setParent = function setParent(vfxItem) {
        if (vfxItem === this) {
            return;
        }
        if (this.parent) {
            removeItem(this.parent.children, this);
        }
        this.parent = vfxItem;
        if (vfxItem) {
            if (!VFXItem.isCamera(this)) {
                this.transform.parentTransform = vfxItem.transform;
            }
            vfxItem.children.push(this);
            if (!this.composition) {
                this.composition = vfxItem.composition;
            }
        }
    };
    /**
   * 元素动画结束播放时回调函数
   * @override
   */ _proto.onEnd = function onEnd() {
    // OVERRIDE
    };
    /**
   * 通过指定 r、g、b、a 值设置元素的颜色
   * @param {number} r
   * @param {number} g
   * @param {number} b
   * @param {number} a
   * @internal
   */ _proto.setColor = function setColor(r, g, b, a) {};
    /**
   * 设置元素的透明度
   * @param opacity - 透明度值，范围 [0,1]
   */ _proto.setOpacity = function setOpacity(opacity) {};
    /**
   * 获取元素显隐属性
   */ _proto.getVisible = function getVisible() {
        return this.visible;
    };
    /**
   * 设置元素显隐属性 会触发 `handleVisibleChanged` 回调
   */ _proto.setVisible = function setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = !!visible;
        }
    };
    /**
   * 获取元素变换包括位置、旋转、缩放
   * @param transform 将元素变换拷贝到该对象，并将其作为返回值
   * @returns 元素变换的拷贝
   */ _proto.getWorldTransform = function getWorldTransform(transform) {
        var tf = transform != null ? transform : new Transform({
            valid: true
        });
        tf.cloneFromMatrix(this.transform.getWorldMatrix());
        return tf;
    };
    /**
   * 获取元素内部节点的变换，目前只有场景树元素在使用
   * @param itemId 元素id信息，如果带^就返回内部节点变换，否则返回自己的变换
   * @returns 元素变换或内部节点变换
   */ _proto.getNodeTransform = function getNodeTransform(itemId) {
        for(var i = 0; i < this.components.length; i++){
            var comp = this.components[1];
            // @ts-expect-error
            if (comp.getNodeTransform) {
                // @ts-expect-error
                return comp.getNodeTransform(itemId);
            }
        }
        return this.transform;
    };
    /**
   * 设置元素在 3D 坐标轴上相对移动
   */ _proto.translate = function translate(x, y, z) {
        this.transform.translate(x, y, z);
    };
    /**
   * 设置元素在 3D 坐标轴上相对旋转（角度）
   */ _proto.rotate = function rotate(x, y, z) {
        var euler = new Euler(x, y, z);
        var q = Quaternion.fromEuler(euler);
        q.conjugate();
        this.transform.rotateByQuat(q);
    };
    /**
   * 设置元素在 3D 坐标轴上相对缩放
   */ _proto.scale = function scale(x, y, z) {
        this.transform.scaleBy(x, y, z);
    };
    /**
   * 设置元素在画布上的像素位置
   * Tips:
   *  - 坐标原点在 canvas 左上角，x 正方向水平向右， y 正方向垂直向下
   *  - 设置后会覆盖原有的位置信息
   * @param x - x 坐标
   * @param y - y 坐标
   */ _proto.setPositionByPixel = function setPositionByPixel(x, y) {
        if (this.composition) {
            var z = this.transform.getWorldPosition().z;
            var _this_composition_camera_getInverseVPRatio = this.composition.camera.getInverseVPRatio(z), rx = _this_composition_camera_getInverseVPRatio.x, ry = _this_composition_camera_getInverseVPRatio.y;
            var width = this.composition.renderer.getWidth() / 2;
            var height = this.composition.renderer.getHeight() / 2;
            this.transform.setPosition((2 * x / width - 1) * rx, (1 - 2 * y / height) * ry, z);
        }
    };
    /**
   * 设置元素在 3D 坐标轴的位置
   */ _proto.setPosition = function setPosition(x, y, z) {
        this.transform.setPosition(x, y, z);
    };
    /**
   * 设置元素在 3D 坐标轴的角度
   */ _proto.setRotation = function setRotation(x, y, z) {
        this.transform.setRotation(x, y, z);
    };
    /**
   * 设置元素在 3D 坐标轴的缩放
   */ _proto.setScale = function setScale(x, y, z) {
        this.transform.setScale(x, y, z);
    };
    /**
   * 获取元素包围盒
   * @override
   */ _proto.getBoundingBox = function getBoundingBox() {
    // OVERRIDE
    };
    /**
   * 获取元素用于计算光线投射的面片类型和参数
   * @override
   * @param force - 元素没有开启交互也返回参数
   */ _proto.getHitTestParams = function getHitTestParams(force) {
    // OVERRIDE
    };
    /**
   * 获取元素当前世界坐标
   */ _proto.getCurrentPosition = function getCurrentPosition() {
        var pos = new Vector3();
        this.transform.assignWorldTRS(pos);
        return pos;
    };
    /**
   * 是否到达元素的结束时间
   * @param now
   * @returns
   */ _proto.isEnded = function isEnded(now) {
        // at least 1 ms
        return now - this.duration > 0.001;
    };
    _proto.find = function find(name) {
        if (this.name === name) {
            return this;
        }
        for(var _iterator = _create_for_of_iterator_helper_loose(this.children), _step; !(_step = _iterator()).done;){
            var child = _step.value;
            if (child.name === name) {
                return child;
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(this.children), _step1; !(_step1 = _iterator1()).done;){
            var child1 = _step1.value;
            var res = child1.find(name);
            if (res) {
                return res;
            }
        }
        return undefined;
    };
    _proto.fromData = function fromData(data) {
        EffectsObject.prototype.fromData.call(this, data);
        var id = data.id, name = data.name, delay = data.delay, parentId = data.parentId, endBehavior = data.endBehavior, transform = data.transform, _data_listIndex = data.listIndex, listIndex = _data_listIndex === void 0 ? 0 : _data_listIndex, _data_duration = data.duration, duration = _data_duration === void 0 ? 0 : _data_duration;
        this.props = data;
        //@ts-expect-error
        this.type = data.type;
        this.id = id.toString(); // TODO 老数据 id 是 number，需要转换
        this.name = name;
        this.start = delay ? delay : this.start;
        if (transform) {
            //@ts-expect-error TODO 数据改造后移除 expect-error
            transform.position = new Vector3().copyFrom(transform.position);
            // FIXME: transform.rotation待删除
            if (transform.quat) {
                //@ts-expect-error
                transform.quat = new Quaternion(transform.quat.x, transform.quat.y, transform.quat.z, transform.quat.w);
            } else {
                var _transform_eulerHint;
                //@ts-expect-error
                transform.rotation = new Euler().copyFrom((_transform_eulerHint = transform.eulerHint) != null ? _transform_eulerHint : transform.rotation);
            }
            //@ts-expect-error
            transform.scale = new Vector3().copyFrom(transform.scale);
            //@ts-expect-error
            if (transform.size) {
                //@ts-expect-error
                transform.size = new Vector2().copyFrom(transform.size);
            }
            //@ts-expect-error
            if (transform.anchor) {
                //@ts-expect-error
                transform.anchor = new Vector2().copyFrom(transform.anchor);
            }
            this.transform.setTransform(transform);
        }
        this.transform.name = this.name;
        this.transform.engine = this.engine;
        this.parentId = parentId;
        this.duration = duration;
        // TODO spec endbehavior 类型修正
        this.endBehavior = endBehavior;
        if (!data.content) {
            data.content = {
                options: {}
            };
        }
        if (duration <= 0) {
            throw new Error("Item duration can't be less than 0, see " + HELP_LINK$1["Item duration can't be less than 0"] + ".");
        }
        this.itemBehaviours.length = 0;
        this.rendererComponents.length = 0;
        for(var _iterator = _create_for_of_iterator_helper_loose(this.components), _step; !(_step = _iterator()).done;){
            var component = _step.value;
            component.item = this;
            if (_instanceof1(component, Behaviour)) {
                this.itemBehaviours.push(component);
            }
            if (_instanceof1(component, RendererComponent)) {
                this.rendererComponents.push(component);
            }
            // TODO ParticleSystemRenderer 现在是动态生成的，后面需要在 json 中单独表示为一个组件
            if (_instanceof1(component, exports.ParticleSystem)) {
                if (!this.components.includes(component.renderer)) {
                    this.components.push(component.renderer);
                }
                this.rendererComponents.push(component.renderer);
            }
        }
        // renderOrder 在 component 初始化后设置。确保能拿到 rendererComponent。
        this.renderOrder = listIndex;
    };
    _proto.toData = function toData() {
        var _this_parent;
        this.taggedProperties.id = this.guid;
        this.taggedProperties.transform = this.transform.toData();
        this.taggedProperties.dataType = DataType.VFXItemData;
        if (((_this_parent = this.parent) == null ? void 0 : _this_parent.name) !== "rootItem") {
            var _this_parent1;
            this.taggedProperties.parentId = (_this_parent1 = this.parent) == null ? void 0 : _this_parent1.guid;
        }
        // TODO 统一 sprite 等其他组件的序列化逻辑
        if (!this.taggedProperties.components) {
            this.taggedProperties.components = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(this.components), _step; !(_step = _iterator()).done;){
                var component = _step.value;
                if (_instanceof1(component, exports.EffectComponent)) {
                    this.taggedProperties.components.push(component);
                }
            }
        }
        this.taggedProperties.content = {};
    };
    _proto.translateByPixel = function translateByPixel(x, y) {
        if (this.composition) {
            // @ts-expect-error
            var _this_composition_renderer_canvas_getBoundingClientRect = this.composition.renderer.canvas.getBoundingClientRect(), width = _this_composition_renderer_canvas_getBoundingClientRect.width, height = _this_composition_renderer_canvas_getBoundingClientRect.height;
            var z = this.transform.getWorldPosition().z;
            var _this_composition_camera_getInverseVPRatio = this.composition.camera.getInverseVPRatio(z), rx = _this_composition_camera_getInverseVPRatio.x, ry = _this_composition_camera_getInverseVPRatio.y;
            this.transform.translate(2 * x * rx / width, -2 * y * ry / height, 0);
        }
    };
    /**
   * 销毁元素
   */ _proto.dispose = function dispose() {
        this.resetChildrenParent();
        if (this.composition) {
            this.composition.destroyItem(this);
            // component 调用 dispose() 会将自身从 this.components 数组删除，slice() 避免迭代错误
            for(var _iterator = _create_for_of_iterator_helper_loose(this.components.slice()), _step; !(_step = _iterator()).done;){
                var component = _step.value;
                component.dispose();
            }
            this.components = [];
            this._content = undefined;
            this.composition = null;
            this.transform.setValid(false);
        }
    };
    _proto.resetChildrenParent = function resetChildrenParent() {
        // GE 父元素销毁子元素继承逻辑
        // 如果有父对象，销毁时子对象继承父对象。
        for(var _iterator = _create_for_of_iterator_helper_loose(this.children), _step; !(_step = _iterator()).done;){
            var child = _step.value;
            if (this.parent) {
                child.setParent(this.parent);
            }
        }
        if (this.parent) {
            var _this_parent;
            removeItem((_this_parent = this.parent) == null ? void 0 : _this_parent.children, this);
        }
    // const contentItems = compositonVFXItem.getComponent(CompositionComponent)!.items;
    // contentItems.splice(contentItems.indexOf(this), 1);
    // else {
    //   // 普通元素正常销毁逻辑, 子元素不继承
    // if (this.parent) {
    //   removeItem(this.parent?.children, this);
    // }
    // }
    };
    VFXItem.isComposition = function isComposition(item) {
        return item.type === ItemType.composition;
    };
    VFXItem.isSprite = function isSprite(item) {
        return item.type === ItemType.sprite;
    };
    VFXItem.isParticle = function isParticle(item) {
        return item.type === ItemType.particle;
    };
    VFXItem.isNull = function isNull(item) {
        return item.type === ItemType.null;
    };
    VFXItem.isTree = function isTree(item) {
        return item.type === ItemType.tree;
    };
    VFXItem.isCamera = function isCamera(item) {
        return item.type === ItemType.camera;
    };
    VFXItem.isExtraCamera = function isExtraCamera(item) {
        return item.id === "extra-camera" && item.name === "extra-camera";
    };
    _create_class(VFXItem, [
        {
            key: "content",
            get: /**
   * 返回元素创建的数据
   */ function get() {
                return this._content;
            }
        },
        {
            key: "compositionReusable",
            get: /**
   * 播放完成后是否需要再使用，是的话生命周期结束后不会 dispose
   */ function get() {
                var _this_composition;
                var _this_composition_reusable;
                return (_this_composition_reusable = (_this_composition = this.composition) == null ? void 0 : _this_composition.reusable) != null ? _this_composition_reusable : false;
            }
        },
        {
            key: "renderOrder",
            get: /**
   * 元素在合成中的索引
   */ function get() {
                return this.listIndex;
            },
            set: function set(value) {
                if (this.listIndex !== value) {
                    this.listIndex = value;
                    for(var _iterator = _create_for_of_iterator_helper_loose(this.rendererComponents), _step; !(_step = _iterator()).done;){
                        var rendererComponent = _step.value;
                        rendererComponent.priority = value;
                    }
                }
            }
        }
    ]);
    return VFXItem;
}(EffectsObject);
__decorate([
    serialize()
], exports.VFXItem.prototype, "components", void 0);
exports.VFXItem = __decorate([
    effectsClass(DataType.VFXItemData)
], exports.VFXItem);
exports.Item = void 0;
(function(Item) {
    function is(item, type) {
        return item.type === type;
    }
    Item.is = is;
    function isComposition(item) {
        return item.type === ItemType.composition;
    }
    Item.isComposition = isComposition;
    function isParticle(item) {
        return item.type === ItemType.particle;
    }
    Item.isParticle = isParticle;
    function isNull(item) {
        return item.type === ItemType.null;
    }
    Item.isNull = isNull;
})(exports.Item || (exports.Item = {}));

var pluginLoaderMap = {};
var defaultPlugins = [];
var pluginCtrlMap = {};
/**
 * 注册 plugin
 * @param name
 * @param pluginClass class of plugin
 * @param itemClass class of item
 * @param isDefault load
 */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
function registerPlugin(name, pluginClass, itemClass, isDefault) {
    if (pluginCtrlMap[name]) {
        logger.error("Duplicate registration for plugin " + name + ".");
    }
    pluginCtrlMap[name] = itemClass;
    pluginLoaderMap[name] = pluginClass;
    if (isDefault) {
        addItem(defaultPlugins, name);
    }
}
function unregisterPlugin(name) {
    delete pluginCtrlMap[name];
    delete pluginLoaderMap[name];
    removeItem(defaultPlugins, name);
}
var PluginSystem = /*#__PURE__*/ function() {
    function PluginSystem(pluginNames) {
        var loaders = {};
        var loaded = [];
        var addLoader = function(name) {
            var loader = pluginLoaderMap[name];
            if (!loaded.includes(loader)) {
                loaded.push(loader);
                loaders[name] = loader;
            }
        };
        defaultPlugins.forEach(addLoader);
        pluginNames.forEach(addLoader);
        this.plugins = Object.keys(loaders).map(function(name) {
            var CTRL = pluginLoaderMap[name];
            if (!CTRL) {
                throw new Error("The plugin '" + name + "' not found." + getPluginUsageInfo(name));
            }
            var loader = new CTRL();
            loader.name = name;
            return loader;
        }).sort(function(a, b) {
            return a.order - b.order;
        });
    }
    var _proto = PluginSystem.prototype;
    _proto.initializeComposition = function initializeComposition(composition, scene) {
        this.plugins.forEach(function(loader) {
            return loader.onCompositionConstructed(composition, scene);
        });
    };
    _proto.destroyComposition = function destroyComposition(comp) {
        this.plugins.forEach(function(loader) {
            return loader.onCompositionDestroyed(comp);
        });
    };
    _proto.resetComposition = function resetComposition(comp, renderFrame) {
        this.plugins.forEach(function(loader) {
            return loader.onCompositionReset(comp, renderFrame);
        });
    };
    _proto.createPluginItem = function createPluginItem(name, props, composition) {
        var CTRL = pluginCtrlMap[name];
        if (!CTRL) {
            throw new Error("The plugin '" + name + "' does not have a registered constructor.");
        }
        var engine = composition.getEngine();
        var item = new CTRL(engine, props, composition);
        item.composition = composition;
        if (!_instanceof1(item, exports.VFXItem)) {
            throw new Error("The plugin '" + name + "' invalid constructor type.");
        }
        return item;
    };
    _proto.processRawJSON = function processRawJSON(json, options) {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    _this.callStatic("processRawJSON", json, options)
                ];
            });
        })();
    };
    _proto.callStatic = function callStatic(name) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        var _this = this;
        return _async_to_generator(function() {
            var pendings, plugins, i, plugin, ctrl, _ctrl_name, _ctrl_name1;
            return __generator(this, function(_state) {
                pendings = [];
                plugins = _this.plugins;
                for(i = 0; i < plugins.length; i++){
                    plugin = plugins[i];
                    ctrl = pluginLoaderMap[plugin.name];
                    if (name in ctrl) {
                        pendings.push(Promise.resolve((_ctrl_name1 = ctrl[name]) == null ? void 0 : (_ctrl_name = _ctrl_name1).call.apply(_ctrl_name, [].concat([
                            ctrl
                        ], args))));
                    }
                }
                return [
                    2,
                    Promise.all(pendings)
                ];
            });
        })();
    };
    _proto.precompile = function precompile(compositions, renderer, options) {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    _this.callStatic("precompile", compositions, renderer, options)
                ];
            });
        })();
    };
    _proto.loadResources = function loadResources(scene, options) {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    _this.callStatic("prepareResource", scene, options)
                ];
            });
        })();
    };
    return PluginSystem;
}();
var pluginInfoMap = {
    "alipay-downgrade": "@galacean/effects-plugin-alipay-downgrade",
    "editor-gizmo": "@galacean/effects-plugin-editor-gizmo",
    "tree": "@galacean/effects-plugin-model",
    "model": "@galacean/effects-plugin-model",
    "orientation-transformer": "@galacean/effects-plugin-orientation-transformer",
    "spine": "@galacean/effects-plugin-spine"
};
function getPluginUsageInfo(name) {
    var info = pluginInfoMap[name];
    if (info) {
        return "\n请按如下命令进行操作（Please follow the commands below to proceed）：\n1、使用 npm 安装插件（Install Plugin）：npm i " + info + "@latest --save\n2、导入插件（Import Plugin）：import '" + info + "'";
    } else {
        return "";
    }
}

var SerializationHelper = /*#__PURE__*/ function() {
    function SerializationHelper() {}
    SerializationHelper.collectSerializableObject = function collectSerializableObject(effectsObject, res) {
        if (res[effectsObject.getInstanceId()]) {
            return;
        }
        effectsObject.toData();
        res[effectsObject.getInstanceId()] = effectsObject;
        var serializedProperties = getMergedStore(effectsObject);
        if (serializedProperties) {
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(serializedProperties)), _step; !(_step = _iterator()).done;){
                var key = _step.value;
                // TODO 待移除，序列化属性通过 effectsObject 对象直接获取
                var value = effectsObject.taggedProperties[key];
                if (value === undefined) {
                    value = effectsObject[key];
                }
                if (EffectsObject.is(value)) {
                    SerializationHelper.collectSerializableObject(value, res);
                } else if (isArray(value)) {
                    for(var _iterator1 = _create_for_of_iterator_helper_loose(value), _step1; !(_step1 = _iterator1()).done;){
                        var arrayValue = _step1.value;
                        if (EffectsObject.is(arrayValue)) {
                            SerializationHelper.collectSerializableObject(arrayValue, res);
                        }
                    }
                } else if (isObject(value)) {
                    // 非 EffectsObject 对象只递归一层
                    for(var _iterator2 = _create_for_of_iterator_helper_loose(Object.keys(value)), _step2; !(_step2 = _iterator2()).done;){
                        var objectKey = _step2.value;
                        var objectValue = value[objectKey];
                        if (EffectsObject.is(objectValue)) {
                            SerializationHelper.collectSerializableObject(objectValue, res);
                        }
                    }
                }
            }
        }
    };
    SerializationHelper.serializeEffectObject = function serializeEffectObject(effectsObject) {
        // 持有所有需要序列化的引擎对象
        var serializableMap = {};
        var engine = effectsObject.engine;
        // 加入内存中已加载的资产数据，避免重复创建资产数据
        var serializedDatas = _extends({}, engine.jsonSceneData);
        // 递归收集所有需要序列化的对象
        SerializationHelper.collectSerializableObject(effectsObject, serializableMap);
        // 依次序列化
        for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(serializableMap)), _step; !(_step = _iterator()).done;){
            var guid = _step.value;
            var serializeObject = serializableMap[guid];
            if (!serializedDatas[serializeObject.getInstanceId()]) {
                serializedDatas[serializeObject.getInstanceId()] = {};
            }
            SerializationHelper.serializeTaggedProperties(serializeObject, serializedDatas[serializeObject.getInstanceId()]);
        }
        return serializedDatas;
    };
    SerializationHelper.serializeTaggedProperties = function serializeTaggedProperties(effectsObject, serializedData) {
        effectsObject.toData();
        if (!serializedData) {
            serializedData = {};
        }
        var serializedProperties = getMergedStore(effectsObject);
        if (serializedProperties) {
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(serializedProperties)), _step; !(_step = _iterator()).done;){
                var key = _step.value;
                var value = effectsObject[key];
                if (typeof value === "number" || typeof value === "string" || typeof value === "boolean" || SerializationHelper.checkTypedArray(value)) {
                    // TODO json 数据避免传 typedArray
                    serializedData[key] = value;
                } else if (isArray(value)) {
                    if (!serializedData[key]) {
                        serializedData[key] = [];
                    }
                    SerializationHelper.serializeArrayProperty(value, serializedData[key], 0);
                } else if (EffectsObject.is(value)) {
                    // TODO 处理 EffectsObject 递归序列化
                    serializedData[key] = {
                        id: value.getInstanceId()
                    };
                } else if (isObject(value)) {
                    if (!serializedData[key]) {
                        serializedData[key] = {};
                    }
                    SerializationHelper.serializeObjectProperty(value, serializedData[key], 0);
                }
            }
        }
        // TODO 待移除 tagggedProperties 为没有装饰器的临时方案
        for(var _iterator1 = _create_for_of_iterator_helper_loose(Object.keys(effectsObject.taggedProperties)), _step1; !(_step1 = _iterator1()).done;){
            var key1 = _step1.value;
            var value1 = effectsObject.taggedProperties[key1];
            if (typeof value1 === "number" || typeof value1 === "string" || typeof value1 === "boolean" || SerializationHelper.checkTypedArray(value1)) {
                // TODO json 数据避免传 typedArray
                serializedData[key1] = value1;
            } else if (isArray(value1)) {
                if (!serializedData[key1]) {
                    serializedData[key1] = [];
                }
                SerializationHelper.serializeArrayProperty(value1, serializedData[key1], 0);
            } else if (EffectsObject.is(value1)) {
                // TODO 处理 EffectsObject 递归序列化
                serializedData[key1] = {
                    id: value1.getInstanceId()
                };
            } else if (isObject(value1)) {
                if (!serializedData[key1]) {
                    serializedData[key1] = {};
                }
                SerializationHelper.serializeObjectProperty(value1, serializedData[key1], 0);
            }
        }
        return serializedData;
    };
    SerializationHelper.deserializeTaggedProperties = function deserializeTaggedProperties(serializedData, effectsObject) {
        var taggedProperties = effectsObject.taggedProperties;
        var serializedProperties = getMergedStore(effectsObject);
        var engine = effectsObject.engine;
        for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(serializedData)), _step; !(_step = _iterator()).done;){
            var key = _step.value;
            if (serializedProperties && serializedProperties[key]) {
                continue;
            }
            var value = serializedData[key];
            taggedProperties[key] = SerializationHelper.deserializeProperty(value, engine, 0);
        }
        if (serializedProperties) {
            for(var _iterator1 = _create_for_of_iterator_helper_loose(Object.keys(serializedProperties)), _step1; !(_step1 = _iterator1()).done;){
                var key1 = _step1.value;
                var value1 = serializedData[key1];
                if (value1 === undefined) {
                    continue;
                }
                var propertyType = serializedProperties[key1].type;
                // FIXME: taggedProperties 为 readonly，这里存在强制赋值
                // @ts-expect-error
                effectsObject[key1] = SerializationHelper.deserializeProperty(value1, engine, 0, propertyType);
            }
        }
        effectsObject.fromData(taggedProperties);
    };
    SerializationHelper.deserializeTaggedPropertiesAsync = function deserializeTaggedPropertiesAsync(serializedData, effectsObject) {
        return _async_to_generator(function() {
            var taggedProperties, serializedProperties, engine, _iterator, _step, key, value, _iterator1, _step1, key1, value1, propertyType;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        taggedProperties = effectsObject.taggedProperties;
                        serializedProperties = getMergedStore(effectsObject);
                        engine = effectsObject.engine;
                        _iterator = _create_for_of_iterator_helper_loose(Object.keys(serializedData));
                        _state.label = 1;
                    case 1:
                        if (!!(_step = _iterator()).done) return [
                            3,
                            4
                        ];
                        key = _step.value;
                        if (serializedProperties && serializedProperties[key]) {
                            return [
                                3,
                                3
                            ];
                        }
                        value = serializedData[key];
                        return [
                            4,
                            SerializationHelper.deserializePropertyAsync(value, engine, 0)
                        ];
                    case 2:
                        taggedProperties[key] = _state.sent();
                        _state.label = 3;
                    case 3:
                        return [
                            3,
                            1
                        ];
                    case 4:
                        if (!serializedProperties) return [
                            3,
                            8
                        ];
                        _iterator1 = _create_for_of_iterator_helper_loose(Object.keys(serializedProperties));
                        _state.label = 5;
                    case 5:
                        if (!!(_step1 = _iterator1()).done) return [
                            3,
                            8
                        ];
                        key1 = _step1.value;
                        value1 = serializedData[key1];
                        if (value1 === undefined) {
                            return [
                                3,
                                7
                            ];
                        }
                        propertyType = serializedProperties[key1].type;
                        return [
                            4,
                            SerializationHelper.deserializePropertyAsync(value1, engine, 0, propertyType)
                        ];
                    case 6:
                        // FIXME: taggedProperties 为 readonly，这里存在强制赋值
                        // @ts-expect-error
                        effectsObject[key1] = _state.sent();
                        _state.label = 7;
                    case 7:
                        return [
                            3,
                            5
                        ];
                    case 8:
                        effectsObject.fromData(taggedProperties);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    SerializationHelper.checkTypedArray = function checkTypedArray(obj) {
        return _instanceof1(obj, Int8Array) || _instanceof1(obj, Uint8Array) || _instanceof1(obj, Uint8ClampedArray) || _instanceof1(obj, Int16Array) || _instanceof1(obj, Uint16Array) || _instanceof1(obj, Int32Array) || _instanceof1(obj, Uint32Array) || _instanceof1(obj, Float32Array) || _instanceof1(obj, Float64Array) || _instanceof1(obj, ArrayBuffer);
    };
    // check value is { id: 7e69662e964e4892ae8933f24562395b }
    SerializationHelper.checkDataPath = function checkDataPath(value) {
        return !!(isObject(value) && Object.keys(value).length === 1 && "id" in value && isString(value.id) && value.id.length === 32);
    };
    // TODO 测试函数，2.0 上线后移除
    SerializationHelper.checkGLTFNode = function checkGLTFNode(value) {
        return isObject(value) && value.nodeIndex !== undefined && value.isJoint !== undefined;
    };
    SerializationHelper.checkImageSource = function checkImageSource(value) {
        return isCanvas(value) || _instanceof1(value, douyin.HTMLImageElement);
    };
    SerializationHelper.deserializeProperty = function deserializeProperty(property, engine, level, type) {
        if (level > 14) {
            console.error("The nested object layers of the serialized data exceed the maximum limit.");
            return;
        }
        // 加载并链接 DataPath 字段表示的 EffectsObject 引用。Class 对象 copy [key, value] 会丢失对象信息，因此只递归数组对象和普通 js Object 结构对象。
        if (isArray(property)) {
            var res = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(property), _step; !(_step = _iterator()).done;){
                var value = _step.value;
                res.push(SerializationHelper.deserializeProperty(value, engine, level + 1, type));
            }
            return res;
        // TODO json 数据避免传 typedArray
        } else if (SerializationHelper.checkDataPath(property)) {
            return engine.assetLoader.loadGUID(property.id);
        } else if (isObject(property) && property.constructor === Object) {
            var res1;
            if (type) {
                res1 = new type();
            } else {
                res1 = {};
            }
            for(var _iterator1 = _create_for_of_iterator_helper_loose(Object.keys(property)), _step1; !(_step1 = _iterator1()).done;){
                var key = _step1.value;
                res1[key] = SerializationHelper.deserializeProperty(property[key], engine, level + 1);
            }
            return res1;
        } else {
            return property;
        }
    };
    SerializationHelper.deserializePropertyAsync = function deserializePropertyAsync(property, engine, level, type) {
        return _async_to_generator(function() {
            var res, _iterator, _step, value, _, res1, res2, _iterator1, _step1, key;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (level > 14) {
                            console.error("The nested object layers of the serialized data exceed the maximum limit.");
                            return [
                                2
                            ];
                        }
                        if (!isArray(property)) return [
                            3,
                            5
                        ];
                        res = [];
                        _iterator = _create_for_of_iterator_helper_loose(property);
                        _state.label = 1;
                    case 1:
                        if (!!(_step = _iterator()).done) return [
                            3,
                            4
                        ];
                        value = _step.value;
                        _ = res.push;
                        return [
                            4,
                            SerializationHelper.deserializePropertyAsync(value, engine, level + 1, type)
                        ];
                    case 2:
                        _.apply(res, [
                            _state.sent()
                        ]);
                        _state.label = 3;
                    case 3:
                        return [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            res
                        ];
                    case 5:
                        if (!SerializationHelper.checkDataPath(property)) return [
                            3,
                            7
                        ];
                        return [
                            4,
                            engine.assetLoader.loadGUIDAsync(property.id)
                        ];
                    case 6:
                        res1 = _state.sent();
                        return [
                            2,
                            res1
                        ];
                    case 7:
                        if (!(isObject(property) && property.constructor === Object)) return [
                            3,
                            12
                        ];
                        if (type) {
                            res2 = new type();
                        } else {
                            res2 = {};
                        }
                        _iterator1 = _create_for_of_iterator_helper_loose(Object.keys(property));
                        _state.label = 8;
                    case 8:
                        if (!!(_step1 = _iterator1()).done) return [
                            3,
                            11
                        ];
                        key = _step1.value;
                        return [
                            4,
                            SerializationHelper.deserializePropertyAsync(property[key], engine, level + 1)
                        ];
                    case 9:
                        res2[key] = _state.sent();
                        _state.label = 10;
                    case 10:
                        return [
                            3,
                            8
                        ];
                    case 11:
                        return [
                            2,
                            res2
                        ];
                    case 12:
                        return [
                            2,
                            property
                        ];
                    case 13:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    SerializationHelper.serializeObjectProperty = function serializeObjectProperty(objectProperty, serializedData, level) {
        if (level > 14) {
            console.error("The nested object layers of the serialized data exceed the maximum limit.");
            return;
        }
        if (!serializedData) {
            serializedData = {};
        }
        for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(objectProperty)), _step; !(_step = _iterator()).done;){
            var key = _step.value;
            var value = objectProperty[key];
            if (typeof value === "number" || typeof value === "string" || typeof value === "boolean" || SerializationHelper.checkTypedArray(objectProperty)) {
                // TODO json 数据避免传 typedArray
                serializedData[key] = value;
            } else if (isArray(value)) {
                if (!serializedData[key]) {
                    serializedData[key] = [];
                }
                SerializationHelper.serializeArrayProperty(value, serializedData[key], level + 1);
            } else if (EffectsObject.is(value)) {
                // TODO 处理 EffectsObject 递归序列化
                serializedData[key] = {
                    id: value.getInstanceId()
                };
            } else if (isObject(value)) {
                if (!serializedData[key]) {
                    serializedData[key] = {};
                }
                SerializationHelper.serializeObjectProperty(value, serializedData[key], level + 1);
            }
        }
    };
    SerializationHelper.serializeArrayProperty = function serializeArrayProperty(arrayProperty, serializedData, level) {
        if (level > 14) {
            console.error("The nested object layers of the serialized data exceed the maximum limit.");
            return;
        }
        if (!serializedData) {
            serializedData = [];
        }
        for(var i = 0; i < arrayProperty.length; i++){
            var value = arrayProperty[i];
            if (typeof value === "number" || typeof value === "string" || typeof value === "boolean" || SerializationHelper.checkTypedArray(arrayProperty)) {
                // TODO json 数据避免传 typedArray
                serializedData[i] = value;
            } else if (isArray(value)) {
                if (!serializedData[i]) {
                    serializedData[i] = [];
                }
                SerializationHelper.serializeArrayProperty(value, serializedData[i], level + 1);
            } else if (EffectsObject.is(value)) {
                // TODO 处理 EffectsObject 递归序列化
                serializedData[i] = {
                    id: value.getInstanceId()
                };
            } else if (isObject(value)) {
                if (!serializedData[i]) {
                    serializedData[i] = {};
                }
                SerializationHelper.serializeObjectProperty(value, serializedData[i], level + 1);
            }
        }
    };
    return SerializationHelper;
}();

/**
 * @since 2.0.0
 */ var AssetLoader = /*#__PURE__*/ function() {
    function AssetLoader(engine) {
        this.engine = engine;
    }
    var _proto = AssetLoader.prototype;
    _proto.loadGUID = function loadGUID(guid) {
        if (this.engine.objectInstance[guid]) {
            return this.engine.objectInstance[guid];
        }
        var effectsObjectData = this.findData(guid);
        var effectsObject;
        if (!effectsObjectData) {
            console.error("Object data with uuid: " + guid + " not found.");
            return undefined;
        }
        switch(effectsObjectData.dataType){
            case DataType.Material:
                effectsObject = Material.create(this.engine);
                break;
            case DataType.Geometry:
                effectsObject = Geometry.create(this.engine);
                break;
            case DataType.Texture:
                effectsObject = Texture.create(this.engine);
                break;
            default:
                {
                    var classConstructor = AssetLoader.getClass(effectsObjectData.dataType);
                    if (classConstructor) {
                        effectsObject = new classConstructor(this.engine);
                    }
                }
        }
        if (!effectsObject) {
            console.error("Constructor for DataType: " + effectsObjectData.dataType + " not found.");
            return undefined;
        }
        effectsObject.setInstanceId(effectsObjectData.id);
        this.engine.addInstance(effectsObject);
        SerializationHelper.deserializeTaggedProperties(effectsObjectData, effectsObject);
        return effectsObject;
    };
    // 加载本地文件资产
    _proto.loadGUIDAsync = function loadGUIDAsync(guid) {
        var _this = this;
        return _async_to_generator(function() {
            var effectsObjectData, effectsObject, classConstructor;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (_this.engine.objectInstance[guid]) {
                            return [
                                2,
                                _this.engine.objectInstance[guid]
                            ];
                        }
                        effectsObjectData = _this.findData(guid);
                        if (!!effectsObjectData) return [
                            3,
                            2
                        ];
                        if (!_this.engine.database) {
                            console.error("Object data with uuid: " + guid + " not found.");
                            return [
                                2,
                                undefined
                            ];
                        }
                        return [
                            4,
                            _this.engine.database.loadGUID(guid)
                        ];
                    case 1:
                        effectsObject = _state.sent();
                        if (!effectsObject) {
                            console.error("Disk data with uuid: " + guid + " not found.");
                            return [
                                2,
                                undefined
                            ];
                        }
                        _this.engine.addInstance(effectsObject);
                        return [
                            2,
                            effectsObject
                        ];
                    case 2:
                        switch(effectsObjectData.dataType){
                            case DataType.Material:
                                effectsObject = Material.create(_this.engine);
                                break;
                            case DataType.Geometry:
                                effectsObject = Geometry.create(_this.engine);
                                break;
                            case DataType.Texture:
                                effectsObject = Texture.create(_this.engine);
                                break;
                            default:
                                {
                                    classConstructor = AssetLoader.getClass(effectsObjectData.dataType);
                                    if (classConstructor) {
                                        effectsObject = new classConstructor(_this.engine);
                                    }
                                }
                        }
                        if (!effectsObject) {
                            console.error("Constructor for DataType: " + effectsObjectData.dataType + " not found.");
                            return [
                                2,
                                undefined
                            ];
                        }
                        effectsObject.setInstanceId(effectsObjectData.id);
                        _this.engine.addInstance(effectsObject);
                        return [
                            4,
                            SerializationHelper.deserializeTaggedPropertiesAsync(effectsObjectData, effectsObject)
                        ];
                    case 3:
                        _state.sent();
                        return [
                            2,
                            effectsObject
                        ];
                }
            });
        })();
    };
    _proto.findData = function findData(uuid) {
        return this.engine.jsonSceneData[uuid];
    };
    AssetLoader.getClass = function getClass(dataType) {
        return effectsClassStore[dataType];
    };
    return AssetLoader;
}();
var Database = /*#__PURE__*/ function() {
    function Database() {}
    var _proto = Database.prototype;
    _proto.loadGUID = function loadGUID(guid) {
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    undefined
                ];
            });
        })();
    };
    return Database;
}();

function arrAdd(arr, item) {
    if (!arr.includes(item)) {
        arr.push(item);
        return true;
    }
}
function ensureFixedNumber(a) {
    if (Number.isFinite(a)) {
        return [
            ValueType.CONSTANT,
            a
        ];
    }
    if (a) {
        var valueType = a[0];
        var valueData = a[1];
        if (Array.isArray(valueType)) {
            // 没有数据类型的数据
            return;
        }
        if (valueType === "static" || valueType === ValueType.CONSTANT) {
            return [
                ValueType.CONSTANT,
                a[1]
            ];
        }
        if (valueType === "lines") {
            return [
                ValueType.LINE,
                a[1]
            ];
        }
        if (valueType === ValueType.LINE) {
            // @ts-expect-error
            var keyframes = valueData.map(function(data) {
                return [
                    BezierKeyframeType.LINE,
                    data
                ];
            });
            return [
                ValueType.BEZIER_CURVE,
                keyframes
            ];
        }
        if (valueType === "curve" || valueType === ValueType.CURVE) {
            return [
                ValueType.BEZIER_CURVE,
                getBezierCurveFromHermiteInGE(valueData)
            ];
        }
        return a;
    }
}
function ensureFixedNumberWithRandom(a, p) {
    if (Array.isArray(a) && a[0] === "random") {
        return [
            ValueType.CONSTANT,
            a[1][p]
        ];
    }
    return ensureFixedNumber(a);
}
function ensureRGBAValue(a) {
    if (a && a[0] === "color") {
        return colorToArr(a[1], true);
    }
    return [
        1,
        1,
        1,
        1
    ];
}
function ensureColorExpression(a, normalized) {
    if (a) {
        if (a[0] === "colors") {
            return [
                ValueType.COLORS,
                a[1].map(function(color) {
                    return colorToArr(color, normalized);
                })
            ];
        } else if (a[0] === "gradient") {
            return ensureGradient(a[1], normalized);
        } else if (a[0] === "color") {
            return [
                ValueType.RGBA_COLOR,
                colorToArr(a[1], normalized)
            ];
        }
        return a;
    }
}
function ensureNumberExpression(a) {
    if (a && a[0] === "random") {
        return [
            ValueType.RANDOM,
            a[1]
        ];
    }
    return ensureFixedNumber(a);
}
function ensureGradient(a, normalized) {
    if (a) {
        var stops = [];
        Object.getOwnPropertyNames(a).forEach(function(p) {
            var stop = parsePercent(p);
            var color = colorToArr(a[p], normalized);
            stops.push([
                stop,
                color[0],
                color[1],
                color[2],
                color[3]
            ]);
        });
        stops = stops.sort(function(a, b) {
            return a[0] - b[0];
        });
        return [
            ValueType.GRADIENT_COLOR,
            stops
        ];
    }
}
function colorToArr(hex, normalized) {
    var ret;
    if (typeof hex === "string") {
        hex = hex.replace(/[\s\t\r\n]/g, "");
        var m = /rgba?\(([.\d]+),([.\d]+),([.\d]+),?([.\d]+)?\)/.exec(hex);
        if (m) {
            var a = +m[4];
            ret = [
                +m[1],
                +m[2],
                +m[3],
                isNaN(a) ? 255 : Math.round(a * 255)
            ];
        } else if (/^#[a-f\d]{3}$/i.test(hex)) {
            ret = [
                parseInt(hex[1] + hex[1], 16),
                parseInt(hex[2] + hex[2], 16),
                parseInt(hex[3] + hex[3], 16),
                255
            ];
        // eslint-disable-next-line no-cond-assign
        } else if (m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)) {
            ret = [
                parseInt(m[1], 16),
                parseInt(m[2], 16),
                parseInt(m[3], 16),
                255
            ] || [
                0,
                0,
                0,
                255
            ];
        }
    } else if (_instanceof1(hex, Array)) {
        ret = [
            hex[0],
            hex[1],
            hex[2],
            isNaN(hex[3]) ? 255 : Math.round(hex[3] * 255)
        ];
    }
    if (normalized) {
        // @ts-expect-error
        ret = normalizeColor(ret);
    }
    // @ts-expect-error
    return ret;
}
function normalizeColor(a) {
    if (Array.isArray(a)) {
        return a.map(function(i) {
            return Number.isFinite(i / 255) ? Number((i / 255).toFixed(6)) : 0;
        });
    }
}
function parsePercent(c) {
    var match = /^(-)?([\d+.]+)%$/.exec(c);
    if (match) {
        return +match[2] / 100 * (match[1] ? -1 : 1);
    }
    return +c;
}
function getGradientColor(color, normalized) {
    if (Array.isArray(color)) {
        if (color[0] === ValueType.GRADIENT_COLOR) {
            return color;
        }
        // @ts-expect-error
        return (color[0] === "gradient" || color[0] === "color") && ensureGradient(color[1], normalized);
    } else {
        return ensureGradient(color, normalized);
    }
}
function ensureFixedVec3(a) {
    if (a) {
        if (a.length === 3) {
            return [
                ValueType.CONSTANT_VEC3,
                a
            ];
        }
        var valueType = a[0];
        if (valueType === "path" || valueType === "bezier" || valueType === ValueType.BEZIER_PATH || valueType === ValueType.LINEAR_PATH) {
            var valueData = a[1];
            var easing = valueData[0];
            var points = valueData[1];
            var controlPoints = valueData[2];
            var bezierEasing = getBezierCurveFromHermiteInGE(easing);
            // linear path没有controlPoints
            if (!controlPoints) {
                controlPoints = [];
                for(var keyframeIndex = 0; keyframeIndex < points.length; keyframeIndex++){
                    var point = points[keyframeIndex].slice();
                    if (keyframeIndex === 0) {
                        controlPoints.push(point);
                    } else if (keyframeIndex < points.length - 1) {
                        controlPoints.push(point);
                        controlPoints.push(point);
                    } else {
                        controlPoints.push(point);
                    }
                }
            }
            return [
                ValueType.BEZIER_CURVE_PATH,
                [
                    bezierEasing,
                    points,
                    controlPoints
                ]
            ];
        }
        return a;
    }
}
function objectValueToNumber(o) {
    for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(o)), _step; !(_step = _iterator()).done;){
        var key = _step.value;
        o[key] = Number(o[key]);
    }
    return o;
}
function deleteEmptyValue(o) {
    for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(o)), _step; !(_step = _iterator()).done;){
        var key = _step.value;
        if (o[key] === undefined) {
            delete o[key];
        }
    }
    return o;
}
var cos = Math.cos;
var sin = Math.sin;
var d2r = Math.PI / 180;
var r2d = 180 / Math.PI;
function quatFromXYZRotation(out, x, y, z) {
    var c1 = cos(x * d2r / 2);
    var c2 = cos(y * d2r / 2);
    var c3 = cos(z * d2r / 2);
    var s1 = sin(x * d2r / 2);
    var s2 = sin(y * d2r / 2);
    var s3 = sin(z * d2r / 2);
    out[0] = s1 * c2 * c3 + c1 * s2 * s3;
    out[1] = c1 * s2 * c3 - s1 * c2 * s3;
    out[2] = c1 * c2 * s3 + s1 * s2 * c3;
    out[3] = c1 * c2 * c3 - s1 * s2 * s3;
    return out;
}
function clamp(v, min, max) {
    return v > max ? max : v < min ? min : v;
}
function rotationZYXFromQuat(out, quat) {
    var x = quat[0];
    var y = quat[1];
    var z = quat[2];
    var w = quat[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var m11 = 1 - yy - zz, m12 = yx - wz;
    var m21 = yx + wz, m22 = 1 - xx - zz;
    var m31 = zx - wy, m32 = zy + wx, m33 = 1 - xx - yy;
    out[1] = Math.asin(clamp(-m31, -1, 1)) * r2d;
    if (Math.abs(m31) < 0.9999999) {
        out[0] = Math.atan2(m32, m33) * r2d;
        out[2] = Math.atan2(m21, m11) * r2d;
    } else {
        out[0] = 0;
        out[2] = Math.atan2(-m12, m22) * r2d;
    }
    return out;
}
/**
 * 提取并转换 JSON 数据中的 anchor 值
 */ function convertAnchor(anchor, particleOrigin) {
    if (anchor) {
        return [
            anchor[0] - 0.5,
            0.5 - anchor[1]
        ];
    } else if (particleOrigin) {
        return particleOriginTranslateMap[particleOrigin];
    } else {
        return [
            0,
            0
        ];
    }
}
var _obj$5;
var particleOriginTranslateMap = (_obj$5 = {}, _obj$5[ParticleOrigin.PARTICLE_ORIGIN_CENTER] = [
    0,
    0
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_CENTER_BOTTOM] = [
    0,
    -0.5
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_CENTER_TOP] = [
    0,
    0.5
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_LEFT_TOP] = [
    -0.5,
    0.5
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_LEFT_CENTER] = [
    -0.5,
    0
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_LEFT_BOTTOM] = [
    -0.5,
    -0.5
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_CENTER] = [
    0.5,
    0
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_BOTTOM] = [
    0.5,
    -0.5
], _obj$5[ParticleOrigin.PARTICLE_ORIGIN_RIGHT_TOP] = [
    0.5,
    0.5
], _obj$5);
function getBezierCurveFromHermite(m0, m1, p0, p3) {
    var xStart = p0[0];
    var yStart = p0[1];
    var xEnd = p3[0];
    var yEnd = p3[1];
    var dt = xEnd - xStart;
    m0 = m0 * dt;
    m1 = m1 * dt;
    var bezierControlPoints = [
        [
            xStart + (xEnd - xStart) / 3,
            yStart + m0 / 3
        ],
        [
            xEnd - (xEnd - xStart) / 3,
            yEnd - m1 / 3
        ]
    ];
    return bezierControlPoints;
}
function getBezierCurveFromHermiteInGE(geHermiteCurves) {
    var ymax = -1000000;
    var ymin = 1000000;
    for(var i = 0; i < geHermiteCurves.length; i++){
        ymax = Math.max(ymax, geHermiteCurves[i][1]);
        ymin = Math.min(ymin, geHermiteCurves[i][1]);
    }
    var geBezierCurves = [
        [
            geHermiteCurves[0][0],
            geHermiteCurves[0][1]
        ]
    ];
    for(var i1 = 0; i1 < geHermiteCurves.length - 1; i1++){
        var m0 = geHermiteCurves[i1][3] * (ymax - ymin);
        var m1 = geHermiteCurves[i1 + 1][2] * (ymax - ymin);
        var p0 = [
            geHermiteCurves[i1][0],
            geHermiteCurves[i1][1]
        ];
        var p3 = [
            geHermiteCurves[i1 + 1][0],
            geHermiteCurves[i1 + 1][1]
        ];
        if (p0[0] != p3[0]) {
            var bezierControlPoints = getBezierCurveFromHermite(m0, m1, p0, p3);
            var p1 = bezierControlPoints[0];
            var p2 = bezierControlPoints[1];
            geBezierCurves[geBezierCurves.length - 1].push(p1[0]);
            geBezierCurves[geBezierCurves.length - 1].push(p1[1]);
            geBezierCurves.push([
                p2[0],
                p2[1],
                p3[0],
                p3[1]
            ]);
        } else {
            geBezierCurves[geBezierCurves.length - 1].push(p3[0]);
            geBezierCurves[geBezierCurves.length - 1].push(p3[1]);
        }
    }
    // 添加关键帧类型
    return geBezierCurves.map(function(curve, index) {
        return index === 0 ? [
            BezierKeyframeType.EASE_OUT,
            curve
        ] : index === geBezierCurves.length - 1 ? [
            BezierKeyframeType.EASE_IN,
            curve
        ] : [
            BezierKeyframeType.EASE,
            curve
        ];
    });
}

function getStandardCameraContent(model) {
    var _model_transform;
    var opt = model.options;
    var ret = {
        options: {
            fov: opt.fov,
            far: opt.far,
            near: opt.near,
            clipMode: opt.clipMode
        }
    };
    var velocityOverLifetime = model.velocityOverLifetime;
    if (velocityOverLifetime || ((_model_transform = model.transform) == null ? void 0 : _model_transform.path)) {
        var _model_transform1;
        var positionOverLifetime = {
            path: ensureFixedVec3((_model_transform1 = model.transform) == null ? void 0 : _model_transform1.path),
            linearX: ensureFixedNumber(velocityOverLifetime == null ? void 0 : velocityOverLifetime.translateX),
            linearY: ensureFixedNumber(velocityOverLifetime == null ? void 0 : velocityOverLifetime.translateY),
            linearZ: ensureFixedNumber(velocityOverLifetime == null ? void 0 : velocityOverLifetime.translateZ)
        };
        deleteEmptyValue(positionOverLifetime);
        ret.positionOverLifetime = positionOverLifetime;
    }
    var rol = model.rotationOverLifetime;
    if (rol) {
        var rotationOverLifetime = {
            separateAxes: rol.separateAxes,
            x: ensureFixedNumber(rol == null ? void 0 : rol.rotateX),
            y: ensureFixedNumber(rol == null ? void 0 : rol.rotateY),
            z: rol.separateAxes ? ensureFixedNumber(rol == null ? void 0 : rol.rotateZ) : ensureFixedNumber(rol.rotation)
        };
        deleteEmptyValue(rotationOverLifetime);
        ret.rotationOverLifetime = rotationOverLifetime;
    }
    return ret;
}

function getStandardInteractContent(ui) {
    var options = ui.options;
    var option;
    switch(options.type){
        case "click":
            {
                option = {
                    type: InteractType.CLICK,
                    showPreview: options.showPreview,
                    previewColor: options.previewColor && ensureRGBAValue(options.previewColor),
                    behavior: options.behavior || InteractBehavior.NOTIFY
                };
                break;
            }
        case "drag":
            {
                option = {
                    type: InteractType.DRAG,
                    enableInEditor: !!options.enableInEditor,
                    dxRange: options.dxRange,
                    dyRange: options.dyRange,
                    target: options.target
                };
                break;
            }
        case "message":
            {
                option = {
                    type: InteractType.MESSAGE
                };
                break;
            }
    }
    var ret = {
        // @ts-expect-error
        options: option
    };
    return ret;
}

/**
 * 2.1 以下版本数据适配（mars-player@2.4.0 及以上版本支持 2.1 以下数据的适配）
 */ function version21Migration(json) {
    json.compositions.forEach(function(composition) {
        composition.items.forEach(function(item) {
            if (item.type === ItemType.null) {
                if (item.endBehavior === EndBehavior.destroy) {
                    item.endBehavior = EndBehavior.freeze;
                }
            }
        });
    });
    json.version = "2.1";
    return json;
}
/**
 * 2.2 以下版本数据适配（mars-player@2.5.0 及以上版本支持 2.2 以下数据的适配）
 */ function version22Migration(json) {
    var _json_version;
    var singleVersion = (_json_version = json.version) == null ? void 0 : _json_version.split(".");
    if (!singleVersion || Number(singleVersion[0]) > 2 || Number(singleVersion[0]) === 2 && Number(singleVersion[1]) >= 2) {
        return json;
    }
    json.compositions.forEach(function(composition) {
        composition.items.forEach(function(item) {
            if (item.type === ItemType.mesh || item.type === ItemType.light) {
                item.endBehavior = item.endBehavior === 1 ? EndBehavior.destroy : item.endBehavior;
            }
        });
    });
    return json;
}
/**
 * 3.0 以下版本数据适配（runtime 2.0及以上版本支持）
 */ function version30Migration(json) {
    var _loop = function() {
        var composition = _step1.value;
        // composition 的 endBehavior 兼容
        if (// @ts-expect-error
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        composition.endBehavior === END_BEHAVIOR_PAUSE_AND_DESTROY || // @ts-expect-error
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        composition.endBehavior === END_BEHAVIOR_PAUSE) {
            composition.endBehavior = END_BEHAVIOR_FREEZE;
        }
        // 过滤掉滤镜元素
        composition.items = composition.items.filter(function(item) {
            return item.type !== "8";
        });
        // 过滤掉粒子滤镜（扭曲）
        composition.items.forEach(function(item) {
            if (item.type === ItemType.particle) {
                // @ts-expect-error
                var filterData = item.content["filter"];
                if (filterData) {
                    // @ts-expect-error
                    delete item.content["filter"];
                }
            }
        });
        for(var _iterator = _create_for_of_iterator_helper_loose(composition.items), _step; !(_step = _iterator()).done;){
            var item = _step.value;
            itemOldIdToGuidMap[item.id] = generateGUID();
            // TODO: 编辑器测试用，上线后删除
            //@ts-expect-error
            item.oldId = item.id;
            item.id = itemOldIdToGuidMap[item.id];
            guidToItemMap[item.id] = item;
        }
        composition.items.forEach(function(item, index) {
            if (item.parentId) {
                if (item.parentId.includes("^")) {
                    var parentId = item.parentId.split("^")[0];
                    var nodeId = item.parentId.split("^")[1];
                    item.parentId = itemOldIdToGuidMap[parentId] + "^" + nodeId;
                } else {
                    item.parentId = itemOldIdToGuidMap[item.parentId];
                }
            }
            // @ts-expect-error fix item type
            result.items.push(item);
            // @ts-expect-error fix item type
            composition.items[index] = {
                id: item.id
            };
        });
        var compositionData = _extends({}, composition, {
            timelineAsset: {
                id: ""
            },
            sceneBindings: []
        });
        result.compositions.push(compositionData);
        // 生成时间轴数据
        convertTimelineAsset(compositionData, guidToItemMap, result);
    };
    var // 兼容老版本数据中不存在textures的情况
    _result;
    var result = _extends({}, json, {
        items: [],
        compositions: [],
        components: [],
        materials: [],
        shaders: [],
        geometries: [],
        animations: [],
        miscs: []
    });
    // image数据添加 guid
    for(var _iterator = _create_for_of_iterator_helper_loose(result.images), _step; !(_step = _iterator()).done;){
        var image = _step.value;
        image.id = generateGUID();
    }
    var _textures;
    (_textures = (_result = result).textures) != null ? _textures : _result.textures = [];
    result.textures.forEach(function(textureOptions) {
        var _result_images_textureOptions_source;
        textureOptions.id = generateGUID();
        textureOptions.dataType = DataType.Texture;
        // @ts-expect-error
        textureOptions.source = {
            id: (_result_images_textureOptions_source = result.images[textureOptions.source]) == null ? void 0 : _result_images_textureOptions_source.id
        };
    });
    if (result.textures.length < result.images.length) {
        for(var i = result.textures.length; i < result.images.length; i++){
            result.textures.push({
                id: generateGUID(),
                dataType: DataType.Texture,
                //@ts-expect-error
                source: {
                    id: result.images[i].id
                },
                flipY: true
            });
        }
    }
    // 处理老版本数据中 bins 没有 id 的情况
    if (json.bins) {
        convertBinaryAsset(json.bins, result);
    }
    var itemOldIdToGuidMap = {};
    var guidToItemMap = {};
    // 更正Composition.endBehavior
    for(var _iterator1 = _create_for_of_iterator_helper_loose(json.compositions), _step1; !(_step1 = _iterator1()).done;)_loop();
    for(var _iterator2 = _create_for_of_iterator_helper_loose(result.items), _step2; !(_step2 = _iterator2()).done;){
        var item = _step2.value;
        // 原 texture 索引转为统一 guid 索引
        if (item.content) {
            if (item.content.renderer) {
                if (item.content.renderer.texture !== undefined) {
                    var oldTextureId = item.content.renderer.texture;
                    item.content.renderer.texture = {
                        id: result.textures[oldTextureId].id
                    };
                }
            }
            if (item.content.trails) {
                if (item.content.trails.texture !== undefined) {
                    var oldTextureId1 = item.content.trails.texture;
                    item.content.trails.texture = {
                        id: result.textures[oldTextureId1].id
                    };
                }
            }
        }
        // item 的 transform 属性由数组转为 {x:n, y:n, z:n}
        if (item.transform) {
            var _item_transform_position;
            //@ts-expect-error
            var position = [].concat((_item_transform_position = item.transform.position) != null ? _item_transform_position : [
                0,
                0,
                0
            ]);
            var _item_transform_rotation;
            //@ts-expect-error
            var rotation = [].concat((_item_transform_rotation = item.transform.rotation) != null ? _item_transform_rotation : [
                0,
                0,
                0
            ]);
            var _item_transform_scale;
            //@ts-expect-error
            var scale = [].concat((_item_transform_scale = item.transform.scale) != null ? _item_transform_scale : [
                1,
                1,
                1
            ]);
            Object.assign(item, {
                transform: {
                    position: {
                        x: position[0],
                        y: position[1],
                        z: position[2]
                    },
                    eulerHint: {
                        x: rotation[0],
                        y: rotation[1],
                        z: rotation[2]
                    },
                    scale: {
                        x: scale[0],
                        y: scale[1],
                        z: scale[0]
                    }
                }
            });
            // sprite 的 scale 转为 size
            if (item.type === ItemType.sprite) {
                item.transform.size = {
                    x: scale[0],
                    y: scale[1]
                };
                item.transform.scale = {
                    x: 1,
                    y: 1,
                    z: 1
                };
            }
            // sprite 的 anchor 修正
            if (item.type === ItemType.sprite) {
                var content = item.content;
                if (!content.renderer) {
                    content.renderer = {};
                }
                var renderer = content.renderer;
                var realAnchor = convertAnchor(renderer.anchor, renderer.particleOrigin);
                var startSize = item.transform.size;
                // 兼容旧JSON（anchor和particleOrigin可能同时存在）
                if (!renderer.anchor && renderer.particleOrigin !== undefined) {
                    var _startSize_x;
                    item.transform.position.x += -realAnchor[0] * ((_startSize_x = startSize == null ? void 0 : startSize.x) != null ? _startSize_x : 1);
                    var _startSize_y;
                    item.transform.position.y += -realAnchor[1] * ((_startSize_y = startSize == null ? void 0 : startSize.y) != null ? _startSize_y : 1);
                }
                var _startSize_x1, _startSize_y1;
                item.transform.anchor = {
                    x: realAnchor[0] * ((_startSize_x1 = startSize == null ? void 0 : startSize.x) != null ? _startSize_x1 : 1),
                    y: realAnchor[1] * ((_startSize_y1 = startSize == null ? void 0 : startSize.y) != null ? _startSize_y1 : 1)
                };
            }
        }
        if (item.type === ItemType.particle) {
            var content1 = item.content;
            if (!content1.renderer) {
                content1.renderer = {};
            }
            var renderer1 = content1.renderer;
            content1.renderer.anchor = convertAnchor(renderer1.anchor, renderer1.particleOrigin);
        }
        // 修复相机K帧缺失 asMovement 参数
        if (item.type === ItemType.camera && item.content.positionOverLifetime && Object.keys(item.content.positionOverLifetime).length !== 0) {
            item.content.positionOverLifetime.asMovement = true;
        }
        // 修正老 json 的 item.pluginName
        if (item.pn !== undefined) {
            var pn = item.pn;
            var _json_plugins = json.plugins, plugins = _json_plugins === void 0 ? [] : _json_plugins;
            if (pn !== undefined && Number.isInteger(pn)) {
                item.pluginName = plugins[pn];
            }
        }
        // 修正老 json 的 item.type
        if (item.pluginName === "editor-gizmo") {
            //@ts-expect-error
            item.type = "editor-gizmo";
        }
        if (item.pluginName === "orientation-transformer") {
            //@ts-expect-error
            item.type = "orientation-transformer";
        }
        // gizmo 的 target id 转换为新的 item guid
        if (item.content.options.target && item.pluginName === "editor-gizmo") {
            item.content.options.target = itemOldIdToGuidMap[item.content.options.target];
        }
        // Spine 元素转为 guid 索引
        if (item.type === ItemType.spine && json.spines && json.spines.length !== 0) {
            convertSpineData(json.spines[item.content.options.spine], item.content, result);
        }
        // item 的 content 转为 component data 加入 JSONScene.components
        if (item.type === ItemType.sprite || item.type === ItemType.particle || item.type === ItemType.mesh || item.type === ItemType.skybox || item.type === ItemType.light || item.type === "camera" || item.type === ItemType.tree || item.type === ItemType.interact || item.type === ItemType.camera || item.type === ItemType.text || item.type === ItemType.spine || item.type === "editor-gizmo" || item.type === "orientation-transformer") {
            item.components = [];
            result.components.push(item.content);
            item.content.id = generateGUID();
            item.content.item = {
                id: item.id
            };
            item.dataType = DataType.VFXItemData;
            item.components.push({
                id: item.content.id
            });
        }
        if (item.type === ItemType.null || item.type === ItemType.composition) {
            item.components = [];
            item.dataType = DataType.VFXItemData;
        }
        switch(item.type){
            case ItemType.sprite:
                item.content.dataType = DataType.SpriteComponent;
                break;
            case ItemType.particle:
                item.content.dataType = DataType.ParticleSystem;
                break;
            case ItemType.mesh:
                item.content.dataType = DataType.MeshComponent;
                break;
            case ItemType.skybox:
                item.content.dataType = DataType.SkyboxComponent;
                break;
            case ItemType.light:
                item.content.dataType = DataType.LightComponent;
                break;
            case "camera":
                item.content.dataType = DataType.CameraComponent;
                break;
            case "editor-gizmo":
                item.content.dataType = "GizmoComponent";
                break;
            case "orientation-transformer":
                item.content.dataType = "OrientationComponent";
                break;
            case ItemType.tree:
                item.content.dataType = DataType.TreeComponent;
                break;
            case ItemType.interact:
                item.content.dataType = DataType.InteractComponent;
                break;
            case ItemType.camera:
                item.content.dataType = DataType.CameraController;
                break;
            case ItemType.text:
                item.content.dataType = DataType.TextComponent;
                break;
            case ItemType.spine:
                item.content.dataType = "SpineComponent";
                break;
        }
    }
    result.version = "3.0";
    return result;
}
/**
 * 2.5 以下版本 赫尔米特数据转换成贝塞尔数据
 */ function version24Migration(json) {
    // 曲线转换成贝塞尔
    json.compositions.map(function(comp) {
        for(var _iterator = _create_for_of_iterator_helper_loose(comp.items), _step; !(_step = _iterator()).done;){
            var item = _step.value;
            convertParam(item.content);
        }
    });
    return json;
}
function convertParam(content) {
    if (!content) {
        return;
    }
    for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(content)), _step; !(_step = _iterator()).done;){
        var key = _step.value;
        var value = content[key];
        var isArray = Array.isArray(value);
        if (isArray && value.length === 2 && Array.isArray(value[1])) {
            if (key === "path") {
                content[key] = ensureFixedVec3(value);
            } else {
                content[key] = ensureFixedNumber(value);
            }
        } else if (!isArray && typeof value === "object") {
            convertParam(value);
        }
    }
}
function convertTimelineAsset(composition, guidToItemMap, jsonScene) {
    var sceneBindings = [];
    var trackDatas = [];
    var playableAssetDatas = [];
    var timelineAssetData = {
        tracks: [],
        id: generateGUID(),
        //@ts-expect-error
        dataType: "TimelineAsset"
    };
    for(var _iterator = _create_for_of_iterator_helper_loose(composition.items), _step; !(_step = _iterator()).done;){
        var itemDataPath = _step.value;
        var item = guidToItemMap[itemDataPath.id];
        var subTrackDatas = [];
        var newActivationPlayableAsset = {
            id: generateGUID(),
            dataType: "ActivationPlayableAsset"
        };
        playableAssetDatas.push(newActivationPlayableAsset);
        var newActivationTrackData = {
            id: generateGUID(),
            dataType: "ActivationTrack",
            children: [],
            clips: [
                {
                    start: item.delay,
                    duration: item.duration,
                    endBehavior: item.endBehavior,
                    asset: {
                        id: newActivationPlayableAsset.id
                    }
                }
            ]
        };
        subTrackDatas.push({
            id: newActivationTrackData.id
        });
        trackDatas.push(newActivationTrackData);
        if (item.type !== ItemType.particle) {
            var newTransformPlayableAssetData = {
                id: generateGUID(),
                dataType: "TransformPlayableAsset",
                //@ts-expect-error
                sizeOverLifetime: item.content.sizeOverLifetime,
                //@ts-expect-error
                rotationOverLifetime: item.content.rotationOverLifetime,
                //@ts-expect-error
                positionOverLifetime: item.content.positionOverLifetime
            };
            playableAssetDatas.push(newTransformPlayableAssetData);
            var newTrackData = {
                id: generateGUID(),
                dataType: "TransformTrack",
                children: [],
                clips: [
                    {
                        start: item.delay,
                        duration: item.duration,
                        endBehavior: item.endBehavior,
                        asset: {
                            id: newTransformPlayableAssetData.id
                        }
                    }
                ]
            };
            subTrackDatas.push({
                id: newTrackData.id
            });
            trackDatas.push(newTrackData);
        }
        if (item.type === ItemType.sprite || item.type === ItemType.text) {
            var newSpriteColorPlayableAssetData = {
                id: generateGUID(),
                dataType: "SpriteColorPlayableAsset",
                colorOverLifetime: item.content.colorOverLifetime
            };
            playableAssetDatas.push(newSpriteColorPlayableAssetData);
            var newTrackData1 = {
                id: generateGUID(),
                dataType: "SpriteColorTrack",
                children: [],
                clips: [
                    {
                        start: item.delay,
                        duration: item.duration,
                        endBehavior: item.endBehavior,
                        asset: {
                            id: newSpriteColorPlayableAssetData.id
                        }
                    }
                ]
            };
            subTrackDatas.push({
                id: newTrackData1.id
            });
            trackDatas.push(newTrackData1);
        }
        if (item.type === ItemType.composition) {
            var newSubCompositionPlayableAssetData = {
                id: generateGUID(),
                dataType: "SubCompositionPlayableAsset"
            };
            playableAssetDatas.push(newSubCompositionPlayableAssetData);
            var newTrackData2 = {
                id: generateGUID(),
                dataType: "SubCompositionTrack",
                children: [],
                clips: [
                    {
                        start: item.delay,
                        duration: item.duration,
                        endBehavior: item.endBehavior,
                        asset: {
                            id: newSubCompositionPlayableAssetData.id
                        }
                    }
                ]
            };
            subTrackDatas.push({
                id: newTrackData2.id
            });
            trackDatas.push(newTrackData2);
        }
        var bindingTrackData = {
            id: generateGUID(),
            dataType: "ObjectBindingTrack",
            children: subTrackDatas,
            clips: []
        };
        trackDatas.push(bindingTrackData);
        timelineAssetData.tracks.push({
            id: bindingTrackData.id
        });
        sceneBindings.push({
            key: {
                id: bindingTrackData.id
            },
            value: {
                id: item.id
            }
        });
    }
    var trackIds = [];
    for(var _iterator1 = _create_for_of_iterator_helper_loose(trackDatas), _step1; !(_step1 = _iterator1()).done;){
        var trackData = _step1.value;
        trackIds.push({
            id: trackData.id
        });
    }
    composition.timelineAsset = {
        id: timelineAssetData.id
    };
    composition.sceneBindings = sceneBindings;
    jsonScene.miscs.push(timelineAssetData);
    for(var _iterator2 = _create_for_of_iterator_helper_loose(trackDatas), _step2; !(_step2 = _iterator2()).done;){
        var trackData1 = _step2.value;
        //@ts-expect-error
        jsonScene.miscs.push(trackData1);
    }
    for(var _iterator3 = _create_for_of_iterator_helper_loose(playableAssetDatas), _step3; !(_step3 = _iterator3()).done;){
        var playableAsset = _step3.value;
        //@ts-expect-error
        jsonScene.miscs.push(playableAsset);
    }
}
function convertBinaryAsset(bins, jsonScene) {
    //@ts-expect-error
    jsonScene.bins = bins.map(function(bin) {
        return {
            url: bin.url,
            "dataType": "BinaryAsset",
            id: generateGUID()
        };
    });
}
function convertSpineData(resource, content, jsonScene) {
    //@ts-expect-error
    content.resource = {
        "atlas": {
            "bins": {
                //@ts-expect-error
                "id": jsonScene.bins[resource.atlas[1][0]].id
            },
            "source": resource.atlas[1].slice(1)
        },
        "skeleton": {
            "bins": {
                //@ts-expect-error
                "id": jsonScene.bins[resource.skeleton[1][0]].id
            },
            "source": resource.skeleton[1].slice(1)
        },
        "skeletonType": resource.skeletonType,
        "images": resource.images.map(function(i) {
            return {
                //@ts-expect-error
                id: jsonScene.textures[i].id
            };
        })
    };
}

function getStandardParticleContent(particle) {
    var options = particle.options;
    var transform = particle.transform;
    var shape = {
        type: ShapeType.NONE
    };
    if (particle.shape) {
        var _particle_shape_shape;
        var shapeType = (_particle_shape_shape = particle.shape.shape) == null ? void 0 : _particle_shape_shape.replace(/([A-Z])/g, "_$1").toUpperCase().replace(/^_/, "");
        shape = _extends({}, particle.shape, {
            type: ShapeType[shapeType]
        });
        if (particle.shape.upDirection) {
            var _particle_shape_upDirection = particle.shape.upDirection, x = _particle_shape_upDirection[0], y = _particle_shape_upDirection[1], z = _particle_shape_upDirection[2];
            if (x === 0 && y === 0 && z === 0) {
                delete shape.upDirection;
            }
        }
    }
    if (options.startTurbulence) {
        shape.turbulenceX = ensureNumberExpression(options.turbulenceX);
        shape.turbulenceY = ensureNumberExpression(options.turbulenceY);
        shape.turbulenceZ = ensureNumberExpression(options.turbulenceZ);
    }
    var emission = particle.emission;
    if (emission.bursts && emission.bursts.length > 0) {
        emission.bursts = emission.bursts.map(function(b) {
            return objectValueToNumber(b);
        });
    }
    if (emission.burstOffsets && emission.burstOffsets.length > 0) {
        emission.burstOffsets = emission.burstOffsets.map(function(b) {
            return objectValueToNumber(b);
        });
    }
    if (emission.rateOverTime) {
        emission.rateOverTime = ensureNumberExpression(emission.rateOverTime);
    }
    var ret = {
        renderer: particle.renderer,
        shape: shape,
        splits: particle.splits,
        emission: emission,
        options: {
            startLifetime: ensureNumberExpression(options.startLifetime),
            start3DSize: !!options.start3DSize,
            startSize: ensureNumberExpression(options.startSize),
            startSizeX: ensureNumberExpression(options.startSizeX),
            startSizeY: ensureNumberExpression(options.startSizeY),
            sizeAspect: ensureNumberExpression(options.sizeAspect),
            maxCount: options.maxCount,
            startDelay: ensureNumberExpression(options.startDelay),
            startColor: ensureColorExpression(options.startColor, true),
            startRotationZ: ensureNumberExpression(options.startRotation || options.startRotationZ),
            particleFollowParent: options.particleFollowParent
        }
    };
    if (options.start3DRotation) {
        ret.options.startRotationX = ensureNumberExpression(options.startRotationX);
        ret.options.startRotationY = ensureNumberExpression(options.startRotationY);
    }
    if (transform && transform.path) {
        ret.emitterTransform = {
            path: ensureFixedVec3(transform.path)
        };
    }
    var sizeOverLifetime = particle.sizeOverLifetime;
    if (sizeOverLifetime) {
        if (sizeOverLifetime.separateAxes) {
            ret.sizeOverLifetime = {
                separateAxes: true,
                x: ensureNumberExpression(sizeOverLifetime.x),
                y: ensureNumberExpression(sizeOverLifetime.y)
            };
        } else {
            ret.sizeOverLifetime = {
                size: ensureNumberExpression(sizeOverLifetime.size)
            };
        }
    }
    var velocityOverLifetime = particle.velocityOverLifetime || {};
    var sol = velocityOverLifetime.speedOverLifetime;
    if (sol) {
        sol = ensureFixedNumber(sol);
    } else {
        sol = undefined;
    }
    ret.positionOverLifetime = {
        gravity: options.gravity,
        gravityOverLifetime: ensureFixedNumber(options.gravityModifier),
        startSpeed: ensureNumberExpression(options.startSpeed),
        speedOverLifetime: sol,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureNumberExpression(velocityOverLifetime.linearX),
        linearY: ensureNumberExpression(velocityOverLifetime.linearY),
        linearZ: ensureNumberExpression(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureNumberExpression(velocityOverLifetime.orbitalX),
        orbitalY: ensureNumberExpression(velocityOverLifetime.orbitalY),
        orbitalZ: ensureNumberExpression(velocityOverLifetime.orbitalZ),
        forceTarget: velocityOverLifetime.forceTarget,
        target: velocityOverLifetime.target,
        forceCurve: ensureFixedNumber(velocityOverLifetime.forceCurve)
    };
    deleteEmptyValue(ret.positionOverLifetime);
    var rotationOverLifetime = particle.rotationOverLifetime;
    if (rotationOverLifetime) {
        ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation,
            z: ensureNumberExpression(rotationOverLifetime.separateAxes ? rotationOverLifetime.z : rotationOverLifetime.angularVelocity)
        };
        if (rotationOverLifetime.separateAxes) {
            ret.rotationOverLifetime.y = ensureFixedNumber(rotationOverLifetime.y);
            ret.rotationOverLifetime.x = ensureFixedNumber(rotationOverLifetime.x);
        }
    }
    var colorOverLifetime = particle.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity)
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var textureSheetAnimation = particle.textureSheetAnimation;
    if (textureSheetAnimation) {
        ret.textureSheetAnimation = {
            row: textureSheetAnimation.row,
            col: textureSheetAnimation.col,
            total: textureSheetAnimation.total,
            animate: textureSheetAnimation.animate,
            cycles: ensureFixedNumber(textureSheetAnimation.cycles),
            animationDelay: ensureFixedNumberWithRandom(textureSheetAnimation.animationDelay, 0),
            animationDuration: ensureFixedNumberWithRandom(textureSheetAnimation.animationDuration, 0)
        };
    }
    var trials = particle.trails;
    if (trials) {
        ret.trails = {
            lifetime: ensureNumberExpression(trials.lifetime),
            dieWithParticles: trials.dieWithParticles,
            maxPointPerTrail: trials.maxPointPerTrail,
            minimumVertexDistance: trials.minimumVertexDistance,
            widthOverTrail: ensureFixedNumber(trials.widthOverTrail),
            colorOverTrail: trials.colorOverTrail && getGradientColor(trials.colorOverTrail, false),
            blending: trials.blending,
            colorOverLifetime: trials.colorOverLifetime && getGradientColor(trials.colorOverLifetime, false),
            inheritParticleColor: trials.inheritParticleColor,
            occlusion: trials.occlusion,
            transparentOcclusion: trials.transparentOcclusion,
            orderOffset: trials.orderOffset,
            sizeAffectsLifetime: trials.sizeAffectsLifetime,
            sizeAffectsWidth: trials.sizeAffectsWidth,
            texture: trials.texture,
            parentAffectsPosition: trials.parentAffectsPosition,
            opacityOverLifetime: ensureNumberExpression(trials.opacityOverLifetime)
        };
    }
    ret.trails && deleteEmptyValue(ret.trails);
    var interaction = particle.interaction;
    if (interaction) {
        ret.interaction = {
            behavior: interaction.behavior,
            radius: interaction.radius,
            multiple: interaction.multiple
        };
    }
    return ret;
}

function getStandardNullContent(sprite, transform) {
    var _sprite_transform;
    var opt = sprite.options;
    var velocityOverLifetime = sprite.velocityOverLifetime || {};
    var positionOverLifetime = {
        path: ensureFixedVec3((_sprite_transform = sprite.transform) == null ? void 0 : _sprite_transform.path),
        gravity: opt.gravity,
        gravityOverLifetime: ensureFixedNumber(opt.gravityModifier),
        direction: opt.direction,
        startSpeed: opt.startSpeed,
        asMovement: velocityOverLifetime.asMovement,
        linearX: ensureFixedNumber(velocityOverLifetime.linearX),
        linearY: ensureFixedNumber(velocityOverLifetime.linearY),
        linearZ: ensureFixedNumber(velocityOverLifetime.linearZ),
        asRotation: velocityOverLifetime.asRotation,
        orbCenter: velocityOverLifetime.orbCenter,
        orbitalX: ensureFixedNumber(velocityOverLifetime.orbitalX),
        orbitalY: ensureFixedNumber(velocityOverLifetime.orbitalY),
        orbitalZ: ensureFixedNumber(velocityOverLifetime.orbitalZ),
        speedOverLifetime: ensureFixedNumber(velocityOverLifetime.speedOverLifetime)
    };
    deleteEmptyValue(positionOverLifetime);
    var ret = {
        options: {
            startColor: ensureRGBAValue(opt.startColor)
        },
        positionOverLifetime: positionOverLifetime
    };
    if (opt.startSize) {
        transform.scale = [
            opt.startSize,
            opt.startSize / (opt.sizeAspect || 1),
            1
        ];
    }
    if (opt.startRotation) {
        if (!transform.rotation) {
            transform.rotation = [
                0,
                0,
                opt.startRotation
            ];
        } else {
            transform.rotation[2] += opt.startRotation;
        }
    }
    var rotationOverLifetime = sprite.rotationOverLifetime;
    if (rotationOverLifetime) {
        var rot = ret.rotationOverLifetime = {
            separateAxes: rotationOverLifetime.separateAxes,
            asRotation: rotationOverLifetime.asRotation
        };
        if (rot.separateAxes) {
            rot.x = ensureFixedNumber(rotationOverLifetime.x);
            rot.y = ensureFixedNumber(rotationOverLifetime.y);
            rot.z = ensureFixedNumber(rotationOverLifetime.z);
        } else {
            rot.z = ensureFixedNumber(rotationOverLifetime.angularVelocity);
        }
    }
    var colorOverLifetime = sprite.colorOverLifetime;
    if (colorOverLifetime) {
        var col = ret.colorOverLifetime = {
            opacity: ensureFixedNumber(colorOverLifetime.opacity)
        };
        if (colorOverLifetime.color) {
            col.color = getGradientColor(colorOverLifetime.color);
        }
    }
    var sizeOverLifetime = sprite.sizeOverLifetime;
    if (sizeOverLifetime) {
        ret.sizeOverLifetime = {
            separateAxes: sizeOverLifetime.separateAxes,
            size: ensureFixedNumber(sizeOverLifetime.size),
            x: ensureFixedNumber(sizeOverLifetime.x),
            y: ensureFixedNumber(sizeOverLifetime.y),
            z: ensureFixedNumber(sizeOverLifetime.z)
        };
    }
    return ret;
}
function getStandardSpriteContent(sprite, transform) {
    var ret = getStandardNullContent(sprite, transform);
    var texAni = sprite.textureSheetAnimation;
    if (texAni) {
        ret.textureSheetAnimation = {
            row: texAni.row,
            col: texAni.col,
            total: texAni.total || undefined,
            animate: texAni.animate
        };
    }
    ret.renderer = sprite.renderer;
    if (sprite.splits) {
        ret.splits = sprite.splits;
    }
    if (sprite.interaction) {
        ret.interaction = sprite.interaction;
    }
    return ret;
}

var v0 = /^(\d+)\.(\d+)\.(\d+)(-(\w+)\.\d+)?$/;
var standardVersion = /^(\d+)\.(\d+)$/;
var reverseParticle = false;
function getStandardJSON(json) {
    if (!json || typeof json !== "object") {
        throw new Error("Invalid input: Expected a JSON object.");
    }
    // 修正老版本数据中，meshItem 以及 lightItem 结束行为错误问题
    version22Migration(json);
    if (v0.test(json.version)) {
        var _exec;
        reverseParticle = ((_exec = /^(\d+)/.exec(json.version)) == null ? void 0 : _exec[0]) === "0";
        return version30Migration(version21Migration(getStandardJSONFromV0(json)));
    }
    reverseParticle = false;
    var vs = standardVersion.exec(json.version) || [];
    var mainVersion = Number(vs[1]);
    var minorVersion = Number(vs[2]);
    if (mainVersion) {
        if (mainVersion < 2 || mainVersion === 2 && minorVersion < 4) {
            json = version24Migration(json);
        }
        if (mainVersion < 3) {
            return version30Migration(version21Migration(json));
        }
        return json;
    }
    throw new Error("Invalid JSON version: " + json.version + ".");
}
var currentVersion = "1.0";
function getStandardJSONFromV0(json) {
    var _json_bins;
    currentVersion = "1.0";
    var plugins = json.plugins || [];
    if ((_json_bins = json.bins) == null ? void 0 : _json_bins.length) {
        currentVersion = "1.3";
    }
    var requires = (json.requires || []).slice();
    var images = json.images.map(function(img, index) {
        return getStandardImage(img, index, json.imageTags || []);
    });
    var textures = json.textures || images.map(function(img, i) {
        return {
            source: i,
            flipY: true
        };
    });
    var _json_playerVersion;
    var ret = {
        plugins: plugins,
        shapes: json.shapes || [],
        type: "ge",
        version: currentVersion,
        playerVersion: (_json_playerVersion = json.playerVersion) != null ? _json_playerVersion : {
            web: "",
            native: ""
        },
        compositionId: json.compositionId + "",
        compositions: json.compositions.map(function(comp) {
            return getStandardComposition(comp, {
                plugins: plugins,
                requires: requires
            });
        }),
        images: images,
        imgUsage: json._imgs,
        binUsage: json.binUsage,
        spines: json.spines,
        requires: json.requires,
        textures: textures,
        bins: (json.bins || []).slice()
    };
    if (json._textures) {
        ret._textures = json._textures;
    }
    return ret;
}
function getStandardImage(image, index, imageTags) {
    var renderLevel = imageTags[index];
    var oriY = image.oriY;
    if (typeof image === "string") {
        return {
            id: generateGUID(),
            renderLevel: renderLevel,
            url: image,
            oriY: oriY
        };
    } else if (image.template) {
        return {
            id: generateGUID(),
            url: image.url,
            template: image.template,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY
        };
    } else if (image.compressed) {
        return {
            id: generateGUID(),
            url: image.url,
            oriY: oriY,
            compressed: {
                astc: image.compressed.android,
                pvrtc: image.compressed.iOS
            },
            webp: image.webp,
            renderLevel: renderLevel
        };
    } else if (image.url) {
        return {
            id: generateGUID(),
            url: image.url,
            webp: image.webp,
            renderLevel: renderLevel,
            oriY: oriY
        };
    } else if (image && image.sourceType) {
        return image;
    }
    throw new Error("Invalid image type.");
}
function getStandardComposition(composition, opt) {
    if (opt === void 0) opt = {};
    var _composition_meta;
    var ret = {
        id: composition.id + "",
        camera: _extends({
            clipMode: CAMERA_CLIP_MODE_NORMAL
        }, composition.camera),
        duration: composition.duration,
        endBehavior: composition.endBehavior,
        items: composition.items.map(function(item) {
            return getStandardItem(item, opt);
        }),
        name: composition.name
    };
    var startTime = composition.startTime || composition.st;
    if (startTime) {
        ret.startTime = startTime;
    }
    var previewSize = (_composition_meta = composition.meta) == null ? void 0 : _composition_meta.previewSize;
    if (previewSize && previewSize[0] === previewSize[1] && previewSize[0] === 0) {
        previewSize = undefined;
    }
    if (previewSize) {
        ret.previewSize = previewSize;
    }
    return ret;
}
var tempQuat = [
    0,
    0,
    0,
    1
];
var stdAnchor = 0.5;
function getStandardItem(item, opt) {
    if (opt === void 0) opt = {};
    var _content_renderer;
    var type = ItemType.base;
    var transform;
    var originContent;
    var content;
    var endBehavior = item.endBehavior;
    var renderLevel;
    var pluginName;
    var duration = NaN;
    var pn;
    if (item.content) {
        type = item.type || ItemType.plugin;
        pn = item.pn;
        pluginName = item.pluginName;
        content = item.content;
        originContent = item.content;
        if (isNaN(pn) && !pluginName) {
            pluginName = content.options.type;
        }
        if (item.duration) {
            duration = item.duration;
        }
        transform = item.transform || getTransform(originContent.transform);
    } else if (item.particle) {
        type = ItemType.particle;
        originContent = item.particle;
        transform = getTransform(originContent.transform, reverseParticle, true);
        content = getStandardParticleContent(originContent);
    } else if (item.sprite) {
        type = ItemType.sprite;
        originContent = item.sprite;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardSpriteContent(originContent, transform);
    } else if (item.cal) {
        type = ItemType.null;
        originContent = item.cal;
        transform = getTransform(originContent.transform, false, true);
        content = getStandardNullContent(originContent, transform);
    } else if (item.ui) {
        type = ItemType.interact;
        originContent = item.ui;
        transform = getTransform(originContent.transform);
        content = getStandardInteractContent(originContent);
        transform.scale = [
            originContent.options.width || 1,
            originContent.options.height || 1,
            1
        ];
    } else if (item.model) {
        originContent = item.model;
        if (item.model.options.type === 1) {
            type = ItemType.camera;
            transform = getTransform(originContent.transform);
            content = getStandardCameraContent(originContent);
        }
    }
    if ((_content_renderer = content.renderer) == null ? void 0 : _content_renderer.anchor) {
        var anchor = new Float32Array(content.renderer.anchor);
        if (anchor[0] == stdAnchor && anchor[1] == stdAnchor) {
            delete content.renderer.anchor;
        } else if (opt.requires) {
            arrAdd(opt.requires, "anchor");
        }
    }
    if (originContent) {
        var _originContent_options;
        var looping = (_originContent_options = originContent.options) == null ? void 0 : _originContent_options.looping;
        if (looping) {
            if (Array.isArray(looping)) {
                endBehavior = looping[1] ? EndBehavior.restart : EndBehavior.destroy;
            } else {
                endBehavior = EndBehavior.restart;
            }
        } else {
            var _originContent_options1;
            endBehavior = endBehavior || (originContent == null ? void 0 : (_originContent_options1 = originContent.options) == null ? void 0 : _originContent_options1.endBehavior) || EndBehavior.destroy;
        }
        if (originContent.options.renderLevel) {
            renderLevel = originContent.options.renderLevel;
        }
        if (isNaN(duration)) {
            duration = originContent.options.duration;
        }
    }
    var ret = {
        type: type,
        name: item.name,
        delay: item.delay,
        duration: duration,
        id: item.id + "",
        // @ts-expect-error
        transform: transform,
        endBehavior: endBehavior,
        // @ts-expect-error
        renderLevel: renderLevel,
        content: content
    };
    // @ts-expect-error
    if (pluginName) {
        if (opt.plugins) {
            arrAdd(opt.plugins, pluginName);
            ret.pn = opt.plugins.indexOf(pluginName);
        } else {
            ret.pluginName = pluginName;
        }
    // @ts-expect-error
    } else if (Number.isInteger(pn)) {
        // @ts-expect-error
        ret.pn = pn;
    }
    if (item.parentId) {
        ret.parentId = item.parentId + "";
    }
    return ret;
    function getTransform(originTransform, inverseRotation, changeOrder) {
        if (originTransform) {
            var transform = {};
            var rotation = originTransform.rotation;
            if (rotation) {
                if (inverseRotation) {
                    transform.rotation = [
                        -rotation[0],
                        -rotation[1],
                        -rotation[2]
                    ];
                } else {
                    transform.rotation = [
                        rotation[0],
                        rotation[1],
                        rotation[2]
                    ];
                }
                if (changeOrder) {
                    var q = quatFromXYZRotation(tempQuat, transform.rotation[0], transform.rotation[1], transform.rotation[2]);
                    transform.rotation = rotationZYXFromQuat([], q);
                }
            }
            var position = originTransform.position;
            if (position) {
                transform.position = originTransform.position;
            }
            if (Array.isArray(originTransform.scale)) {
                transform.scale = [
                    originTransform.scale[0] || 1,
                    originTransform.scale[1] || 1,
                    originTransform.scale[2] || 1
                ];
            }
            return transform;
        }
        return {};
    }
}

var _obj$4;
/**
 * 机型和渲染等级对应表
 *
 * 机型：B-低端机、A-中端机、S-高端机
 * 渲染等级：B-低、A-中、S-高、A+-中高、B+-全部
 *
 * - S（高端机）：高、全部、中高
 * - A（中端机）：中、全部、中高
 * - B（低端机）：低、全部
 * - undefined（全部机型）
 */ var renderLevelPassSet = (_obj$4 = {}, _obj$4[RenderLevel.S] = [
    RenderLevel.S,
    RenderLevel.BPlus,
    RenderLevel.APlus
], _obj$4[RenderLevel.A] = [
    RenderLevel.A,
    RenderLevel.BPlus,
    RenderLevel.APlus
], _obj$4[RenderLevel.B] = [
    RenderLevel.B,
    RenderLevel.BPlus
], _obj$4);
function passRenderLevel(l, renderLevel) {
    if (!l || !renderLevel) {
        return true;
    }
    var arr = renderLevelPassSet[renderLevel];
    if (arr) {
        return arr.includes(l);
    }
    return false;
}

function isSceneJSON(scene) {
    return isObject(scene) && "jsonScene" in scene;
}
function isSceneURL(scene) {
    return isObject(scene) && "url" in scene;
}
function isSceneWithOptions(scene) {
    return isObject(scene) && "options" in scene;
}

function getBackgroundImage(template, variables) {
    var templateBackground;
    var _template_background;
    var _ref = (_template_background = template == null ? void 0 : template.background) != null ? _template_background : {}, name = _ref.name, url = _ref.url;
    if (name) {
        if (variables && variables[name]) {
            templateBackground = variables[name];
        } else if (url) {
            templateBackground = url;
        }
    }
    return templateBackground;
}
/**
 * @param url
 * @param template
 * @param variables
 * @param options
 * @returns
 */ function combineImageTemplate(url, template, variables) {
    return _combineImageTemplate.apply(this, arguments);
}
function _combineImageTemplate() {
    _combineImageTemplate = _async_to_generator(function(url, template, variables) {
        var image, templateBackground;
        return __generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!(typeof url === "string")) return [
                        3,
                        2
                    ];
                    return [
                        4,
                        loadImage(url)
                    ];
                case 1:
                    image = _state.sent();
                    return [
                        3,
                        3
                    ];
                case 2:
                    image = url;
                    _state.label = 3;
                case 3:
                    if (!image) {
                        throw new Error("Image not provided.");
                    }
                    if (!template) {
                        return [
                            2,
                            image
                        ];
                    }
                    // 获取动态换图的图片对象或 url 地址
                    templateBackground = getBackgroundImage(template, variables);
                    if (templateBackground) {
                        if (isString(templateBackground) && templateBackground !== image.src) {
                            return [
                                2,
                                loadImage(templateBackground)
                            ];
                        }
                        if (_instanceof1(templateBackground, douyin.HTMLImageElement)) {
                            return [
                                2,
                                templateBackground
                            ];
                        }
                    }
                    return [
                        2,
                        image
                    ];
            }
        });
    });
    return _combineImageTemplate.apply(this, arguments);
}

var ImageAsset = /*#__PURE__*/ function(EffectsObject) {
    _inherits(ImageAsset, EffectsObject);
    function ImageAsset() {
        return EffectsObject.apply(this, arguments);
    }
    return ImageAsset;
}(EffectsObject);

var seed$4 = 1;
/**
 * 资源管理器
 * 用于加载和动效中所有的资源文件，包括图片、插件、图层粒子数据等
 */ var AssetManager = /*#__PURE__*/ function() {
    function AssetManager(options, downloader) {
        if (options === void 0) options = {};
        if (downloader === void 0) downloader = new Downloader();
        this.options = options;
        this.downloader = downloader;
        this.assets = {};
        this.id = seed$4++;
        this.timers = [];
        this.updateOptions(options);
    }
    var _proto = AssetManager.prototype;
    _proto.updateOptions = function updateOptions(options) {
        if (options === void 0) options = {};
        this.options = options;
        if (!options.pluginData) {
            options.pluginData = {};
        }
        var _options_timeout = options.timeout, timeout = _options_timeout === void 0 ? 10 : _options_timeout;
        this.timeout = timeout;
    };
    /**
   * 根据用户传入的参数修改场景数据
   */ _proto.updateSceneData = function updateSceneData(items) {
        var variables = this.options.variables;
        if (!variables || Object.keys(variables).length === 0) {
            return;
        }
        items.forEach(function(item) {
            if (item.type === ItemType.text) {
                var textVariable = variables[item.name];
                if (textVariable) {
                    item.content.options.text = textVariable;
                }
            }
        });
    };
    /**
   * 场景创建，通过 json 创建出场景对象，并进行提前编译等工作
   * @param url - json 的 URL 链接或者 json 对象
   * @param renderer - renderer 对象，用于获取管理、编译 shader 及 GPU 上下文的参数
   * @param options - 扩展参数
   * @returns
   */ _proto.loadScene = function loadScene(url, renderer, options) {
        var _this = this;
        return _async_to_generator(function() {
            var _gpuInstance_detail, rawJSON, assetUrl, startTime, timeInfoMessages, gpuInstance, _gpuInstance_detail_asyncShaderCompile, asyncShaderCompile, _gpuInstance_detail_compressedTexture, compressedTexture, timeInfos, loadTimer, cancelLoading, waitPromise, hookTimeInfo, loadResourcePromise;
            return __generator(this, function(_state) {
                assetUrl = isString(url) ? url : _this.id;
                startTime = douyin.performance.now();
                timeInfoMessages = [];
                gpuInstance = renderer == null ? void 0 : renderer.engine.gpuCapability;
                asyncShaderCompile = (_gpuInstance_detail_asyncShaderCompile = gpuInstance == null ? void 0 : (_gpuInstance_detail = gpuInstance.detail) == null ? void 0 : _gpuInstance_detail.asyncShaderCompile) != null ? _gpuInstance_detail_asyncShaderCompile : false;
                compressedTexture = (_gpuInstance_detail_compressedTexture = gpuInstance == null ? void 0 : gpuInstance.detail.compressedTexture) != null ? _gpuInstance_detail_compressedTexture : exports.COMPRESSED_TEXTURE.NONE;
                timeInfos = {};
                cancelLoading = false;
                waitPromise = new Promise(function(resolve, reject) {
                    loadTimer = douyin.window.setTimeout(function() {
                        cancelLoading = true;
                        _this.removeTimer(loadTimer);
                        var totalTime = douyin.performance.now() - startTime;
                        reject(new Error("Load time out: totalTime: " + totalTime.toFixed(4) + "ms " + timeInfoMessages.join(" ") + ", url: " + assetUrl + "."));
                    }, _this.timeout * 1000);
                    _this.timers.push(loadTimer);
                });
                hookTimeInfo = /*#__PURE__*/ _async_to_generator(function(label, func) {
                    var st, result, time, e;
                    return __generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!!cancelLoading) return [
                                    3,
                                    4
                                ];
                                st = douyin.performance.now();
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    func()
                                ];
                            case 2:
                                result = _state.sent();
                                time = douyin.performance.now() - st;
                                timeInfoMessages.push("[" + label + ": " + time.toFixed(2) + "]");
                                timeInfos[label] = time;
                                return [
                                    2,
                                    result
                                ];
                            case 3:
                                e = _state.sent();
                                throw new Error("Load error in " + label + ", " + e + ".");
                            case 4:
                                throw new Error("Load canceled.");
                        }
                    });
                });
                loadResourcePromise = /*#__PURE__*/ _async_to_generator(function() {
                    var scene, _rawJSON_jsonScene, rawImages, images, i, i1, _ref, usedImages, jsonScene, pluginSystem, _jsonScene_bins, bins, images1, compositions, fonts, _ref1, loadedBins, loadedImages, i2, imageAsset, loadedTextures, totalTime;
                    return __generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!isObject(url)) return [
                                    3,
                                    1
                                ];
                                // TODO: 原 JSONLoader contructor 判断是否兼容
                                rawJSON = url;
                                _this.baseUrl = douyin.location.href;
                                return [
                                    3,
                                    3
                                ];
                            case 1:
                                // 兼容相对路径
                                url = new douyin.URL(url, douyin.location.href).href;
                                _this.baseUrl = url;
                                return [
                                    4,
                                    hookTimeInfo("loadJSON", function() {
                                        return _this.loadJSON(url);
                                    })
                                ];
                            case 2:
                                rawJSON = _state.sent();
                                _state.label = 3;
                            case 3:
                                if (!isSceneJSON(rawJSON)) return [
                                    3,
                                    6
                                ];
                                // 已经加载过的 可能需要更新数据模板
                                scene = _extends({}, rawJSON);
                                if (!(_this.options && _this.options.variables && Object.keys(_this.options.variables).length !== 0)) return [
                                    3,
                                    5
                                ];
                                _rawJSON_jsonScene = rawJSON.jsonScene, rawImages = _rawJSON_jsonScene.images;
                                images = scene.images;
                                for(i = 0; i < rawImages.length; i++){
                                    // 仅重新加载数据模板对应的图片
                                    if (_instanceof1(images[i], douyin.HTMLCanvasElement)) {
                                        images[i] = rawImages[i];
                                    }
                                }
                                return [
                                    4,
                                    hookTimeInfo("processImages", function() {
                                        return _this.processImages(images, compressedTexture);
                                    })
                                ];
                            case 4:
                                scene.images = _state.sent();
                                // 更新 TextureOptions 中的 image 指向
                                for(i1 = 0; i1 < scene.images.length; i1++){
                                    scene.textureOptions[i1].image = scene.images[i1];
                                }
                                _this.updateSceneData(scene.jsonScene.items);
                                _state.label = 5;
                            case 5:
                                return [
                                    3,
                                    12
                                ];
                            case 6:
                                return [
                                    4,
                                    hookTimeInfo("processJSON", function() {
                                        return _this.processJSON(rawJSON);
                                    })
                                ];
                            case 7:
                                _ref = _state.sent(), usedImages = _ref.usedImages, jsonScene = _ref.jsonScene, pluginSystem = _ref.pluginSystem;
                                _jsonScene_bins = jsonScene.bins, bins = _jsonScene_bins === void 0 ? [] : _jsonScene_bins, images1 = jsonScene.images, compositions = jsonScene.compositions, fonts = jsonScene.fonts;
                                return [
                                    4,
                                    Promise.all([
                                        hookTimeInfo("processBins", function() {
                                            return _this.processBins(bins);
                                        }),
                                        hookTimeInfo("processImages", function() {
                                            return _this.processImages(images1, compressedTexture);
                                        }),
                                        hookTimeInfo("" + (asyncShaderCompile ? "async" : "sync") + "Compile", function() {
                                            return _this.precompile(compositions, pluginSystem, renderer, options);
                                        })
                                    ])
                                ];
                            case 8:
                                _ref1 = _state.sent(), loadedBins = _ref1[0], loadedImages = _ref1[1];
                                if (renderer) {
                                    for(i2 = 0; i2 < images1.length; i2++){
                                        imageAsset = new ImageAsset(renderer.engine);
                                        imageAsset.data = loadedImages[i2];
                                        imageAsset.setInstanceId(images1[i2].id);
                                        renderer.engine.addInstance(imageAsset);
                                    }
                                }
                                return [
                                    4,
                                    hookTimeInfo("processFontURL", function() {
                                        return _this.processFontURL(fonts);
                                    })
                                ];
                            case 9:
                                _state.sent();
                                return [
                                    4,
                                    hookTimeInfo("processTextures", function() {
                                        return _this.processTextures(loadedImages, loadedBins, jsonScene, renderer.engine);
                                    })
                                ];
                            case 10:
                                loadedTextures = _state.sent();
                                _this.updateSceneData(jsonScene.items);
                                scene = {
                                    timeInfos: timeInfos,
                                    url: url,
                                    renderLevel: _this.options.renderLevel,
                                    storage: {},
                                    pluginSystem: pluginSystem,
                                    jsonScene: jsonScene,
                                    usedImages: usedImages,
                                    images: loadedImages,
                                    textureOptions: loadedTextures,
                                    bins: loadedBins
                                };
                                // 触发插件系统 pluginSystem 的回调 prepareResource
                                return [
                                    4,
                                    hookTimeInfo("processPlugins", function() {
                                        return pluginSystem.loadResources(scene, _this.options);
                                    })
                                ];
                            case 11:
                                _state.sent();
                                _state.label = 12;
                            case 12:
                                totalTime = douyin.performance.now() - startTime;
                                logger.info("Load asset: totalTime: " + totalTime.toFixed(4) + "ms " + timeInfoMessages.join(" ") + ", url: " + assetUrl + ".");
                                douyin.window.clearTimeout(loadTimer);
                                _this.removeTimer(loadTimer);
                                scene.totalTime = totalTime;
                                scene.startTime = startTime;
                                // 各部分分段时长
                                scene.timeInfos = timeInfos;
                                return [
                                    2,
                                    scene
                                ];
                        }
                    });
                });
                return [
                    2,
                    Promise.race([
                        waitPromise,
                        loadResourcePromise()
                    ])
                ];
            });
        })();
    };
    _proto.precompile = function precompile(compositions, pluginSystem, renderer, options) {
        return _async_to_generator(function() {
            var shaderLibrary;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!renderer || !renderer.getShaderLibrary()) {
                            return [
                                2
                            ];
                        }
                        shaderLibrary = renderer == null ? void 0 : renderer.getShaderLibrary();
                        return [
                            4,
                            pluginSystem == null ? void 0 : pluginSystem.precompile(compositions, renderer, options)
                        ];
                    case 1:
                        _state.sent();
                        return [
                            4,
                            new Promise(function(resolve) {
                                shaderLibrary == null ? void 0 : shaderLibrary.compileAllShaders(function() {
                                    resolve(null);
                                });
                            })
                        ];
                    case 2:
                        _state.sent();
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto.processJSON = function processJSON(json) {
        var _this = this;
        return _async_to_generator(function() {
            var jsonScene, _jsonScene_plugins, plugins, sceneCompositions, imgUsage, images, pluginSystem, renderLevel, usedImages;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        jsonScene = getStandardJSON(json);
                        _jsonScene_plugins = jsonScene.plugins, plugins = _jsonScene_plugins === void 0 ? [] : _jsonScene_plugins, sceneCompositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage, images = jsonScene.images;
                        pluginSystem = new PluginSystem(plugins);
                        return [
                            4,
                            pluginSystem.processRawJSON(jsonScene, _this.options)
                        ];
                    case 1:
                        _state.sent();
                        renderLevel = _this.options.renderLevel;
                        usedImages = {};
                        if (imgUsage) {
                            // TODO: 考虑放到独立的 fix 文件
                            fixOldImageUsage(usedImages, sceneCompositions, imgUsage, images, renderLevel);
                        } else {
                            images == null ? void 0 : images.forEach(function(_, i) {
                                usedImages[i] = true;
                            });
                        }
                        return [
                            2,
                            {
                                usedImages: usedImages,
                                jsonScene: jsonScene,
                                pluginSystem: pluginSystem
                            }
                        ];
                }
            });
        })();
    };
    _proto.processBins = function processBins(bins) {
        var _this = this;
        return _async_to_generator(function() {
            var renderLevel, baseUrl, jobs;
            return __generator(this, function(_state) {
                renderLevel = _this.options.renderLevel;
                baseUrl = _this.baseUrl;
                jobs = bins.map(function(bin) {
                    if (_instanceof1(bin, ArrayBuffer)) {
                        return bin;
                    }
                    if (passRenderLevel(bin.renderLevel, renderLevel)) {
                        return _this.loadBins(new douyin.URL(bin.url, baseUrl).href);
                    }
                    throw new Error("Invalid bins source: " + JSON.stringify(bins) + ".");
                });
                return [
                    2,
                    Promise.all(jobs)
                ];
            });
        })();
    };
    _proto.processFontURL = function processFontURL(fonts) {
        var _this = this;
        return _async_to_generator(function() {
            var jobs;
            return __generator(this, function(_state) {
                // 对老数据的兼容
                if (!fonts) {
                    return [
                        2
                    ];
                }
                jobs = fonts.map(/*#__PURE__*/ _async_to_generator(function(font) {
                    var url, _font_fontFamily, fontFace;
                    return __generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!(font.fontURL && !AssetManager.fonts.has(font.fontFamily))) return [
                                    3,
                                    4
                                ];
                                if (!isValidFontFamily(font.fontFamily)) {
                                    // 在所有设备上提醒开发者
                                    console.warn("Risky font family: " + font.fontFamily + ".");
                                }
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                url = new douyin.URL(font.fontURL, _this.baseUrl).href;
                                fontFace = new FontFace((_font_fontFamily = font.fontFamily) != null ? _font_fontFamily : "", "url(" + url + ")");
                                return [
                                    4,
                                    fontFace.load()
                                ];
                            case 2:
                                _state.sent();
                                //@ts-expect-error
                                douyin.document.fonts.add(fontFace);
                                AssetManager.fonts.add(font.fontFamily);
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                _state.sent();
                                logger.warn("Invalid font family or font source: " + JSON.stringify(font.fontURL) + ".");
                                return [
                                    3,
                                    4
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }));
                return [
                    2,
                    Promise.all(jobs)
                ];
            });
        })();
    };
    _proto.processImages = function processImages(images, compressedTexture) {
        if (compressedTexture === void 0) compressedTexture = 0;
        var _this = this;
        return _async_to_generator(function() {
            var _this_options, useCompressedTexture, variables, baseUrl, jobs;
            return __generator(this, function(_state) {
                _this_options = _this.options, useCompressedTexture = _this_options.useCompressedTexture, variables = _this_options.variables;
                baseUrl = _this.baseUrl;
                jobs = images.map(/*#__PURE__*/ _async_to_generator(function(img, idx) {
                    var png, webp, avif, imageURL, webpURL, avifURL, template, background, url, isVideo, loadFn, resultImage, e, compressed, src, bufferURL, _ref, url1, image, _tmp;
                    return __generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                png = img.url, webp = img.webp, avif = img.avif;
                                // eslint-disable-next-line compat/compat
                                imageURL = new douyin.URL(png, baseUrl).href;
                                // eslint-disable-next-line compat/compat
                                webpURL = webp && new douyin.URL(webp, baseUrl).href;
                                // eslint-disable-next-line compat/compat
                                avifURL = avif && new douyin.URL(avif, baseUrl).href;
                                if (!("template" in img)) return [
                                    3,
                                    8
                                ];
                                // 1. 数据模板
                                template = img.template;
                                // 获取数据模板 background 参数
                                background = template.background;
                                if (!background) return [
                                    3,
                                    7
                                ];
                                url = getBackgroundImage(template, variables);
                                isVideo = background.type === BackgroundType.video;
                                // 根据背景类型确定加载函数
                                loadFn = background && isVideo ? loadVideo : loadImage;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    6,
                                    ,
                                    7
                                ]);
                                return [
                                    4,
                                    loadMedia(url, loadFn)
                                ];
                            case 2:
                                resultImage = _state.sent();
                                if (!_instanceof1(resultImage, douyin.HTMLVideoElement)) return [
                                    3,
                                    3
                                ];
                                return [
                                    2,
                                    resultImage
                                ];
                            case 3:
                                // 如果是加载图片且是数组，设置变量，视频情况下不需要
                                if (background && Array.isArray(url) && variables) {
                                    variables[background.name] = resultImage.src;
                                }
                                return [
                                    4,
                                    combineImageTemplate(resultImage, template, variables)
                                ];
                            case 4:
                                return [
                                    2,
                                    _state.sent()
                                ];
                            case 5:
                                return [
                                    3,
                                    7
                                ];
                            case 6:
                                e = _state.sent();
                                throw new Error("Failed to load. Check the template or if the URL is " + (isVideo ? "video" : "image") + " type, URL: " + url + ", Error: " + e.message + ".");
                            case 7:
                                return [
                                    3,
                                    9
                                ];
                            case 8:
                                if ("compressed" in img && useCompressedTexture && compressedTexture) {
                                    // 2. 压缩纹理
                                    compressed = img.compressed;
                                    if (compressedTexture === exports.COMPRESSED_TEXTURE.ASTC) {
                                        src = compressed.astc;
                                    } else if (compressedTexture === exports.COMPRESSED_TEXTURE.PVRTC) {
                                        src = compressed.pvrtc;
                                    }
                                    if (src) {
                                        bufferURL = new douyin.URL(src, baseUrl).href;
                                        _this.assets[idx] = {
                                            url: bufferURL,
                                            type: exports.TextureSourceType.compressed
                                        };
                                        return [
                                            2,
                                            _this.loadBins(bufferURL)
                                        ];
                                    }
                                } else if ("sourceType" in img) {
                                    // TODO: 确定是否有用
                                    return [
                                        2,
                                        img
                                    ];
                                } else if (_instanceof1(img, douyin.HTMLImageElement) || _instanceof1(img, douyin.HTMLCanvasElement) || _instanceof1(img, douyin.HTMLVideoElement) || _instanceof1(img, Texture)) {
                                    return [
                                        2,
                                        img
                                    ];
                                }
                                _state.label = 9;
                            case 9:
                                if (!avifURL) return [
                                    3,
                                    11
                                ];
                                return [
                                    4,
                                    loadAVIFOptional(imageURL, avifURL)
                                ];
                            case 10:
                                _tmp = _state.sent();
                                return [
                                    3,
                                    13
                                ];
                            case 11:
                                return [
                                    4,
                                    loadWebPOptional(imageURL, webpURL)
                                ];
                            case 12:
                                _tmp = _state.sent();
                                _state.label = 13;
                            case 13:
                                _ref = _tmp, url1 = _ref.url, image = _ref.image;
                                _this.assets[idx] = {
                                    url: url1,
                                    type: exports.TextureSourceType.image
                                };
                                return [
                                    2,
                                    image
                                ];
                        }
                    });
                }));
                return [
                    2,
                    Promise.all(jobs)
                ];
            });
        })();
    };
    _proto.processTextures = function processTextures(images, bins, jsonScene, engine) {
        var _this = this;
        return _async_to_generator(function() {
            var _jsonScene_textures, textures, jobs;
            return __generator(this, function(_state) {
                textures = (_jsonScene_textures = jsonScene.textures) != null ? _jsonScene_textures : images.map(function(img, source) {
                    return {
                        source: source
                    };
                });
                jobs = textures.map(/*#__PURE__*/ _async_to_generator(function(textureOptions, idx) {
                    var e, source, image, texture;
                    return __generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (_instanceof1(textureOptions, Texture)) {
                                    return [
                                        2,
                                        textureOptions
                                    ];
                                }
                                if (!("mipmaps" in textureOptions)) return [
                                    3,
                                    4
                                ];
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    deserializeMipmapTexture(textureOptions, bins, engine, jsonScene.bins)
                                ];
                            case 2:
                                return [
                                    2,
                                    _state.sent()
                                ];
                            case 3:
                                e = _state.sent();
                                throw new Error("Load texture " + idx + " fails, error message: " + e + ".");
                            case 4:
                                source = textureOptions.source;
                                if (!isObject(source)) return [
                                    3,
                                    5
                                ];
                                image = engine.assetLoader.loadGUID(source.id).data;
                                return [
                                    3,
                                    7
                                ];
                            case 5:
                                if (!(typeof source === "string")) return [
                                    3,
                                    7
                                ];
                                return [
                                    4,
                                    loadImage(base64ToFile(source))
                                ];
                            case 6:
                                image = _state.sent();
                                _state.label = 7;
                            case 7:
                                if (image) {
                                    texture = createTextureOptionsBySource(image, _this.assets[idx]);
                                    texture.id = textureOptions.id;
                                    texture.dataType = DataType.Texture;
                                    return [
                                        2,
                                        texture.sourceType === exports.TextureSourceType.compressed ? texture : _extends({}, texture, textureOptions)
                                    ];
                                }
                                throw new Error("Invalid texture source: " + source + ".");
                        }
                    });
                }));
                return [
                    2,
                    Promise.all(jobs)
                ];
            });
        })();
    };
    _proto.loadJSON = function loadJSON(url) {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    new Promise(function(resolve, reject) {
                        _this.downloader.downloadJSON(url, resolve, function(status, responseText) {
                            reject("Couldn't load JSON " + JSON.stringify(url) + ": status " + status + ", " + responseText);
                        });
                    })
                ];
            });
        })();
    };
    _proto.loadBins = function loadBins(url) {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                return [
                    2,
                    new Promise(function(resolve, reject) {
                        _this.downloader.downloadBinary(url, resolve, function(status, responseText) {
                            reject("Couldn't load bins " + JSON.stringify(url) + ": status " + status + ", " + responseText);
                        });
                    })
                ];
            });
        })();
    };
    _proto.removeTimer = function removeTimer(id) {
        var index = this.timers.indexOf(id);
        if (index !== -1) {
            this.timers.splice(index, 1);
        }
    };
    /**
   * 销毁方法
   */ _proto.dispose = function dispose() {
        if (this.timers.length) {
            this.timers.map(function(id) {
                return douyin.window.clearTimeout(id);
            });
        }
        for(var key in this.assets){
            var _asset_dispose;
            var asset = this.assets[key];
            asset == null ? void 0 : (_asset_dispose = asset.dispose) == null ? void 0 : _asset_dispose.call(asset);
        }
        this.assets = {};
        this.timers = [];
    };
    return AssetManager;
}();
/**
   * 自定义文本缓存，随页面销毁而销毁
   */ AssetManager.fonts = new Set();
function fixOldImageUsage(usedImages, compositions, imgUsage, images, renderLevel) {
    for(var i = 0; i < compositions.length; i++){
        var id = compositions[i].id;
        var ids = imgUsage[id];
        if (ids) {
            for(var j = 0; j < ids.length; j++){
                var id1 = ids[j];
                var tag = images[id1].renderLevel;
                if (passRenderLevel(tag, renderLevel)) {
                    usedImages[id1] = true;
                }
            }
        }
    }
}
function createTextureOptionsBySource(image, sourceFrom) {
    if (_instanceof1(image, Texture)) {
        return image.source;
    } else if (_instanceof1(image, douyin.HTMLImageElement) || isCanvas(image)) {
        return {
            image: image,
            sourceType: exports.TextureSourceType.image,
            sourceFrom: sourceFrom,
            keepImageSource: true,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR
        };
    } else if (_instanceof1(image, douyin.HTMLVideoElement)) {
        // 视频
        return {
            sourceType: exports.TextureSourceType.video,
            video: image,
            minFilter: glContext.LINEAR,
            magFilter: glContext.LINEAR
        };
    } else if (_instanceof1(image, ArrayBuffer)) {
        // 压缩纹理
        return _extends({}, getKTXTextureOptions(image), {
            sourceFrom: sourceFrom
        });
    } else if ("width" in image && "height" in image && "data" in image) {
        return {
            sourceType: exports.TextureSourceType.data,
            data: image,
            wrapS: glContext.CLAMP_TO_EDGE,
            wrapT: glContext.CLAMP_TO_EDGE,
            minFilter: glContext.NEAREST,
            magFilter: glContext.NEAREST
        };
    }
    throw new Error("Invalid texture options.");
}

var tmpScale = new Vector3(1, 1, 1);
/**
 * 合成的相机对象，采用透视投影
 */ var Camera = /*#__PURE__*/ function() {
    function Camera(name, options) {
        if (options === void 0) options = {};
        this.name = name;
        this.viewportMatrix = Matrix4$1.fromIdentity();
        this.viewMatrix = Matrix4$1.fromIdentity();
        this.projectionMatrix = Matrix4$1.fromIdentity();
        this.viewProjectionMatrix = Matrix4$1.fromIdentity();
        this.inverseViewMatrix = Matrix4$1.fromIdentity();
        this.dirty = true;
        var _options_near = options.near, near = _options_near === void 0 ? 0.1 : _options_near, _options_far = options.far, far = _options_far === void 0 ? 20 : _options_far, _options_fov = options.fov, fov = _options_fov === void 0 ? 60 : _options_fov, _options_aspect = options.aspect, aspect = _options_aspect === void 0 ? 1 : _options_aspect, _options_clipMode = options.clipMode, clipMode = _options_clipMode === void 0 ? CameraClipMode.portrait : _options_clipMode, _options_position = options.position, position = _options_position === void 0 ? [
            0,
            0,
            8
        ] : _options_position, _options_rotation = options.rotation, rotation = _options_rotation === void 0 ? [
            0,
            0,
            0
        ] : _options_rotation;
        this.options = {
            near: near,
            far: far,
            fov: fov,
            aspect: aspect,
            clipMode: clipMode,
            position: Vector3.fromArray(position),
            rotation: Euler.fromArray(rotation)
        };
        this.dirty = true;
        this.updateMatrix();
    }
    var _proto = Camera.prototype;
    _proto.setViewportMatrix = function setViewportMatrix(matrix) {
        this.viewportMatrix = matrix.clone();
        this.dirty = true;
    };
    _proto.getViewportMatrix = function getViewportMatrix() {
        return this.viewportMatrix;
    };
    /**
   * 获取相机的视图变换矩阵
   * @return
   */ _proto.getViewMatrix = function getViewMatrix() {
        this.updateMatrix();
        return this.viewMatrix.clone();
    };
    /**
   * 获取视图变换的逆矩阵
   */ _proto.getInverseViewMatrix = function getInverseViewMatrix() {
        this.updateMatrix();
        return this.inverseViewMatrix.clone();
    };
    /**
   * 获取相机的投影矩阵
   * @return
   */ _proto.getProjectionMatrix = function getProjectionMatrix() {
        this.updateMatrix();
        return this.projectionMatrix.clone();
    };
    /**
   * 获取相机投影矩阵的逆矩阵
   * @return
   */ _proto.getInverseProjectionMatrix = function getInverseProjectionMatrix() {
        var _this_inverseProjectionMatrix;
        this.updateMatrix();
        return (_this_inverseProjectionMatrix = this.inverseProjectionMatrix) == null ? void 0 : _this_inverseProjectionMatrix.clone();
    };
    /**
   * 获取相机的 VP 矩阵
   * @return
   */ _proto.getViewProjectionMatrix = function getViewProjectionMatrix() {
        this.updateMatrix();
        return this.viewProjectionMatrix.clone();
    };
    /**
   * 获取相机 VP 矩阵的逆矩阵
   * @return
   */ _proto.getInverseViewProjectionMatrix = function getInverseViewProjectionMatrix() {
        this.updateMatrix();
        if (!this.inverseViewProjectionMatrix) {
            this.inverseViewProjectionMatrix = this.viewProjectionMatrix.clone();
            this.inverseViewProjectionMatrix.invert();
        }
        return this.inverseViewProjectionMatrix.clone();
    };
    /**
   * 根据相机的视图投影矩阵对指定模型矩阵做变换
   * @param out - 结果矩阵
   * @param model - 模型变换矩阵
   */ _proto.getModelViewProjection = function getModelViewProjection(out, model) {
        return out.multiplyMatrices(this.viewProjectionMatrix, model);
    };
    /**
   * 获取归一化坐标和 3D 世界坐标的换算比例，使用 ViewProjection 矩阵
   * @param z - 当前的位置 z
   */ _proto.getInverseVPRatio = function getInverseVPRatio(z) {
        var pos = new Vector3(this.position.x, this.position.y, z);
        var mat = this.getViewProjectionMatrix();
        var inverseMat = this.getInverseViewProjectionMatrix();
        if (!this.viewportMatrix.isIdentity()) {
            var viewportMatrix = this.viewportMatrix.clone();
            inverseMat.premultiply(viewportMatrix);
            mat.multiply(viewportMatrix.invert());
        }
        var _mat_projectPoint = mat.projectPoint(pos), nz = _mat_projectPoint.z;
        var _inverseMat_projectPoint = inverseMat.projectPoint(new Vector3(1, 1, nz)), xMax = _inverseMat_projectPoint.x, yMax = _inverseMat_projectPoint.y;
        var _inverseMat_projectPoint1 = inverseMat.projectPoint(new Vector3(-1, -1, nz)), xMin = _inverseMat_projectPoint1.x, yMin = _inverseMat_projectPoint1.y;
        return new Vector3((xMax - xMin) / 2, (yMax - yMin) / 2, 0);
    };
    /**
   * 设置相机的旋转四元数
   * @param value - 旋转四元数
   */ _proto.setQuat = function setQuat(value) {
        if (this.options.quat === undefined) {
            this.options.quat = value.clone();
            this.dirty = true;
        } else {
            if (!this.options.quat.equals(value)) {
                this.options.quat.copyFrom(value);
                this.dirty = true;
            }
        }
        if (this.dirty) {
            this.setRotationByQuat(value);
        }
    };
    /**
   * 获取相机旋转对应的四元数
   * @returns
   */ _proto.getQuat = function getQuat() {
        var quat = this.options.quat;
        if (quat === undefined) {
            quat = new Quaternion();
            var rotation = this.options.rotation;
            if (rotation) {
                quat.setFromEuler(rotation);
            }
            this.options.quat = quat;
        }
        return quat;
    };
    /**
   * 获取相机内部的 options
   * @returns 相机 options
   */ _proto.getOptions = function getOptions() {
        return this.options;
    };
    /**
   * 复制指定相机元素的属性到当前相机
   * @param camera
   */ _proto.copy = function copy(camera) {
        var near = camera.near, far = camera.far, fov = camera.fov, clipMode = camera.clipMode, aspect = camera.aspect, position = camera.position, rotation = camera.rotation;
        this.near = near;
        this.far = far;
        this.fov = fov;
        this.clipMode = clipMode;
        this.aspect = aspect;
        this.position = position;
        this.rotation = rotation;
        this.updateMatrix();
    };
    /**
   * 更新相机相关的矩阵，获取矩阵前会自动调用
   */ _proto.updateMatrix = function updateMatrix() {
        if (this.dirty) {
            var _this_options = this.options, fov = _this_options.fov, aspect = _this_options.aspect, near = _this_options.near, far = _this_options.far, clipMode = _this_options.clipMode, position = _this_options.position;
            this.projectionMatrix.perspective(fov * DEG2RAD, aspect, near, far, clipMode === CameraClipMode.portrait);
            this.projectionMatrix.premultiply(this.viewportMatrix);
            this.inverseViewMatrix.compose(position, this.getQuat(), tmpScale);
            this.viewMatrix.copyFrom(this.inverseViewMatrix).invert();
            this.viewProjectionMatrix.multiplyMatrices(this.projectionMatrix, this.viewMatrix);
            this.inverseViewProjectionMatrix = null;
            this.dirty = false;
        }
    };
    _proto.setRotationByQuat = function setRotationByQuat(quat) {
        Transform.getRotation(quat, this.options.rotation);
    };
    _create_class(Camera, [
        {
            key: "near",
            get: function get() {
                return this.options.near;
            },
            set: /**
   * 设置相机近平面
   * @param near
   */ function set(near) {
                if (this.options.near !== near) {
                    this.options.near = near;
                    this.dirty = true;
                }
            }
        },
        {
            key: "far",
            get: function get() {
                return this.options.far;
            },
            set: /**
   * 设置相机远平面
   * @param far
   */ function set(far) {
                if (this.options.far !== far) {
                    this.options.far = far;
                    this.dirty = true;
                }
            }
        },
        {
            key: "fov",
            get: function get() {
                return this.options.fov;
            },
            set: /**
   * 设置相机视锥体垂直视野角度
   * @param fov
   */ function set(fov) {
                if (this.options.fov !== fov) {
                    this.options.fov = fov;
                    this.dirty = true;
                }
            }
        },
        {
            key: "aspect",
            get: function get() {
                return this.options.aspect;
            },
            set: /**
   * 设置相机视锥体的长宽比
   * @param aspect
   */ function set(aspect) {
                if (this.options.aspect !== aspect) {
                    this.options.aspect = aspect;
                    this.dirty = true;
                }
            }
        },
        {
            key: "clipMode",
            get: function get() {
                return this.options.clipMode;
            },
            set: /**
   * 相机的裁剪模式
   * @param clipMode
   */ function set(clipMode) {
                if (clipMode !== undefined && this.options.clipMode !== clipMode) {
                    this.options.clipMode = clipMode;
                    this.dirty = true;
                }
            }
        },
        {
            key: "position",
            get: function get() {
                return this.options.position.clone();
            },
            set: /**
   * 设置相机的位置
   * @param value
   */ function set(value) {
                if (!this.options.position.equals(value)) {
                    this.options.position.copyFrom(value);
                    this.dirty = true;
                }
            }
        },
        {
            key: "rotation",
            get: function get() {
                return this.options.rotation.clone();
            },
            set: /**
   * 设置相机的旋转角度
   * @param value
   */ function set(value) {
                if (!this.options.rotation.equals(value)) {
                    this.options.rotation.copyFrom(value);
                    this.dirty = true;
                    this.options.quat = undefined;
                }
            }
        }
    ]);
    return Camera;
}();

var listOrder = 0;
/**
 * 合成资源管理
 */ var CompositionSourceManager = /*#__PURE__*/ function() {
    function CompositionSourceManager(scene, engine) {
        this.refCompositions = new Map();
        this.refCompositionProps = new Map();
        this.mask = 0;
        this.engine = engine;
        // 资源
        var jsonScene = scene.jsonScene, renderLevel = scene.renderLevel, textureOptions = scene.textureOptions, pluginSystem = scene.pluginSystem, totalTime = scene.totalTime;
        var compositions = jsonScene.compositions, imgUsage = jsonScene.imgUsage, compositionId = jsonScene.compositionId;
        if (!textureOptions) {
            throw new Error("scene.textures expected.");
        }
        var cachedTextures = textureOptions;
        for(var _iterator = _create_for_of_iterator_helper_loose(compositions), _step; !(_step = _iterator()).done;){
            var comp = _step.value;
            if (comp.id === compositionId) {
                this.composition = comp;
            } else {
                this.refCompositions.set(comp.id, comp);
            }
        }
        if (!this.composition) {
            throw new Error("Invalid composition id: " + compositionId + ".");
        }
        this.jsonScene = jsonScene;
        this.renderLevel = renderLevel;
        this.pluginSystem = pluginSystem;
        this.totalTime = totalTime != null ? totalTime : 0;
        this.imgUsage = imgUsage != null ? imgUsage : {};
        this.textures = cachedTextures;
        listOrder = 0;
        this.sourceContent = this.getContent(this.composition);
    }
    var _proto = CompositionSourceManager.prototype;
    _proto.getContent = function getContent(composition) {
        var id = composition.id, duration = composition.duration, name = composition.name, endBehavior = composition.endBehavior, camera = composition.camera, _composition_startTime = composition.startTime, startTime = _composition_startTime === void 0 ? 0 : _composition_startTime;
        var items = this.assembleItems(composition);
        return _extends({}, composition, {
            id: id,
            duration: duration,
            name: name,
            endBehavior: isNaN(endBehavior) ? EndBehavior.freeze : endBehavior,
            // looping,
            items: items,
            camera: camera,
            startTime: startTime
        });
    };
    _proto.assembleItems = function assembleItems(composition) {
        var items = [];
        this.mask++;
        var componentMap = {};
        //@ts-expect-error
        for(var _iterator = _create_for_of_iterator_helper_loose(this.jsonScene.components), _step; !(_step = _iterator()).done;){
            var component = _step.value;
            componentMap[component.id] = component;
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(composition.items), _step1; !(_step1 = _iterator1()).done;){
            var itemDataPath = _step1.value;
            //@ts-expect-error
            var sourceItemData = this.engine.jsonSceneData[itemDataPath.id];
            var itemProps = sourceItemData;
            if (passRenderLevel(sourceItemData.renderLevel, this.renderLevel)) {
                itemProps.listIndex = listOrder++;
                if (itemProps.type === ItemType.sprite || itemProps.type === ItemType.particle) {
                    for(var _iterator2 = _create_for_of_iterator_helper_loose(itemProps.components), _step2; !(_step2 = _iterator2()).done;){
                        var componentPath = _step2.value;
                        var componentData = componentMap[componentPath.id];
                        this.preProcessItemContent(componentData);
                    }
                }
                // 处理预合成的渲染顺序
                if (itemProps.type === ItemType.composition) {
                    var refId = sourceItemData.content.options.refId;
                    if (!this.refCompositions.get(refId)) {
                        throw new Error("Invalid ref composition id: " + refId + ".");
                    }
                    var ref = this.getContent(this.refCompositions.get(refId));
                    if (!this.refCompositionProps.has(refId)) {
                        this.refCompositionProps.set(refId, ref);
                    }
                }
                items.push(itemProps);
            }
        }
        return items;
    };
    _proto.preProcessItemContent = function preProcessItemContent(renderContent) {
        if (renderContent.renderer) {
            renderContent.renderer = this.changeTex(renderContent.renderer);
            if (!renderContent.renderer.mask) {
                this.processMask(renderContent.renderer);
            }
            var split = renderContent.splits && !renderContent.textureSheetAnimation && renderContent.splits[0];
            if (Number.isInteger(renderContent.renderer.shape)) {
                var _this_jsonScene;
                // TODO: scene.shapes 类型问题？
                renderContent.renderer.shape = getGeometryByShape((_this_jsonScene = this.jsonScene) == null ? void 0 : _this_jsonScene.shapes[renderContent.renderer.shape], split);
            } else if (renderContent.renderer.shape && isObject(renderContent.renderer.shape)) {
                renderContent.renderer.shape = getGeometryByShape(renderContent.renderer.shape, split);
            }
        }
        if (renderContent.trails) {
            renderContent.trails = this.changeTex(renderContent.trails);
        }
    };
    _proto.changeTex = function changeTex(renderer) {
        if (!renderer.texture) {
            return renderer;
        }
        //@ts-expect-error
        var texIdx = renderer.texture.id;
        if (texIdx !== undefined) {
            //@ts-expect-error
            this.addTextureUsage(texIdx) || texIdx;
        }
        return renderer;
    };
    _proto.addTextureUsage = function addTextureUsage(texIdx) {
        var texId = texIdx;
        var _this_imgUsage;
        // FIXME: imageUsage 取自 scene.imgUsage，类型为 Record<string, number[]>，这里给的 number，类型对不上
        var imageUsage = (_this_imgUsage = this.imgUsage) != null ? _this_imgUsage : {};
        if (texId && imageUsage) {
            // eslint-disable-next-line no-prototype-builtins
            if (!imageUsage.hasOwnProperty(texId)) {
                imageUsage[texId] = 0;
            }
            imageUsage[texId]++;
        }
    };
    /**
   * 处理蒙版和遮挡关系写入 stencil 的 ref 值
   */ _proto.processMask = function processMask(renderer) {
        var maskMode = renderer.maskMode;
        if (maskMode === MaskMode.NONE) {
            return;
        }
        if (!renderer.mask) {
            if (maskMode === MaskMode.MASK) {
                renderer.mask = ++this.mask;
            } else if (maskMode === MaskMode.OBSCURED || maskMode === MaskMode.REVERSE_OBSCURED) {
                renderer.mask = this.mask;
            }
        }
    };
    _proto.dispose = function dispose() {
        this.textures = [];
        this.composition = undefined;
        this.jsonScene = undefined;
        this.totalTime = 0;
        this.pluginSystem = undefined;
        this.sourceContent = undefined;
        this.refCompositions.clear();
        this.refCompositionProps.clear();
    };
    return CompositionSourceManager;
}();

/**
 * 合成抽象类：核心对象，通常一个场景只包含一个合成，可能会有多个合成。
 * 合成中包含了相关的 Item 元素，支持对 Item 元素的创建、更新和销毁。
 * 也负责 Item 相关的动画播放控制，和持有渲染帧数据。
 */ var Composition = /*#__PURE__*/ function(EventEmitter) {
    _inherits(Composition, EventEmitter);
    function Composition(props, scene) {
        var _this;
        _this = EventEmitter.call(this) || this;
        /**
   * 动画播放速度
   */ _this.speed = 1;
        /**
   * 用于保存与当前合成相关的插件数据
   */ _this.loaderData = {};
        /**
   * 预合成数组
   */ _this.refContent = [];
        /**
   * 预合成的合成属性，在 content 中会被其元素属性覆盖
   */ _this.refCompositionProps = new Map();
        // TODO: 待优化
        _this.assigned = false;
        /**
   * 销毁状态位
   */ _this.destroyed = false;
        _this.postLoaders = [];
        /**
   * 合成暂停/播放 标识
   */ _this.paused = false;
        _this.lastVideoUpdateTime = 0;
        var _props_reusable = props.reusable, reusable = _props_reusable === void 0 ? false : _props_reusable, _props_speed = props.speed, speed = _props_speed === void 0 ? 1 : _props_speed, _props_baseRenderOrder = props.baseRenderOrder, baseRenderOrder = _props_baseRenderOrder === void 0 ? 0 : _props_baseRenderOrder, renderer = props.renderer, event = props.event, width = props.width, height = props.height, handleItemMessage = props.handleItemMessage;
        _this.compositionSourceManager = new CompositionSourceManager(scene, renderer.engine);
        scene.jsonScene.imgUsage = undefined;
        if (reusable) {
            _this.keepResource = true;
            scene.textures = undefined;
            scene.consumed = true;
        }
        var _this_compositionSourceManager = _this.compositionSourceManager, sourceContent = _this_compositionSourceManager.sourceContent, pluginSystem = _this_compositionSourceManager.pluginSystem, imgUsage = _this_compositionSourceManager.imgUsage, totalTime = _this_compositionSourceManager.totalTime, refCompositionProps = _this_compositionSourceManager.refCompositionProps;
        assertExist(sourceContent);
        _this.renderer = renderer;
        _this.refCompositionProps = refCompositionProps;
        _this.rootItem = new exports.VFXItem(_this.getEngine(), sourceContent);
        _this.rootItem.name = "rootItem";
        _this.rootItem.composition = _assert_this_initialized(_this);
        _this.rootComposition = _this.rootItem.addComponent(CompositionComponent);
        _this.rootComposition.startTime = sourceContent.startTime;
        _this.rootComposition.data = sourceContent;
        var imageUsage = !reusable && imgUsage;
        _this.width = width;
        _this.height = height;
        _this.renderOrder = baseRenderOrder;
        _this.id = sourceContent.id;
        _this.renderer = renderer;
        _this.texInfo = imageUsage != null ? imageUsage : {};
        _this.event = event;
        var _scene_startTime, _scene_timeInfos_asyncCompile;
        _this.statistic = {
            loadTime: totalTime != null ? totalTime : 0,
            loadStart: (_scene_startTime = scene.startTime) != null ? _scene_startTime : 0,
            firstFrameTime: 0,
            precompileTime: (_scene_timeInfos_asyncCompile = scene.timeInfos["asyncCompile"]) != null ? _scene_timeInfos_asyncCompile : scene.timeInfos["syncCompile"]
        };
        _this.reusable = reusable;
        _this.speed = speed;
        _this.autoRefTex = !_this.keepResource && imageUsage && _this.rootItem.endBehavior !== EndBehavior.restart;
        _this.name = sourceContent.name;
        _this.pluginSystem = pluginSystem;
        _this.pluginSystem.initializeComposition(_assert_this_initialized(_this), scene);
        _this.camera = new Camera(_this.name, _extends({}, sourceContent == null ? void 0 : sourceContent.camera, {
            aspect: width / height
        }));
        _this.url = scene.url;
        _this.assigned = true;
        _this.globalTime = 0;
        _this.interactive = true;
        _this.handleItemMessage = handleItemMessage;
        _this.createRenderFrame();
        _this.rendererOptions = null;
        _this.rootComposition.createContent();
        _this.buildItemTree(_this.rootItem);
        _this.callAwake(_this.rootItem);
        _this.rootItem.onEnd = function() {
            douyin.window.setTimeout(function() {
                _this.emit("end", {
                    composition: _assert_this_initialized(_this)
                });
            }, 0);
        };
        _this.pluginSystem.resetComposition(_assert_this_initialized(_this), _this.renderFrame);
        return _this;
    }
    var _proto = Composition.prototype;
    /**
   * 获取合成的时长
   */ _proto.getDuration = function getDuration() {
        return this.rootItem.duration;
    };
    /**
   * 重新开始合成
   */ _proto.restart = function restart() {
        this.reset();
        this.forwardTime(this.startTime);
    };
    /**
   * 设置当前合成的渲染顺序
   * @param index - 序号，大的后绘制
   */ _proto.setIndex = function setIndex(index) {
        this.renderOrder = index;
    };
    /**
   * 获取当前合成的渲染顺序
   * @returns
   */ _proto.getIndex = function getIndex() {
        return this.renderOrder;
    };
    /**
   * 设置合成的动画速度
   * @param speed - 速度
   */ _proto.setSpeed = function setSpeed(speed) {
        this.speed = speed;
    };
    /**
   * 设置合成的可见性
   * @since 2.0.0
   * @param visible - 是否可见
   */ _proto.setVisible = function setVisible(visible) {
        this.items.forEach(function(item) {
            item.setVisible(visible);
        });
    };
    /**
   * 获取合成的动画速度
   * @returns
   */ _proto.getSpeed = function getSpeed() {
        return this.speed;
    };
    _proto.play = function play() {
        if (this.rootItem.ended && this.reusable) {
            this.restart();
        }
        if (this.rootComposition.isStartCalled) {
            this.gotoAndPlay(this.time - this.startTime);
        } else {
            this.gotoAndPlay(0);
        }
    };
    /**
   * 暂停合成的播放
   */ _proto.pause = function pause() {
        this.paused = true;
    };
    _proto.getPaused = function getPaused() {
        return this.paused;
    };
    /**
   * 恢复合成的播放
   */ _proto.resume = function resume() {
        this.paused = false;
    };
    /**
   * 跳转合成到指定时间播放
   * @param time - 相对 startTime 的时间
   */ _proto.gotoAndPlay = function gotoAndPlay(time) {
        this.setTime(time);
        this.resume();
    };
    /**
   * 跳转合成到指定时间并暂停
   * @param time - 相对 startTime 的时间
   */ _proto.gotoAndStop = function gotoAndStop(time) {
        this.setTime(time);
        this.pause();
    };
    /**
   *
   */ _proto.createRenderFrame = function createRenderFrame() {
        this.renderFrame = new RenderFrame({
            camera: this.camera,
            renderer: this.renderer,
            keepColorBuffer: this.keepColorBuffer,
            globalVolume: this.globalVolume
        });
        // TODO 考虑放到构造函数
        this.renderFrame.cachedTextures = this.textures;
    };
    /**
   * 跳到指定时间点（不做任何播放行为）
   * @param time - 相对 startTime 的时间
   */ _proto.setTime = function setTime(time) {
        var pause = this.paused;
        if (pause) {
            this.resume();
        }
        if (!this.rootComposition.isStartCalled) {
            this.rootComposition.start();
            this.rootComposition.isStartCalled = true;
        }
        this.forwardTime(time + this.startTime);
        if (pause) {
            this.pause();
        }
    };
    _proto.addItem = function addItem(item) {
        this.items.push(item);
        item.setParent(this.rootItem);
    };
    /**
   * 前进合成到指定时间
   * @param time - 相对0时刻的时间
   * @param skipRender - 是否跳过渲染
   */ _proto.forwardTime = function forwardTime(time) {
        var deltaTime = time * 1000 - this.rootComposition.time * 1000;
        var reverse = deltaTime < 0;
        var step = 15;
        var t = Math.abs(deltaTime);
        var ss = reverse ? -step : step;
        for(t; t > step; t -= step){
            this.update(ss);
        }
        this.update(reverse ? -t : t);
    };
    /**
   * 重置状态函数
   */ _proto.reset = function reset() {
        this.rendererOptions = null;
        this.globalTime = 0;
        this.rootItem.ended = false;
        this.pluginSystem.resetComposition(this, this.renderFrame);
    };
    _proto.prepareRender = function prepareRender() {
        var _this = this;
        var frame = this.renderFrame;
        frame._renderPasses[0].meshes.length = 0;
        this.postLoaders.length = 0;
        this.pluginSystem.plugins.forEach(function(loader) {
            if (loader.prepareRenderFrame(_this, frame)) {
                _this.postLoaders.push(loader);
            }
        });
        this.gatherRendererComponent(this.rootItem, frame);
        this.postLoaders.forEach(function(loader) {
            return loader.postProcessFrame(_this, frame);
        });
    };
    _proto.gatherRendererComponent = function gatherRendererComponent(vfxItem, renderFrame) {
        for(var _iterator = _create_for_of_iterator_helper_loose(vfxItem.rendererComponents), _step; !(_step = _iterator()).done;){
            var rendererComponent = _step.value;
            if (rendererComponent.isActiveAndEnabled) {
                renderFrame.addMeshToDefaultRenderPass(rendererComponent);
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(vfxItem.children), _step1; !(_step1 = _iterator1()).done;){
            var item = _step1.value;
            this.gatherRendererComponent(item, renderFrame);
        }
    };
    /**
   * 合成更新，针对所有 item 的更新
   * @param deltaTime - 更新的时间步长
   * @param skipRender - 是否需要渲染
   */ _proto.update = function update(deltaTime) {
        if (!this.assigned || this.paused) {
            return;
        }
        var time = this.getUpdateTime(deltaTime * this.speed);
        this.globalTime += time;
        this.updateRootComposition();
        this.updateVideo();
        // 更新 model-tree-plugin
        this.updatePluginLoaders(deltaTime);
        // scene VFXItem components lifetime function.
        this.callStart(this.rootItem);
        this.callUpdate(this.rootItem, time);
        this.callLateUpdate(this.rootItem, time);
        this.updateCamera();
        this.prepareRender();
        if (this.shouldDispose()) {
            this.dispose();
        }
    };
    _proto.toLocalTime = function toLocalTime(time) {
        var localTime = time - this.rootItem.start;
        var duration = this.rootItem.duration;
        if (localTime - duration > 0.001) {
            if (!this.rootItem.ended) {
                this.rootItem.ended = true;
                this.emit("end", {
                    composition: this
                });
            }
            switch(this.rootItem.endBehavior){
                case EndBehavior.restart:
                    {
                        localTime = localTime % duration;
                        this.restart();
                        break;
                    }
                case EndBehavior.freeze:
                    {
                        localTime = Math.min(duration, localTime);
                        break;
                    }
                case EndBehavior.forward:
                    {
                        break;
                    }
                case EndBehavior.destroy:
                    {
                        break;
                    }
            }
        }
        return localTime;
    };
    _proto.shouldDispose = function shouldDispose() {
        return this.rootItem.ended && this.rootItem.endBehavior === EndBehavior.destroy && !this.reusable;
    };
    _proto.getUpdateTime = function getUpdateTime(t) {
        var startTimeInMs = this.startTime * 1000;
        var now = this.rootComposition.time * 1000;
        if (t < 0 && now + t < startTimeInMs) {
            return startTimeInMs - now;
        }
        return t;
    };
    _proto.callAwake = function callAwake(item) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.itemBehaviours), _step; !(_step = _iterator()).done;){
            var itemBehaviour = _step.value;
            if (!itemBehaviour.isAwakeCalled) {
                itemBehaviour.awake();
                itemBehaviour.isAwakeCalled = true;
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(item.children), _step1; !(_step1 = _iterator1()).done;){
            var child = _step1.value;
            this.callAwake(child);
        }
    };
    _proto.callStart = function callStart(item) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.itemBehaviours), _step; !(_step = _iterator()).done;){
            var itemBehaviour = _step.value;
            if (itemBehaviour.isActiveAndEnabled && !itemBehaviour.isStartCalled) {
                itemBehaviour.start();
                itemBehaviour.isStartCalled = true;
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(item.rendererComponents), _step1; !(_step1 = _iterator1()).done;){
            var rendererComponent = _step1.value;
            if (rendererComponent.isActiveAndEnabled && !rendererComponent.isStartCalled) {
                rendererComponent.start();
                rendererComponent.isStartCalled = true;
            }
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(item.children), _step2; !(_step2 = _iterator2()).done;){
            var child = _step2.value;
            this.callStart(child);
        }
    };
    _proto.callUpdate = function callUpdate(item, dt) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.itemBehaviours), _step; !(_step = _iterator()).done;){
            var itemBehaviour = _step.value;
            if (itemBehaviour.isActiveAndEnabled && itemBehaviour.isStartCalled) {
                itemBehaviour.update(dt);
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(item.rendererComponents), _step1; !(_step1 = _iterator1()).done;){
            var rendererComponent = _step1.value;
            if (rendererComponent.isActiveAndEnabled && rendererComponent.isStartCalled) {
                rendererComponent.update(dt);
            }
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(item.children), _step2; !(_step2 = _iterator2()).done;){
            var child = _step2.value;
            if (exports.VFXItem.isComposition(child)) {
                if (child.ended && child.endBehavior === EndBehavior.restart) {
                    child.ended = false;
                    // TODO K帧动画在元素重建后需要 tick ，否则会导致元素位置和 k 帧第一帧位置不一致
                    this.callUpdate(child, 0);
                } else {
                    this.callUpdate(child, dt);
                }
            } else {
                this.callUpdate(child, dt);
            }
        }
    };
    _proto.callLateUpdate = function callLateUpdate(item, dt) {
        for(var _iterator = _create_for_of_iterator_helper_loose(item.itemBehaviours), _step; !(_step = _iterator()).done;){
            var itemBehaviour = _step.value;
            if (itemBehaviour.isActiveAndEnabled && itemBehaviour.isStartCalled) {
                itemBehaviour.lateUpdate(dt);
            }
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(item.rendererComponents), _step1; !(_step1 = _iterator1()).done;){
            var rendererComponent = _step1.value;
            if (rendererComponent.isActiveAndEnabled && rendererComponent.isStartCalled) {
                rendererComponent.lateUpdate(dt);
            }
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(item.children), _step2; !(_step2 = _iterator2()).done;){
            var child = _step2.value;
            this.callLateUpdate(child, dt);
        }
    };
    /**
   * 构建父子树，同时保存到 itemCacheMap 中便于查找
   */ _proto.buildItemTree = function buildItemTree(compVFXItem) {
        if (!compVFXItem.composition) {
            return;
        }
        var itemMap = new Map();
        var contentItems = compVFXItem.getComponent(CompositionComponent).items;
        for(var _iterator = _create_for_of_iterator_helper_loose(contentItems), _step; !(_step = _iterator()).done;){
            var item = _step.value;
            itemMap.set(item.id, item);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(contentItems), _step1; !(_step1 = _iterator1()).done;){
            var item1 = _step1.value;
            if (item1.parentId === undefined) {
                item1.setParent(compVFXItem);
            } else {
                // 兼容 treeItem 子元素的 parentId 带 '^'
                var parentId = this.getParentIdWithoutSuffix(item1.parentId);
                var parent = itemMap.get(parentId);
                if (parent) {
                    if (exports.VFXItem.isTree(parent) && item1.parentId.includes("^")) {
                        item1.parent = parent;
                        item1.transform.parentTransform = parent.getNodeTransform(item1.parentId);
                    } else {
                        item1.parent = parent;
                        item1.transform.parentTransform = parent.transform;
                    }
                    parent.children.push(item1);
                } else {
                    throw new Error("The element references a non-existent element, please check the data.");
                }
            }
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(contentItems), _step2; !(_step2 = _iterator2()).done;){
            var item2 = _step2.value;
            if (exports.VFXItem.isComposition(item2)) {
                this.buildItemTree(item2);
            }
        }
    };
    _proto.getParentIdWithoutSuffix = function getParentIdWithoutSuffix(id) {
        var idx = id.lastIndexOf("^");
        return idx > -1 ? id.substring(0, idx) : id;
    };
    /**
   * 更新视频数据到纹理
   * @override
   */ _proto.updateVideo = function updateVideo() {
        var now = douyin.performance.now();
        // 视频固定30帧更新
        if (now - this.lastVideoUpdateTime > 33) {
            var _this_textures;
            ((_this_textures = this.textures) != null ? _this_textures : []).forEach(function(tex) {
                return tex == null ? void 0 : tex.uploadCurrentVideoFrame();
            });
            this.lastVideoUpdateTime = now;
        }
    };
    /**
   * 更新相机
   * @override
   */ _proto.updateCamera = function updateCamera() {
        this.camera.updateMatrix();
    };
    /**
   * 插件更新，来自 CompVFXItem 的更新调用
   * @param deltaTime - 更新的时间步长
   */ _proto.updatePluginLoaders = function updatePluginLoaders(deltaTime) {
        var _this = this;
        this.pluginSystem.plugins.forEach(function(loader) {
            return loader.onCompositionUpdate(_this, deltaTime);
        });
    };
    /**
   * 更新主合成组件
   */ _proto.updateRootComposition = function updateRootComposition() {
        if (this.rootComposition.isActiveAndEnabled) {
            var localTime = this.toLocalTime(this.globalTime / 1000);
            this.rootComposition.time = localTime;
        }
    };
    /**
   * 通过名称获取元素
   * @param name - 元素名称
   * @returns 元素对象
   */ _proto.getItemByName = function getItemByName(name) {
        return this.rootItem.find(name);
    };
    /**
   * 获取指定位置和相机连成的射线
   * @param x
   * @param y
   * @returns
   */ _proto.getHitTestRay = function getHitTestRay(x, y) {
        var _this_renderFrame_editorTransform = this.renderFrame.editorTransform, a = _this_renderFrame_editorTransform.x, b = _this_renderFrame_editorTransform.y, c = _this_renderFrame_editorTransform.z, d = _this_renderFrame_editorTransform.w;
        return setRayFromCamera((x - c) / a, (y - d) / b, this.camera);
    };
    /**
   * 获取 engine 对象
   * @returns
   */ _proto.getEngine = function getEngine() {
        var _this_renderer;
        return (_this_renderer = this.renderer) == null ? void 0 : _this_renderer.engine;
    };
    /**
   * Item 求交测试，返回求交结果列表，x 和 y 是归一化到[-1, 1]区间的值，原点在左上角
   * @param x - 鼠标或触点的 x，已经归一化到[-1, 1]
   * @param y - 鼠标或触点的 y，已经归一化到[-1, 1]
   * @param force - 是否强制求交，没有交互信息的 Item 也要进行求交测试
   * @param options - 最大求交数和求交时的回调
   */ _proto.hitTest = function hitTest(x, y, force, options) {
        var _this_rootItem_getComponent;
        if (this.isDestroyed || !this.interactive) {
            return [];
        }
        var regions = [];
        var ray = this.getHitTestRay(x, y);
        (_this_rootItem_getComponent = this.rootItem.getComponent(CompositionComponent)) == null ? void 0 : _this_rootItem_getComponent.hitTest(ray, x, y, regions, force, options);
        this.refContent.forEach(function(ref) {
            var _ref_getComponent;
            (_ref_getComponent = ref.getComponent(CompositionComponent)) == null ? void 0 : _ref_getComponent.hitTest(ray, x, y, regions, force, options);
        });
        return regions;
    };
    /**
   * InteractItem 生命周期开始时的调用
   * @param item - 交互元素
   * @param type - 交互类型
   */ _proto.addInteractiveItem = function addInteractiveItem(item, type) {
        if (type === InteractType.MESSAGE) {
            this.handleItemMessage({
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_BEGIN,
                id: item.id,
                compositionId: this.id
            });
            item.emit("message", {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_BEGIN,
                id: item.id
            });
            return item.id;
        }
    };
    /**
   * InteractItem 生命周期结束时的调用
   * @param item - 交互元素
   * @param type - 交互类型
   */ _proto.removeInteractiveItem = function removeInteractiveItem(item, type) {
        // MESSAGE ITEM 的结束行为
        if (type === InteractType.MESSAGE) {
            this.handleItemMessage({
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_END,
                id: item.id,
                compositionId: this.id
            });
            item.emit("message", {
                name: item.name,
                phrase: MESSAGE_ITEM_PHRASE_END,
                id: item.id
            });
        }
    };
    /**
   * 销毁插件 Item 中保存的纹理数组
   * @internal
   * @param textures - 需要销毁的数组
   */ _proto.destroyTextures = function destroyTextures(textures) {
        for(var i = 0; i < textures.length; i++){
            var texture = textures[i];
            if (!texture) {
                continue;
            }
            if (texture.sourceType === exports.TextureSourceType.data && !this.texInfo[texture.getInstanceId()]) {
                var _this_rendererOptions;
                if (texture !== ((_this_rendererOptions = this.rendererOptions) == null ? void 0 : _this_rendererOptions.emptyTexture) && texture !== this.renderFrame.transparentTexture && texture !== this.getEngine().emptyTexture) {
                    texture.dispose();
                }
                continue;
            }
            if (this.autoRefTex) {
                // texInfo的类型有点不明确，改成<string, number>不会提前删除texture
                var c = --this.texInfo[texture.getInstanceId()];
                if (!c) {
                    texture.dispose();
                }
            }
        }
    };
    /**
   * 销毁 Item
   * @internal
   * @param item - 需要销毁的 item
   */ _proto.destroyItem = function destroyItem(item) {
        var _this = this;
        // 预合成元素销毁时销毁其中的item
        if (item.type == ItemType.composition) {
            if (item.endBehavior !== EndBehavior.freeze) {
                var contentItems = item.getComponent(CompositionComponent).items;
                contentItems.forEach(function(it) {
                    return _this.pluginSystem.plugins.forEach(function(loader) {
                        return loader.onCompositionItemRemoved(_this, it);
                    });
                });
            }
        } else {
            // this.content.removeItem(item);
            // 预合成中的元素移除
            // this.refContent.forEach(content => content.removeItem(item));
            removeItem(this.items, item);
            this.pluginSystem.plugins.forEach(function(loader) {
                return loader.onCompositionItemRemoved(_this, item);
            });
        }
    };
    _proto.lost = function lost(e) {
        this.videoState = this.textures.map(function(tex) {
            if ("video" in tex.source) {
                tex.source.video.pause();
                return tex.source.video.currentTime;
            }
        });
        this.textures.map(function(tex) {
            return tex.dispose();
        });
        this.dispose();
    };
    /**
   * 合成对象销毁
   */ _proto.dispose = function dispose() {
        var _this = this;
        var _this_rendererOptions, _this_pluginSystem;
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var textureDisposes = {};
        var textures = this.textures;
        if (textures) {
            if (this.keepResource) {
                textures.forEach(function(tex) {
                    if (tex == null ? void 0 : tex.dispose) {
                        textureDisposes[tex.id] = tex.dispose;
                        tex.dispose = noop;
                    }
                });
            }
        }
        this.rootItem.dispose();
        // FIXME: 注意这里增加了renderFrame销毁
        this.renderFrame.dispose();
        (_this_rendererOptions = this.rendererOptions) == null ? void 0 : _this_rendererOptions.emptyTexture.dispose();
        (_this_pluginSystem = this.pluginSystem) == null ? void 0 : _this_pluginSystem.destroyComposition(this);
        this.update = function() {
            {
                logger.error("Update disposed composition: " + _this.name + ".");
            }
        };
        this.dispose = noop;
        if (textures && this.keepResource) {
            textures.forEach(function(tex) {
                return tex.dispose = textureDisposes[tex.id];
            });
        }
        this.compositionSourceManager.dispose();
        this.refCompositionProps.clear();
        if (this.renderer.env === PLAYER_OPTIONS_ENV_EDITOR) {
            return;
        }
        this.renderer.clear({
            stencilAction: exports.TextureLoadAction.clear,
            clearStencil: 0,
            depthAction: exports.TextureLoadAction.clear,
            clearDepth: 1,
            colorAction: exports.TextureLoadAction.clear,
            clearColor: [
                0,
                0,
                0,
                0
            ]
        });
    };
    /**
   * 编辑器使用的 transform 修改方法
   * @internal
   * @param scale - 缩放比例
   * @param dx - x偏移量
   * @param dy - y偏移量
   */ _proto.setEditorTransform = function setEditorTransform(scale, dx, dy) {
        this.renderFrame.editorTransform.set(scale, scale, dx, dy);
    };
    /**
   * 合成整体在水平方向移动 x 像素，垂直方向移动 y 像素
   */ _proto.translateByPixel = function translateByPixel(x, y) {
        if (!this.renderer) {
            console.warn("Renderer not assigned. Operation aborted.");
            return;
        }
        this.rootItem.translateByPixel(x, y);
    };
    /**
   * 设置合成在画布上的像素位置
   * Tips:
   *  - 坐标原点在 canvas 左上角，x 正方向水平向右， y 正方向垂直向下
   *  - 设置后会覆盖原有的位置信息
   * @param x - x 坐标
   * @param y - y 坐标
   */ _proto.setPositionByPixel = function setPositionByPixel(x, y) {
        if (!this.renderer) {
            console.warn("Renderer not assigned. Operation aborted.");
            return;
        }
        this.rootItem.setPositionByPixel(x, y);
    };
    /**
   * 设置合成在 3D 坐标轴上相对当前的位移
   */ _proto.translate = function translate(x, y, z) {
        this.rootItem.translate(x, y, z);
    };
    /**
   * 设置合成在 3D 坐标轴上相对原点的位移
   */ _proto.setPosition = function setPosition(x, y, z) {
        this.rootItem.setPosition(x, y, z);
    };
    /**
   * 设置合成在 3D 坐标轴上相对当前的旋转（角度）
   */ _proto.rotate = function rotate(x, y, z) {
        this.rootItem.rotate(x, y, z);
    };
    /**
   * 设置合成在 3D 坐标轴上的相对原点的旋转（角度）
   */ _proto.setRotation = function setRotation(x, y, z) {
        this.rootItem.setRotation(x, y, z);
    };
    /**
   * 设置合成在 3D 坐标轴上相对当前的缩放
   */ _proto.scale = function scale(x, y, z) {
        this.rootItem.scale(x, y, z);
    };
    /**
   * 设置合成在 3D 坐标轴上的缩放
   */ _proto.setScale = function setScale(x, y, z) {
        this.rootItem.setScale(x, y, z);
    };
    /**
   * 卸载贴图纹理方法，减少内存
   */ _proto.offloadTexture = function offloadTexture() {
        if (!this.textureOffloaded) {
            this.textures.forEach(function(tex) {
                return tex && tex.offloadData();
            });
            this.textureOffloaded = true;
        }
    };
    _proto.getRendererOptions = function getRendererOptions() {
        if (!this.rendererOptions) {
            this.rendererOptions = {
                emptyTexture: this.renderFrame.emptyTexture,
                cachePrefix: "-"
            };
        }
        return this.rendererOptions;
    };
    /**
   * 重新加载纹理
   */ _proto.reloadTexture = function reloadTexture() {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!_this.textureOffloaded) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            Promise.all(_this.textures.map(function(tex) {
                                return tex == null ? void 0 : tex.reloadData();
                            }))
                        ];
                    case 1:
                        _state.sent();
                        _this.textureOffloaded = false;
                        _state.label = 2;
                    case 2:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _create_class(Composition, [
        {
            key: "transform",
            get: /**
   * 所有合成 Item 的根变换
   */ function get() {
                return this.rootItem.transform;
            }
        },
        {
            key: "textures",
            get: /**
   * 获取场景中的纹理数组
   */ function get() {
                return this.compositionSourceManager.textures;
            }
        },
        {
            key: "items",
            get: /**
   * 获取合成中所有元素
   */ function get() {
                return this.rootComposition.items;
            }
        },
        {
            key: "startTime",
            get: /**
   * 获取合成开始渲染的时间
   */ function get() {
                var _this_rootComposition_startTime;
                return (_this_rootComposition_startTime = this.rootComposition.startTime) != null ? _this_rootComposition_startTime : 0;
            }
        },
        {
            key: "time",
            get: /**
   * 获取合成当前时间
   */ function get() {
                return this.rootComposition.time;
            }
        },
        {
            key: "isDestroyed",
            get: /**
   * 获取销毁状态
   */ function get() {
                return this.destroyed;
            }
        },
        {
            key: "viewportMatrix",
            get: function get() {
                return this.camera.getViewportMatrix();
            },
            set: function set(matrix) {
                this.camera.setViewportMatrix(matrix);
            }
        }
    ]);
    return Composition;
}(EventEmitter);

var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;

var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([
    1,
    0
]).buffer)[0] === 1;

var Encoding;
(function(Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

var ByteBuffer = /*#__PURE__*/ function() {
    function ByteBuffer(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
    }
    var _proto = ByteBuffer.prototype;
    _proto.clear = function clear() {
        this.position_ = 0;
    };
    /**
     * Get the underlying `Uint8Array`.
     */ _proto.bytes = function bytes() {
        return this.bytes_;
    };
    /**
     * Get the buffer's position.
     */ _proto.position = function position() {
        return this.position_;
    };
    /**
     * Set the buffer's position.
     */ _proto.setPosition = function setPosition(position) {
        this.position_ = position;
    };
    /**
     * Get the buffer's capacity.
     */ _proto.capacity = function capacity() {
        return this.bytes_.length;
    };
    _proto.readInt8 = function readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    };
    _proto.readUint8 = function readUint8(offset) {
        return this.bytes_[offset];
    };
    _proto.readInt16 = function readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    };
    _proto.readUint16 = function readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };
    _proto.readInt32 = function readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };
    _proto.readUint32 = function readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    };
    _proto.readInt64 = function readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    };
    _proto.readUint64 = function readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    };
    _proto.readFloat32 = function readFloat32(offset) {
        int32[0] = this.readInt32(offset);
        return float32[0];
    };
    _proto.readFloat64 = function readFloat64(offset) {
        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return float64[0];
    };
    _proto.writeInt8 = function writeInt8(offset, value) {
        this.bytes_[offset] = value;
    };
    _proto.writeUint8 = function writeUint8(offset, value) {
        this.bytes_[offset] = value;
    };
    _proto.writeInt16 = function writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    };
    _proto.writeUint16 = function writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    };
    _proto.writeInt32 = function writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    };
    _proto.writeUint32 = function writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    };
    _proto.writeInt64 = function writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    };
    _proto.writeUint64 = function writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    };
    _proto.writeFloat32 = function writeFloat32(offset, value) {
        float32[0] = value;
        this.writeInt32(offset, int32[0]);
    };
    _proto.writeFloat64 = function writeFloat64(offset, value) {
        float64[0] = value;
        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    };
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */ _proto.getBufferIdentifier = function getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
            throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
        }
        var result = "";
        for(var i = 0; i < FILE_IDENTIFIER_LENGTH; i++){
            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
        }
        return result;
    };
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */ _proto.__offset = function __offset(bb_pos, vtable_offset) {
        var vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */ _proto.__union = function __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    };
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */ _proto.__string = function __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        var length = this.readInt32(offset);
        offset += SIZEOF_INT;
        var utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === Encoding.UTF8_BYTES) return utf8bytes;
        else return this.text_decoder_.decode(utf8bytes);
    };
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */ _proto.__union_with_string = function __union_with_string(o, offset) {
        if (typeof o === "string") {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    };
    /**
     * Retrieve the relative offset stored at "offset"
     */ _proto.__indirect = function __indirect(offset) {
        return offset + this.readInt32(offset);
    };
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */ _proto.__vector = function __vector(offset) {
        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length
    };
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */ _proto.__vector_len = function __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    };
    _proto.__has_identifier = function __has_identifier(ident) {
        if (ident.length != FILE_IDENTIFIER_LENGTH) {
            throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for(var i = 0; i < FILE_IDENTIFIER_LENGTH; i++){
            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    };
    /**
     * A helper function for generating list for obj api
     */ _proto.createScalarList = function createScalarList(listAccessor, listLength) {
        var ret = [];
        for(var i = 0; i < listLength; ++i){
            var val = listAccessor(i);
            if (val !== null) {
                ret.push(val);
            }
        }
        return ret;
    };
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */ _proto.createObjList = function createObjList(listAccessor, listLength) {
        var ret = [];
        for(var i = 0; i < listLength; ++i){
            var val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    };
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */ ByteBuffer.allocate = function allocate(byte_size) {
        return new ByteBuffer(new Uint8Array(byte_size));
    };
    return ByteBuffer;
}();

var Builder = /*#__PURE__*/ function() {
    function Builder(opt_initial_size) {
        /** Minimum alignment encountered so far. */ this.minalign = 1;
        /** The vtable for the current table. */ this.vtable = null;
        /** The amount of fields we're actually using. */ this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */ this.isNested = false;
        /** Starting offset of the current struct/table. */ this.object_start = 0;
        /** List of offsets of all vtables. */ this.vtables = [];
        /** For the current vector being built. */ this.vector_num_elems = 0;
        /** False omits default values from the serialized data */ this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        var initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        } else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */ this.bb = ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    var _proto = Builder.prototype;
    _proto.clear = function clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    };
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */ _proto.forceDefaults = function forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    };
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */ _proto.dataBuffer = function dataBuffer() {
        return this.bb;
    };
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */ _proto.asUint8Array = function asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */ _proto.prep = function prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
        // Reallocate the buffer if needed.
        while(this.space < align_size + size + additional_bytes){
            var old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    };
    _proto.pad = function pad(byte_size) {
        for(var i = 0; i < byte_size; i++){
            this.bb.writeInt8(--this.space, 0);
        }
    };
    _proto.writeInt8 = function writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    };
    _proto.writeInt16 = function writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    };
    _proto.writeInt32 = function writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    };
    _proto.writeInt64 = function writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    };
    _proto.writeFloat32 = function writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    };
    _proto.writeFloat64 = function writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    };
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */ _proto.addInt8 = function addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    };
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */ _proto.addInt16 = function addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    };
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */ _proto.addInt32 = function addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    };
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */ _proto.addInt64 = function addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    };
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */ _proto.addFloat32 = function addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    };
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */ _proto.addFloat64 = function addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    };
    _proto.addFieldInt8 = function addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldInt16 = function addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldInt32 = function addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldInt64 = function addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldFloat32 = function addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldFloat64 = function addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    };
    _proto.addFieldOffset = function addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    };
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */ _proto.addFieldStruct = function addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    };
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */ _proto.nested = function nested(obj) {
        if (obj != this.offset()) {
            throw new TypeError("FlatBuffers: struct must be serialized inline.");
        }
    };
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */ _proto.notNested = function notNested() {
        if (this.isNested) {
            throw new TypeError("FlatBuffers: object serialization must not be nested.");
        }
    };
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */ _proto.slot = function slot(voffset) {
        if (this.vtable !== null) this.vtable[voffset] = this.offset();
    };
    /**
     * @returns Offset relative to the end of the buffer.
     */ _proto.offset = function offset() {
        return this.bb.capacity() - this.space;
    };
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */ _proto.addOffset = function addOffset(offset) {
        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + SIZEOF_INT);
    };
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */ _proto.startObject = function startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for(var i = 0; i < numfields; i++){
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    };
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */ _proto.endObject = function endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error("FlatBuffers: endObject called without startObject");
        }
        this.addInt32(0);
        var vtableloc = this.offset();
        // Trim trailing zeroes.
        var i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for(; i >= 0 && this.vtable[i] == 0; i--){}
        var trimmed_size = i + 1;
        // Write out the current vtable.
        for(; i >= 0; i--){
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        var standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        var len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        var existing_vtable = 0;
        var vt1 = this.space;
        outer_loop: for(i = 0; i < this.vtables.length; i++){
            var vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for(var j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT){
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        } else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    };
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */ _proto.finish = function finish(root_table, opt_file_identifier, opt_size_prefix) {
        var size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            var file_identifier = opt_file_identifier;
            this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
                throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
            }
            for(var i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--){
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    };
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */ _proto.finishSizePrefixed = function finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    };
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */ _proto.requiredField = function requiredField(table, field) {
        var table_start = this.bb.capacity() - table;
        var vtable_start = table_start - this.bb.readInt32(table_start);
        var ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new TypeError("FlatBuffers: field " + field + " must be set");
        }
    };
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */ _proto.startVector = function startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    };
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */ _proto.endVector = function endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    };
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */ _proto.createSharedString = function createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        var offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    };
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */ _proto.createString = function createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        var utf8;
        if (_instanceof1(s, Uint8Array)) {
            utf8 = s;
        } else {
            utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        this.bb.bytes().set(utf8, this.space);
        return this.endVector();
    };
    /**
     * Create a byte vector.
     *
     * @param v The bytes to add
     * @returns The offset in the buffer where the byte vector starts
     */ _proto.createByteVector = function createByteVector(v) {
        if (v === null || v === undefined) {
            return 0;
        }
        this.startVector(1, v.length, 1);
        this.bb.setPosition(this.space -= v.length);
        this.bb.bytes().set(v, this.space);
        return this.endVector();
    };
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */ _proto.createObjectOffset = function createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === "string") {
            return this.createString(obj);
        } else {
            return obj.pack(this);
        }
    };
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */ _proto.createObjectOffsetList = function createObjectOffsetList(list) {
        var ret = [];
        for(var i = 0; i < list.length; ++i){
            var val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            } else {
                throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
            }
        }
        return ret;
    };
    _proto.createStructOffsetList = function createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
    };
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */ Builder.growByteBuffer = function growByteBuffer(bb) {
        var old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
        }
        var new_buf_size = old_buf_size << 1;
        var nbb = ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    };
    return Builder;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBEffectsObjectData = /*#__PURE__*/ function() {
    function FBEffectsObjectData() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBEffectsObjectData.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.dataType = function dataType(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.data = function data(index) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    _proto.dataLength = function dataLength() {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.dataArray = function dataArray() {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    _proto.unpack = function unpack() {
        return new FBEffectsObjectDataT(this.dataType(), this.bb.createScalarList(this.data.bind(this), this.dataLength()));
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.dataType = this.dataType();
        _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());
    };
    FBEffectsObjectData.getRootAsFBEffectsObjectData = function getRootAsFBEffectsObjectData(bb, obj) {
        return (obj || new FBEffectsObjectData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBEffectsObjectData.getSizePrefixedRootAsFBEffectsObjectData = function getSizePrefixedRootAsFBEffectsObjectData(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBEffectsObjectData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBEffectsObjectData.startFBEffectsObjectData = function startFBEffectsObjectData(builder) {
        builder.startObject(2);
    };
    FBEffectsObjectData.addDataType = function addDataType(builder, dataTypeOffset) {
        builder.addFieldOffset(0, dataTypeOffset, 0);
    };
    FBEffectsObjectData.addData = function addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    };
    FBEffectsObjectData.createDataVector = function createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    FBEffectsObjectData.startDataVector = function startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    FBEffectsObjectData.endFBEffectsObjectData = function endFBEffectsObjectData(builder) {
        var offset = builder.endObject();
        return offset;
    };
    FBEffectsObjectData.createFBEffectsObjectData = function createFBEffectsObjectData(builder, dataTypeOffset, dataOffset) {
        FBEffectsObjectData.startFBEffectsObjectData(builder);
        FBEffectsObjectData.addDataType(builder, dataTypeOffset);
        FBEffectsObjectData.addData(builder, dataOffset);
        return FBEffectsObjectData.endFBEffectsObjectData(builder);
    };
    return FBEffectsObjectData;
}();
var FBEffectsObjectDataT = /*#__PURE__*/ function() {
    function FBEffectsObjectDataT(dataType, data) {
        if (dataType === void 0) dataType = null;
        if (data === void 0) data = [];
        this.dataType = dataType;
        this.data = data;
    }
    var _proto = FBEffectsObjectDataT.prototype;
    _proto.pack = function pack(builder) {
        var dataType = this.dataType !== null ? builder.createString(this.dataType) : 0;
        var data = FBEffectsObjectData.createDataVector(builder, this.data);
        return FBEffectsObjectData.createFBEffectsObjectData(builder, dataType, data);
    };
    return FBEffectsObjectDataT;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBEffectsPackageData = /*#__PURE__*/ function() {
    function FBEffectsPackageData() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBEffectsPackageData.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.exportObjects = function exportObjects(index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new FBEffectsObjectData()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    _proto.exportObjectsLength = function exportObjectsLength() {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.unpack = function unpack() {
        return new FBEffectsPackageDataT(this.bb.createObjList(this.exportObjects.bind(this), this.exportObjectsLength()));
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.exportObjects = this.bb.createObjList(this.exportObjects.bind(this), this.exportObjectsLength());
    };
    FBEffectsPackageData.getRootAsFBEffectsPackageData = function getRootAsFBEffectsPackageData(bb, obj) {
        return (obj || new FBEffectsPackageData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBEffectsPackageData.getSizePrefixedRootAsFBEffectsPackageData = function getSizePrefixedRootAsFBEffectsPackageData(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBEffectsPackageData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBEffectsPackageData.startFBEffectsPackageData = function startFBEffectsPackageData(builder) {
        builder.startObject(1);
    };
    FBEffectsPackageData.addExportObjects = function addExportObjects(builder, exportObjectsOffset) {
        builder.addFieldOffset(0, exportObjectsOffset, 0);
    };
    FBEffectsPackageData.createExportObjectsVector = function createExportObjectsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    FBEffectsPackageData.startExportObjectsVector = function startExportObjectsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    FBEffectsPackageData.endFBEffectsPackageData = function endFBEffectsPackageData(builder) {
        var offset = builder.endObject();
        return offset;
    };
    FBEffectsPackageData.finishFBEffectsPackageDataBuffer = function finishFBEffectsPackageDataBuffer(builder, offset) {
        builder.finish(offset);
    };
    FBEffectsPackageData.finishSizePrefixedFBEffectsPackageDataBuffer = function finishSizePrefixedFBEffectsPackageDataBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    };
    FBEffectsPackageData.createFBEffectsPackageData = function createFBEffectsPackageData(builder, exportObjectsOffset) {
        FBEffectsPackageData.startFBEffectsPackageData(builder);
        FBEffectsPackageData.addExportObjects(builder, exportObjectsOffset);
        return FBEffectsPackageData.endFBEffectsPackageData(builder);
    };
    return FBEffectsPackageData;
}();
var FBEffectsPackageDataT = /*#__PURE__*/ function() {
    function FBEffectsPackageDataT(exportObjects) {
        if (exportObjects === void 0) exportObjects = [];
        this.exportObjects = exportObjects;
    }
    var _proto = FBEffectsPackageDataT.prototype;
    _proto.pack = function pack(builder) {
        var exportObjects = FBEffectsPackageData.createExportObjectsVector(builder, builder.createObjectOffsetList(this.exportObjects));
        return FBEffectsPackageData.createFBEffectsPackageData(builder, exportObjects);
    };
    return FBEffectsPackageDataT;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBSubMesh = /*#__PURE__*/ function() {
    function FBSubMesh() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBSubMesh.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.offset = function offset() {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.indexCount = function indexCount() {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.vertexCount = function vertexCount() {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.unpack = function unpack() {
        return new FBSubMeshT(this.offset(), this.indexCount(), this.vertexCount());
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.offset = this.offset();
        _o.indexCount = this.indexCount();
        _o.vertexCount = this.vertexCount();
    };
    FBSubMesh.getRootAsFBSubMesh = function getRootAsFBSubMesh(bb, obj) {
        return (obj || new FBSubMesh()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBSubMesh.getSizePrefixedRootAsFBSubMesh = function getSizePrefixedRootAsFBSubMesh(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBSubMesh()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBSubMesh.startFBSubMesh = function startFBSubMesh(builder) {
        builder.startObject(3);
    };
    FBSubMesh.addOffset = function addOffset(builder, offset) {
        builder.addFieldInt32(0, offset, 0);
    };
    FBSubMesh.addIndexCount = function addIndexCount(builder, indexCount) {
        builder.addFieldInt32(1, indexCount, 0);
    };
    FBSubMesh.addVertexCount = function addVertexCount(builder, vertexCount) {
        builder.addFieldInt32(2, vertexCount, 0);
    };
    FBSubMesh.endFBSubMesh = function endFBSubMesh(builder) {
        var offset = builder.endObject();
        return offset;
    };
    FBSubMesh.createFBSubMesh = function createFBSubMesh(builder, offset, indexCount, vertexCount) {
        FBSubMesh.startFBSubMesh(builder);
        FBSubMesh.addOffset(builder, offset);
        FBSubMesh.addIndexCount(builder, indexCount);
        FBSubMesh.addVertexCount(builder, vertexCount);
        return FBSubMesh.endFBSubMesh(builder);
    };
    return FBSubMesh;
}();
var FBSubMeshT = /*#__PURE__*/ function() {
    function FBSubMeshT(offset, indexCount, vertexCount) {
        if (offset === void 0) offset = 0;
        if (indexCount === void 0) indexCount = 0;
        if (vertexCount === void 0) vertexCount = 0;
        this.offset = offset;
        this.indexCount = indexCount;
        this.vertexCount = vertexCount;
    }
    var _proto = FBSubMeshT.prototype;
    _proto.pack = function pack(builder) {
        return FBSubMesh.createFBSubMesh(builder, this.offset, this.indexCount, this.vertexCount);
    };
    return FBSubMeshT;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBVertexChannel = /*#__PURE__*/ function() {
    function FBVertexChannel() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBVertexChannel.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.semantic = function semantic(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.offset = function offset() {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.format = function format() {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.dimension = function dimension() {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.normalize = function normalize() {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    _proto.unpack = function unpack() {
        return new FBVertexChannelT(this.semantic(), this.offset(), this.format(), this.dimension(), this.normalize());
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.semantic = this.semantic();
        _o.offset = this.offset();
        _o.format = this.format();
        _o.dimension = this.dimension();
        _o.normalize = this.normalize();
    };
    FBVertexChannel.getRootAsFBVertexChannel = function getRootAsFBVertexChannel(bb, obj) {
        return (obj || new FBVertexChannel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBVertexChannel.getSizePrefixedRootAsFBVertexChannel = function getSizePrefixedRootAsFBVertexChannel(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBVertexChannel()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBVertexChannel.startFBVertexChannel = function startFBVertexChannel(builder) {
        builder.startObject(5);
    };
    FBVertexChannel.addSemantic = function addSemantic(builder, semanticOffset) {
        builder.addFieldOffset(0, semanticOffset, 0);
    };
    FBVertexChannel.addOffset = function addOffset(builder, offset) {
        builder.addFieldInt32(1, offset, 0);
    };
    FBVertexChannel.addFormat = function addFormat(builder, format) {
        builder.addFieldInt32(2, format, 0);
    };
    FBVertexChannel.addDimension = function addDimension(builder, dimension) {
        builder.addFieldInt32(3, dimension, 0);
    };
    FBVertexChannel.addNormalize = function addNormalize(builder, normalize) {
        builder.addFieldInt8(4, +normalize, +false);
    };
    FBVertexChannel.endFBVertexChannel = function endFBVertexChannel(builder) {
        var offset = builder.endObject();
        return offset;
    };
    FBVertexChannel.createFBVertexChannel = function createFBVertexChannel(builder, semanticOffset, offset, format, dimension, normalize) {
        FBVertexChannel.startFBVertexChannel(builder);
        FBVertexChannel.addSemantic(builder, semanticOffset);
        FBVertexChannel.addOffset(builder, offset);
        FBVertexChannel.addFormat(builder, format);
        FBVertexChannel.addDimension(builder, dimension);
        FBVertexChannel.addNormalize(builder, normalize);
        return FBVertexChannel.endFBVertexChannel(builder);
    };
    return FBVertexChannel;
}();
var FBVertexChannelT = /*#__PURE__*/ function() {
    function FBVertexChannelT(semantic, offset, format, dimension, normalize) {
        if (semantic === void 0) semantic = null;
        if (offset === void 0) offset = 0;
        if (format === void 0) format = 0;
        if (dimension === void 0) dimension = 0;
        if (normalize === void 0) normalize = false;
        this.semantic = semantic;
        this.offset = offset;
        this.format = format;
        this.dimension = dimension;
        this.normalize = normalize;
    }
    var _proto = FBVertexChannelT.prototype;
    _proto.pack = function pack(builder) {
        var semantic = this.semantic !== null ? builder.createString(this.semantic) : 0;
        return FBVertexChannel.createFBVertexChannel(builder, semantic, this.offset, this.format, this.dimension, this.normalize);
    };
    return FBVertexChannelT;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBVertexData = /*#__PURE__*/ function() {
    function FBVertexData() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBVertexData.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.vertexCount = function vertexCount() {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.channels = function channels(index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new FBVertexChannel()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    _proto.channelsLength = function channelsLength() {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.unpack = function unpack() {
        return new FBVertexDataT(this.vertexCount(), this.bb.createObjList(this.channels.bind(this), this.channelsLength()));
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.vertexCount = this.vertexCount();
        _o.channels = this.bb.createObjList(this.channels.bind(this), this.channelsLength());
    };
    FBVertexData.getRootAsFBVertexData = function getRootAsFBVertexData(bb, obj) {
        return (obj || new FBVertexData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBVertexData.getSizePrefixedRootAsFBVertexData = function getSizePrefixedRootAsFBVertexData(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBVertexData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBVertexData.startFBVertexData = function startFBVertexData(builder) {
        builder.startObject(2);
    };
    FBVertexData.addVertexCount = function addVertexCount(builder, vertexCount) {
        builder.addFieldInt32(0, vertexCount, 0);
    };
    FBVertexData.addChannels = function addChannels(builder, channelsOffset) {
        builder.addFieldOffset(1, channelsOffset, 0);
    };
    FBVertexData.createChannelsVector = function createChannelsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    FBVertexData.startChannelsVector = function startChannelsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    FBVertexData.endFBVertexData = function endFBVertexData(builder) {
        var offset = builder.endObject();
        return offset;
    };
    FBVertexData.createFBVertexData = function createFBVertexData(builder, vertexCount, channelsOffset) {
        FBVertexData.startFBVertexData(builder);
        FBVertexData.addVertexCount(builder, vertexCount);
        FBVertexData.addChannels(builder, channelsOffset);
        return FBVertexData.endFBVertexData(builder);
    };
    return FBVertexData;
}();
var FBVertexDataT = /*#__PURE__*/ function() {
    function FBVertexDataT(vertexCount, channels) {
        if (vertexCount === void 0) vertexCount = 0;
        if (channels === void 0) channels = [];
        this.vertexCount = vertexCount;
        this.channels = channels;
    }
    var _proto = FBVertexDataT.prototype;
    _proto.pack = function pack(builder) {
        var channels = FBVertexData.createChannelsVector(builder, builder.createObjectOffsetList(this.channels));
        return FBVertexData.createFBVertexData(builder, this.vertexCount, channels);
    };
    return FBVertexDataT;
}();

// automatically generated by the FlatBuffers compiler, do not modify
var FBGeometryData = /*#__PURE__*/ function() {
    function FBGeometryData() {
        this.bb = null;
        this.bb_pos = 0;
    }
    var _proto = FBGeometryData.prototype;
    _proto.__init = function __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    _proto.id = function id(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.name = function name(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.vertexData = function vertexData(obj) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new FBVertexData()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    _proto.indexFormat = function indexFormat() {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.indexOffset = function indexOffset() {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.subMeshes = function subMeshes(index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new FBSubMesh()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    _proto.subMeshesLength = function subMeshesLength() {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.mode = function mode() {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    _proto.buffer = function buffer(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.binaryData = function binaryData(index) {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    };
    _proto.binaryDataLength = function binaryDataLength() {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.binaryDataArray = function binaryDataArray() {
        var offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    _proto.boneNames = function boneNames(index, optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    };
    _proto.boneNamesLength = function boneNamesLength() {
        var offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.rootBoneName = function rootBoneName(optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    _proto.inverseBindMatrices = function inverseBindMatrices(index) {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    _proto.inverseBindMatricesLength = function inverseBindMatricesLength() {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    _proto.inverseBindMatricesArray = function inverseBindMatricesArray() {
        var offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    _proto.unpack = function unpack() {
        return new FBGeometryDataT(this.id(), this.name(), this.vertexData() !== null ? this.vertexData().unpack() : null, this.indexFormat(), this.indexOffset(), this.bb.createObjList(this.subMeshes.bind(this), this.subMeshesLength()), this.mode(), this.buffer(), this.bb.createScalarList(this.binaryData.bind(this), this.binaryDataLength()), this.bb.createScalarList(this.boneNames.bind(this), this.boneNamesLength()), this.rootBoneName(), this.bb.createScalarList(this.inverseBindMatrices.bind(this), this.inverseBindMatricesLength()));
    };
    _proto.unpackTo = function unpackTo(_o) {
        _o.id = this.id();
        _o.name = this.name();
        _o.vertexData = this.vertexData() !== null ? this.vertexData().unpack() : null;
        _o.indexFormat = this.indexFormat();
        _o.indexOffset = this.indexOffset();
        _o.subMeshes = this.bb.createObjList(this.subMeshes.bind(this), this.subMeshesLength());
        _o.mode = this.mode();
        _o.buffer = this.buffer();
        _o.binaryData = this.bb.createScalarList(this.binaryData.bind(this), this.binaryDataLength());
        _o.boneNames = this.bb.createScalarList(this.boneNames.bind(this), this.boneNamesLength());
        _o.rootBoneName = this.rootBoneName();
        _o.inverseBindMatrices = this.bb.createScalarList(this.inverseBindMatrices.bind(this), this.inverseBindMatricesLength());
    };
    FBGeometryData.getRootAsFBGeometryData = function getRootAsFBGeometryData(bb, obj) {
        return (obj || new FBGeometryData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBGeometryData.getSizePrefixedRootAsFBGeometryData = function getSizePrefixedRootAsFBGeometryData(bb, obj) {
        bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
        return (obj || new FBGeometryData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    FBGeometryData.startFBGeometryData = function startFBGeometryData(builder) {
        builder.startObject(12);
    };
    FBGeometryData.addId = function addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    };
    FBGeometryData.addName = function addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    };
    FBGeometryData.addVertexData = function addVertexData(builder, vertexDataOffset) {
        builder.addFieldOffset(2, vertexDataOffset, 0);
    };
    FBGeometryData.addIndexFormat = function addIndexFormat(builder, indexFormat) {
        builder.addFieldInt32(3, indexFormat, 0);
    };
    FBGeometryData.addIndexOffset = function addIndexOffset(builder, indexOffset) {
        builder.addFieldInt32(4, indexOffset, 0);
    };
    FBGeometryData.addSubMeshes = function addSubMeshes(builder, subMeshesOffset) {
        builder.addFieldOffset(5, subMeshesOffset, 0);
    };
    FBGeometryData.createSubMeshesVector = function createSubMeshesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    FBGeometryData.startSubMeshesVector = function startSubMeshesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    FBGeometryData.addMode = function addMode(builder, mode) {
        builder.addFieldInt32(6, mode, 0);
    };
    FBGeometryData.addBuffer = function addBuffer(builder, bufferOffset) {
        builder.addFieldOffset(7, bufferOffset, 0);
    };
    FBGeometryData.addBinaryData = function addBinaryData(builder, binaryDataOffset) {
        builder.addFieldOffset(8, binaryDataOffset, 0);
    };
    FBGeometryData.createBinaryDataVector = function createBinaryDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    };
    FBGeometryData.startBinaryDataVector = function startBinaryDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    };
    FBGeometryData.addBoneNames = function addBoneNames(builder, boneNamesOffset) {
        builder.addFieldOffset(9, boneNamesOffset, 0);
    };
    FBGeometryData.createBoneNamesVector = function createBoneNamesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    FBGeometryData.startBoneNamesVector = function startBoneNamesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    FBGeometryData.addRootBoneName = function addRootBoneName(builder, rootBoneNameOffset) {
        builder.addFieldOffset(10, rootBoneNameOffset, 0);
    };
    FBGeometryData.addInverseBindMatrices = function addInverseBindMatrices(builder, inverseBindMatricesOffset) {
        builder.addFieldOffset(11, inverseBindMatricesOffset, 0);
    };
    FBGeometryData.createInverseBindMatricesVector = function createInverseBindMatricesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for(var i = data.length - 1; i >= 0; i--){
            builder.addFloat32(data[i]);
        }
        return builder.endVector();
    };
    FBGeometryData.startInverseBindMatricesVector = function startInverseBindMatricesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    FBGeometryData.endFBGeometryData = function endFBGeometryData(builder) {
        var offset = builder.endObject();
        return offset;
    };
    return FBGeometryData;
}();
var FBGeometryDataT = /*#__PURE__*/ function() {
    function FBGeometryDataT(id, name, vertexData, indexFormat, indexOffset, subMeshes, mode, buffer, binaryData, boneNames, rootBoneName, inverseBindMatrices) {
        if (id === void 0) id = null;
        if (name === void 0) name = null;
        if (vertexData === void 0) vertexData = null;
        if (indexFormat === void 0) indexFormat = 0;
        if (indexOffset === void 0) indexOffset = 0;
        if (subMeshes === void 0) subMeshes = [];
        if (mode === void 0) mode = 0;
        if (buffer === void 0) buffer = null;
        if (binaryData === void 0) binaryData = [];
        if (boneNames === void 0) boneNames = [];
        if (rootBoneName === void 0) rootBoneName = null;
        if (inverseBindMatrices === void 0) inverseBindMatrices = [];
        this.id = id;
        this.name = name;
        this.vertexData = vertexData;
        this.indexFormat = indexFormat;
        this.indexOffset = indexOffset;
        this.subMeshes = subMeshes;
        this.mode = mode;
        this.buffer = buffer;
        this.binaryData = binaryData;
        this.boneNames = boneNames;
        this.rootBoneName = rootBoneName;
        this.inverseBindMatrices = inverseBindMatrices;
    }
    var _proto = FBGeometryDataT.prototype;
    _proto.pack = function pack(builder) {
        var id = this.id !== null ? builder.createString(this.id) : 0;
        var name = this.name !== null ? builder.createString(this.name) : 0;
        var vertexData = this.vertexData !== null ? this.vertexData.pack(builder) : 0;
        var subMeshes = FBGeometryData.createSubMeshesVector(builder, builder.createObjectOffsetList(this.subMeshes));
        var buffer = this.buffer !== null ? builder.createString(this.buffer) : 0;
        var binaryData = FBGeometryData.createBinaryDataVector(builder, this.binaryData);
        var boneNames = FBGeometryData.createBoneNamesVector(builder, builder.createObjectOffsetList(this.boneNames));
        var rootBoneName = this.rootBoneName !== null ? builder.createString(this.rootBoneName) : 0;
        var inverseBindMatrices = FBGeometryData.createInverseBindMatricesVector(builder, this.inverseBindMatrices);
        FBGeometryData.startFBGeometryData(builder);
        FBGeometryData.addId(builder, id);
        FBGeometryData.addName(builder, name);
        FBGeometryData.addVertexData(builder, vertexData);
        FBGeometryData.addIndexFormat(builder, this.indexFormat);
        FBGeometryData.addIndexOffset(builder, this.indexOffset);
        FBGeometryData.addSubMeshes(builder, subMeshes);
        FBGeometryData.addMode(builder, this.mode);
        FBGeometryData.addBuffer(builder, buffer);
        FBGeometryData.addBinaryData(builder, binaryData);
        FBGeometryData.addBoneNames(builder, boneNames);
        FBGeometryData.addRootBoneName(builder, rootBoneName);
        FBGeometryData.addInverseBindMatrices(builder, inverseBindMatrices);
        return FBGeometryData.endFBGeometryData(builder);
    };
    return FBGeometryDataT;
}();

/**
 * @since 2.0.0
 */ var EffectsPackage = /*#__PURE__*/ function() {
    function EffectsPackage() {
        this.exportObjectDatas = [];
    }
    var _proto = EffectsPackage.prototype;
    _proto.addData = function addData(effectsObjectData) {
        this.exportObjectDatas.push(effectsObjectData);
    };
    _proto.serializeToBinary = function serializeToBinary() {
        var fbb = new Builder(1);
        var effectsPackage = new FBEffectsPackageDataT();
        var exportObjects = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(this.exportObjectDatas), _step; !(_step = _iterator()).done;){
            var effectsObjectData = _step.value;
            var fbEffectsObjectData = void 0;
            if (effectsObjectData.dataType === DataType.Geometry) {
                fbEffectsObjectData = new FBEffectsObjectDataT("Geometry", this.geometryDataToBinary(effectsObjectData));
            }
            if (!fbEffectsObjectData) {
                continue;
            }
            exportObjects.push(fbEffectsObjectData);
        }
        effectsPackage.exportObjects = exportObjects;
        FBEffectsPackageData.finishFBEffectsPackageDataBuffer(fbb, effectsPackage.pack(fbb));
        return fbb.asUint8Array(); // Of type `Uint8Array`.
    };
    _proto.deserializeFromBinary = function deserializeFromBinary(buffer) {
        var buf = new ByteBuffer(buffer);
        var fbEffectsPackage = FBEffectsPackageData.getRootAsFBEffectsPackageData(buf);
        for(var i = 0; i < fbEffectsPackage.exportObjectsLength(); i++){
            var fbEffectsObjectData = fbEffectsPackage.exportObjects(i);
            if (!fbEffectsObjectData) {
                continue;
            }
            var dataBuffer = fbEffectsObjectData.dataArray();
            var dataType = fbEffectsObjectData.dataType();
            if (!dataBuffer) {
                continue;
            }
            var effectsObjectData = void 0;
            if (dataType === DataType.Geometry) {
                effectsObjectData = this.binaryToGeometryData(dataBuffer);
            }
            if (!effectsObjectData) {
                continue;
            }
            this.exportObjectDatas.push(effectsObjectData);
        }
    };
    _proto.geometryDataToBinary = function geometryDataToBinary(geometryData) {
        var fbb = new Builder(1);
        var fbGeometryData = new FBGeometryDataT();
        var indexFormat = geometryData.indexFormat, indexOffset = geometryData.indexOffset, mode = geometryData.mode, id = geometryData.id, vertexData = geometryData.vertexData, _geometryData_boneNames = geometryData.boneNames, boneNames = _geometryData_boneNames === void 0 ? [] : _geometryData_boneNames, _geometryData_rootBoneName = geometryData.rootBoneName, rootBoneName = _geometryData_rootBoneName === void 0 ? "" : _geometryData_rootBoneName, _geometryData_inverseBindMatrices = geometryData.inverseBindMatrices, inverseBindMatrices = _geometryData_inverseBindMatrices === void 0 ? [] : _geometryData_inverseBindMatrices, _geometryData_binaryData = geometryData.binaryData, binaryData = _geometryData_binaryData === void 0 ? [] : _geometryData_binaryData;
        fbGeometryData.indexFormat = indexFormat;
        fbGeometryData.indexOffset = indexOffset;
        fbGeometryData.mode = mode;
        fbGeometryData.id = id;
        fbGeometryData.boneNames = boneNames;
        fbGeometryData.rootBoneName = rootBoneName;
        fbGeometryData.inverseBindMatrices = inverseBindMatrices;
        fbGeometryData.binaryData = binaryData;
        var fbVertexdata = new FBVertexDataT();
        fbVertexdata.vertexCount = vertexData.vertexCount;
        fbVertexdata.channels = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(vertexData.channels), _step; !(_step = _iterator()).done;){
            var channel = _step.value;
            var semantic = channel.semantic, offset = channel.offset, format = channel.format, dimension = channel.dimension, normalize = channel.normalize;
            var fbChannel = new FBVertexChannelT(semantic, offset, format, dimension, normalize);
            fbVertexdata.channels.push(fbChannel);
        }
        fbGeometryData.vertexData = fbVertexdata;
        var fbSubMeshes = [];
        for(var _iterator1 = _create_for_of_iterator_helper_loose(geometryData.subMeshes), _step1; !(_step1 = _iterator1()).done;){
            var subMesh = _step1.value;
            var offset1 = subMesh.offset, indexCount = subMesh.indexCount, vertexCount = subMesh.vertexCount;
            var fbSubMesh = new FBSubMeshT(offset1, indexCount, vertexCount);
            fbSubMeshes.push(fbSubMesh);
        }
        fbGeometryData.subMeshes = fbSubMeshes;
        FBEffectsPackageData.finishFBEffectsPackageDataBuffer(fbb, fbGeometryData.pack(fbb));
        return fbb.asUint8Array(); // Of type `Uint8Array`.
    };
    _proto.binaryToGeometryData = function binaryToGeometryData(buffer) {
        var buf = new ByteBuffer(buffer);
        var fbGeometryData = FBGeometryData.getRootAsFBGeometryData(buf);
        var vertexData = {
            vertexCount: 0,
            channels: []
        };
        var fbVertexData = fbGeometryData.vertexData();
        if (fbVertexData) {
            vertexData.vertexCount = fbVertexData.vertexCount();
            for(var i = 0; i < fbVertexData.channelsLength(); i++){
                var channel = fbVertexData.channels(i);
                if (!channel) {
                    continue;
                }
                var _channel_semantic;
                var vertexChannel = {
                    semantic: (_channel_semantic = channel.semantic()) != null ? _channel_semantic : "",
                    offset: channel.offset(),
                    format: channel.format(),
                    dimension: channel.dimension(),
                    normalize: channel.normalize()
                };
                vertexData.channels.push(vertexChannel);
            }
        }
        var subMeshes = [];
        for(var i1 = 0; i1 < fbGeometryData.subMeshesLength(); i1++){
            var fbSubMesh = fbGeometryData.subMeshes(i1);
            if (!fbSubMesh) {
                continue;
            }
            var subMesh = {
                offset: fbSubMesh.offset(),
                vertexCount: fbSubMesh.vertexCount(),
                indexCount: fbSubMesh.indexCount()
            };
            subMeshes.push(subMesh);
        }
        var boneNames = [];
        for(var i2 = 0; i2 < fbGeometryData.boneNamesLength(); i2++){
            var boneName = fbGeometryData.boneNames(i2);
            boneNames.push(boneName);
        }
        var inverseBindMatricesArray = fbGeometryData.inverseBindMatricesArray();
        var _fbGeometryData_buffer, _fbGeometryData_rootBoneName, _fbGeometryData_binaryDataArray, _fbGeometryData_id;
        var geometryData = {
            vertexData: vertexData,
            indexFormat: fbGeometryData.indexFormat(),
            indexOffset: fbGeometryData.indexOffset(),
            subMeshes: subMeshes,
            mode: fbGeometryData.mode(),
            buffer: (_fbGeometryData_buffer = fbGeometryData.buffer()) != null ? _fbGeometryData_buffer : "",
            boneNames: boneNames,
            rootBoneName: (_fbGeometryData_rootBoneName = fbGeometryData.rootBoneName()) != null ? _fbGeometryData_rootBoneName : "",
            inverseBindMatrices: inverseBindMatricesArray ? Array.from(inverseBindMatricesArray) : undefined,
            binaryData: (_fbGeometryData_binaryDataArray = fbGeometryData.binaryDataArray()) != null ? _fbGeometryData_binaryDataArray : undefined,
            id: (_fbGeometryData_id = fbGeometryData.id()) != null ? _fbGeometryData_id : "",
            dataType: DataType.Geometry
        };
        return geometryData;
    };
    return EffectsPackage;
}();

/**
 * Engine 基类，负责维护所有 GPU 资源的管理及销毁
 */ var Engine = /*#__PURE__*/ function() {
    function Engine() {
        /**
   * 渲染过程中错误队列
   */ this.renderErrors = new Set();
        this.destroyed = false;
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
        this.jsonSceneData = {};
        this.objectInstance = {};
        this.assetLoader = new AssetLoader(this);
        this.emptyTexture = generateWhiteTexture(this);
        this.transparentTexture = generateTransparentTexture(this);
    }
    var _proto = Engine.prototype;
    _proto.clearResources = function clearResources() {
        this.jsonSceneData = {};
        this.objectInstance = {};
    };
    _proto.addEffectsObjectData = function addEffectsObjectData(data) {
        this.jsonSceneData[data.id] = data;
    };
    _proto.findEffectsObjectData = function findEffectsObjectData(uuid) {
        return this.jsonSceneData[uuid];
    };
    _proto.addInstance = function addInstance(effectsObject) {
        this.objectInstance[effectsObject.getInstanceId()] = effectsObject;
    };
    _proto.getInstance = function getInstance(id) {
        return this.objectInstance[id];
    };
    _proto.removeInstance = function removeInstance(id) {
        delete this.objectInstance[id];
    };
    _proto.addPackageDatas = function addPackageDatas(scene) {
        var jsonScene = scene.jsonScene, _scene_textureOptions = scene.textureOptions, textureOptions = _scene_textureOptions === void 0 ? [] : _scene_textureOptions;
        var _jsonScene_items = jsonScene.items, items = _jsonScene_items === void 0 ? [] : _jsonScene_items, _jsonScene_materials = jsonScene.materials, materials = _jsonScene_materials === void 0 ? [] : _jsonScene_materials, _jsonScene_shaders = jsonScene.shaders, shaders = _jsonScene_shaders === void 0 ? [] : _jsonScene_shaders, _jsonScene_geometries = jsonScene.geometries, geometries = _jsonScene_geometries === void 0 ? [] : _jsonScene_geometries, _jsonScene_components = jsonScene.components, components = _jsonScene_components === void 0 ? [] : _jsonScene_components, _jsonScene_animations = jsonScene.animations, animations = _jsonScene_animations === void 0 ? [] : _jsonScene_animations, _jsonScene_bins = jsonScene.bins, bins = _jsonScene_bins === void 0 ? [] : _jsonScene_bins, _jsonScene_miscs = jsonScene.miscs, miscs = _jsonScene_miscs === void 0 ? [] : _jsonScene_miscs;
        for(var _iterator = _create_for_of_iterator_helper_loose(items), _step; !(_step = _iterator()).done;){
            var vfxItemData = _step.value;
            this.addEffectsObjectData(vfxItemData);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(materials), _step1; !(_step1 = _iterator1()).done;){
            var materialData = _step1.value;
            this.addEffectsObjectData(materialData);
        }
        for(var _iterator2 = _create_for_of_iterator_helper_loose(shaders), _step2; !(_step2 = _iterator2()).done;){
            var shaderData = _step2.value;
            this.addEffectsObjectData(shaderData);
        }
        for(var _iterator3 = _create_for_of_iterator_helper_loose(geometries), _step3; !(_step3 = _iterator3()).done;){
            var geometryData = _step3.value;
            this.addEffectsObjectData(geometryData);
        }
        for(var _iterator4 = _create_for_of_iterator_helper_loose(components), _step4; !(_step4 = _iterator4()).done;){
            var componentData = _step4.value;
            this.addEffectsObjectData(componentData);
        }
        for(var _iterator5 = _create_for_of_iterator_helper_loose(animations), _step5; !(_step5 = _iterator5()).done;){
            var animationData = _step5.value;
            this.addEffectsObjectData(animationData);
        }
        for(var _iterator6 = _create_for_of_iterator_helper_loose(miscs), _step6; !(_step6 = _iterator6()).done;){
            var miscData = _step6.value;
            this.addEffectsObjectData(miscData);
        }
        for(var i = 0; i < bins.length; i++){
            var binaryData = bins[i];
            var binaryBuffer = scene.bins[i];
            if (binaryData.dataType === DataType.BinaryAsset) {
                //@ts-expect-error
                binaryData.buffer = binaryBuffer;
                if (binaryData.id) {
                    this.addEffectsObjectData(binaryData);
                }
            } else {
                var effectsPackage = new EffectsPackage();
                effectsPackage.deserializeFromBinary(new Uint8Array(binaryBuffer));
                for(var _iterator7 = _create_for_of_iterator_helper_loose(effectsPackage.exportObjectDatas), _step7; !(_step7 = _iterator7()).done;){
                    var effectsObjectData = _step7.value;
                    this.addEffectsObjectData(effectsObjectData);
                }
            }
        }
        for(var _iterator8 = _create_for_of_iterator_helper_loose(textureOptions), _step8; !(_step8 = _iterator8()).done;){
            var textureData = _step8.value;
            this.addEffectsObjectData(textureData);
        }
    };
    _proto.createVFXItems = function createVFXItems(scene) {
        var _this = this;
        return _async_to_generator(function() {
            var jsonScene, _iterator, _step, itemData, itemType;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        jsonScene = scene.jsonScene;
                        _iterator = _create_for_of_iterator_helper_loose(jsonScene.items);
                        _state.label = 1;
                    case 1:
                        if (!!(_step = _iterator()).done) return [
                            3,
                            4
                        ];
                        itemData = _step.value;
                        itemType = itemData.type;
                        if (!(itemType === "ECS" || itemType === "camera" || itemType === ItemType.sprite || itemType === ItemType.particle || itemType === ItemType.mesh || itemType === ItemType.skybox || itemType === ItemType.light || itemType === ItemType.tree || itemType === ItemType.interact || itemType === ItemType.camera)) {
                            return [
                                3,
                                3
                            ];
                        }
                        if (!_this.database) return [
                            3,
                            3
                        ];
                        return [
                            4,
                            _this.assetLoader.loadGUIDAsync(itemData.id)
                        ];
                    case 2:
                        _state.sent();
                        _state.label = 3;
                    case 3:
                        return [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto.addTexture = function addTexture(tex) {
        if (this.destroyed) {
            return;
        }
        addItem(this.textures, tex);
    };
    _proto.removeTexture = function removeTexture(tex) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.textures, tex);
    };
    _proto.addMaterial = function addMaterial(mat) {
        if (this.destroyed) {
            return;
        }
        addItem(this.materials, mat);
    };
    _proto.removeMaterial = function removeMaterial(mat) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.materials, mat);
    };
    _proto.addGeometry = function addGeometry(geo) {
        if (this.destroyed) {
            return;
        }
        addItem(this.geometries, geo);
    };
    _proto.removeGeometry = function removeGeometry(geo) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.geometries, geo);
    };
    _proto.addMesh = function addMesh(mesh) {
        if (this.destroyed) {
            return;
        }
        addItem(this.meshes, mesh);
    };
    _proto.removeMesh = function removeMesh(mesh) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.meshes, mesh);
    };
    _proto.addRenderPass = function addRenderPass(pass) {
        if (this.destroyed) {
            return;
        }
        addItem(this.renderPasses, pass);
    };
    _proto.removeRenderPass = function removeRenderPass(pass) {
        if (this.destroyed) {
            return;
        }
        removeItem(this.renderPasses, pass);
    };
    _proto.getShaderLibrary = function getShaderLibrary() {
        return this.renderer.getShaderLibrary();
    };
    /**
   * 销毁所有缓存的资源
   */ _proto.dispose = function dispose() {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var info = [];
        if (this.renderPasses.length > 0) {
            info.push("Pass " + this.renderPasses.length);
        }
        if (this.meshes.length > 0) {
            info.push("Mesh " + this.meshes.length);
        }
        if (this.geometries.length > 0) {
            info.push("Geom " + this.geometries.length);
        }
        if (this.textures.length > 0) {
            info.push("Tex " + this.textures.length);
        }
        if (info.length > 0) {
            logger.warn("Release GPU memory: " + info.join(", ") + ".");
        }
        this.renderPasses.forEach(function(pass) {
            return pass.dispose();
        });
        this.meshes.forEach(function(mesh) {
            return mesh.dispose();
        });
        this.geometries.forEach(function(geo) {
            return geo.dispose();
        });
        this.materials.forEach(function(mat) {
            return mat.dispose();
        });
        this.textures.forEach(function(tex) {
            return tex.dispose();
        });
        this.textures = [];
        this.materials = [];
        this.geometries = [];
        this.meshes = [];
        this.renderPasses = [];
        // @ts-expect-error
        this.renderer = null;
    };
    _create_class(Engine, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return Engine;
}();

/**
 * 定时器类
 */ var Ticker = /*#__PURE__*/ function() {
    function Ticker(fps) {
        if (fps === void 0) fps = 60;
        this.paused = true;
        this.lastTime = 0;
        // deltaTime
        this.dt = 0;
        this.setFPS(fps);
        this.tickers = [];
    }
    var _proto = Ticker.prototype;
    /**
   * FPS 帧率设置
   */ _proto.getFPS = function getFPS() {
        return this.targetFPS;
    };
    _proto.setFPS = function setFPS(fps) {
        this.targetFPS = clamp$1(fps, 1, 120);
        // 注意：-2 的原因是保证帧率稳定
        // interval 在 fps 为 60 的时候设成 15 累计误差会很大，设成 14 较稳定
        // requestanimationFrame 在不同的刷新率下时间间隔不一样，120hz 的误差在 8 以内，60hz 的误差在 16 以内
        this.interval = Math.floor(1000 / fps) - 2;
    };
    /**
   * 获取定时器暂停标志位
   * @returns
   */ _proto.getPaused = function getPaused() {
        return this.paused;
    };
    /**
   * 定时器开始方法
   */ _proto.start = function start() {
        var _this = this;
        this.paused = false;
        this.dt = 0;
        if (!this.intervalId) {
            this.lastTime = douyin.performance.now();
            var raf = douyin.requestAnimationFrame || function(func) {
                return douyin.window.setTimeout(func, 16.7);
            };
            var runLoop = function() {
                _this.intervalId = raf(runLoop);
                if (!_this.paused) {
                    _this.tick();
                }
            };
            runLoop();
        }
    };
    /**
   * 定时器停止方法
   */ _proto.stop = function stop() {
        (douyin.cancelAnimationFrame || douyin.window.clearTimeout)(this.intervalId);
        this.intervalId = 0;
        this.lastTime = 0;
        this.paused = true;
        this.dt = 0;
        this.tickers = [];
    };
    /**
   * 定时器暂停方法
   */ _proto.pause = function pause() {
        this.paused = true;
        this.dt = 0;
    };
    /**
   * 定时器恢复方法
   */ _proto.resume = function resume() {
        this.paused = false;
        this.dt = 0;
    };
    /**
   * 定时器 tick 方法
   */ _proto.tick = function tick() {
        if (this.paused) {
            return;
        }
        var startTime = douyin.performance.now();
        this.dt = startTime - this.lastTime;
        if (this.dt >= this.interval) {
            this.lastTime = startTime;
            if (this.resetTickers) {
                this.tickers = this.tickers.filter(function(tick) {
                    return tick;
                });
                this.resetTickers = false;
            }
            for(var i = 0, len = this.tickers.length; i < len; i++){
                var tick = this.tickers[i];
                tick(this.dt);
            }
        }
    };
    /**
   * 定时器添加计时方法
   * @param ticker - 定时器类
   */ _proto.add = function add(ticker) {
        if (typeof ticker !== "function") {
            throw new Error("The tick object must implement the tick method.");
        }
        this.tickers.push(ticker);
    };
    _create_class(Ticker, [
        {
            key: "deltaTime",
            get: /**
   * 获取定时器当前帧更新的时间
   */ function get() {
                return this.dt;
            }
        }
    ]);
    return Ticker;
}();

exports.BinaryAsset = /*#__PURE__*/ function(EffectsObject) {
    _inherits(BinaryAsset, EffectsObject);
    function BinaryAsset() {
        return EffectsObject.apply(this, arguments);
    }
    var _proto = BinaryAsset.prototype;
    _proto.fromData = function fromData(data) {};
    return BinaryAsset;
}(EffectsObject);
__decorate([
    serialize()
], exports.BinaryAsset.prototype, "buffer", void 0);
exports.BinaryAsset = __decorate([
    effectsClass("BinaryAsset")
], exports.BinaryAsset);

registerPlugin("camera", CameraVFXItemLoader, exports.VFXItem, true);
registerPlugin("text", TextLoader, exports.VFXItem, true);
registerPlugin("sprite", SpriteLoader, exports.VFXItem, true);
registerPlugin("particle", ParticleLoader, exports.VFXItem, true);
registerPlugin("cal", CalculateLoader, exports.VFXItem, true);
registerPlugin("interact", InteractLoader, exports.VFXItem, true);
var version$1 = "2.0.3";
logger.info("Core version: " + version$1 + ".");

var _obj$3;
var FORMAT_HALF_FLOAT = (_obj$3 = {}, _obj$3[glContext.RGBA] = 34842, _obj$3[glContext.RGB] = 34843, _obj$3[glContext.ALPHA] = 33325, _obj$3[glContext.RED] = 33325, _obj$3[glContext.LUMINANCE_ALPHA] = 33327, _obj$3[glContext.LUMINANCE] = 33325, _obj$3);
var _obj1$1;
var FORMAT_FLOAT = (_obj1$1 = {}, _obj1$1[glContext.RGBA] = 34836, _obj1$1[glContext.RGB] = 34837, _obj1$1[glContext.ALPHA] = 33326, _obj1$1[glContext.RED] = 33326, _obj1$1[glContext.LUMINANCE_ALPHA] = 33328, _obj1$1[glContext.LUMINANCE] = 33326, _obj1$1);
var GLTexture = /*#__PURE__*/ function(Texture) {
    _inherits(GLTexture, Texture);
    function GLTexture(engine, source) {
        var _this;
        _this = Texture.call(this, engine) || this;
        _this.initialized = false;
        if (source) {
            _this.fromData(source);
        }
        return _this;
    }
    var _proto = GLTexture.prototype;
    /**
   * 绑定当前 Texture 对象
   */ _proto.bind = function bind(force) {
        this.pipelineContext.bindTexture(this.target, this.textureBuffer, force);
    };
    /**
   * 初始化 Texture 的 GPU 资源
   */ _proto.initialize = function initialize() {
        if (this.initialized) {
            return;
        }
        var glEngine = this.engine;
        glEngine.addTexture(this);
        this.pipelineContext = glEngine.getGLPipelineContext();
        var gl = this.pipelineContext.gl;
        var _this_source = this.source, _this_source_target = _this_source.target, target = _this_source_target === void 0 ? gl.TEXTURE_2D : _this_source_target, name = _this_source.name;
        this.textureBuffer = gl.createTexture();
        assignInspectorName(this.textureBuffer, name);
        this.target = target;
        this.update(this.source);
        this.release();
        this.initialized = true;
    };
    _proto.clone = function clone() {
        var clonedTexture = new GLTexture(this.engine, this.source);
        clonedTexture.sourceFrom = this.sourceFrom;
        clonedTexture.sourceType = this.sourceType;
        clonedTexture.width = this.width;
        clonedTexture.height = this.height;
        return clonedTexture;
    };
    _proto.release = function release() {
        var sourceType = this.source.sourceType;
        switch(sourceType){
            case exports.TextureSourceType.image:
                // @ts-expect-error
                delete this.source.image;
                // @ts-expect-error
                delete this.source.cube;
                break;
            case exports.TextureSourceType.data:
                // @ts-expect-error
                delete this.source.data;
                break;
            case exports.TextureSourceType.compressed:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
            case exports.TextureSourceType.mipmaps:
                // @ts-expect-error
                delete this.source.mipmaps;
                break;
        }
    };
    _proto.update = function update(sourceOptions) {
        var _this = this;
        if (!this.pipelineContext || !this.textureBuffer) {
            this.width = 0;
            this.height = 0;
            return;
        }
        var target = this.target;
        var source = this.source;
        var gl = this.pipelineContext.gl;
        var detail = this.engine.gpuCapability.detail;
        var sourceType = source.sourceType;
        var data = source.data;
        var cube = source.cube;
        var image = source.image;
        var video = source.video;
        var mipmaps = source.mipmaps;
        var cubeMipmaps = source.mipmaps;
        var optionsData = sourceOptions.data;
        var optionsCube = sourceOptions.cube;
        var generateMipmap = sourceOptions.generateMipmap;
        var optionsMipmaps = sourceOptions.mipmaps;
        var format = source.format, type = source.type, internalFormat = source.internalFormat;
        var width = 0;
        var height = 0;
        // TODO 原GLState的textureUnitDict参数未处理。
        this.bind(sourceType === exports.TextureSourceType.video);
        // 选择 type 和 format
        if (type === glContext.HALF_FLOAT) {
            type = detail.halfFloatTexture;
            if (!type) {
                logger.error("Half float texture is not support.");
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_HALF_FLOAT[format];
            }
            if (!detail.halfFloatLinear) {
                source.minFilter = source.magFilter = gl.NEAREST;
                logger.warn("Half float linear not support, change to NEAREST.");
            }
        } else if (type === gl.FLOAT) {
            type = detail.floatTexture;
            if (!type) {
                logger.error("Float texture is not support.");
            }
            if (isWebGL2(gl) && internalFormat === format) {
                if (format === glContext.LUMINANCE) {
                    format = glContext.RED;
                }
                internalFormat = FORMAT_FLOAT[format];
            }
            if (!detail.floatLinear) {
                source.minFilter = gl.NEAREST;
                source.magFilter = gl.NEAREST;
                logger.warn("Float linear not support, change to NEAREST.");
            }
        }
        // 处理是否RGB透明度相乘和Y轴反转, 默认值都为false。
        if (source.premultiplyAlpha === undefined) {
            source.premultiplyAlpha = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, source.premultiplyAlpha);
        if (source.flipY === undefined) {
            source.flipY = false;
        }
        // gl的状态可能在外面被改变了，这里必须重新设置
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, source.flipY);
        // 根据不同的 TextureSourceType 传输对应贴图数据到 GPU
        if (sourceType === exports.TextureSourceType.framebuffer) {
            if (optionsData) {
                var _optionsData_width;
                width = (_optionsData_width = optionsData.width) != null ? _optionsData_width : 0;
                var _optionsData_height;
                height = (_optionsData_height = optionsData.height) != null ? _optionsData_height : 0;
                if (width && height && (this.width !== width || this.height !== height)) {
                    gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, null);
                }
            }
        } else if (sourceType === exports.TextureSourceType.data) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                optionsCube.forEach(function(data, key) {
                    var _this_texImage2DData = _this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, data), x = _this_texImage2DData[0], y = _this_texImage2DData[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            } else {
                var ref;
                ref = this.texImage2DData(gl, target, 0, internalFormat, format, type, data), width = ref[0], height = ref[1];
            }
        } else if (sourceType === exports.TextureSourceType.image || sourceType === exports.TextureSourceType.video) {
            if (target === gl.TEXTURE_CUBE_MAP) {
                cube.forEach(function(image, key) {
                    var _this_texImage2D = _this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, 0, internalFormat, format, type, image), x = _this_texImage2D[0], y = _this_texImage2D[1];
                    width = Math.max(x, width);
                    height = Math.max(y, height);
                });
            } else if (target === gl.TEXTURE_2D) {
                var imageData = image != null ? image : video;
                var ref1;
                ref1 = this.texImage2D(gl, target, 0, internalFormat, format, type, imageData), width = ref1[0], height = ref1[1];
            }
            if (generateMipmap) {
                if (isPowerOfTwo(width) && isPowerOfTwo(height) || isWebGL2(gl)) {
                    gl.generateMipmap(target);
                }
            }
        } else if (sourceType === exports.TextureSourceType.mipmaps) {
            var ret;
            if (target === gl.TEXTURE_2D) {
                mipmaps.forEach(function(mipmap, level) {
                    if ("data" in mipmap) {
                        ret = _this.texImage2DData(gl, target, level, internalFormat, format, type, mipmap);
                    } else {
                        ret = _this.texImage2D(gl, target, level, internalFormat, format, type, mipmap);
                    }
                    if (level === 0) {
                        var ref;
                        ref = ret, width = ref[0], height = ref[1];
                    }
                });
            } else if (target === gl.TEXTURE_CUBE_MAP) {
                cubeMipmaps.forEach(function(mipmap, level) {
                    mipmap.forEach(function(face, key) {
                        if ("data" in face) {
                            ret = _this.texImage2DData(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        } else {
                            ret = _this.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + key, level, internalFormat, format, type, face);
                        }
                        if (level === 0) {
                            var ref;
                            ref = ret, width = ref[0], height = ref[1];
                        }
                    });
                });
            }
        } else if (sourceType === exports.TextureSourceType.compressed) {
            if (optionsMipmaps && optionsMipmaps.length !== 0) {
                width = optionsMipmaps[0].width;
                height = optionsMipmaps[0].height;
                optionsMipmaps.forEach(function(mipmap, idx) {
                    gl.compressedTexImage2D(target, idx, internalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                });
            }
        }
        this.width = width;
        this.height = height;
        this.setTextureFilters(gl, target, source);
    };
    _proto.setTextureFilters = function setTextureFilters(gl, target, options) {
        var _options_anisotropic = options.anisotropic, anisotropic = _options_anisotropic === void 0 ? 4 : _options_anisotropic, _options_wrapS = options.wrapS, wrapS = _options_wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options_wrapS, _options_wrapT = options.wrapT, wrapT = _options_wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options_wrapT;
        var gpuCapability = this.engine.gpuCapability;
        if (this.target === gl.TEXTURE_2D) {
            gpuCapability.setTextureAnisotropic(gl, this.target, anisotropic);
        }
        var isPot = isWebGL2(gl) || isPowerOfTwo(this.width) && isPowerOfTwo(this.height);
        var magFilter = options.magFilter ? options.magFilter : gl.NEAREST;
        var minFilter = options.minFilter ? options.minFilter : gl.NEAREST;
        if (!isPot) {
            if (minFilter === gl.LINEAR_MIPMAP_LINEAR || minFilter === gl.LINEAR_MIPMAP_NEAREST || minFilter === gl.NEAREST_MIPMAP_LINEAR || minFilter === gl.NEAREST_MIPMAP_NEAREST) {
                minFilter = gl.LINEAR;
            }
        }
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, minFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, isPot ? wrapS : gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, isPot ? wrapT : gl.CLAMP_TO_EDGE);
    };
    _proto.fromData = function fromData(data) {
        Texture.prototype.fromData.call(this, data);
        var source = data;
        var options = this.assembleOptions(source);
        var sourceType = options.sourceType, sourceFrom = options.sourceFrom, _options_name = options.name, name = _options_name === void 0 ? "" : _options_name;
        this.source = options;
        this.sourceType = sourceType;
        this.sourceFrom = sourceFrom;
        this.name = name;
        this.guid = data.id;
    };
    _proto.texImage2D = function texImage2D(gl, target, level, internalformat, format, type, image) {
        var _this = this;
        var _this_source = this.source, sourceType = _this_source.sourceType, minFilter = _this_source.minFilter, magFilter = _this_source.magFilter, wrapS = _this_source.wrapS, wrapT = _this_source.wrapT;
        var _this_engine_gpuCapability_detail_maxTextureSize;
        var maxSize = (_this_engine_gpuCapability_detail_maxTextureSize = this.engine.gpuCapability.detail.maxTextureSize) != null ? _this_engine_gpuCapability_detail_maxTextureSize : 2048;
        var img = image;
        if (sourceType !== exports.TextureSourceType.video) {
            var shouldResize = minFilter !== gl.NEAREST || magFilter !== gl.NEAREST || wrapS !== gl.CLAMP_TO_EDGE || wrapT !== gl.CLAMP_TO_EDGE;
            shouldResize = shouldResize || image.width > maxSize || image.height > maxSize;
            if (shouldResize) {
                // fix android webgl1 img lost error
                setTimeout(function() {
                    img = _this.resizeImage(image);
                });
            }
        }
        gl.texImage2D(target, level, internalformat, format, type, img);
        var size = [
            img.width,
            img.height
        ];
        if (sourceType === exports.TextureSourceType.video) {
            var videoWidth = image.videoWidth, videoHeight = image.videoHeight;
            return [
                videoWidth,
                videoHeight
            ];
        }
        return size;
    };
    _proto.texImage2DData = function texImage2DData(gl, target, level, internalformat, format, type, data) {
        var bufferView = data.data, width = data.width, height = data.height;
        // Uint8ClampedArray is incompatible in android
        var neoBuffer = format === gl.UNSIGNED_BYTE ? new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength / bufferView.BYTES_PER_ELEMENT) : bufferView;
        gl.texImage2D(target, level, internalformat, width, height, 0, format, type, neoBuffer);
        return [
            width,
            height
        ];
    };
    _proto.resizeImage = function resizeImage(image, targetWidth, targetHeight) {
        var detail = this.engine.gpuCapability.detail;
        var _detail_maxTextureSize;
        var maxSize = (_detail_maxTextureSize = detail.maxTextureSize) != null ? _detail_maxTextureSize : 2048;
        var gl = this.pipelineContext.gl;
        if (isWebGL2(gl) && image.width < maxSize && image.height < maxSize) {
            return image;
        }
        var canvas = resizeImageByCanvas(image, maxSize, targetWidth, targetHeight);
        if (canvas) {
            return canvas;
        }
        return image;
    };
    _proto.reloadData = function reloadData() {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!_this.offloaded) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            getDefaultTextureFactory().reload(_this)
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto.offloadData = function offloadData() {
        if (!(this.initialized && getDefaultTextureFactory().canOffloadTexture(this.source.sourceFrom))) {
            return;
        }
        var target = this.target;
        var gl = this.pipelineContext.gl;
        if (gl && this.textureBuffer) {
            var data = new Uint8Array([
                255
            ]);
            this.bind();
            if (target === gl.TEXTURE_2D) {
                gl.texImage2D(target, 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
            } else if (target === gl.TEXTURE_CUBE_MAP) {
                var faces = [
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                    gl.TEXTURE_CUBE_MAP_POSITIVE_Z
                ];
                for(var i = 0; i < faces.length; i++){
                    gl.texImage2D(faces[i], 0, gl.LUMINANCE, 1, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
                }
            }
            // rewrite mipmap
            gl.generateMipmap(target);
            this.width = 1;
            this.height = 1;
        }
        this.offloaded = true;
    };
    _proto.uploadCurrentVideoFrame = function uploadCurrentVideoFrame() {
        var _this = this;
        return _async_to_generator(function() {
            var video;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!(_this.source.sourceType === exports.TextureSourceType.video && _this.source.video && _this.initialized)) return [
                            3,
                            3
                        ];
                        video = _this.source.video;
                        if (!video.paused) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            video.play()
                        ];
                    case 1:
                        _state.sent();
                        _state.label = 2;
                    case 2:
                        _this.update({
                            video: _this.source.video
                        });
                        return [
                            2,
                            true
                        ];
                    case 3:
                        return [
                            2,
                            false
                        ];
                }
            });
        })();
    };
    _proto.updateSource = function updateSource(opts) {
        // @ts-expect-error
        this.source = this.assembleOptions(_extends({}, this.source, opts));
        this.sourceType = this.source.sourceType;
        this.sourceFrom = this.source.sourceFrom;
        this.update(this.source);
    };
    _proto.restore = function restore() {
    // TODO
    };
    _proto.dispose = function dispose() {
        /**
     * 原先Player是允许多次调用dispose，并且不会报错
     * dispose之后assignRenderer会报错
     */ if (this.pipelineContext && this.textureBuffer) {
            this.pipelineContext.gl.deleteTexture(this.textureBuffer);
        }
        if (this.source.sourceType === exports.TextureSourceType.video && this.source.video && this.initialized) {
            this.source.video.pause();
            this.source.video.src = "";
            this.source.video.load();
        }
        this.width = 0;
        this.height = 0;
        this.textureBuffer = null;
        this.destroyed = true;
        this.update = function() {
            logger.error("This texture has been destroyed.");
        };
        this.initialize = throwDestroyedError;
        if (this.engine !== undefined) {
            this.engine.removeTexture(this);
        }
    };
    return GLTexture;
}(Texture);
function resizeImageByCanvas(image, maxSize, targetWidth, targetHeight) {
    var width = image.width, height = image.height;
    var nw = Math.min(maxSize, targetWidth || nearestPowerOfTwo(width));
    var nh = Math.min(maxSize, targetHeight || nearestPowerOfTwo(height));
    if (nh !== height || nw !== width) {
        var canvas = canvasPool.getCanvas();
        var ctx = canvas.getContext("2d");
        canvas.width = nw;
        canvas.height = nh;
        ctx == null ? void 0 : ctx.drawImage(image, 0, 0, width, height, 0, 0, nw, nh);
        logger.warn("Image resize from " + width + "x" + height + " to " + nw + "x" + nh + ".");
        return canvas;
    }
}
function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
}

var GLVertexArrayObject = /*#__PURE__*/ function() {
    function GLVertexArrayObject(engine, name) {
        this.ready = false;
        this.disposed = false;
        this.gl = engine.getGLPipelineContext().gl;
        this.vaoExt = engine.gpuCapability.vaoExt;
        this.vao = this.createVertexArray(name);
    }
    var _proto = GLVertexArrayObject.prototype;
    _proto.bind = function bind() {
        this.bindVertexArray(this.vao);
    };
    _proto.unbind = function unbind() {
        this.bindVertexArray(null);
    };
    _proto.createVertexArray = function createVertexArray(name) {
        var vao = null;
        if (isWebGL2(this.gl)) {
            vao = this.gl.createVertexArray();
        }
        if (!vao && this.vaoExt) {
            vao = this.vaoExt.createVertexArrayOES();
        }
        assignInspectorName(vao, name);
        return vao;
    };
    /**
   * 根据 gpu level 选择对应的绑定函数
   * @param vao
   */ _proto.bindVertexArray = function bindVertexArray(vao) {
        if (isWebGL2(this.gl)) {
            this.gl.bindVertexArray(vao);
        } else {
            var _this_vaoExt;
            (_this_vaoExt = this.vaoExt) == null ? void 0 : _this_vaoExt.bindVertexArrayOES(vao);
        }
    };
    _proto.dispose = function dispose() {
        if (isWebGL2(this.gl)) {
            this.gl.deleteVertexArray(this.vao);
        } else {
            var _this_vaoExt;
            (_this_vaoExt = this.vaoExt) == null ? void 0 : _this_vaoExt.deleteVertexArrayOES(this.vao);
        }
    };
    return GLVertexArrayObject;
}();

var seed$3 = 1;
var GLRendererInternal = /*#__PURE__*/ function() {
    function GLRendererInternal(engine) {
        this.engine = engine;
        this.textures = [];
        this.renderbuffers = [];
        this.framebuffers = [];
        this.destroyed = false;
        var d = {
            width: 1,
            height: 1,
            data: new Uint8Array([
                255
            ])
        };
        var pipelineContext = engine.getGLPipelineContext();
        var gl = pipelineContext.gl;
        this.gl = gl;
        this.pipelineContext = pipelineContext;
        this.emptyTexture2D = new GLTexture(engine, {
            data: d,
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE
        });
        this.emptyTexture2D.initialize();
        this.emptyTextureCube = new GLTexture(engine, {
            target: gl.TEXTURE_CUBE_MAP,
            cube: [
                d,
                d,
                d,
                d,
                d,
                d
            ],
            sourceType: exports.TextureSourceType.data,
            format: gl.LUMINANCE,
            internalFormat: gl.LUMINANCE,
            type: gl.UNSIGNED_BYTE
        });
        this.emptyTextureCube.initialize();
        this.name = "GLGPURenderer" + seed$3;
        seed$3++;
    }
    var _proto = GLRendererInternal.prototype;
    _proto.copy2 = function copy2(source, target) {
        var gl = this.gl;
        if (!gl) {
            return;
        }
        if (!this.sourceFbo) {
            this.sourceFbo = gl.createFramebuffer();
        }
        if (!this.targetFbo) {
            this.targetFbo = gl.createFramebuffer();
        }
        var state = this.pipelineContext;
        state.bindFramebuffer(gl.FRAMEBUFFER, this.sourceFbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, source.textureBuffer, 0);
        state.bindFramebuffer(gl.FRAMEBUFFER, this.targetFbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target.textureBuffer, 0);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, this.sourceFbo);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.targetFbo);
        var filter = source.getWidth() === source.getHeight() && target.getWidth() == target.getHeight() ? gl.NEAREST : gl.LINEAR;
        gl.blitFramebuffer(0, 0, source.getWidth(), source.getHeight(), 0, 0, target.getWidth(), target.getHeight(), gl.COLOR_BUFFER_BIT, filter);
        state.bindFramebuffer(gl.FRAMEBUFFER, null);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    };
    _proto.resetColorAttachments = function resetColorAttachments(rp, colors) {
        rp.bind();
        rp.resetColorTextures(colors);
    };
    _proto.createGLRenderbuffer = function createGLRenderbuffer(renderbuffer) {
        var rb = this.gl.createRenderbuffer();
        if (rb) {
            addItem(this.renderbuffers, renderbuffer);
        }
        return rb;
    };
    _proto.resize = function resize(width, height) {
        var gl = this.gl;
        if (gl && gl.drawingBufferWidth !== width || gl.drawingBufferHeight !== height) {
            gl.canvas.width = width;
            gl.canvas.height = height;
            gl.viewport(0, 0, width, height);
            this.framebuffers.forEach(function(framebuffer) {
                var viewport = framebuffer.viewport;
                if (!framebuffer.isCustomViewport) {
                    framebuffer.resize(viewport[0], viewport[1], width * framebuffer.viewportScale, height * framebuffer.viewportScale);
                }
            });
        }
    };
    _proto.drawGeometry = function drawGeometry(geometry, material, subMeshIndex) {
        if (!this.gl) {
            console.warn("GLGPURenderer has not bound a gl object, unable to render geometry.");
            return;
        }
        var glGeometry = geometry;
        var glMaterial = material;
        var program = glMaterial.shaderVariant.program;
        if (!program) {
            return;
        }
        var vao = program.setupAttributes(glGeometry);
        var gl = this.gl;
        var indicesBuffer = glGeometry.indicesBuffer;
        var offset = glGeometry.drawStart;
        var count = glGeometry.drawCount;
        var mode = glGeometry.mode;
        var subMeshes = glGeometry.subMeshes;
        if (subMeshes && subMeshes.length) {
            var subMesh = subMeshes[subMeshIndex];
            // FIXME: 临时处理3D线框状态下隐藏模型
            if (count < 0) {
                return;
            }
            offset = subMesh.offset;
            var _subMesh_indexCount;
            count = (_subMesh_indexCount = subMesh.indexCount) != null ? _subMesh_indexCount : subMesh.vertexCount;
            if (indicesBuffer) {
                gl.drawElements(mode, count, indicesBuffer.type, offset != null ? offset : 0);
            } else {
                gl.drawArrays(mode, offset, count);
            }
        } else {
            if (indicesBuffer) {
                gl.drawElements(mode, count, indicesBuffer.type, offset != null ? offset : 0);
            } else {
                gl.drawArrays(mode, offset, count);
            }
        }
        vao == null ? void 0 : vao.unbind();
    };
    _proto.createGLFramebuffer = function createGLFramebuffer(framebuffer, name) {
        var fbo = this.gl.createFramebuffer();
        if (fbo) {
            addItem(this.framebuffers, framebuffer);
            assignInspectorName(fbo, name, name);
        }
        return fbo;
    };
    /**创建包裹VAO对象。 */ _proto.createVAO = function createVAO(name) {
        var ret = new GLVertexArrayObject(this.engine, name);
        return ret;
    };
    _proto.deleteGLTexture = function deleteGLTexture(texture) {
        if (texture.textureBuffer && !this.destroyed) {
            this.gl.deleteTexture(texture.textureBuffer);
            removeItem(this.textures, texture);
            // @ts-expect-error
            delete texture.textureBuffer;
        }
    };
    _proto.deleteGPUBuffer = function deleteGPUBuffer(buffer) {
        if (buffer && !this.destroyed) {
            this.gl.deleteBuffer(buffer.glBuffer);
            // @ts-expect-error
            delete buffer.glBuffer;
        }
    };
    _proto.deleteGLFramebuffer = function deleteGLFramebuffer(framebuffer) {
        if (framebuffer && !this.destroyed) {
            this.gl.deleteFramebuffer(framebuffer.fbo);
            removeItem(this.framebuffers, framebuffer);
            delete framebuffer.fbo;
        }
    };
    _proto.deleteGLRenderbuffer = function deleteGLRenderbuffer(renderbuffer) {
        if (renderbuffer && !this.destroyed) {
            this.gl.deleteRenderbuffer(renderbuffer.buffer);
            removeItem(this.renderbuffers, renderbuffer);
            // @ts-expect-error
            delete renderbuffer.buffer;
        }
    };
    _proto.deleteResource = function deleteResource() {
        var _this = this;
        var gl = this.gl;
        if (gl) {
            gl.deleteFramebuffer(this.sourceFbo);
            gl.deleteFramebuffer(this.targetFbo);
            this.emptyTexture2D.dispose();
            this.emptyTextureCube.dispose();
            this.framebuffers.forEach(function(fb) {
                return _this.deleteGLFramebuffer(fb);
            });
            this.framebuffers.length = 0;
            this.renderbuffers.forEach(function(rb) {
                return _this.deleteGLRenderbuffer(rb);
            });
            this.renderbuffers.length = 0;
            this.textures.forEach(function(tex) {
                return _this.deleteGLTexture(tex);
            });
            this.textures.length = 0;
        }
    };
    _proto.lost = function lost(e) {
        logger.error("WebGL context lost, destroying glRenderer by default to prevent memory leaks. Event target: " + e.target + ".");
        this.deleteResource();
    };
    _proto.dispose = function dispose() {
        this.deleteResource();
        // @ts-expect-error safe to assign
        this.emptyTexture2D = this.emptyTextureCube = this.pipelineContext = this.gpu = this.gl = null;
        this.destroyed = true;
    };
    _create_class(GLRendererInternal, [
        {
            key: "height",
            get: function get() {
                var _this_gl;
                return (_this_gl = this.gl) == null ? void 0 : _this_gl.drawingBufferHeight;
            }
        },
        {
            key: "width",
            get: function get() {
                var _this_gl;
                return (_this_gl = this.gl) == null ? void 0 : _this_gl.drawingBufferWidth;
            }
        },
        {
            key: "canvas",
            get: function get() {
                return this.gl.canvas;
            }
        },
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return GLRendererInternal;
}();
function assignInspectorName(obj, name, id) {
    if (name === undefined || obj === null) {
        return;
    }
    obj.__SPECTOR_Metadata = {
        name: name
    };
    if (obj.__SPECTOR_Object_TAG) {
        obj.__SPECTOR_Object_TAG.displayText = name;
        if (id) {
            obj.__SPECTOR_Object_TAG.id = id;
        }
    } else {
        obj.__SPECTOR_Object_TAG = {
            displayText: name,
            id: ""
        };
    }
}

var GLGPUBuffer = /*#__PURE__*/ function() {
    function GLGPUBuffer(pipelineContext, props) {
        this.pipelineContext = pipelineContext;
        this.byteLength = 0;
        this.destroyed = false;
        var name = props.name, data = props.data, elementCount = props.elementCount, _props_target = props.target, target = _props_target === void 0 ? glContext.ARRAY_BUFFER : _props_target, _props_type = props.type, type = _props_type === void 0 ? glContext.FLOAT : _props_type, _props_usage = props.usage, usage = _props_usage === void 0 ? glContext.STATIC_DRAW : _props_usage;
        var bytesPerElement = getBytesPerElementByGLType(type);
        this.target = target;
        this.type = type;
        this.usage = usage;
        this.glBuffer = this.createGLBuffer(name);
        this.bytesPerElement = bytesPerElement;
        if (data) {
            this.bufferData(data);
        } else if (elementCount) {
            this.bufferData(bytesPerElement * elementCount);
        }
    }
    var _proto = GLGPUBuffer.prototype;
    _proto.createGLBuffer = function createGLBuffer(name) {
        var buffer = this.pipelineContext.gl.createBuffer();
        assignInspectorName(buffer, name);
        return buffer;
    };
    _proto.bind = function bind() {
        this.pipelineContext.gl.bindBuffer(this.target, this.glBuffer);
    };
    _proto.bufferData = function bufferData(data) {
        var byteLength = typeof data === "number" ? data : data.byteLength;
        if (this.pipelineContext) {
            this.byteLength = byteLength;
            var gl = this.pipelineContext.gl;
            var target = this.target;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength === 0) {
                // ios 12 13 cause error when byteLength == 0
                gl.bufferData(target, 1, this.usage);
            } else {
                gl.bufferData(target, byteLength, this.usage);
                if (typeof data !== "number") {
                    gl.bufferSubData(target, 0, data);
                }
            }
        } else {
            this.byteLength = 0;
        }
    };
    _proto.bufferSubData = function bufferSubData(elementOffset, data) {
        if (this.pipelineContext) {
            var gl = this.pipelineContext.gl;
            var target = this.target;
            var byteOffset = elementOffset * this.bytesPerElement;
            var byteLength = byteOffset + data.byteLength;
            gl.bindBuffer(target, this.glBuffer);
            if (byteLength > this.byteLength) {
                this.byteLength = byteLength;
                gl.bufferData(target, byteLength, this.usage);
            }
            gl.bufferSubData(target, byteOffset, data);
        } else {
            this.byteLength = 0;
        }
    };
    _proto.dispose = function dispose() {
        this.pipelineContext.gl.deleteBuffer(this.glBuffer);
        // @ts-expect-error safe to assign
        this.glBuffer = null;
        this.destroyed = true;
    };
    // for test
    _proto.readSubData = function readSubData(elementOffset, dstBuffer) {
        if (isWebGL2(this.pipelineContext.gl)) {
            this.pipelineContext.gl.getBufferSubData(this.target, elementOffset * this.bytesPerElement, dstBuffer);
            return true;
        }
        return false;
    };
    _create_class(GLGPUBuffer, [
        {
            key: "elementCount",
            get: function get() {
                return this.byteLength / this.bytesPerElement;
            }
        },
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return GLGPUBuffer;
}();
var _obj$2;
var map = (_obj$2 = {}, _obj$2[glContext.INT] = Int32Array, _obj$2[glContext.FLOAT] = Float32Array, _obj$2[glContext.SHORT] = Int16Array, _obj$2[glContext.BYTE] = Int8Array, _obj$2[glContext.UNSIGNED_BYTE] = Uint8Array, _obj$2[glContext.UNSIGNED_INT] = Uint32Array, _obj$2[glContext.UNSIGNED_SHORT] = Uint16Array, _obj$2);
function getBytesPerElementByGLType(type) {
    var _map_type;
    var _map_type_BYTES_PER_ELEMENT;
    return (_map_type_BYTES_PER_ELEMENT = (_map_type = map[type]) == null ? void 0 : _map_type.BYTES_PER_ELEMENT) != null ? _map_type_BYTES_PER_ELEMENT : 0;
}

var _obj$1;
var INDEX_TYPE_MAP = (_obj$1 = {}, _obj$1[Uint8Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_BYTE, _obj$1[Uint16Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_SHORT, _obj$1[Uint32Array.BYTES_PER_ELEMENT] = glContext.UNSIGNED_INT, _obj$1);
var seed$2 = 1;
/**
 * 应用层 Geometry 对象，本身不直接保存 GPU 资源而是通过 geometryInternal 成员保存 GPU 资源
 */ var GLGeometry = /*#__PURE__*/ function(Geometry) {
    _inherits(GLGeometry, Geometry);
    function GLGeometry(engine, props) {
        var _this;
        _this = Geometry.call(this, engine) || this;
        _this.drawCount = 0;
        /**
   * 记录了顶点属性与 GPUBuffer 对应关系
   */ _this.buffers = {};
        _this.vaos = {};
        _this.skin = {};
        _this.initialized = false;
        _this.indicesReleasable = false;
        _this.attributesName = [];
        _this.destroyed = false;
        if (props) {
            _this.processProps(props);
        }
        return _this;
    }
    var _proto = GLGeometry.prototype;
    _proto.getOptions = function getOptions() {
        return _extends({}, this.options);
    };
    /**
   * Geometry 的 GPU 资源初始化方法，在绘制前调用
   */ _proto.initialize = function initialize() {
        var _this = this;
        if (this.initialized) {
            return;
        }
        var engine = this.engine;
        assertExist(engine);
        engine.addGeometry(this);
        var pipelineContext = this.engine.getGLPipelineContext();
        // 创建vbo
        Object.keys(this.bufferProps).forEach(function(name) {
            _this.buffers[name] = new GLGPUBuffer(pipelineContext, _this.bufferProps[name]);
        });
        // 创建ibo
        if (this.indices) {
            this.indicesBuffer = this.createIndicesBuffer(pipelineContext, this.indices);
        }
        this.initialized = true;
        // 向 GPU 传输顶点数据
        this.flush();
        this.options = undefined;
    };
    _proto.getAttributeBuffer = function getAttributeBuffer(name) {
        if (!this.initialized) {
            return undefined;
        }
        var key = this.attributes[name].dataSource;
        return this.buffers[key];
    };
    _proto.setAttributeData = function setAttributeData(name, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        var key = this.attributes[name].dataSource;
        if (bufferOption) {
            var usage = bufferOption.usage, target = bufferOption.target;
            this.bufferProps[key] = {
                data: data,
                usage: usage,
                target: target,
                elementCount: data.length
            };
            this.dirtyFlags[key].discard = true;
            this.dirtyFlags[key].dirty = true;
        }
    };
    _proto.getAttributeData = function getAttributeData(name) {
        if (this.bufferProps == undefined) {
            return;
        }
        var bufferOption = this.getAttributeBufferOption(name);
        return bufferOption ? bufferOption.data : undefined;
    };
    _proto.setAttributeSubData = function setAttributeSubData(name, offset, data) {
        if (this.bufferProps == undefined) {
            return;
        }
        var attribute = this.getAttributeBufferOption(name);
        if (attribute && attribute.data != undefined) {
            var start = offset;
            var length = offset + data.length;
            if (attribute.data.length < length) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(length);
                newData.set(attribute.data);
                attribute.data = newData;
                this.dirtyFlags[name].discard = true;
            } else if (!this.dirtyFlags[name].discard) {
                var dirtyFlag = this.dirtyFlags[name];
                if (dirtyFlag.start !== undefined) {
                    dirtyFlag.start = Math.min(dirtyFlag.start, start);
                }
                if (dirtyFlag.end !== undefined) {
                    dirtyFlag.end = Math.max(dirtyFlag.end, length - 1);
                }
            }
            attribute.data.set(data, start);
            this.dirtyFlags[name].dirty = true;
        }
    };
    _proto.getIndexData = function getIndexData() {
        return this.indices;
    };
    _proto.setIndexData = function setIndexData(data) {
        if (_instanceof1(data, Uint8Array) || _instanceof1(data, Uint16Array) || _instanceof1(data, Uint32Array)) {
            this.indices = data;
            this.dirtyFlags["index"].discard = true;
            this.dirtyFlags["index"].dirty = true;
        }
    };
    _proto.setIndexSubData = function setIndexSubData(offset, data) {
        if (this.indices) {
            var _this_indices;
            var start = offset;
            var length = offset + data.length;
            if (this.indices.length < length) {
                // @ts-expect-error safe to use
                var newData = new data.constructor(length);
                newData.set(this.indices);
                this.indices = newData;
                this.dirtyFlags["index"].discard = true;
            } else if (!this.dirtyFlags["index"].discard) {
                var dirtyFlag = this.dirtyFlags["index"];
                if (dirtyFlag.start !== undefined) {
                    dirtyFlag.start = Math.min(dirtyFlag.start, start);
                }
                if (dirtyFlag.end !== undefined) {
                    dirtyFlag.end = Math.max(dirtyFlag.end, length - 1);
                }
            }
            (_this_indices = this.indices) == null ? void 0 : _this_indices.set(data, start);
            this.dirtyFlags["index"].dirty = true;
        }
    };
    _proto.getAttributeStride = function getAttributeStride(name) {
        var attr = this.attributes[name];
        var stride = attr.stride, size = attr.size, type = attr.type;
        return stride ? stride : size * BYTES_TYPE_MAP[type];
    };
    _proto.getAttributeNames = function getAttributeNames() {
        return this.attributesName;
    };
    _proto.setDrawStart = function setDrawStart(count) {
        this.drawStart = count;
    };
    _proto.getDrawStart = function getDrawStart() {
        return this.drawStart;
    };
    _proto.setDrawCount = function setDrawCount(count) {
        this.drawCount = count;
    };
    _proto.getDrawCount = function getDrawCount() {
        return this.drawCount;
    };
    _proto.getSkinProps = function getSkinProps() {
        return this.skin;
    };
    // 根据 attribute 的 datasource 获取 js 端 buffer
    _proto.getAttributeBufferOption = function getAttributeBufferOption(name) {
        var attribute = this.attributes[name];
        return attribute ? this.bufferProps[attribute.dataSource] : undefined;
    };
    _proto.createIndicesBuffer = function createIndicesBuffer(pipelineContext, data) {
        var type = INDEX_TYPE_MAP[data.BYTES_PER_ELEMENT];
        var indexProps = {
            data: data,
            target: glContext.ELEMENT_ARRAY_BUFFER,
            type: type,
            name: "" + this.name + "##index"
        };
        return new GLGPUBuffer(pipelineContext, indexProps);
    };
    _proto.flush = function flush() {
        var _this = this;
        if (!this.initialized) {
            return;
        }
        var attributes = this.attributes;
        var bufferProps = this.bufferProps;
        var indices = this.indices;
        Object.keys(this.dirtyFlags).forEach(function(name) {
            var flag = _this.dirtyFlags[name];
            var buffer;
            var data;
            if (name == "index") {
                buffer = _this.indicesBuffer;
                data = indices;
            } else {
                var bufferName = attributes[name].dataSource;
                buffer = _this.buffers[bufferName];
                data = bufferProps[bufferName].data;
            }
            if ((flag.dirty || flag.discard) && buffer && data) {
                if (flag.discard) {
                    buffer.bufferData(data);
                } else {
                    if (flag.start !== undefined && flag.end !== undefined) {
                        var offset = flag.start * data.BYTES_PER_ELEMENT + data.byteOffset;
                        var length = flag.end - flag.start + 1;
                        // @ts-expect-error safe to use
                        var subData = new data.constructor(data.buffer, offset, length);
                        buffer.bufferSubData(flag.start, subData);
                    }
                }
                flag.start = Number.POSITIVE_INFINITY;
                flag.end = 0;
                flag.dirty = flag.discard = false;
            }
        });
        // 需要释放的 attributes 数据
        Object.keys(this.attributesReleasable).forEach(function(name) {
            var releasable = _this.attributesReleasable[name];
            var bufferName = attributes[name].dataSource;
            if (bufferProps[bufferName] && releasable) {
                bufferProps[bufferName].data = undefined;
            }
        });
        // 释放 indices buffer
        if (this.indicesReleasable) ;
    };
    _proto.processProps = function processProps(data) {
        var props = data;
        var _props_drawStart = props.drawStart, drawStart = _props_drawStart === void 0 ? 0 : _props_drawStart, drawCount = props.drawCount, mode = props.mode, indices = props.indices, _props_name = props.name, name = _props_name === void 0 ? "effectsGeometry:" + seed$2++ : _props_name, _props_bufferUsage = props.bufferUsage, bufferUsage = _props_bufferUsage === void 0 ? glContext.STATIC_DRAW : _props_bufferUsage;
        this.name = name;
        // 记录顶点属性，需要与 Shader 中 attribute 进行关联
        var bufferProps = {};
        var attributesName = [];
        var attributes = {};
        // key为buffer的名字
        var dirtyFlags = {};
        var attributesReleasable = {};
        var usage = bufferUsage;
        this.drawStart = drawStart;
        if (drawCount !== undefined) {
            this.drawCount = drawCount;
        }
        this.mode = isNaN(mode) ? glContext.TRIANGLES : mode;
        Object.keys(props.attributes).forEach(function(name) {
            var attr = props.attributes[name];
            var size = attr.size, stride = attr.stride, offset = attr.offset, normalize = attr.normalize;
            var _attr_type = attr.type, type = _attr_type === void 0 ? glContext.FLOAT : _attr_type, releasable = attr.releasable;
            var _$data = attr.data;
            if (type && !("dataSource" in attr) && !_$data) {
                _$data = generateEmptyTypedArray(type);
            }
            if (_$data) {
                var glType = _instanceof1(_$data, Float32Array) ? glContext.FLOAT : glContext.INT;
                // 使用 AttributeWithData 构造的 attribute
                bufferProps[name] = {
                    data: _$data,
                    usage: usage,
                    target: glContext.ARRAY_BUFFER,
                    name: name
                };
                attributes[name] = {
                    size: size,
                    stride: stride,
                    offset: offset,
                    type: type != null ? type : glType,
                    normalize: !!normalize,
                    dataSource: name
                };
                attributesReleasable[name] = releasable != null ? releasable : false;
                dirtyFlags[name] = {
                    dirty: true,
                    discard: true,
                    start: Number.POSITIVE_INFINITY,
                    end: 0
                };
            } else {
                // 使用 AttributeWithType 构造的 attribute
                var dataSource = attr.dataSource;
                if (dataSource) {
                    // 属性共享 buffer
                    attributes[name] = {
                        size: size,
                        stride: stride,
                        offset: offset,
                        type: type,
                        dataSource: dataSource,
                        normalize: !!normalize
                    };
                }
            }
            attributesName.push(name);
        });
        dirtyFlags.index = {
            dirty: true,
            discard: true,
            start: Number.POSITIVE_INFINITY,
            end: 0
        };
        // 顶点索引
        this.indices = indices == null ? void 0 : indices.data;
        this.indicesReleasable = (indices == null ? void 0 : indices.releasable) === true;
        this.bufferProps = bufferProps;
        this.attributes = attributes;
        this.attributesName = attributesName;
        this.attributesReleasable = attributesReleasable;
        this.dirtyFlags = dirtyFlags;
        this.options = props;
        this.initialized = false;
    };
    _proto.fromData = function fromData(data) {
        var _this = this;
        Geometry.prototype.fromData.call(this, data);
        this.subMeshes = data.subMeshes;
        var buffer;
        if (data.buffer) {
            buffer = new Uint8Array(decodeBase64ToArrays(data.buffer));
        } else if (data.binaryData) {
            buffer = data.binaryData;
        }
        if (!buffer) {
            return;
        }
        var vertexCount = data.vertexData.vertexCount;
        if (this.hasSemantic(data)) {
            var geometryProps = {
                mode: glContext.TRIANGLES,
                attributes: {}
            };
            data.vertexData.channels.forEach(function(channel) {
                var _vertexBufferSemanticMap_channel_semantic;
                var attribName = (_vertexBufferSemanticMap_channel_semantic = vertexBufferSemanticMap[channel.semantic]) != null ? _vertexBufferSemanticMap_channel_semantic : channel.semantic;
                var attribBuffer = _this.createVertexTypedArray(channel, buffer, vertexCount);
                geometryProps.attributes[attribName] = {
                    type: vertexFormatType2GLType(channel.format),
                    size: channel.dimension,
                    data: attribBuffer,
                    normalize: channel.normalize
                };
            });
            if (data.indexFormat !== IndexFormatType.None) {
                var indexBuffer = this.createIndexTypedArray(data.indexFormat, buffer, data.indexOffset);
                geometryProps.indices = {
                    data: indexBuffer
                };
                geometryProps.drawCount = indexBuffer.length;
            } else {
                geometryProps.drawCount = vertexCount;
            }
            this.processProps(geometryProps);
        } else {
            var positionChannel = data.vertexData.channels[0];
            var uvChannel = data.vertexData.channels[1];
            var normalChannel = data.vertexData.channels[2];
            // 根据提供的长度信息创建 Float32Array
            var positionBuffer = this.createVertexTypedArray(positionChannel, buffer, vertexCount);
            var uvBuffer = this.createVertexTypedArray(uvChannel, buffer, vertexCount);
            var normalBuffer = this.createVertexTypedArray(normalChannel, buffer, vertexCount);
            // 根据提供的长度信息创建 Uint16Array，它紧随 Float32Array 数据之后
            var indexBuffer1 = this.createIndexTypedArray(data.indexFormat, buffer, data.indexOffset);
            var geometryProps1 = {
                mode: glContext.TRIANGLES,
                attributes: {
                    aPos: {
                        type: vertexFormatType2GLType(positionChannel.format),
                        size: 3,
                        data: positionBuffer,
                        normalize: positionChannel.normalize
                    },
                    aUV: {
                        type: vertexFormatType2GLType(uvChannel.format),
                        size: 2,
                        data: uvBuffer,
                        normalize: uvChannel.normalize
                    },
                    aNormal: {
                        type: vertexFormatType2GLType(normalChannel.format),
                        size: 3,
                        data: normalBuffer,
                        normalize: normalChannel.normalize
                    }
                }
            };
            geometryProps1.indices = {
                data: indexBuffer1
            };
            geometryProps1.drawCount = indexBuffer1.length;
            this.processProps(geometryProps1);
        }
        this.skin = {
            boneNames: data.boneNames,
            rootBoneName: data.rootBoneName,
            inverseBindMatrices: data.inverseBindMatrices
        };
    };
    _proto.dispose = function dispose() {
        var _this = this;
        this.drawStart = 0;
        this.drawCount = NaN;
        this.bufferProps = {};
        this.indices = undefined;
        this.attributes = {};
        this.attributesName = [];
        this.options = undefined;
        if (this.initialized) {
            var _this_indicesBuffer;
            Object.keys(this.buffers).forEach(function(name) {
                _this.buffers[name].dispose();
            });
            this.buffers = {};
            (_this_indicesBuffer = this.indicesBuffer) == null ? void 0 : _this_indicesBuffer.dispose();
            Object.keys(this.vaos).forEach(function(name) {
                var _this_vaos_name;
                (_this_vaos_name = _this.vaos[name]) == null ? void 0 : _this_vaos_name.dispose();
                _this.vaos[name] = undefined;
            });
            this.indicesBuffer = undefined;
            if (this.engine !== undefined) {
                this.engine.removeGeometry(this);
                // @ts-expect-error
                this.engine = undefined;
            }
        }
        this.destroyed = true;
    };
    _proto.createVertexTypedArray = function createVertexTypedArray(channel, baseBuffer, vertexCount) {
        var arrayBuffer = baseBuffer.buffer;
        switch(channel.format){
            case VertexFormatType.Float32:
                return new Float32Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
            case VertexFormatType.Int16:
                return new Int16Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
            case VertexFormatType.Int8:
                return new Int8Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
            case VertexFormatType.UInt16:
                return new Uint16Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
            case VertexFormatType.UInt8:
                return new Uint8Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
            default:
                console.error("Invalid vertex format type: " + channel.format + ".");
                return new Float32Array(arrayBuffer, baseBuffer.byteOffset + channel.offset, channel.dimension * vertexCount);
        }
    };
    _proto.createIndexTypedArray = function createIndexTypedArray(type, baseBuffer, offset) {
        var arrayBuffer = baseBuffer.buffer;
        switch(type){
            case IndexFormatType.UInt16:
                return new Uint16Array(arrayBuffer, baseBuffer.byteOffset + offset);
            case IndexFormatType.UInt32:
                return new Uint32Array(arrayBuffer, baseBuffer.byteOffset + offset);
            default:
                console.error("Invalid index format type: " + type + ".");
                return new Uint32Array(arrayBuffer, baseBuffer.byteOffset + offset);
        }
    };
    _proto.hasSemantic = function hasSemantic(data) {
        var hasSemantic = false;
        var vertexData = data.vertexData;
        vertexData.channels.forEach(function(channel) {
            if (channel.semantic && channel.semantic.length > 0) {
                hasSemantic = true;
            }
        });
        return hasSemantic;
    };
    _create_class(GLGeometry, [
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        },
        {
            key: "isInitialized",
            get: function get() {
                return this.initialized;
            }
        }
    ]);
    return GLGeometry;
}(Geometry);
var vertexBufferSemanticMap = {
    POSITION: "aPos",
    TEXCOORD0: "aUV",
    TEXCOORD_0: "aUV",
    TEXCOORD1: "aUV2",
    NORMAL: "aNormal",
    TANGENT: "aTangent",
    COLOR: "aColor",
    JOINTS: "aJoints",
    JOINTS_0: "aJoints",
    WEIGHTS: "aWeights",
    WEIGHTS_0: "aWeights",
    //
    POSITION_BS0: "aTargetPosition0",
    POSITION_BS1: "aTargetPosition1",
    POSITION_BS2: "aTargetPosition2",
    POSITION_BS3: "aTargetPosition3",
    POSITION_BS4: "aTargetPosition4",
    POSITION_BS5: "aTargetPosition5",
    POSITION_BS6: "aTargetPosition6",
    POSITION_BS7: "aTargetPosition7",
    NORMAL_BS0: "aTargetNormal0",
    NORMAL_BS1: "aTargetNormal1",
    NORMAL_BS2: "aTargetNormal2",
    NORMAL_BS3: "aTargetNormal3",
    TANGENT_BS0: "aTargetTangent0",
    TANGENT_BS1: "aTargetTangent1",
    TANGENT_BS2: "aTargetTangent2",
    TANGENT_BS3: "aTargetTangent3"
};
function decodeBase64ToArrays(base64String) {
    // 将 Base64 编码的字符串转换为二进制字符串
    var binaryString = douyin.atob(base64String);
    // 将二进制字符串转换为字节数组
    var bytes = new Uint8Array(binaryString.length);
    for(var i = 0; i < binaryString.length; i++){
        bytes[i] = binaryString.charCodeAt(i);
    }
    // 创建 ArrayBuffer 并为其创建视图
    var buffer = bytes.buffer;
    // 返回解码后的数组
    return buffer;
}

var GLMaterialState = /*#__PURE__*/ function() {
    function GLMaterialState() {
        this.reset();
    }
    var _proto = GLMaterialState.prototype;
    _proto.setBlendColor = function setBlendColor(color) {
        var r = color[0], g = color[1], b = color[2], a = color[3];
        if (this.blendColor[0] === r && this.blendColor[1] === g && this.blendColor[2] === b && this.blendColor[3] === a) {
            return;
        }
        this.blendColor[0] = r;
        this.blendColor[1] = g;
        this.blendColor[2] = b;
        this.blendColor[3] = a;
    };
    _proto.setBlending = function setBlending(value) {
        if (this.blending !== value) {
            this.blending = value;
        }
    };
    _proto.setBlendFunctionParameters = function setBlendFunctionParameters(value) {
        var blendSrc = value[0], blendDst = value[1], blendSrcAlpha = value[2], blendDstAlpha = value[3];
        if (this.blendFunctionParameters[0] === blendSrc && this.blendFunctionParameters[1] === blendDst && this.blendFunctionParameters[2] === blendSrcAlpha && this.blendFunctionParameters[3] === blendDstAlpha) {
            return;
        }
        this.blendFunctionParameters[0] = blendSrc;
        this.blendFunctionParameters[1] = blendDst;
        this.blendFunctionParameters[2] = blendSrcAlpha;
        this.blendFunctionParameters[3] = blendDstAlpha;
    };
    _proto.setBlendEquationParameters = function setBlendEquationParameters(value) {
        var rgb = value[0], alpha = value[1];
        if (this.blendEquationParameters[0] === rgb && this.blendEquationParameters[1] === alpha) {
            return;
        }
        this.blendEquationParameters[0] = rgb;
        this.blendEquationParameters[1] = alpha;
    };
    _proto.setDepthTest = function setDepthTest(value) {
        if (this.depthTest === value) {
            return;
        }
        this.depthTest = value;
    };
    _proto.setDepthMask = function setDepthMask(value) {
        if (this.depthMask === value) {
            return;
        }
        this.depthMask = value;
    };
    _proto.setDepthRange = function setDepthRange(value) {
        if (this.depthRange[0] === value[0] && this.depthRange[1] === value[1]) {
            return;
        }
        this.depthRange[0] = value[0];
        this.depthRange[1] = value[1];
    };
    _proto.setDepthFunc = function setDepthFunc(value) {
        if (this.depthFunc === value) {
            return;
        }
        this.depthFunc = value;
    };
    _proto.setPolygonOffsetFill = function setPolygonOffsetFill(value) {
        if (this.polygonOffsetFill === value) {
            return;
        }
        this.polygonOffsetFill = value;
    };
    _proto.setPolygonOffset = function setPolygonOffset(value) {
        if (this.polygonOffset[0] === value[0] && this.polygonOffset[1] === value[1]) {
            return;
        }
        this.polygonOffset[0] = value[0];
        this.polygonOffset[1] = value[1];
    };
    _proto.setSampleAlphaToCoverage = function setSampleAlphaToCoverage(value) {
        if (this.sampleAlphaToCoverage === value) {
            return;
        }
        this.sampleAlphaToCoverage = value;
    };
    _proto.setColorMask = function setColorMask(color) {
        var r = color[0], g = color[1], b = color[2], a = color[3];
        if (this.colorMask[0] === r && this.colorMask[1] === g && this.colorMask[2] === b && this.colorMask[3] === a) {
            return;
        }
        this.colorMask[0] = r;
        this.colorMask[1] = g;
        this.colorMask[2] = b;
        this.colorMask[3] = a;
    };
    _proto.setStencilTest = function setStencilTest(value) {
        if (this.stencilTest === value) {
            return;
        }
        this.stencilTest = value;
    };
    _proto.setStencilMask = function setStencilMask(value) {
        if (this.stencilMask[0] === value[0] && this.stencilMask[1] === value[1]) {
            return;
        }
        this.stencilMask[0] = value[0];
        this.stencilMask[1] = value[1];
    };
    _proto.setStencilRef = function setStencilRef(value) {
        if (this.stencilRef[0] === value[0] && this.stencilRef[1] === value[1]) {
            return;
        }
        this.stencilRef[0] = value[0];
        this.stencilRef[1] = value[1];
    };
    _proto.setStencilFunc = function setStencilFunc(value) {
        if (this.stencilFunc[0] === value[0] && this.stencilFunc[1] === value[1]) {
            return;
        }
        this.stencilFunc[0] = value[0];
        this.stencilFunc[1] = value[1];
    };
    _proto.setStencilOpFail = function setStencilOpFail(value) {
        if (this.stencilOpFail[0] === value[0] && this.stencilOpFail[1] === value[1]) {
            return;
        }
        this.stencilOpFail[0] = value[0];
        this.stencilOpFail[1] = value[1];
    };
    _proto.setStencilOpZFail = function setStencilOpZFail(value) {
        if (this.stencilOpZFail[0] === value[0] && this.stencilOpZFail[1] === value[1]) {
            return;
        }
        this.stencilOpZFail[0] = value[0];
        this.stencilOpZFail[1] = value[1];
    };
    _proto.setStencilOpZPass = function setStencilOpZPass(value) {
        if (this.stencilOpZPass[0] === value[0] && this.stencilOpZPass[1] === value[1]) {
            return;
        }
        this.stencilOpZPass[0] = value[0];
        this.stencilOpZPass[1] = value[1];
    };
    _proto.setCulling = function setCulling(value) {
        if (this.culling === value) {
            return;
        }
        this.culling = value;
    };
    _proto.setFrontFace = function setFrontFace(value) {
        if (this.frontFace === value) {
            return;
        }
        this.frontFace = value;
    };
    _proto.setCullFace = function setCullFace(value) {
        if (this.cullFace === value) {
            return;
        }
        this.cullFace = value;
    };
    _proto.reset = function reset() {
        this.blending = false;
        this.blendColor = [
            0,
            0,
            0,
            0
        ];
        this.blendFunctionParameters = [
            glContext.ONE,
            glContext.ONE_MINUS_SRC_ALPHA,
            glContext.ONE,
            glContext.ONE_MINUS_SRC_ALPHA
        ];
        this.blendEquationParameters = [
            glContext.FUNC_ADD,
            glContext.FUNC_ADD
        ];
        this.depthTest = false;
        this.depthMask = false;
        this.depthRange = [
            0,
            1
        ];
        this.depthFunc = glContext.LESS;
        this.polygonOffset = [
            0,
            0
        ];
        this.polygonOffsetFill = false;
        this.sampleAlphaToCoverage = false;
        this.colorMask = [
            true,
            true,
            true,
            true
        ];
        this.stencilTest = false;
        this.stencilMask = [
            0xFF,
            0xFF
        ];
        this.stencilRef = [
            0,
            0
        ];
        this.stencilFunc = [
            glContext.ALWAYS,
            glContext.ALWAYS
        ];
        this.stencilOpFail = [
            glContext.KEEP,
            glContext.KEEP
        ];
        this.stencilOpZFail = [
            glContext.KEEP,
            glContext.KEEP
        ];
        this.stencilOpZPass = [
            glContext.KEEP,
            glContext.KEEP
        ];
        this.culling = false;
        this.frontFace = glContext.CCW;
        this.cullFace = glContext.FRONT;
    };
    _proto.apply = function apply(pipelineContext) {
        pipelineContext.toggle(glContext.SAMPLE_ALPHA_TO_COVERAGE, this.sampleAlphaToCoverage);
        pipelineContext.toggle(glContext.BLEND, this.blending);
        pipelineContext.toggle(glContext.DEPTH_TEST, this.depthTest);
        pipelineContext.toggle(glContext.STENCIL_TEST, this.stencilTest);
        pipelineContext.toggle(glContext.CULL_FACE, this.culling);
        pipelineContext.toggle(glContext.POLYGON_OFFSET_FILL, this.polygonOffsetFill);
        if (this.stencilTest) {
            //stencil
            pipelineContext.stencilMaskSeparate(glContext.BACK, this.stencilMask[1]);
            pipelineContext.stencilMaskSeparate(glContext.FRONT, this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.BACK, this.stencilFunc[0], this.stencilRef[0], this.stencilMask[0]);
            pipelineContext.stencilFuncSeparate(glContext.FRONT, this.stencilFunc[1], this.stencilRef[1], this.stencilMask[1]);
            pipelineContext.stencilOpSeparate(glContext.BACK, this.stencilOpFail[0], this.stencilOpZFail[0], this.stencilOpZPass[0]);
            pipelineContext.stencilOpSeparate(glContext.FRONT, this.stencilOpFail[1], this.stencilOpZFail[1], this.stencilOpZPass[1]);
        }
        if (this.blending) {
            var _this = this, blendColor = _this.blendColor, blendEquationParameters = _this.blendEquationParameters, blendFunctionParameters = _this.blendFunctionParameters;
            pipelineContext.blendColor(blendColor[0], blendColor[1], blendColor[2], blendColor[3]);
            pipelineContext.blendEquationSeparate(blendEquationParameters[0], blendEquationParameters[1]);
            pipelineContext.blendFuncSeparate(blendFunctionParameters[0], blendFunctionParameters[1], blendFunctionParameters[2], blendFunctionParameters[3]);
        }
        //color depth
        pipelineContext.colorMask(this.colorMask[0], this.colorMask[1], this.colorMask[2], this.colorMask[3]);
        if (this.depthTest) {
            pipelineContext.depthMask(this.depthMask);
            pipelineContext.depthFunc(this.depthFunc);
            pipelineContext.depthRange(this.depthRange[0], this.depthRange[1]);
        }
        if (this.culling) {
            //face
            pipelineContext.cullFace(this.cullFace);
            pipelineContext.frontFace(this.frontFace);
        }
        if (this.polygonOffsetFill) {
            pipelineContext.polygonOffset(this.polygonOffset[0], this.polygonOffset[1]);
        }
    };
    return GLMaterialState;
}();

var Vector4 = Vector4$1, Matrix4 = Matrix4$1;
var GLMaterial = /*#__PURE__*/ function(Material) {
    _inherits(GLMaterial, Material);
    function GLMaterial(engine, props) {
        var _this;
        _this = Material.call(this, engine, props) || this;
        // material存放的uniform数据。
        _this.floats = {};
        _this.ints = {};
        _this.vector2s = {};
        _this.vector3s = {};
        _this.vector4s = {};
        _this.colors = {};
        _this.quaternions = {};
        _this.matrices = {};
        _this.matrice3s = {};
        _this.textures = {};
        _this.floatArrays = {};
        _this.vector4Arrays = {};
        _this.matrixArrays = {};
        _this.samplers = [] // material存放的sampler名称。
        ;
        _this.uniforms = [] // material存放的uniform名称（不包括sampler）。
        ;
        _this.uniformDirtyFlag = true;
        _this.macrosDirtyFlag = true;
        _this.glMaterialState = new GLMaterialState();
        if (props) {
            _this.shader = new exports.Shader(engine);
            _this.shader.shaderData = _extends({}, props.shader, {
                id: generateGUID(),
                dataType: DataType.Shader
            });
        }
        return _this;
    }
    var _proto = GLMaterial.prototype;
    _proto.enableMacro = function enableMacro(keyword, value) {
        if (!this.isMacroEnabled(keyword) || this.enabledMacros[keyword] !== value) {
            this.enabledMacros[keyword] = value != null ? value : true;
            this.macrosDirtyFlag = true;
        }
    };
    _proto.disableMacro = function disableMacro(keyword) {
        if (this.isMacroEnabled(keyword)) {
            delete this.enabledMacros[keyword];
            this.macrosDirtyFlag = true;
        }
    };
    _proto.isMacroEnabled = function isMacroEnabled(keyword) {
        return this.enabledMacros[keyword] !== undefined;
    };
    // TODO 待废弃 兼容 model/spine 插件 改造后可移除
    _proto.createMaterialStates = function createMaterialStates(states) {
        this.sampleAlphaToCoverage = !!states.sampleAlphaToCoverage;
        this.depthTest = states.depthTest;
        this.depthMask = states.depthMask;
        this.depthRange = states.depthRange;
        this.depthFunc = states.depthFunc;
        this.colorMask = states.colorMask;
        this.polygonOffset = states.polygonOffset;
        this.polygonOffsetFill = states.polygonOffsetFill;
        this.blending = states.blending;
        this.blendFunction = states.blendFunction;
        this.stencilTest = states.stencilTest;
    };
    /**shader和texture的GPU资源初始化。 */ _proto.initialize = function initialize() {
        var _this = this;
        var engine = this.engine;
        this.createShaderVariant();
        this.shaderVariant.initialize();
        if (this.initialized) {
            return;
        }
        engine.addMaterial(this);
        Object.keys(this.textures).forEach(function(key) {
            var texture = _this.textures[key];
            if (!isFunction(texture.initialize)) {
                logger.error("Failed to initialize texture: " + JSON.stringify(texture) + ". Ensure the texture conforms to the expected format.");
                return;
            }
            texture.initialize();
        });
        this.initialized = true;
    };
    _proto.createShaderVariant = function createShaderVariant() {
        if (!this.shaderVariant || this.shaderVariant.shader !== this.shader || this.macrosDirtyFlag) {
            this.shaderVariant = this.shader.createVariant(this.enabledMacros);
            this.macrosDirtyFlag = false;
        }
    };
    _proto.setupStates = function setupStates(pipelineContext) {
        this.glMaterialState.apply(pipelineContext);
    };
    _proto.use = function use(renderer, globalUniforms) {
        var engine = renderer.engine;
        var pipelineContext = engine.getGLPipelineContext();
        var shaderVariant = this.shaderVariant;
        if (!shaderVariant.program) {
            var _this_engine;
            (_this_engine = this.engine) == null ? void 0 : _this_engine.renderErrors.add(new Error("Shader program is not initialized."));
            return;
        }
        shaderVariant.program.bind();
        this.setupStates(pipelineContext);
        var name;
        if (globalUniforms) {
            // 加入全局 uniform 名称
            for(var _iterator = _create_for_of_iterator_helper_loose(globalUniforms.uniforms), _step; !(_step = _iterator()).done;){
                name = _step.value;
                this.checkUniform(name);
            }
            for(var _iterator1 = _create_for_of_iterator_helper_loose(globalUniforms.samplers), _step1; !(_step1 = _iterator1()).done;){
                name = _step1.value;
                if (!this.samplers.includes(name)) {
                    this.samplers.push(name);
                    this.uniformDirtyFlag = true;
                }
            }
        }
        // 更新 cached uniform location
        if (this.uniformDirtyFlag) {
            shaderVariant.fillShaderInformation(this.uniforms, this.samplers);
            this.uniformDirtyFlag = false;
        }
        if (globalUniforms) {
            // 设置全局 uniform
            for(name in globalUniforms.floats){
                shaderVariant.setFloat(name, globalUniforms.floats[name]);
            }
            for(name in globalUniforms.ints){
                shaderVariant.setInt(name, globalUniforms.ints[name]);
            }
            for(name in globalUniforms.vector4s){
                shaderVariant.setVector4(name, globalUniforms.vector4s[name]);
            }
            for(name in globalUniforms.matrices){
                shaderVariant.setMatrix(name, globalUniforms.matrices[name]);
            }
        }
        // 检查贴图数据是否初始化。
        for(name in this.textures){
            if (!this.textures[name].textureBuffer) {
                this.textures[name].initialize();
            }
        }
        for(name in this.floats){
            shaderVariant.setFloat(name, this.floats[name]);
        }
        for(name in this.ints){
            shaderVariant.setInt(name, this.ints[name]);
        }
        for(name in this.floatArrays){
            shaderVariant.setFloats(name, this.floatArrays[name]);
        }
        for(name in this.textures){
            shaderVariant.setTexture(name, this.textures[name]);
        }
        for(name in this.vector2s){
            shaderVariant.setVector2(name, this.vector2s[name]);
        }
        for(name in this.vector3s){
            shaderVariant.setVector3(name, this.vector3s[name]);
        }
        for(name in this.vector4s){
            shaderVariant.setVector4(name, this.vector4s[name]);
        }
        for(name in this.colors){
            shaderVariant.setColor(name, this.colors[name]);
        }
        for(name in this.quaternions){
            shaderVariant.setQuaternion(name, this.quaternions[name]);
        }
        for(name in this.matrices){
            shaderVariant.setMatrix(name, this.matrices[name]);
        }
        for(name in this.matrice3s){
            shaderVariant.setMatrix3(name, this.matrice3s[name]);
        }
        for(name in this.vector4Arrays){
            shaderVariant.setVector4Array(name, this.vector4Arrays[name]);
        }
        for(name in this.matrixArrays){
            shaderVariant.setMatrixArray(name, this.matrixArrays[name]);
        }
    };
    _proto.getFloat = function getFloat(name) {
        return this.floats[name];
    };
    _proto.setFloat = function setFloat(name, value) {
        this.checkUniform(name);
        this.floats[name] = value;
    };
    _proto.getInt = function getInt(name) {
        return this.ints[name];
    };
    _proto.setInt = function setInt(name, value) {
        this.checkUniform(name);
        this.ints[name] = value;
    };
    _proto.getFloats = function getFloats(name) {
        return this.floatArrays[name];
    };
    _proto.setFloats = function setFloats(name, value) {
        this.checkUniform(name);
        this.floatArrays[name] = value;
    };
    _proto.getVector2 = function getVector2(name) {
        return this.vector2s[name];
    };
    _proto.setVector2 = function setVector2(name, value) {
        this.checkUniform(name);
        this.vector2s[name] = value;
    };
    _proto.getVector3 = function getVector3(name) {
        return this.vector3s[name];
    };
    _proto.setVector3 = function setVector3(name, value) {
        this.checkUniform(name);
        this.vector3s[name] = value;
    };
    _proto.getVector4 = function getVector4(name) {
        return this.vector4s[name];
    };
    _proto.setVector4 = function setVector4(name, value) {
        this.checkUniform(name);
        this.vector4s[name] = value;
    };
    _proto.getColor = function getColor(name) {
        return this.colors[name];
    };
    _proto.setColor = function setColor(name, value) {
        this.checkUniform(name);
        this.colors[name] = value;
    };
    _proto.getQuaternion = function getQuaternion(name) {
        return this.quaternions[name];
    };
    _proto.setQuaternion = function setQuaternion(name, value) {
        this.checkUniform(name);
        this.quaternions[name] = value;
    };
    _proto.getMatrix = function getMatrix(name) {
        return this.matrices[name];
    };
    _proto.setMatrix = function setMatrix(name, value) {
        this.checkUniform(name);
        this.matrices[name] = value;
    };
    _proto.setMatrix3 = function setMatrix3(name, value) {
        this.checkUniform(name);
        this.matrice3s[name] = value;
    };
    _proto.getVector4Array = function getVector4Array(name) {
        return this.vector4Arrays[name];
    };
    _proto.setVector4Array = function setVector4Array(name, array) {
        this.checkUniform(name);
        this.vector4Arrays[name] = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(array), _step; !(_step = _iterator()).done;){
            var v = _step.value;
            this.vector4Arrays[name].push(v.x, v.y, v.z, v.w);
        }
    };
    _proto.getMatrixArray = function getMatrixArray(name) {
        return this.matrixArrays[name];
    };
    _proto.setMatrixArray = function setMatrixArray(name, array) {
        this.checkUniform(name);
        this.matrixArrays[name] = [];
        for(var _iterator = _create_for_of_iterator_helper_loose(array), _step; !(_step = _iterator()).done;){
            var m = _step.value;
            for(var i = 0; i < 16; i++){
                this.matrixArrays[name].push(m.elements[i]);
            }
        }
    };
    _proto.setMatrixNumberArray = function setMatrixNumberArray(name, array) {
        this.checkUniform(name);
        this.matrixArrays[name] = array;
    };
    _proto.getTexture = function getTexture(name) {
        return this.textures[name];
    };
    _proto.setTexture = function setTexture(name, texture) {
        if (!this.samplers.includes(name)) {
            this.samplers.push(name);
            this.uniformDirtyFlag = true;
        }
        this.textures[name] = texture;
    };
    _proto.hasUniform = function hasUniform(name) {
        return this.uniforms.includes(name) || this.samplers.includes(name);
    };
    _proto.clone = function clone(props) {
        var newProps = props ? props : this.props;
        var engine = this.engine;
        assertExist(engine);
        var clonedMaterial = new GLMaterial(engine, newProps);
        // TODO: 更换 Object.assign，低端设备兼容问题
        clonedMaterial.glMaterialState = Object.assign(new GLMaterialState(), clonedMaterial.glMaterialState);
        clonedMaterial.floats = this.floats;
        clonedMaterial.ints = this.ints;
        clonedMaterial.vector2s = this.vector2s;
        clonedMaterial.vector3s = this.vector3s;
        clonedMaterial.vector4s = this.vector4s;
        clonedMaterial.colors = this.colors;
        clonedMaterial.quaternions = this.quaternions;
        clonedMaterial.matrices = this.matrices;
        clonedMaterial.textures = this.textures;
        clonedMaterial.floatArrays = this.floatArrays;
        clonedMaterial.vector4Arrays = this.vector4Arrays;
        clonedMaterial.matrixArrays = this.matrixArrays;
        clonedMaterial.samplers = this.samplers;
        clonedMaterial.uniforms = this.uniforms;
        clonedMaterial.uniformDirtyFlag = true;
        return clonedMaterial;
    };
    _proto.fromData = function fromData(data) {
        Material.prototype.fromData.call(this, data);
        this.uniforms = [];
        this.samplers = [];
        this.textures = {};
        this.floats = {};
        this.ints = {};
        this.floatArrays = {};
        this.vector4s = {};
        var propertiesData = _extends({
            blending: false,
            zTest: false,
            zWrite: false
        }, data);
        // FIXME: 刷新 Material 状态，后面删除 data 中的 blending，zTest 和 zWrite 状态
        if (data.stringTags["RenderType"] !== undefined) {
            propertiesData.blending = data.stringTags["RenderType"] === RenderType.Transparent;
        }
        if (data.floats["ZTest"] !== undefined) {
            propertiesData.zTest = data.floats["ZTest"] !== 0;
        }
        if (data.floats["ZWrite"] !== undefined) {
            propertiesData.zWrite = data.floats["ZWrite"] !== 0;
        }
        this.blending = propertiesData.blending;
        this.depthTest = propertiesData.zTest;
        this.depthMask = propertiesData.zWrite;
        var renderFace = data.stringTags["RenderFace"];
        if (renderFace === RenderFace.Front) {
            this.culling = true;
            this.cullFace = glContext.BACK;
        } else if (renderFace === RenderFace.Back) {
            this.culling = true;
            this.cullFace = glContext.FRONT;
        } else {
            this.culling = false;
        }
        var name;
        for(name in propertiesData.floats){
            this.setFloat(name, propertiesData.floats[name]);
        }
        for(name in propertiesData.ints){
            this.setInt(name, propertiesData.ints[name]);
        }
        for(name in propertiesData.vector4s){
            var vector4Value = propertiesData.vector4s[name];
            this.setVector4(name, new Vector4$1(vector4Value.x, vector4Value.y, vector4Value.z, vector4Value.w));
        }
        for(name in propertiesData.colors){
            var colorValue = propertiesData.colors[name];
            this.setColor(name, new Color(colorValue.r, colorValue.g, colorValue.b, colorValue.a));
        }
        for(name in propertiesData.textures){
            var textureProperties = propertiesData.textures[name];
            // TODO 纹理通过 id 加入场景数据
            this.setTexture(name, textureProperties.texture);
            var offset = textureProperties.offset;
            var scale = textureProperties.scale;
            if (offset && scale) {
                this.setVector4(name + "_ST", new Vector4(scale.x, scale.y, offset.x, offset.y));
            }
        }
        if (data.shader) {
            this.shader = data.shader;
            this.shaderSource = this.shader.shaderData;
        }
        var _data_stringTags;
        this.stringTags = (_data_stringTags = data.stringTags) != null ? _data_stringTags : {};
        this.initialized = false;
    };
    /**
   * @since 2.0.0
   * @param sceneData
   * @returns
   */ _proto.toData = function toData() {
        // @ts-expect-error
        var materialData = this.taggedProperties;
        if (this.shader) {
            // @ts-expect-error
            materialData.shader = this.shader;
        }
        materialData.floats = {};
        materialData.ints = {};
        materialData.vector4s = {};
        materialData.textures = {};
        materialData.dataType = DataType.Material;
        materialData.stringTags = this.stringTags;
        for(var name in this.floats){
            materialData.floats[name] = this.floats[name];
        }
        for(var name1 in this.ints){
            materialData.ints[name1] = this.ints[name1];
        }
        for(var name2 in this.vector4s){
            materialData.vector4s[name2] = this.vector4s[name2];
        }
        for(var name3 in this.colors){
            materialData.colors[name3] = this.colors[name3];
        }
        for(var name4 in this.textures){
            if (!materialData.textures[name4]) {
                materialData.textures[name4] = {
                    texture: this.textures[name4]
                };
            }
            var textureProperties = materialData.textures[name4];
            var scaleOffset = this.getVector4(name4 + "_ST");
            if (scaleOffset) {
                textureProperties.scale = {
                    x: scaleOffset.x,
                    y: scaleOffset.y
                };
                textureProperties.offset = {
                    x: scaleOffset.z,
                    y: scaleOffset.w
                };
                delete materialData.vector4s[name4 + "_ST"];
            }
        }
        return materialData;
    };
    _proto.cloneUniforms = function cloneUniforms(sourceMaterial) {
        var material = sourceMaterial;
        var name;
        for(name in material.floats){
            this.setFloat(name, material.floats[name]);
        }
        for(name in material.ints){
            this.setInt(name, material.ints[name]);
        }
        for(name in material.floatArrays){
            this.setFloats(name, material.floatArrays[name]);
        }
        for(name in material.textures){
            this.setTexture(name, material.textures[name]);
        }
        for(name in material.vector2s){
            this.setVector2(name, material.vector2s[name]);
        }
        for(name in material.vector3s){
            this.setVector3(name, material.vector3s[name]);
        }
        for(name in material.vector4s){
            this.setVector4(name, material.vector4s[name]);
        }
        for(name in material.colors){
            this.setColor(name, material.colors[name]);
        }
        for(name in material.quaternions){
            this.setQuaternion(name, material.quaternions[name]);
        }
        for(name in material.matrices){
            this.setMatrix(name, material.matrices[name]);
        }
        for(name in material.vector4Arrays){
            var vec4Array = [];
            for(var i = 0; i < material.vector4Arrays[name].length; i += 4){
                vec4Array.push(new Vector4(material.vector4Arrays[name][i], material.vector4Arrays[name][i + 1], material.vector4Arrays[name][i + 2], material.vector4Arrays[name][i + 3]));
            }
            this.setVector4Array(name, vec4Array);
        }
        for(name in material.matrixArrays){
            var mat4Array = [];
            for(var i1 = 0; i1 < material.matrixArrays[name].length; i1 += 16){
                var matrix = Matrix4.fromIdentity();
                for(var j = 0; j < 16; j++){
                    matrix.elements[j] = material.matrixArrays[name][i1 + j];
                }
                mat4Array.push(matrix);
            }
            this.setMatrixArray(name, mat4Array);
        }
    };
    _proto.checkUniform = function checkUniform(uniformName) {
        if (!this.uniforms.includes(uniformName)) {
            this.uniforms.push(uniformName);
            this.uniformDirtyFlag = true;
        }
    };
    _proto.dispose = function dispose(options) {
        var _this = this;
        var _this_shaderVariant;
        if (this.destroyed) {
            return;
        }
        (_this_shaderVariant = this.shaderVariant) == null ? void 0 : _this_shaderVariant.dispose();
        if ((options == null ? void 0 : options.textures) !== exports.DestroyOptions.keep) {
            Object.keys(this.textures).forEach(function(key) {
                var texture = _this.textures[key];
                // TODO 纹理释放需要引用计数
                if (texture !== _this.engine.emptyTexture) {
                    texture.dispose();
                }
            });
        }
        // @ts-expect-error
        this.shaderSource = null;
        // @ts-expect-error
        this.uniformSemantics = {};
        this.floats = {};
        this.ints = {};
        this.vector2s = {};
        this.vector3s = {};
        this.vector4s = {};
        this.quaternions = {};
        this.matrices = {};
        this.matrice3s = {};
        this.textures = {};
        this.floatArrays = {};
        this.vector4Arrays = {};
        this.matrixArrays = {};
        this.samplers = [];
        this.uniforms = [];
        this.initialize = throwDestroyedError;
        this.destroyed = true;
        if (this.engine !== undefined) {
            this.engine.removeMaterial(this);
        }
    };
    _create_class(GLMaterial, [
        {
            key: "blending",
            get: function get() {
                return this.glMaterialState.blending;
            },
            set: function set(blending) {
                blending !== undefined && this.glMaterialState.setBlending(blending);
            }
        },
        {
            key: "blendColor",
            get: function get() {
                return this.glMaterialState.blendColor;
            },
            set: function set(color) {
                color && this.glMaterialState.setBlendColor(color);
            }
        },
        {
            key: "blendFunction",
            get: function get() {
                return this.glMaterialState.blendFunctionParameters;
            },
            set: function set(func) {
                func && this.glMaterialState.setBlendFunctionParameters(func);
            }
        },
        {
            key: "blendEquation",
            get: function get() {
                return this.glMaterialState.blendEquationParameters;
            },
            set: function set(equation) {
                equation && this.glMaterialState.setBlendEquationParameters(equation);
            }
        },
        {
            key: "depthTest",
            get: function get() {
                return this.glMaterialState.depthTest;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setDepthTest(value);
            }
        },
        {
            key: "depthMask",
            get: function get() {
                return this.glMaterialState.depthMask;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setDepthMask(value);
            }
        },
        {
            key: "depthRange",
            get: function get() {
                return this.glMaterialState.depthRange;
            },
            set: function set(value) {
                value && this.glMaterialState.setDepthRange(value);
            }
        },
        {
            key: "depthFunc",
            get: function get() {
                return this.glMaterialState.depthFunc;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setDepthFunc(value);
            }
        },
        {
            key: "polygonOffsetFill",
            get: function get() {
                return this.glMaterialState.polygonOffsetFill;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setPolygonOffsetFill(value);
            }
        },
        {
            key: "polygonOffset",
            get: function get() {
                return this.glMaterialState.polygonOffset;
            },
            set: function set(value) {
                value && this.glMaterialState.setPolygonOffset(value);
            }
        },
        {
            key: "sampleAlphaToCoverage",
            get: function get() {
                return this.glMaterialState.sampleAlphaToCoverage;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setSampleAlphaToCoverage(value);
            }
        },
        {
            key: "colorMask",
            get: function get() {
                return this.glMaterialState.colorMask;
            },
            set: function set(value) {
                value && this.glMaterialState.setColorMask(value);
            }
        },
        {
            key: "stencilTest",
            get: function get() {
                return this.glMaterialState.stencilTest;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setStencilTest(value);
            }
        },
        {
            key: "stencilMask",
            get: function get() {
                return this.glMaterialState.stencilMask;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilMask(value);
            }
        },
        {
            key: "stencilRef",
            get: function get() {
                return this.glMaterialState.stencilRef;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilRef(value);
            }
        },
        {
            key: "stencilFunc",
            get: function get() {
                return this.glMaterialState.stencilFunc;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilFunc(value);
            }
        },
        {
            key: "stencilOpFail",
            get: function get() {
                return this.glMaterialState.stencilOpFail;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilOpFail(value);
            }
        },
        {
            key: "stencilOpZFail",
            get: function get() {
                return this.glMaterialState.stencilOpZFail;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilOpZFail(value);
            }
        },
        {
            key: "stencilOpZPass",
            get: function get() {
                return this.glMaterialState.stencilOpZPass;
            },
            set: function set(value) {
                value && this.glMaterialState.setStencilOpZPass(value);
            }
        },
        {
            key: "culling",
            get: function get() {
                return this.glMaterialState.culling;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setCulling(value);
            }
        },
        {
            key: "frontFace",
            get: function get() {
                return this.glMaterialState.frontFace;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setFrontFace(value);
            }
        },
        {
            key: "cullFace",
            get: function get() {
                return this.glMaterialState.cullFace;
            },
            set: function set(value) {
                value !== undefined && this.glMaterialState.setCullFace(value);
            }
        },
        {
            key: "isDestroyed",
            get: function get() {
                return this.destroyed;
            }
        }
    ]);
    return GLMaterial;
}(Material);

var copyShaderId = "$mri-internal-copy";
var ExtWrap = /*#__PURE__*/ function() {
    function ExtWrap(renderer) {
        this.renderer = renderer;
        if (renderer.engine.gpuCapability.level === 1) {
            this.copyRenderPass = this.createCopyRenderPass().initialize(renderer);
            var shaderSource = this.copyRenderPass.meshes[0].material.shaderSource;
            renderer.pipelineContext.shaderLibrary.addShader(shaderSource);
        }
    }
    var _proto = ExtWrap.prototype;
    _proto.resetColorAttachments = function resetColorAttachments(rp, colorTextures) {
        if (this.renderer) {
            rp.resetColorAttachments(colorTextures);
        }
    };
    _proto.copyTexture = function copyTexture(source, tex) {
        if (!this.renderer) {
            return;
        }
        source.initialize();
        tex.initialize();
        tex.updateSource({
            sourceType: exports.TextureSourceType.framebuffer,
            data: {
                width: tex.getWidth() || source.getWidth(),
                height: tex.getHeight() || source.getHeight()
            }
        });
        if (this.renderer.engine.gpuCapability.level === 2) {
            this.copy2(source, tex);
        } else {
            this.copy1(source, tex);
        }
    };
    _proto.copy2 = function copy2(source, target) {
        // 保存当前的 fbo
        var framebuffer = this.renderer.getFramebuffer();
        this.renderer.glRenderer.copy2(source, target);
        // 还原 fbo
        this.renderer.setFramebuffer(framebuffer);
    };
    _proto.copy1 = function copy1(source, target) {
        var rp = this.copyRenderPass;
        if (rp) {
            var renderer = this.renderer;
            if (renderer) {
                var fb = rp.framebuffer;
                fb.viewport[2] = target.getWidth() || source.getWidth();
                fb.viewport[3] = target.getHeight() || source.getHeight();
                renderer.glRenderer.resetColorAttachments(fb, [
                    target
                ]);
                var mesh = rp.meshes[0];
                mesh.material.setTexture("uTex", source);
                renderer.renderRenderPass(rp);
            }
        }
    };
    _proto.createCopyRenderPass = function createCopyRenderPass() {
        var name = "mri-copy-mesh";
        var attachment = {
            texture: {
                format: glContext.RGBA
            }
        };
        var engine = this.renderer.engine;
        var geometry = new GLGeometry(engine, {
            name: name,
            mode: glContext.TRIANGLE_STRIP,
            attributes: {
                aPos: {
                    type: glContext.FLOAT,
                    size: 2,
                    data: new Float32Array([
                        -1,
                        1,
                        -1,
                        -1,
                        1,
                        1,
                        1,
                        -1
                    ])
                }
            },
            drawCount: 4
        });
        var vertexShader = "\nprecision highp float;\nattribute vec2 aPos;\nvarying vec2 vTex;\nvoid main(){\n  gl_Position = vec4(aPos,0.,1.0);\n  vTex = (aPos + vec2(1.))/2.;\n}";
        var fragmentShader = "\nprecision highp float;\nvarying vec2 vTex;\nuniform sampler2D uTex;\nvoid main(){\n  gl_FragColor = texture2D(uTex,vTex);\n}";
        var level = engine.gpuCapability.level;
        var material = new GLMaterial(engine, {
            name: name,
            shader: {
                cacheId: copyShaderId,
                name: name,
                vertex: vertexShader,
                fragment: fragmentShader,
                glslVersion: level === 2 ? exports.GLSLVersion.GLSL3 : exports.GLSLVersion.GLSL1
            }
        });
        material.blending = false;
        material.depthTest = false;
        material.culling = false;
        var mesh = new Mesh(engine, {
            name: name,
            geometry: geometry,
            material: material,
            priority: 0
        });
        return new CopyTexturePass(this.renderer, {
            name: "mri-copy-rp",
            clearAction: {
                colorAction: exports.TextureLoadAction.whatever
            },
            attachments: [
                attachment
            ],
            meshes: [
                mesh
            ]
        });
    };
    _proto.dispose = function dispose() {
        if (this.renderer) {
            var _this_copyRenderPass;
            (_this_copyRenderPass = this.copyRenderPass) == null ? void 0 : _this_copyRenderPass.dispose();
            // @ts-expect-error
            this.renderer = undefined;
        }
    };
    return ExtWrap;
}();
var CopyTexturePass = /*#__PURE__*/ function(RenderPass) {
    _inherits(CopyTexturePass, RenderPass);
    function CopyTexturePass() {
        return RenderPass.apply(this, arguments);
    }
    var _proto = CopyTexturePass.prototype;
    _proto.configure = function configure(renderer) {
        this.currentFramebuffer = renderer.getFramebuffer();
        renderer.setFramebuffer(this.framebuffer);
    };
    _proto.execute = function execute(renderer) {
        if (this.clearAction) {
            renderer.clear(this.clearAction);
        }
        renderer.renderMeshes(this.meshes);
        if (this.storeAction) {
            renderer.clear(this.storeAction);
        }
        renderer.setFramebuffer(this.currentFramebuffer);
    };
    return CopyTexturePass;
}(RenderPass);

var GLContextManager = /*#__PURE__*/ function() {
    function GLContextManager(canvas, glType, options) {
        var _this = this;
        if (glType === void 0) glType = "webgl";
        if (options === void 0) options = {};
        this.canvas = canvas;
        this.glType = glType;
        this.restoreHandlers = [];
        this.lostHandlers = [];
        assertExist(canvas);
        this.gl = createGLContext(canvas, glType, options);
        this.contextLostListener = function(e) {
            var _this_canvas;
            for(var _iterator = _create_for_of_iterator_helper_loose(_this.lostHandlers), _step; !(_step = _iterator()).done;){
                var lostHandler = _step.value;
                lostHandler.lost(e);
            }
            (_this_canvas = _this.canvas) == null ? void 0 : _this_canvas.removeEventListener("webglcontextlost", _this.contextLostListener);
        };
        this.contextRestoredListener = function(e) {
            var _this_canvas;
            for(var _iterator = _create_for_of_iterator_helper_loose(_this.restoreHandlers), _step; !(_step = _iterator()).done;){
                var restorable = _step.value;
                restorable.restore();
            }
            (_this_canvas = _this.canvas) == null ? void 0 : _this_canvas.addEventListener("webglcontextlost", _this.contextLostListener);
        };
        canvas.addEventListener("webglcontextlost", this.contextLostListener);
        canvas.addEventListener("webglcontextrestored", this.contextRestoredListener);
    }
    var _proto = GLContextManager.prototype;
    _proto.dispose = function dispose() {
        if (this.canvas) {
            this.canvas.removeEventListener("webglcontextlost", this.contextLostListener);
            this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredListener);
        }
        this.gl = null;
        this.canvas = null;
    };
    _proto.addLostHandler = function addLostHandler(lostHandler) {
        this.lostHandlers.push(lostHandler);
    };
    _proto.removeLostHandler = function removeLostHandler(lostHandler) {
        var index = this.lostHandlers.indexOf(lostHandler);
        if (index > -1) {
            this.lostHandlers.splice(index, 1);
        }
    };
    _proto.addRestoreHandler = function addRestoreHandler(restoreHandler) {
        this.restoreHandlers.push(restoreHandler);
    };
    _proto.removeRestoreHandler = function removeRestoreHandler(restorable) {
        var index = this.restoreHandlers.indexOf(restorable);
        if (index > -1) {
            this.restoreHandlers.splice(index, 1);
        }
    };
    return GLContextManager;
}();

var GLEngine = /*#__PURE__*/ function(Engine) {
    _inherits(GLEngine, Engine);
    function GLEngine(gl) {
        var _this;
        _this = Engine.call(this) || this;
        _this.gpuCapability = new GPUCapability(gl);
        return _this;
    }
    var _proto = GLEngine.prototype;
    _proto.dispose = function dispose() {
        if (this.isDestroyed) {
            return;
        }
        Engine.prototype.dispose.call(this);
    };
    _proto.getGLRenderer = function getGLRenderer() {
        return this.renderer;
    };
    _proto.getGLRendererInternal = function getGLRendererInternal() {
        return this.getGLRenderer().glRenderer;
    };
    _proto.getGLPipelineContext = function getGLPipelineContext() {
        return this.getGLRenderer().pipelineContext;
    };
    return GLEngine;
}(Engine);

var GLRenderbuffer = /*#__PURE__*/ function(Renderbuffer) {
    _inherits(GLRenderbuffer, Renderbuffer);
    function GLRenderbuffer(props, renderer) {
        var _this;
        _this = Renderbuffer.call(this, props) || this;
        _this.initialized = false;
        if (renderer !== undefined) {
            _this.initialize(renderer);
        }
        return _this;
    }
    var _proto = GLRenderbuffer.prototype;
    _proto.initialize = function initialize(renderer) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.renderer = renderer;
        this.buffer = renderer.createGLRenderbuffer(this);
    };
    _proto.setSize = function setSize(width, height) {
        if (!this.initialized) {
            logger.error("Can't set size for uninitialized render buffer.");
            return;
        }
        if (!this.renderer) {
            return;
        }
        if (width !== this.size[0] || height !== this.size[1]) {
            var _this_renderer = this.renderer, gl = _this_renderer.gl, state = _this_renderer.pipelineContext;
            state.bindRenderbuffer(gl.RENDERBUFFER, this.buffer);
            if (width && height) {
                gl.renderbufferStorage(gl.RENDERBUFFER, this.format, this.size[0] = width, this.size[1] = height);
            } else {
                logger.error("Invalid render buffer size: " + width + "x" + height + ".");
            }
        }
    };
    _proto.dispose = function dispose() {
        if (this.renderer) {
            this.renderer.deleteGLRenderbuffer(this);
            this.renderer = null;
            this.buffer = null;
        }
        this.destroyed = true;
        this.initialize = throwDestroyedError;
    };
    return GLRenderbuffer;
}(Renderbuffer);

var seed$1 = 1;
var GLFramebuffer = /*#__PURE__*/ function(Framebuffer) {
    _inherits(GLFramebuffer, Framebuffer);
    function GLFramebuffer(props, renderer) {
        var _this;
        _this = Framebuffer.call(this) || this;
        _this.attachmentTextures = [];
        var depthStencilAttachment = props.depthStencilAttachment, viewport = props.viewport, isCustomViewport = props.isCustomViewport, storeAction = props.storeAction, _props_viewportScale = props.viewportScale, viewportScale = _props_viewportScale === void 0 ? 1 : _props_viewportScale, _props_name = props.name, name = _props_name === void 0 ? "GLFramebuffer" + seed$1++ : _props_name;
        _this.renderer = renderer;
        _this.engine = renderer.engine;
        var _depthStencilAttachment_storageType;
        _this.depthStencilStorageType = (_depthStencilAttachment_storageType = depthStencilAttachment == null ? void 0 : depthStencilAttachment.storageType) != null ? _depthStencilAttachment_storageType : exports.RenderPassAttachmentStorageType.none;
        _this.viewport = viewport;
        _this.isCustomViewport = !!isCustomViewport;
        _this.viewportScale = viewportScale;
        _this.name = name;
        _this.storeAction = storeAction;
        _this.updateProps(props);
        return _this;
    }
    var _proto = GLFramebuffer.prototype;
    _proto.getDepthTexture = function getDepthTexture() {
        return this.depthTexture;
    };
    _proto.getStencilTexture = function getStencilTexture() {
        return this.stencilTexture;
    };
    _proto.getColorTextures = function getColorTextures() {
        return this.colorTextures;
    };
    _proto.updateAttachmentTextures = function updateAttachmentTextures() {
        var _this = this;
        this.attachmentTextures.length = 0;
        this.colorTextures.forEach(function(tex) {
            tex.initialize();
            addItem(_this.attachmentTextures, tex.textureBuffer);
        });
        if (this.stencilTexture) {
            addItem(this.attachmentTextures, this.stencilTexture.textureBuffer);
        }
        if (this.depthTexture) {
            addItem(this.attachmentTextures, this.depthTexture.textureBuffer);
        }
    };
    _proto.updateProps = function updateProps(props) {
        var _props_depthStencilAttachment;
        var renderer = this.renderer;
        var gpuCapability = this.engine.gpuCapability;
        var _props_depthStencilAttachment1;
        var depthStencilAttachment = (_props_depthStencilAttachment1 = props.depthStencilAttachment) != null ? _props_depthStencilAttachment1 : {
            storageType: exports.RenderPassAttachmentStorageType.none
        };
        var willUseFbo = props.attachments.length > 0;
        var separateDepthStencil = true;
        this.externalStorage = false;
        if (props.attachments.length > 1 && !gpuCapability.detail.drawBuffers) {
            throw new Error("Multiple color attachments not support.");
        }
        var optDepthStencilTex = (_props_depthStencilAttachment = props.depthStencilAttachment) == null ? void 0 : _props_depthStencilAttachment.texture;
        var readableDepthStencilTextures = gpuCapability.detail.readableDepthStencilTextures;
        var storageType = depthStencilAttachment.storageType, storage = depthStencilAttachment.storage;
        this.colorTextures = props.attachments.slice();
        if (!willUseFbo && storageType !== exports.RenderPassAttachmentStorageType.none) {
            throw new Error("Use depth stencil attachment without color attachments.");
        }
        if (willUseFbo) {
            this.fbo = renderer.glRenderer.createGLFramebuffer(this, this.name);
        }
        switch(storageType){
            case exports.RenderPassAttachmentStorageType.depth_stencil_opaque:
                if (storage) {
                    if (_instanceof1(storage, GLRenderbuffer)) {
                        this.depthStencilRenderbuffer = storage;
                        this.externalStorage = true;
                    } else {
                        throw new Error("Invalid depth stencil attachment storage.");
                    }
                } else {
                    this.depthStencilRenderbuffer = new GLRenderbuffer({
                        format: glContext.DEPTH_STENCIL,
                        attachment: glContext.DEPTH_STENCIL_ATTACHMENT,
                        storageType: storageType
                    }, renderer.glRenderer);
                }
                separateDepthStencil = false;
                break;
            case exports.RenderPassAttachmentStorageType.depth_16_opaque:
                if (storage) {
                    if (_instanceof1(storage, GLRenderbuffer)) {
                        this.depthStencilRenderbuffer = storage;
                        this.externalStorage = true;
                    } else {
                        throw new Error("Invalid depth attachment storage.");
                    }
                } else {
                    this.depthStencilRenderbuffer = new GLRenderbuffer({
                        attachment: glContext.DEPTH_ATTACHMENT,
                        format: glContext.DEPTH_COMPONENT16,
                        storageType: storageType
                    }, renderer.glRenderer);
                }
                break;
            case exports.RenderPassAttachmentStorageType.stencil_8_opaque:
                if (storage) {
                    if (_instanceof1(storage, GLRenderbuffer)) {
                        this.depthStencilRenderbuffer = storage;
                        this.externalStorage = true;
                    } else {
                        throw new Error("Invalid stencil attachment storage.");
                    }
                } else {
                    this.depthStencilRenderbuffer = new GLRenderbuffer({
                        attachment: glContext.STENCIL_ATTACHMENT,
                        format: glContext.STENCIL_INDEX8,
                        storageType: storageType
                    }, renderer.glRenderer);
                }
                break;
            case exports.RenderPassAttachmentStorageType.depth_16_texture:
                if (!readableDepthStencilTextures) {
                    throw new Error("Depth texture is not support in framebuffer.");
                }
                this.depthTexture = optDepthStencilTex != null ? optDepthStencilTex : new GLTexture(this.engine, {
                    sourceType: exports.TextureSourceType.framebuffer,
                    format: glContext.DEPTH_COMPONENT,
                    internalFormat: gpuCapability.internalFormatDepth16,
                    type: glContext.UNSIGNED_SHORT,
                    name: "" + this.name + "##depthTex"
                });
                this.depthTexture.initialize();
                break;
            case exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture:
                if (!readableDepthStencilTextures) {
                    throw new Error("Depth stencil texture is not support in framebuffer.");
                }
                this.depthTexture = this.stencilTexture = optDepthStencilTex != null ? optDepthStencilTex : new GLTexture(this.engine, {
                    sourceType: exports.TextureSourceType.framebuffer,
                    format: glContext.DEPTH_STENCIL,
                    internalFormat: gpuCapability.internalFormatDepth24_stencil8,
                    type: gpuCapability.UNSIGNED_INT_24_8,
                    name: "" + this.name + "##dpthStclTex"
                });
                this.depthTexture.initialize();
                separateDepthStencil = true;
                break;
        }
        this.storeInvalidAttachments = this.getStoreAttachments(this.storeAction, separateDepthStencil);
        this.updateAttachmentTextures();
    };
    _proto.getStoreAttachments = function getStoreAttachments(storeAction, separateDepthStencil) {
        var gl = this.renderer.glRenderer.gl;
        var colorLen = this.colorTextures.length;
        if (storeAction && isWebGL2(gl) && colorLen > 0) {
            var attachments = [];
            if (storeAction.depthAction === exports.TextureStoreAction.clear && this.depthStorage) {
                addItem(attachments, separateDepthStencil ? gl.DEPTH_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.stencilAction === exports.TextureStoreAction.clear && this.stencilStorage) {
                addItem(attachments, separateDepthStencil ? gl.STENCIL_ATTACHMENT : gl.DEPTH_STENCIL_ATTACHMENT);
            }
            if (storeAction.colorAction === exports.TextureStoreAction.clear) {
                for(var i = 0; i < colorLen; i++){
                    addItem(attachments, gl["COLOR_ATTACHMENT" + i]);
                }
            }
            return attachments;
        }
    };
    _proto.unbind = function unbind() {
        var attachments = this.storeInvalidAttachments;
        if (attachments == null ? void 0 : attachments.length) {
            var gl = this.renderer.glRenderer.gl;
            if (isWebGL2(gl)) {
                gl.invalidateFramebuffer(gl.FRAMEBUFFER, attachments);
            }
        }
        this.renderer.pipelineContext.bindSystemFramebuffer();
    };
    _proto.bind = function bind() {
        var _this = this;
        if (!this.fbo) {
            return;
        }
        var gl = this.renderer.glRenderer.gl;
        var state = this.renderer.pipelineContext;
        var _this_viewport = this.viewport, x = _this_viewport[0], y = _this_viewport[1], width = _this_viewport[2], height = _this_viewport[3];
        state.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        // TODO 不在bind中设置viewport
        state.viewport(x, y, width, height);
        var emptyTexture = this.renderer.glRenderer.emptyTexture2D.textureBuffer;
        // in case frame texture loop
        Object.keys(state.textureUnitDict).forEach(function(unit) {
            var texture = state.textureUnitDict[unit];
            if (texture && texture !== emptyTexture && _this.attachmentTextures.includes(texture)) {
                state.activeTexture(+unit);
                _this.renderer.glRenderer.emptyTexture2D.bind();
            }
        });
        // FIXME: 没有pipeline对象的临时方案
        for(var i = 0; i < 4; i++){
            state.activeTexture(gl.TEXTURE0 + i);
            this.renderer.glRenderer.emptyTexture2D.bind();
        }
        if (this.ready) {
            return;
        }
        var _this1 = this, depthStencilRenderbuffer = _this1.depthStencilRenderbuffer, depthTexture = _this1.depthTexture, stencilTexture = _this1.stencilTexture;
        state.activeTexture(gl.TEXTURE0);
        if (depthStencilRenderbuffer) {
            depthStencilRenderbuffer.setSize(width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStencilRenderbuffer.attachment, gl.RENDERBUFFER, depthStencilRenderbuffer.buffer);
        } else if (depthTexture) {
            // 解决RenderPass在Clone深度贴图时width和height丢失的问题
            depthTexture.source.data = {
                width: width,
                height: height
            };
            depthTexture.update({
                data: {
                    width: width,
                    height: height,
                    data: new Uint16Array(0)
                }
            });
            var attachment = depthTexture && stencilTexture ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, depthTexture.textureBuffer, 0);
        }
        this.resetColorTextures(this.colorTextures);
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            throw new Error("Framebuffer failed, status: " + status + ", error: " + gl.getError() + ".");
        }
        this.ready = true;
    };
    _proto.resetColorTextures = function resetColorTextures(colorTextures) {
        var colors = colorTextures;
        var gl = this.renderer.glRenderer.gl;
        var gpuCapability = this.engine.gpuCapability;
        var viewport = this.viewport;
        var buffers = [];
        if (colors) {
            for(var _iterator = _create_for_of_iterator_helper_loose(colors), _step; !(_step = _iterator()).done;){
                var texture = _step.value;
                texture.initialize();
            }
            this.colorTextures = colors.slice();
        }
        this.renderer.pipelineContext.activeTexture(gl.TEXTURE0);
        this.colorTextures.forEach(function(tex, index) {
            var width = viewport[2];
            var height = viewport[3];
            var data = {
                width: width,
                height: height,
                data: new Uint8Array(0)
            };
            tex.update({
                data: data
            });
            gpuCapability.framebufferTexture2D(gl, gl.FRAMEBUFFER, index, gl.TEXTURE_2D, tex.textureBuffer);
            buffers.push(true);
        });
        gpuCapability.drawBuffers(gl, buffers);
        this.updateAttachmentTextures();
    };
    _proto.resize = function resize(x, y, width, height) {
        var _this_viewport = this.viewport, preX = _this_viewport[0], preY = _this_viewport[1], preWidth = _this_viewport[2], preHeight = _this_viewport[3];
        if (preX !== x || preY !== y || preWidth !== width || preHeight !== height) {
            this.viewport = [
                x,
                y,
                width,
                height
            ];
            this.ready = false;
            this.bind();
        }
    };
    _proto.dispose = function dispose(options) {
        if (this.renderer) {
            this.renderer.glRenderer.deleteGLFramebuffer(this);
            delete this.fbo;
            var clearAttachment = (options == null ? void 0 : options.depthStencilAttachment) ? options.depthStencilAttachment : exports.RenderPassDestroyAttachmentType.force;
            if (clearAttachment === exports.RenderPassDestroyAttachmentType.force || clearAttachment === exports.RenderPassDestroyAttachmentType.keepExternal && !this.externalStorage) {
                var _this_depthStencilRenderbuffer, _this_depthTexture;
                (_this_depthStencilRenderbuffer = this.depthStencilRenderbuffer) == null ? void 0 : _this_depthStencilRenderbuffer.dispose();
                (_this_depthTexture = this.depthTexture) == null ? void 0 : _this_depthTexture.dispose();
            }
            // @ts-expect-error safe to assign
            this.renderer = this.stencilRenderbuffer = this.depthStencilRenderbuffer = null;
        }
    };
    _create_class(GLFramebuffer, [
        {
            key: "stencilStorage",
            get: function get() {
                var storageType = this.depthStencilStorageType;
                if (storageType !== exports.RenderPassAttachmentStorageType.depth_16_opaque) {
                    return this.depthStencilRenderbuffer;
                }
            }
        },
        {
            key: "depthStorage",
            get: function get() {
                if (this.depthStencilStorageType !== exports.RenderPassAttachmentStorageType.stencil_8_opaque) {
                    return this.depthStencilRenderbuffer;
                }
            }
        }
    ]);
    return GLFramebuffer;
}(Framebuffer);

function hash(str) {
    var _$hash = 5381, i = str.length;
    while(i){
        _$hash = _$hash * 33 ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;
}
var stringHash = hash;

var BlockUniformInfoOffset = 1;
var BlockUniformInfoByteLength = 8;
var BlockUniformInfoType = 0;
var BlockUniformInfoArrayStride = 4;
var BlockUniformInfoArraySize = 2;
var BlockUniformInfoRowStride = 5;
var _obj;
var ItemPerValueMap = (_obj = {}, _obj[glContext.FLOAT] = 1, _obj[glContext.INT] = 1, _obj[glContext.UNSIGNED_INT] = 1, _obj[glContext.SHORT] = 1, _obj[glContext.BOOL] = 1, _obj[glContext.UNSIGNED_SHORT] = 1, _obj[glContext.FLOAT_VEC2] = 2, _obj[glContext.FLOAT_VEC3] = 3, _obj[glContext.FLOAT_VEC4] = 4, _obj[glContext.FLOAT_MAT2] = 4, _obj[glContext.FLOAT_MAT3] = 9, _obj[glContext.FLOAT_MAT4] = 16, _obj[glContext.FLOAT_MAT2x3] = 6, _obj[glContext.FLOAT_MAT2x4] = 8, _obj[glContext.FLOAT_MAT4x3] = 12, _obj[glContext.FLOAT_MAT4x2] = 8, _obj[glContext.FLOAT_MAT3x4] = 12, _obj[glContext.FLOAT_MAT3x2] = 6, _obj[glContext.INT_VEC2] = 2, _obj[glContext.INT_VEC3] = 3, _obj[glContext.INT_VEC4] = 4, _obj[glContext.UNSIGNED_INT_VEC2] = 2, _obj[glContext.UNSIGNED_INT_VEC3] = 3, _obj[glContext.UNSIGNED_INT_VEC4] = 4, _obj[glContext.BOOL_VEC2] = 2, _obj[glContext.BOOL_VEC3] = 3, _obj[glContext.BOOL_VEC4] = 4, _obj);
var setFloat32Array = arraySetter(Float32Array);
var setInt32Array = arraySetter(Int32Array);
var setUInt8Array = arraySetter(Uint8Array);
var _obj1;
(_obj1 = {}, _obj1[glContext.FLOAT] = numberSetter(Float32Array), _obj1[glContext.INT] = numberSetter(Int32Array), _obj1[glContext.UNSIGNED_INT] = numberSetter(Uint32Array), _obj1[glContext.SHORT] = numberSetter(Int16Array), _obj1[glContext.BOOL] = numberSetter(Uint8Array), _obj1[glContext.UNSIGNED_SHORT] = numberSetter(Uint16Array), _obj1[glContext.FLOAT_VEC2] = setFloat32Array, _obj1[glContext.FLOAT_VEC3] = setFloat32Array, _obj1[glContext.FLOAT_VEC4] = setFloat32Array, _obj1[glContext.FLOAT_MAT2] = setFloat32Array, _obj1[glContext.FLOAT_MAT3] = setFloat32Array, _obj1[glContext.FLOAT_MAT4] = setFloat32Array, _obj1[glContext.FLOAT_MAT2x3] = setFloat32Array, _obj1[glContext.FLOAT_MAT2x4] = setFloat32Array, _obj1[glContext.FLOAT_MAT4x3] = setFloat32Array, _obj1[glContext.FLOAT_MAT4x2] = setFloat32Array, _obj1[glContext.FLOAT_MAT3x4] = setFloat32Array, _obj1[glContext.FLOAT_MAT3x2] = setFloat32Array, _obj1[glContext.INT_VEC2] = setInt32Array, _obj1[glContext.INT_VEC3] = setInt32Array, _obj1[glContext.INT_VEC4] = setInt32Array, _obj1[glContext.UNSIGNED_INT_VEC2] = setInt32Array, _obj1[glContext.UNSIGNED_INT_VEC3] = setInt32Array, _obj1[glContext.UNSIGNED_INT_VEC4] = setInt32Array, _obj1[glContext.BOOL_VEC2] = setUInt8Array, _obj1[glContext.BOOL_VEC3] = setUInt8Array, _obj1[glContext.BOOL_VEC4] = setUInt8Array);
function numberSetter(typedArray) {
    return function(value, info, name, range) {
        var flag = {
            start: info[BlockUniformInfoOffset],
            dirty: true
        };
        var arrSize = info[BlockUniformInfoArraySize];
        if (arrSize > 1) {
            var values = value;
            if (values.length) {
                var eleCount = range[1] || values.length;
                var vecLen = info[BlockUniformInfoArrayStride] / typedArray.BYTES_PER_ELEMENT;
                var buffer = flag.buffer = new typedArray(eleCount * vecLen);
                var start = range[0] || 0;
                for(var i = 0; i < eleCount; i++){
                    buffer[i * vecLen] = values[i + start];
                }
                flag.start += start * vecLen;
            }
        } else {
            flag.buffer = new typedArray([
                value
            ]);
        }
        return flag;
    };
}
function arraySetter(type) {
    return function(value, info, name, range) {
        var blockByteLen = info[BlockUniformInfoByteLength];
        var arrSize = info[BlockUniformInfoArraySize];
        var rowStride = info[BlockUniformInfoRowStride];
        var entryStride = arrSize === 1 ? blockByteLen : info[BlockUniformInfoArrayStride];
        var entryRowCount = rowStride ? entryStride / rowStride : 1;
        var rowNumPadding = entryStride / type.BYTES_PER_ELEMENT / entryRowCount;
        var maxRowCount = blockByteLen / type.BYTES_PER_ELEMENT / rowNumPadding;
        //set array
        var numPerEntry = ItemPerValueMap[info[BlockUniformInfoType]];
        var numPerRow = numPerEntry / entryRowCount;
        var valueStartIndex = (range[0] || 0) * numPerEntry;
        var totalRow = range[1] ? entryRowCount * range[1] : maxRowCount;
        var buffer = new type(rowNumPadding * totalRow);
        var flag = {
            start: info[BlockUniformInfoOffset] + entryStride * (range[0] || 0),
            dirty: true,
            buffer: buffer
        };
        for(var i = 0, bufferTarget = 0, sourceIndex = valueStartIndex; i < totalRow; i++){
            for(var j = 0; j < numPerRow; j++){
                buffer[bufferTarget + j] = value[sourceIndex + j];
            }
            bufferTarget += rowNumPadding;
            sourceIndex += numPerRow;
        }
        return flag;
    };
}
// TODO: 函数名重定义
function createUniformBlockDataFromProgram(gl, program) {
    var _loop = function(idx) {
        var name = gl.getActiveUniformBlockName(program, idx);
        assertExist(name);
        var blockSpec = {
            index: gl.getUniformBlockIndex(program, name),
            usedByVertexShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
            usedByFragmentShader: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
            size: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_DATA_SIZE),
            uniformIndices: gl.getActiveUniformBlockParameter(program, idx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),
            used: false,
            uniforms: {},
            name: name,
            id: ""
        };
        blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
        blockSpecs[idx] = blockSpec;
        var indices = blockSpec.uniformIndices;
        var uniformNames = [];
        for(var i = 0; i < indices.length; i++){
            var name1 = gl.getActiveUniform(program, indices[i]).name.replace("[0]", "");
            blockSpec.uniforms[name1] = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                i,
                0
            ];
            uniformNames[i] = name1;
            blockUniformNames.push(name1);
        }
        [
            gl.UNIFORM_TYPE,
            gl.UNIFORM_OFFSET,
            gl.UNIFORM_SIZE,
            gl.UNIFORM_BLOCK_INDEX,
            gl.UNIFORM_ARRAY_STRIDE,
            gl.UNIFORM_MATRIX_STRIDE,
            gl.UNIFORM_IS_ROW_MAJOR
        ].forEach(function(param, pi) {
            gl.getActiveUniforms(program, indices, param).forEach(function(value, idx) {
                var name = uniformNames[idx];
                blockSpec.uniforms[name][pi] = +value;
            });
        });
        for(var i1 = 0; i1 < uniformNames.length; i1++){
            var uniform = blockSpec.uniforms[uniformNames[i1]];
            var nextUniform = blockSpec.uniforms[uniformNames[i1 + 1]];
            var size = nextUniform ? nextUniform[1] : blockSpec.size;
            uniform[8] = size - uniform[1];
        }
        blockSpec.id = getUboHash(blockSpec) + "";
    };
    var blockSpecs = [];
    var blockUniformNames = [];
    var uniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
    for(var idx = 0; idx < uniformBlocks; ++idx)_loop(idx);
    return {
        blockSpecs: blockSpecs,
        blockUniformNames: blockUniformNames
    };
}
function getUboHash(spec) {
    var name = spec.name, size = spec.size, uniforms = spec.uniforms, uniformIndices = spec.uniformIndices;
    Object.keys(uniforms).map(function(name) {
        return name + "[" + uniforms[name].join(":") + "]";
    }).join("+");
    return stringHash("" + name + "+", "" + size + "+", "" + uniformIndices.length + "+");
}

var GLProgram = /*#__PURE__*/ function() {
    function GLProgram(engine, program, id) {
        var _this = this;
        this.engine = engine;
        this.program = program;
        this.id = id;
        this.uniformBlockMap = {};
        this.pipelineContext = engine.getGLPipelineContext();
        var gl = this.pipelineContext.gl;
        this.pipelineContext.useProgram(program);
        this.attribInfoMap = this.createAttribMap();
        if (isWebGL2(gl)) {
            var blockSpecs = createUniformBlockDataFromProgram(gl, program).blockSpecs;
            // blockUniformNames = buns;
            blockSpecs.forEach(function(b) {
                return _this.uniformBlockMap[b.name] = b;
            });
        }
        this.pipelineContext.useProgram(null);
    }
    var _proto = GLProgram.prototype;
    _proto.bind = function bind() {
        this.pipelineContext.useProgram(this.program);
    };
    /**
   * 绑定 vao 对象并设置顶点属性
   * 如果当前环境不支持 vao，则使用 gl 函数依次设置属性。
   * @param geometry
   * @returns
   */ _proto.setupAttributes = function setupAttributes(geometry) {
        var _this = this;
        var _geometry_indicesBuffer;
        var programId = this.id;
        var gl = this.pipelineContext.gl;
        var vao;
        if (geometry.vaos[programId]) {
            vao = geometry.vaos[programId];
        } else {
            vao = new GLVertexArrayObject(this.engine, geometry.name + "-" + programId);
            if (!vao) {
                console.error("Failed to create VAO object.");
            }
            geometry.vaos[programId] = vao;
        }
        // 兼容小程序下不支持vao
        if (vao && vao.vao) {
            vao.bind();
            if (vao.ready) {
                return vao;
            }
        }
        Object.keys(this.attribInfoMap).forEach(function(name) {
            var attrInfo = _this.attribInfoMap[name];
            var attribute = geometry.attributes[name];
            if (attribute) {
                var buffer = geometry.buffers[attribute.dataSource];
                if (!buffer) {
                    throw new Error("Failed to find a buffer named '" + (attribute.dataSource || name) + "'. Please ensure the buffer is correctly initialized and bound.");
                }
                buffer.bind();
                gl.enableVertexAttribArray(attrInfo.loc);
                gl.vertexAttribPointer(attrInfo.loc, attribute.size, attribute.type, attribute.normalize, attribute.stride || 0, attribute.offset || 0);
            }
        });
        (_geometry_indicesBuffer = geometry.indicesBuffer) == null ? void 0 : _geometry_indicesBuffer.bind();
        if (vao) {
            vao.ready = true;
        }
        return vao;
    };
    _proto.createAttribMap = function createAttribMap() {
        var gl = this.pipelineContext.gl;
        var program = this.program;
        var attribMap = {};
        var num = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for(var i = 0; i < num; i++){
            var info = gl.getActiveAttrib(program, i);
            if (info) {
                var name = info.name, type = info.type, size = info.size;
                var loc = gl.getAttribLocation(program, name);
                attribMap[name] = {
                    type: type,
                    name: name,
                    size: size,
                    loc: loc
                };
            }
        }
        return attribMap;
    };
    _proto.dispose = function dispose() {
        if (this.pipelineContext) {
            this.pipelineContext.gl.deleteProgram(this.program);
            // @ts-expect-error safe to assign
            this.pipelineContext = null;
        }
    };
    return GLProgram;
}();

var GLShaderVariant = /*#__PURE__*/ function(ShaderVariant) {
    _inherits(GLShaderVariant, ShaderVariant);
    function GLShaderVariant(engine, source) {
        var _this;
        _this = ShaderVariant.call(this, engine, source) || this;
        _this.initialized = false;
        _this.uniformLocations = {};
        _this.samplerChannels = {};
        return _this;
    }
    var _proto = GLShaderVariant.prototype;
    // shader 的 GPU 资源初始化方法，在绘制前调用
    _proto.initialize = function initialize() {
        if (this.initialized) {
            return;
        }
        // 核心初始化都在 compileShader
        // 否则会出现编译了却没有初始化的情况
        var pipelineContext = this.engine.getGLPipelineContext();
        pipelineContext.shaderLibrary.compileShader(this);
    };
    _proto.setFloat = function setFloat(name, value) {
        this.pipelineContext.setFloat(this.uniformLocations[name], value);
    };
    _proto.setInt = function setInt(name, value) {
        this.pipelineContext.setInt(this.uniformLocations[name], value);
    };
    _proto.setFloats = function setFloats(name, value) {
        this.pipelineContext.setFloats(this.uniformLocations[name], value);
    };
    _proto.setTexture = function setTexture(name, texture) {
        this.pipelineContext.setTexture(this.uniformLocations[name], this.samplerChannels[name], texture);
    };
    _proto.setVector2 = function setVector2(name, value) {
        this.pipelineContext.setVector2(this.uniformLocations[name], value);
    };
    _proto.setVector3 = function setVector3(name, value) {
        this.pipelineContext.setVector3(this.uniformLocations[name], value);
    };
    _proto.setVector4 = function setVector4(name, value) {
        this.pipelineContext.setVector4(this.uniformLocations[name], value);
    };
    _proto.setColor = function setColor(name, value) {
        this.pipelineContext.setColor(this.uniformLocations[name], value);
    };
    _proto.setQuaternion = function setQuaternion(name, value) {
        this.pipelineContext.setQuaternion(this.uniformLocations[name], value);
    };
    _proto.setMatrix = function setMatrix(name, value) {
        this.pipelineContext.setMatrix(this.uniformLocations[name], value);
    };
    _proto.setMatrix3 = function setMatrix3(name, value) {
        this.pipelineContext.setMatrix3(this.uniformLocations[name], value);
    };
    _proto.setVector4Array = function setVector4Array(name, array) {
        this.pipelineContext.setVector4Array(this.uniformLocations[name], array);
    };
    _proto.setMatrixArray = function setMatrixArray(name, array) {
        this.pipelineContext.setMatrixArray(this.uniformLocations[name], array);
    };
    _proto.fillShaderInformation = function fillShaderInformation(uniformNames, samplers) {
        // 避免修改原数组。
        var samplerList = samplers.slice();
        uniformNames = uniformNames.concat(samplerList);
        var avaliableUniforms = this.pipelineContext.getUniforms(this.program.program, uniformNames);
        for(var i = 0; i < uniformNames.length; i++){
            this.uniformLocations[uniformNames[i]] = avaliableUniforms[i];
        }
        var index;
        for(index = 0; index < samplerList.length; index++){
            var sampler = this.uniformLocations[samplerList[index]];
            if (sampler == null) {
                samplerList.splice(index, 1);
                index--;
            }
        }
        for(index = 0; index < samplerList.length; index++){
            var samplerName = samplerList[index];
            this.samplerChannels[samplerName] = index;
        }
    };
    _proto.toData = function toData() {
        var shaderData = this.taggedProperties;
        shaderData.dataType = DataType.Shader;
        shaderData.id = this.guid;
        shaderData.vertex = this.source.vertex;
        shaderData.fragment = this.source.fragment;
    };
    _proto.dispose = function dispose() {
        var _this_program;
        if (this.compileResult && this.compileResult.shared) {
            return;
        }
        (_this_program = this.program) == null ? void 0 : _this_program.dispose();
    };
    return GLShaderVariant;
}(ShaderVariant);

var shaderSeed = 0;
var GLShaderLibrary = /*#__PURE__*/ function() {
    function GLShaderLibrary(engine, pipelineContext) {
        this.engine = engine;
        this.pipelineContext = pipelineContext;
        this.shaderResults = {};
        this.programMap = {};
        this.glVertShaderMap = new Map();
        this.glFragShaderMap = new Map();
        this.shaderAllDone = false;
        this.cachedShaders = {};
        this.glAsyncCompileExt = engine.gpuCapability.glAsyncCompileExt;
    }
    var _proto = GLShaderLibrary.prototype;
    _proto.compileAllShaders = function compileAllShaders(asyncCallback) {
        var _this = this;
        if (!this.shaderAllDone) {
            var pendings = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.keys(this.cachedShaders)), _step; !(_step = _iterator()).done;){
                var key = _step.value;
                if (!this.cachedShaders[key].initialized) {
                    pendings.push(key);
                }
            }
            if (asyncCallback) {
                if (pendings.length) {
                    Promise.all(pendings.map(function(key) {
                        return new Promise(function(resolve) {
                            return _this.compileShader(_this.cachedShaders[key], resolve);
                        });
                    })).then(asyncCallback).catch(function() {
                        return 0;
                    });
                } else {
                    asyncCallback([]);
                }
            } else {
                pendings.map(function(key) {
                    return _this.compileShader(_this.cachedShaders[key]);
                });
            }
            this.shaderAllDone = true;
        } else if (asyncCallback) {
            asyncCallback([]);
        }
    };
    // TODO 创建shader的ShaderWithSource和shader的source类型一样，待优化。
    _proto.addShader = function addShader(shaderSource, macros) {
        var mergedMacros = [];
        if (shaderSource.macros) {
            var _mergedMacros;
            (_mergedMacros = mergedMacros).push.apply(_mergedMacros, [].concat(shaderSource.macros));
        }
        if (macros) {
            var _mergedMacros1;
            (_mergedMacros1 = mergedMacros).push.apply(_mergedMacros1, [].concat(macros));
        }
        var shaderWithMacros = _extends({}, shaderSource, {
            vertex: ShaderFactory.genFinalShaderCode({
                level: this.engine.gpuCapability.level,
                shaderType: exports.ShaderType.vertex,
                shader: shaderSource.vertex,
                macros: mergedMacros
            }),
            fragment: ShaderFactory.genFinalShaderCode({
                level: this.engine.gpuCapability.level,
                shaderType: exports.ShaderType.fragment,
                shader: shaderSource.fragment,
                macros: mergedMacros
            })
        });
        var shaderCacheId = this.computeShaderCacheId(shaderWithMacros);
        if (this.cachedShaders[shaderCacheId]) {
            return shaderCacheId;
        }
        this.shaderAllDone = false;
        var shared = false;
        if (shaderWithMacros.shared || shaderWithMacros.cacheId) {
            shared = true;
        }
        this.cachedShaders[shaderCacheId] = new GLShaderVariant(this.engine, _extends({}, shaderWithMacros, {
            vertex: shaderWithMacros.vertex,
            fragment: shaderWithMacros.fragment,
            name: shaderWithMacros.name || shaderCacheId,
            shared: shared
        }));
        this.cachedShaders[shaderCacheId].id = shaderCacheId;
        return shaderCacheId;
    };
    _proto.createShader = function createShader(shaderSource, macros) {
        var shaderCacheId = this.addShader(shaderSource, macros);
        return this.cachedShaders[shaderCacheId];
    };
    _proto.compileShader = function compileShader(shader, asyncCallback) {
        var _this = this;
        var _shader_source = shader.source, sourceShared = _shader_source.shared, vertex = _shader_source.vertex, fragment = _shader_source.fragment, name = _shader_source.name;
        var cacheId = shader.source.cacheId;
        var shared = false;
        if (sourceShared || cacheId) {
            shared = true;
        }
        var gl = this.pipelineContext.gl;
        var result = {
            shared: shared,
            status: exports.ShaderCompileResultStatus.compiling
        };
        var linkProgram = this.createProgram(gl, vertex, fragment, result);
        var ext = this.glAsyncCompileExt;
        var startTime = douyin.performance.now();
        var setupProgram = function(glProgram) {
            result.status = exports.ShaderCompileResultStatus.success;
            result.compileTime = douyin.performance.now() - startTime;
            shader.program = glProgram;
            shader.initialized = true;
            shader.pipelineContext = _this.pipelineContext;
            if (_this.programMap[shader.id] !== undefined) {
                console.warn("Find duplicated shader id: " + shader.id + ".");
            }
            _this.programMap[shader.id] = glProgram;
        };
        var checkComplete = function() {
            if (_this.engine.isDestroyed) {
                console.warn("The player is destroyed during the loadScene process. Please check the timing of calling loadScene and dispose. A common situation is that when calling loadScene, await is not added. This will cause dispose to be called before loadScene is completed.");
                return;
            }
            var shouldLink = !asyncCallback || !ext || ext && gl.getProgramParameter(result.program, ext.COMPLETION_STATUS_KHR) == true;
            var program = shouldLink && linkProgram();
            if (program) {
                if (result.status !== exports.ShaderCompileResultStatus.fail) {
                    assignInspectorName(program, name);
                    var glProgram = new GLProgram(_this.engine, program, shader.id);
                    // FIXME: 这个检测不能在这里调用，安卓上会有兼容性问题。要么开发版使用，要么移到Shader首次使用时
                    gl.validateProgram(program);
                    var valid = gl.getProgramParameter(program, gl.VALIDATE_STATUS);
                    if (!valid) {
                        var error = gl.getProgramInfoLog(program);
                        var err0 = "the same texture";
                        if (error == null ? void 0 : error.includes(err0)) {
                            // 忽略这类错误
                            setupProgram(glProgram);
                        } else {
                            result.status = exports.ShaderCompileResultStatus.fail;
                            result.error = error;
                            console.error("compileProgramError: " + error, "\nvertex:\n", vertex, "\nfragment:\n", fragment);
                            gl.deleteProgram(program);
                        }
                    } else {
                        setupProgram(glProgram);
                    }
                }
                if (asyncCallback) {
                    asyncCallback(result);
                }
            } else if (asyncCallback) {
                douyin.requestAnimationFrame(checkComplete);
            }
        };
        shader.compileResult = result;
        checkComplete();
    };
    _proto.computeShaderCacheId = function computeShaderCacheId(shader) {
        var _shader_vertex = shader.vertex, vertex = _shader_vertex === void 0 ? "" : _shader_vertex, _shader_fragment = shader.fragment, fragment = _shader_fragment === void 0 ? "" : _shader_fragment, shared = shader.shared;
        var cacheId = shader.cacheId;
        var shaderCacheId;
        // let shared = false;
        if (shared || cacheId) {
            // FIXME: string-hash有冲突，这里先用strHashCode替代
            shaderCacheId = cacheId || "shared_" + strHashCode(vertex, fragment);
        // shared = true;
        } else {
            shaderCacheId = "instanced_" + shaderSeed++;
        }
        return shaderCacheId;
    };
    _proto.createProgram = function createProgram(gl, vs, fs, result) {
        var program = gl.createProgram();
        var vertexShader = this.createGLShader(gl, gl.VERTEX_SHADER, vs);
        var fragShader = this.createGLShader(gl, gl.FRAGMENT_SHADER, fs);
        if (program && vertexShader && fragShader) {
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            result.program = program;
            result.status = exports.ShaderCompileResultStatus.compiling;
            return function() {
                result.program = undefined;
                var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
                if (!linked) {
                    // 链接失败，获取并打印错误信息
                    var info = gl.getProgramInfoLog(program);
                    console.error("Failed to link program: " + info + ".");
                    var vsCheckResult = checkShader(gl, vertexShader, "vertex", vs);
                    var fsCheckResult = checkShader(gl, fragShader, "fragment", fs);
                    result.status = exports.ShaderCompileResultStatus.fail;
                    if (vsCheckResult) {
                        result.error = vsCheckResult.error;
                        result.status = vsCheckResult.status;
                    }
                    if (fsCheckResult) {
                        result.error = fsCheckResult.error;
                        result.status = fsCheckResult.status;
                    }
                    return program;
                }
                return program;
            };
        }
        result.status = exports.ShaderCompileResultStatus.fail;
        return function() {
            return null;
        };
    };
    _proto.createGLShader = function createGLShader(gl, shaderType, code) {
        var map = shaderType === gl.VERTEX_SHADER ? this.glVertShaderMap : this.glFragShaderMap;
        var strHash = stringHash(code != null ? code : "");
        var ret = map.get(strHash);
        if (ret) {
            return ret;
        }
        var shader = gl.createShader(shaderType);
        if (shader) {
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            map.set(strHash, shader);
        }
        return shader;
    };
    _proto.deleteShader = function deleteShader(cacheId) {
        var program = this.programMap[cacheId];
        if (program !== undefined) {
            program.dispose();
            delete this.programMap[cacheId];
        }
        var result = this.shaderResults[cacheId];
        if (result !== undefined) {
            delete this.shaderResults[cacheId];
        }
    };
    _proto.restore = function restore() {
    // TODO
    };
    _proto.dispose = function dispose() {
        var _this = this;
        Object.keys(this.programMap).forEach(function(key) {
            var program = _this.programMap[key];
            program.dispose();
        });
        this.programMap = {};
        if (this.pipelineContext) {
            var gl = this.pipelineContext.gl;
            this.glFragShaderMap.forEach(function(shader) {
                gl.deleteShader(shader);
            });
            this.glVertShaderMap.forEach(function(shader) {
                gl.deleteShader(shader);
            });
            this.glVertShaderMap = new Map();
            this.glFragShaderMap = new Map();
        }
    };
    return GLShaderLibrary;
}();
function checkShader(gl, shader, type, code) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var error = gl.getShaderInfoLog(shader);
        console.error("compile " + type + " error: " + error, (code != null ? code : "").split("\n").map(function(line, index) {
            return index + 1 + " " + line;
        }).join("\n"));
        return {
            error: error,
            status: exports.ShaderCompileResultStatus.fail
        };
    }
}
function strHashCode() {
    for(var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++){
        strings[_key] = arguments[_key];
    }
    var h = 0;
    for(var j = 0; j < arguments.length; j++){
        var s = strings[j];
        for(var i = 0; i < s.length; i++){
            h = Math.imul(31, h) + s.charCodeAt(i) | 0;
        }
    }
    return h;
}

var GLPipelineContext = /*#__PURE__*/ function() {
    function GLPipelineContext(engine, gl) {
        this.engine = engine;
        this.gl = gl;
        this.gl = gl;
        this.shaderLibrary = new GLShaderLibrary(engine, this);
        this.maxTextureCount = this.gl.TEXTURE0 + this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS) - 1;
        this.reset();
    }
    var _proto = GLPipelineContext.prototype;
    _proto.dispose = function dispose() {
        this.shaderLibrary.dispose();
        this.reset();
    };
    _proto.reset = function reset() {
        this.glCapabilityCache = {};
        this.activeTextureIndex = glContext.TEXTURE0;
        this.textureUnitDict = {};
        this.currentFramebuffer = {};
        this.pixelStorei = {};
        this.currentRenderbuffer = {};
    };
    _proto.toggle = function toggle(capability, enable) {
        if (enable) {
            this.enable(capability);
        } else {
            this.disable(capability);
        }
    };
    /**
   * 对于该上下文开启某种特性
   * @param capability
   * example:
   * gl.enable(gl.DITHER);
   */ _proto.enable = function enable(capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== true) {
            this.glCapabilityCache[capability] = true;
            this.gl.enable(capability);
        }
    };
    /**
   * 基于某种上下文关闭特性
   * @param capability
   * example:
   * gl.disable(gl.DITHER);
   */ _proto.disable = function disable(capability) {
        var value = this.glCapabilityCache[capability];
        if (value !== false) {
            this.glCapabilityCache[capability] = false;
            this.gl.disable(capability);
        }
    };
    /**
   * 绑定framebuffer webgl2新增: gl.DRAW_FRAMEBUFFER 和 gl.READ_FRAMEBUFFER
   * @param target
   * @param framebuffer
   * example:
   * const framebuffer = gl.createFramebuffer();
   * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
   */ _proto.bindFramebuffer = function bindFramebuffer(target, framebuffer) {
        if (this.currentFramebuffer[target] !== framebuffer) {
            this.currentFramebuffer[target] = framebuffer;
            this.gl.bindFramebuffer(target, framebuffer);
        }
    };
    _proto.bindRenderbuffer = function bindRenderbuffer(target, renderbuffer) {
        if (this.currentRenderbuffer[target] !== renderbuffer) {
            this.currentRenderbuffer[target] = renderbuffer;
            this.gl.bindRenderbuffer(target, renderbuffer);
        }
    };
    /**
   * 绑定系统 framebuffer
   */ _proto.bindSystemFramebuffer = function bindSystemFramebuffer() {
        this.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    };
    /**
   * 将定义好的 WebGLProgram 对象添加到当前的渲染状态中。
   * @param program
   * example:
   * gl.useProgram(program);
   * gl.useProgram(null);
   */ _proto.useProgram = function useProgram(program) {
        this.set1("useProgram", program);
    };
    /**
   * 使用预设值来清空缓冲
   * @param mask
   * example:
   * gl.clear(gl.DEPTH_BUFFER_BIT);
   * gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
   */ _proto.clear = function clear(mask) {
        this.gl.clear(mask);
    };
    /*** depth start ***/ /**
   * 设置深度缓冲区的深度清除值
   * @param depth
   * example:
   * gl.clearDepth(0.5);
   */ _proto.clearDepth = function clearDepth(depth) {
        this.set1("clearDepth", depth);
    };
    /**
   * 指定将输入像素深度与当前深度缓冲区值进行比较的函数。
   * @param func
   * example:
   * gl.enable(gl.DEPTH_TEST);
   * gl.depthFunc(gl.NEVER);
   */ _proto.depthFunc = function depthFunc(func) {
        this.set1("depthFunc", func);
    };
    /**
   * 设置是否启用写入深度缓冲。
   * @param flag
   * example:
   * gl.depthMask(false);
   */ _proto.depthMask = function depthMask(flag) {
        this.set1("depthMask", flag);
    };
    _proto.polygonOffset = function polygonOffset(factor, unit) {
        this.set2("polygonOffset", factor, unit);
    };
    /**
   * 将 z 值从规范化设备坐标映射到窗口坐标
   * @param zNear
   * @param zFar
   * example:
   * gl.depthRange(0.2, 0.6);
   */ _proto.depthRange = function depthRange(zNear, zFar) {
        this.set2("depthRange", zNear, zFar);
    };
    /*** depth end ***/ /*** stencil start ***/ /**
   * 模版测试设置函数和引用值。
   * @param func
   * @param ref
   * @param mask
   * example:
   * gl.enable(gl.STENCIL_TEST);
   * gl.stencilFunc(gl.LESS, 0, 0b1110011);
   */ _proto.clearStencil = function clearStencil(s) {
        this.set1("clearStencil", s);
    };
    /**
   * 控制启用和禁用模板平面中单个位的正面和背面写入
   * @param mask
   * example:
   * gl.stencilMask(0xff);
   */ _proto.stencilMask = function stencilMask(mask) {
        this.stencilMaskSeparate(this.gl.FRONT, mask);
        this.stencilMaskSeparate(this.gl.BACK, mask);
    };
    /**
   * 模版测试设置函数和引用值。
   * @param func
   * @param ref
   * @param mask
   * example:
   * gl.enable(gl.STENCIL_TEST);
   * gl.stencilFunc(gl.LESS, 0, 0b1110011);
   */ _proto.stencilFunc = function stencilFunc(func, ref, mask) {
        this.stencilFuncSeparate(this.gl.FRONT, func, ref, mask);
        this.stencilFuncSeparate(this.gl.BACK, func, ref, mask);
    };
    /**
   * 单面模版测试
   * @param face
   * @param func
   * @param ref
   * @param mask
   * example:
   * gl.enable(gl.STENCIL_TEST);
   * gl.stencilFuncSeparate(gl.FRONT, gl.LESS, 0.2, 1110011);
   */ _proto.stencilFuncSeparate = function stencilFuncSeparate(face, func, ref, mask) {
        this.set4("stencilFuncSeparate", face, func, ref, mask);
    };
    /**
   * 单面的mask写入
   * @param face
   * @param mask
   * example:
   * gl.stencilMaskSeparate(gl.FRONT, 110101);
   */ _proto.stencilMaskSeparate = function stencilMaskSeparate(face, mask) {
        this.set2("stencilMaskSeparate", face, mask);
    };
    /**
   * 设置正面和背面模板测试操作
   * @param fail
   * @param zfail
   * @param zpass
   * example:
   * gl.enable(gl.STENCIL_TEST);
   * gl.stencilOp(gl.INCR, gl.DECR, gl.INVERT);
   */ _proto.stencilOp = function stencilOp(fail, zfail, zpass) {
        this.stencilOpSeparate(this.gl.FRONT, fail, zfail, zpass);
        this.stencilOpSeparate(this.gl.BACK, fail, zfail, zpass);
    };
    /**
   * 设置正面和/或背面模板测试操作
   * @param face
   * @param fail
   * @param zfail
   * @param zpass
   * example:
   * gl.enable(gl.STENCIL_TEST);
   * gl.stencilOpSeparate(gl.FRONT, gl.INCR, gl.DECR, gl.INVERT);
   */ _proto.stencilOpSeparate = function stencilOpSeparate(face, fail, zfail, zpass) {
        this.set4("stencilOpSeparate", face, fail, zfail, zpass);
    };
    /*** stencil end ***/ /*** face start ***/ /**
   * 剔除方式
   * @param mode
   * example:
   * gl.enable(gl.CULL_FACE);
   * gl.cullFace(gl.FRONT_AND_BACK);
   */ _proto.cullFace = function cullFace(mode) {
        this.set1("cullFace", mode);
    };
    /**
   * 设置卷绕方向
   * @param mode
   * example:
   * gl.frontFace(gl.CW);
   */ _proto.frontFace = function frontFace(mode) {
        this.set1("frontFace", mode);
    };
    /*** face end ***/ /*** color start ***/ /**
   * 设置颜色写入
   * @param red
   * @param green
   * @param blue
   * @param alpha
   * example:
   * gl.colorMask(true, true, true, false);
   */ _proto.clearColor = function clearColor(red, green, blue, alpha) {
        this.set4("clearColor", red, green, blue, alpha);
    };
    /**
   * 设置颜色写入
   * @param red
   * @param green
   * @param blue
   * @param alpha
   * example:
   * gl.colorMask(true, true, true, false);
   */ _proto.colorMask = function colorMask(red, green, blue, alpha) {
        this.set4("colorMask", red, green, blue, alpha);
    };
    /**
   * 设置源和目标混合因子
   * @param red
   * @param green
   * @param blue
   * @param alpha
   * example:
   * gl.blendColor(0, 0.5, 1, 1);
   */ _proto.blendColor = function blendColor(red, green, blue, alpha) {
        this.set4("blendColor", red, green, blue, alpha);
    };
    /**
   * 用于混合像素算法
   * @param sfactor
   * @param dfactor
   * example:
   * gl.enable(gl.BLEND);
   * gl.blendFunc(gl.SRC_COLOR, gl.DST_COLOR);
   */ _proto.blendFunc = function blendFunc(sfactor, dfactor) {
        this.blendFuncSeparate(sfactor, dfactor, sfactor, dfactor);
    };
    /**
   * 分别设置应用在 RGB 和 Alpha 上的 factor
   * @param srcRGB
   * @param dstRGB
   * @param srcAlpha
   * @param dstAlpha
   * example:
   * gl.enable(gl.BLEND);
   * gl.blendFuncSeparate(gl.SRC_COLOR, gl.DST_COLOR, gl.ONE, gl.ZERO);
   */ _proto.blendFuncSeparate = function blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        this.set4("blendFuncSeparate", srcRGB, dstRGB, srcAlpha, dstAlpha);
    };
    /**
   * 设置混合模式
   * @param mode
   * example:
   * gl.blendEquation(gl.FUNC_ADD);
   * gl.blendEquation(gl.FUNC_SUBTRACT);
   * gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
   */ _proto.blendEquation = function blendEquation(mode) {
        this.set1("blendEquation", mode);
    };
    /**
   * 可以分别对 RGB 和 Alpha 做不同的操作处理
   * @param modeRGB
   * @param modeAlpha
   * example:
   * gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_SUBTRACT);
   */ _proto.blendEquationSeparate = function blendEquationSeparate(modeRGB, modeAlpha) {
        this.set2("blendEquationSeparate", modeRGB, modeAlpha);
    };
    /*** color end ***/ /**
   * 图像预处理
   * @param pname
   * @param param
   * example:
   * var tex = gl.createTexture();
   * gl.bindTexture(gl.TEXTURE_2D, tex);
   * gl.pixelStorei(gl.PACK_ALIGNMENT, 4);
   */ _proto.setPixelStorei = function setPixelStorei(pname, param) {
        var currentParam = this.pixelStorei[pname];
        if (currentParam !== param) {
            this.pixelStorei[pname] = param;
            this.gl.pixelStorei(pname, param);
        }
    };
    /**
   * 用来设置视口，即指定从标准设备到窗口坐标的x、y仿射变换。
   * @param x
   * @param y
   * @param width
   * @param height
   * example:
   * gl.viewport(0, 0, width, height);
   */ _proto.viewport = function viewport(x, y, width, height) {
        this.set4("viewport", x, y, width, height);
    };
    /**
   * 激活指定的纹理单元
   * @param texture
   * example:
   * gl.activeTexture(gl.TEXTURE1);
   */ _proto.activeTexture = function activeTexture(texture) {
        texture = Math.min(texture, this.maxTextureCount);
        if (this.activeTextureIndex !== texture) {
            this.activeTextureIndex = texture;
            this.gl.activeTexture(texture);
        }
    };
    /**
   * 绑定WebGLTexture
   * @param target
   * @param texture
   * @param force
   * example:
   * const texture = gl.createTexture();
   * gl.bindTexture(gl.TEXTURE_2D, texture)
   */ // TODO: texture.bind 替换时对于这段逻辑的处理
    _proto.bindTexture = function bindTexture(target, texture, force) {
        if (this.currentTextureBinding !== texture || force) {
            this.gl.bindTexture(target, texture);
            this.currentTextureBinding = texture;
        }
        this.textureUnitDict[this.activeTextureIndex] = texture;
    };
    _proto.set1 = function set1(name, param) {
        var value = this.glCapabilityCache[name];
        if (value !== param) {
            this.glCapabilityCache[name] = param;
            // @ts-expect-error save to assign
            this.gl[name](param);
        }
    };
    _proto.set2 = function set2(name, param0, param1) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = {
                x: NaN,
                y: NaN
            };
        }
        if (value.x !== param0 || value.y !== param1) {
            // @ts-expect-error save to assign
            this.gl[name](value.x = param0, value.y = param1);
        }
    };
    _proto.set3 = function set3(name, param0, param1, param2) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = {
                x: NaN,
                y: NaN,
                z: NaN
            };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2);
        }
    };
    _proto.set4 = function set4(name, param0, param1, param2, param3) {
        var value = this.glCapabilityCache[name];
        if (!value) {
            value = this.glCapabilityCache[name] = {
                x: NaN,
                y: NaN,
                z: NaN,
                w: NaN
            };
        }
        if (value.x !== param0 || value.y !== param1 || value.z !== param2 || value.w !== param3) {
            // @ts-expect-error safe to assign
            this.gl[name](value.x = param0, value.y = param1, value.z = param2, value.w = param3);
        }
    };
    // TODO 命名
    _proto.get = function get(name) {
        return this.glCapabilityCache[name];
    };
    _proto.setFloat = function setFloat(uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1f(uniform, value);
    };
    _proto.setInt = function setInt(uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1i(uniform, value);
    };
    _proto.setFloats = function setFloats(uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniform1fv(uniform, value);
    };
    _proto.setVector2 = function setVector2(uniform, value) {
        this.setFloat2(uniform, value.x, value.y);
    };
    _proto.setVector3 = function setVector3(uniform, value) {
        this.setFloat3(uniform, value.x, value.y, value.z);
    };
    _proto.setVector4 = function setVector4(uniform, value) {
        this.setFloat4(uniform, value.x, value.y, value.z, value.w);
    };
    _proto.setColor = function setColor(uniform, value) {
        this.setFloat4(uniform, value.r, value.g, value.b, value.a);
    };
    _proto.setQuaternion = function setQuaternion(uniform, value) {
        this.setFloat4(uniform, value.x, value.y, value.z, value.w);
    };
    _proto.setVector4Array = function setVector4Array(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
            return;
        }
        this.gl.uniform4fv(uniform, array);
    };
    _proto.setMatrix = function setMatrix(uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, value.elements);
    };
    _proto.setMatrix3 = function setMatrix3(uniform, value) {
        if (!uniform) {
            return;
        }
        this.gl.uniformMatrix3fv(uniform, false, value.elements);
    };
    _proto.setMatrixArray = function setMatrixArray(uniform, array) {
        if (!uniform || array.length % 16 !== 0) {
            return;
        }
        this.gl.uniformMatrix4fv(uniform, false, array);
    };
    _proto.setTexture = function setTexture(uniform, channel, texture) {
        if (!uniform) {
            return;
        }
        this.gl.activeTexture(this.gl.TEXTURE0 + channel);
        var target = texture.target;
        this.gl.bindTexture(target, texture.textureBuffer);
        this.gl.uniform1i(uniform, channel);
    };
    /**
   * 查询所有uniform的location。
   * @param program 查询的shader program
   * @param uniformsNames 查询的uniform名称列表
   * @returns
   */ _proto.getUniforms = function getUniforms(program, uniformsNames) {
        var results = [];
        for(var index = 0; index < uniformsNames.length; index++){
            results.push(this.gl.getUniformLocation(program, uniformsNames[index]));
        }
        return results;
    };
    _proto.setFloat4 = function setFloat4(uniform, x, y, z, w) {
        if (!uniform) {
            return;
        }
        this.gl.uniform4f(uniform, x, y, z, w);
    };
    _proto.setFloat3 = function setFloat3(uniform, x, y, z) {
        if (!uniform) {
            return;
        }
        this.gl.uniform3f(uniform, x, y, z);
    };
    _proto.setFloat2 = function setFloat2(uniform, x, y) {
        if (!uniform) {
            return;
        }
        this.gl.uniform2f(uniform, x, y);
    };
    return GLPipelineContext;
}();

var GLRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits(GLRenderer, Renderer);
    function GLRenderer(canvas, framework, renderOptions) {
        var _this;
        _this = Renderer.call(this) || this;
        _this.canvas = canvas;
        _this.temporaryRTs = {};
        var options = _extends({
            preserveDrawingBuffer: undefined,
            alpha: true,
            stencil: true,
            antialias: true,
            depth: true,
            premultipliedAlpha: true
        }, renderOptions);
        _this.context = new GLContextManager(canvas, framework, options);
        var gl = _this.context.gl;
        assertExist(gl);
        // engine 先创建
        _this.engine = new GLEngine(gl);
        _this.engine.renderer = _assert_this_initialized(_this);
        _this.pipelineContext = new GLPipelineContext(_this.engine, gl);
        _this.glRenderer = new GLRendererInternal(_this.engine);
        _this.extension = new ExtWrap(_assert_this_initialized(_this));
        _this.renderingData = {
            // @ts-expect-error
            currentFrame: {}
        };
        _this.framebuffer = new GLFramebuffer({
            storeAction: {},
            viewport: [
                0,
                0,
                _this.width,
                _this.height
            ],
            attachments: [
                new GLTexture(_this.engine, {
                    sourceType: exports.TextureSourceType.framebuffer,
                    data: {
                        width: _this.width,
                        height: _this.height
                    }
                })
            ],
            depthStencilAttachment: {
                storageType: exports.RenderPassAttachmentStorageType.none
            }
        }, _assert_this_initialized(_this));
        return _this;
    }
    var _proto = GLRenderer.prototype;
    _proto.renderRenderFrame = function renderRenderFrame(renderFrame) {
        var _frame_renderer_getShaderLibrary;
        var frame = renderFrame;
        // TODO 需要一个贴图统一初始化的管理类，避免在渲染逻辑代码中初始化。
        // 初始化renderframe的贴图资源
        // if (frame.cachedTextures) {
        //   for (const texture of frame.cachedTextures) {
        //     (texture as GLTexture).initialize(this.pipelineContext);
        //   }
        // }
        if (frame.resource) {
            frame.resource.color_b.initialize();
        }
        frame.emptyTexture.initialize();
        frame.transparentTexture.initialize();
        var passes = frame._renderPasses;
        if (this.isDestroyed) {
            console.error("Renderer is destroyed, target: GLRenderer.");
            return;
        }
        (_frame_renderer_getShaderLibrary = frame.renderer.getShaderLibrary()) == null ? void 0 : _frame_renderer_getShaderLibrary.compileAllShaders();
        this.setFramebuffer(null);
        this.clear(frame.clearAction);
        this.renderingData.currentFrame = frame;
        this.renderingData.currentCamera = frame.camera;
        // 根据 priority 排序 pass
        sortByOrder(passes);
        for(var _iterator = _create_for_of_iterator_helper_loose(passes), _step; !(_step = _iterator()).done;){
            var pass = _step.value;
            var delegate = pass.delegate;
            delegate.willBeginRenderPass == null ? void 0 : delegate.willBeginRenderPass.call(delegate, pass, this.renderingData);
            this.renderRenderPass(pass);
            delegate.didEndRenderPass == null ? void 0 : delegate.didEndRenderPass.call(delegate, pass, this.renderingData);
        }
        for(var _iterator1 = _create_for_of_iterator_helper_loose(passes), _step1; !(_step1 = _iterator1()).done;){
            var pass1 = _step1.value;
            pass1.frameCleanup(this);
        }
    };
    _proto.renderRenderPass = function renderRenderPass(pass) {
        this.renderingData.currentPass = pass;
        // 初始化 pass attachment GPU资源
        pass.initialize(this);
        // 配置当前 renderer 的 RT
        pass.configure(this);
        // 执行当前 pass
        pass.execute(this);
    };
    _proto.renderMeshes = function renderMeshes(meshes) {
        var delegate = this.renderingData.currentPass.delegate;
        for(var _iterator = _create_for_of_iterator_helper_loose(meshes), _step; !(_step = _iterator()).done;){
            var mesh = _step.value;
            delegate.willRenderMesh == null ? void 0 : delegate.willRenderMesh.call(delegate, mesh, this.renderingData);
            mesh.render(this);
            delegate.didRenderMesh == null ? void 0 : delegate.didRenderMesh.call(delegate, mesh, this.renderingData);
        }
    };
    _proto.setGlobalFloat = function setGlobalFloat(name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.floats[name] = value;
    };
    _proto.setGlobalVector4 = function setGlobalVector4(name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.vector4s[name] = value;
    };
    _proto.getGlobalVector4 = function getGlobalVector4(name) {
        return this.renderingData.currentFrame.globalUniforms.vector4s[name];
    };
    _proto.setGlobalInt = function setGlobalInt(name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.ints[name] = value;
    };
    _proto.setGlobalMatrix = function setGlobalMatrix(name, value) {
        this.checkGlobalUniform(name);
        this.renderingData.currentFrame.globalUniforms.matrices[name] = value;
    };
    _proto.drawGeometry = function drawGeometry(geometry, material, subMeshIndex) {
        if (subMeshIndex === void 0) subMeshIndex = 0;
        if (!geometry || !material) {
            return;
        }
        material.initialize();
        geometry.initialize();
        geometry.flush();
        var renderingData = this.renderingData;
        // TODO 后面移到管线相机渲染开始位置
        if (renderingData.currentFrame.globalUniforms) {
            if (renderingData.currentCamera) {
                this.setGlobalMatrix("effects_MatrixInvV", renderingData.currentCamera.getInverseViewMatrix());
                this.setGlobalMatrix("effects_MatrixV", renderingData.currentCamera.getViewMatrix());
                this.setGlobalMatrix("effects_MatrixVP", renderingData.currentCamera.getViewProjectionMatrix());
                this.setGlobalMatrix("_MatrixP", renderingData.currentCamera.getProjectionMatrix());
            }
            // TODO 自定义材质测试代码
            var time = Date.now() % 100000000 * 0.001 * 1;
            var _Time = this.getGlobalVector4("_Time");
            // TODO 待移除
            this.setGlobalFloat("_GlobalTime", time);
            if (!_Time) {
                _Time = new Vector4$1(time / 20, time, time * 2, time * 3);
            }
            this.setGlobalVector4("_Time", _Time.set(time / 20, time, time * 2, time * 3));
        }
        if (renderingData.currentFrame.editorTransform) {
            material.setVector4("uEditorTransform", renderingData.currentFrame.editorTransform);
        }
        try {
            material.use(this, renderingData.currentFrame.globalUniforms);
        } catch (e) {
            console.error(e);
            return;
        }
        this.glRenderer.drawGeometry(geometry, material, subMeshIndex);
    };
    _proto.setFramebuffer = function setFramebuffer(framebuffer) {
        if (framebuffer) {
            this.framebuffer = framebuffer;
            this.framebuffer.bind();
            this.setViewport(framebuffer.viewport[0], framebuffer.viewport[1], framebuffer.viewport[2], framebuffer.viewport[3]);
        } else {
            this.pipelineContext.bindSystemFramebuffer();
            this.setViewport(0, 0, this.getWidth(), this.getHeight());
        }
    };
    _proto.getFramebuffer = function getFramebuffer() {
        return this.framebuffer;
    };
    _proto.getTemporaryRT = function getTemporaryRT(name, width, height, depthBuffer, filter, format) {
        if (this.temporaryRTs[name]) {
            return this.temporaryRTs[name];
        }
        var textureFilter;
        var textureType;
        var depthType = exports.RenderPassAttachmentStorageType.none;
        // TODO 建立Map映射
        if (filter === exports.FilterMode.Linear) {
            textureFilter = glContext.LINEAR;
        } else if (filter === exports.FilterMode.Nearest) {
            textureFilter = glContext.NEAREST;
        }
        if (format === exports.RenderTextureFormat.RGBA32) {
            textureType = glContext.UNSIGNED_BYTE;
        } else if (format === exports.RenderTextureFormat.RGBAHalf) {
            textureType = glContext.HALF_FLOAT;
        }
        if (depthBuffer === 0) {
            depthType = exports.RenderPassAttachmentStorageType.none;
        } else if (depthBuffer === 16) {
            depthType = exports.RenderPassAttachmentStorageType.depth_16_opaque;
        } else if (depthBuffer === 24) {
            depthType = exports.RenderPassAttachmentStorageType.depth_24_stencil_8_texture;
        }
        var colorAttachment = new GLTexture(this.engine, {
            sourceType: exports.TextureSourceType.framebuffer,
            minFilter: textureFilter,
            magFilter: textureFilter,
            internalFormat: glContext.RGBA,
            format: glContext.RGBA,
            type: textureType
        });
        var newFramebuffer = new GLFramebuffer({
            name: name,
            storeAction: {},
            viewport: [
                0,
                0,
                width,
                height
            ],
            viewportScale: 1,
            isCustomViewport: true,
            attachments: [
                colorAttachment
            ],
            depthStencilAttachment: {
                storageType: depthType
            }
        }, this);
        this.temporaryRTs[name] = newFramebuffer;
        return newFramebuffer;
    };
    _proto.setViewport = function setViewport(x, y, width, height) {
        this.pipelineContext.viewport(x, y, width, height);
    };
    _proto.clear = function clear(action) {
        var state = this.pipelineContext;
        var bit = 0;
        if (action.colorAction === exports.TextureLoadAction.clear) {
            var clearColor = action.clearColor;
            if (clearColor) {
                state.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            }
            state.colorMask(true, true, true, true);
            bit = glContext.COLOR_BUFFER_BIT;
        }
        if (action.stencilAction === exports.TextureLoadAction.clear) {
            state.stencilMask(0xff);
            state.clearStencil(action.clearStencil || 0);
            bit = bit | glContext.STENCIL_BUFFER_BIT;
        }
        if (action.depthAction === exports.TextureLoadAction.clear) {
            var depth = action.clearDepth;
            state.depthMask(true);
            state.clearDepth(Number.isFinite(depth) ? depth : 1);
            bit = bit | glContext.DEPTH_BUFFER_BIT;
        }
        if (bit) {
            state.clear(bit);
        }
    };
    _proto.addLostHandler = function addLostHandler(lostHandler) {
        this.context.addLostHandler(lostHandler);
    };
    _proto.addRestoreHandler = function addRestoreHandler(restoreHandler) {
        this.context.addRestoreHandler(restoreHandler);
    };
    _proto.getShaderLibrary = function getShaderLibrary() {
        return this.pipelineContext.shaderLibrary;
    };
    _proto.getWidth = function getWidth() {
        return this.width;
    };
    _proto.getHeight = function getHeight() {
        return this.height;
    };
    _proto.dispose = function dispose() {
        var _this_glRenderer;
        this.context.dispose();
        this.extension.dispose();
        this.pipelineContext.dispose();
        (_this_glRenderer = this.glRenderer) == null ? void 0 : _this_glRenderer.dispose();
        // @ts-expect-error
        this.canvas = null;
        this.engine.dispose();
    };
    _proto.lost = function lost(e) {
        e.preventDefault();
        this.pipelineContext.dispose();
        this.extension.dispose();
        this.glRenderer.lost(e);
    };
    _proto.restore = function restore() {
        // FIXME: 需要测试下lost和restore流程
        var gl = this.context.gl;
        if (!gl) {
            throw new Error("Can not restore automatically because losing gl context.");
        }
        this.engine = new GLEngine(gl);
        this.engine.renderer = this;
        this.pipelineContext = new GLPipelineContext(this.engine, gl);
        this.glRenderer = new GLRendererInternal(this.engine);
        this.extension = new ExtWrap(this);
    };
    _proto.resize = function resize(width, height) {
        var internal = this.glRenderer;
        if (internal) {
            if (this.width !== width || this.height !== height) {
                internal.resize(width, height);
            }
        }
    };
    _proto.checkGlobalUniform = function checkGlobalUniform(name) {
        var globalUniforms = this.renderingData.currentFrame.globalUniforms;
        if (!globalUniforms.uniforms.includes(name)) {
            globalUniforms.uniforms.push(name);
        }
    };
    _create_class(GLRenderer, [
        {
            key: "isDestroyed",
            get: function get() {
                var internal = this.glRenderer;
                return internal ? internal.isDestroyed : true;
            }
        },
        {
            key: "height",
            get: function get() {
                var _this_glRenderer;
                var _this_glRenderer_height;
                return (_this_glRenderer_height = (_this_glRenderer = this.glRenderer) == null ? void 0 : _this_glRenderer.height) != null ? _this_glRenderer_height : 0;
            }
        },
        {
            key: "width",
            get: function get() {
                var _this_glRenderer;
                var _this_glRenderer_width;
                return (_this_glRenderer_width = (_this_glRenderer = this.glRenderer) == null ? void 0 : _this_glRenderer.width) != null ? _this_glRenderer_width : 0;
            }
        }
    ]);
    return GLRenderer;
}(Renderer);

var HELP_LINK = {
    "Container size overflowed": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#MvjnY",
    "DPI overflowed": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#ulfNT",
    "Invalid container size": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#lLlSW",
    "Container is not an HTMLElement": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#WZaWg",
    "Never use destroyed player again": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#YSWQr",
    "Current running player count": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#IzodZ",
    "Create player with different WebGL version": "https://galacean.antgroup.com/effects/user/gasrv4ka5sacrwpg#X0ulg"
};

function isDowngradeIOS() {
    var iOSVersionRegex = /iPhone OS (\d+)_(\d+)/;
    var match = iOSVersionRegex.exec(douyin.navigator.userAgent);
    if (match) {
        return match[1] === "13" || match[1] === "16" && match[2] === "5";
    }
    return false;
}
function throwError(destroyedErrorMessage) {
    throw new Error(destroyedErrorMessage);
}
function throwErrorPromise(destroyedErrorMessage) {
    return Promise.reject(destroyedErrorMessage);
}

var playerMap = new Map();
var enableDebugType = false;
var seed = 1;
/**
 * Galacean Effects 播放器
 */ var Player = /*#__PURE__*/ function(EventEmitter) {
    _inherits(Player, EventEmitter);
    function Player(config) {
        var _this;
        _this = EventEmitter.call(this) || this;
        _this.builtinObjects = [];
        /**
   * 当前播放的合成对象数组，请不要修改内容
   */ _this.compositions = [];
        _this.displayScale = 1;
        _this.resumePending = false;
        _this.disposed = false;
        _this.assetManagers = [];
        _this.speed = 1;
        _this.baseCompositionIndex = 0;
        /**
   * 播放器在 `webglcontextlost` 时执行的操作
   * @param e - Event
   */ _this.lost = function(e) {
            var _this_ticker;
            (_this_ticker = _this.ticker) == null ? void 0 : _this_ticker.pause();
            _this.compositions.forEach(function(comp) {
                return comp.lost(e);
            });
            _this.renderer.lost(e);
            _this.emit("webglcontextlost", e);
            broadcastPlayerEvent(_assert_this_initialized(_this), false);
        };
        var _this1 = _assert_this_initialized(_this);
        /**
   * 播放器在 `webglcontextrestored` 时执行的操作
   * @returns
   */ _this.restore = /*#__PURE__*/ _async_to_generator(function() {
            var _this_ticker;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _this1.renderer.restore();
                        return [
                            4,
                            Promise.all(_this1.compositions.map(/*#__PURE__*/ _async_to_generator(function(composition) {
                                var currentTime, url, speed, keepResource, reusable, renderOrder, transform, videoState, newComposition, i, video, _videoState_i;
                                return __generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            currentTime = composition.time, url = composition.url, speed = composition.speed, keepResource = composition.keepResource, reusable = composition.reusable, renderOrder = composition.renderOrder, transform = composition.transform, videoState = composition.videoState;
                                            return [
                                                4,
                                                _this1.loadScene(url)
                                            ];
                                        case 1:
                                            newComposition = _state.sent();
                                            newComposition.speed = speed;
                                            newComposition.reusable = reusable;
                                            newComposition.keepResource = keepResource;
                                            newComposition.renderOrder = renderOrder;
                                            newComposition.transform.setPosition(transform.position.x, transform.position.y, transform.position.z);
                                            newComposition.transform.setRotation(transform.rotation.x, transform.rotation.y, transform.rotation.z);
                                            newComposition.transform.setScale(transform.scale.x, transform.scale.y, transform.scale.z);
                                            i = 0;
                                            _state.label = 2;
                                        case 2:
                                            if (!(i < videoState.length)) return [
                                                3,
                                                5
                                            ];
                                            if (!videoState[i]) return [
                                                3,
                                                4
                                            ];
                                            video = newComposition.textures[i].source.video;
                                            video.currentTime = (_videoState_i = videoState[i]) != null ? _videoState_i : 0;
                                            return [
                                                4,
                                                video.play()
                                            ];
                                        case 3:
                                            _state.sent();
                                            _state.label = 4;
                                        case 4:
                                            i++;
                                            return [
                                                3,
                                                2
                                            ];
                                        case 5:
                                            newComposition.rootItem.ended = false;
                                            newComposition.gotoAndPlay(currentTime);
                                            return [
                                                2,
                                                newComposition
                                            ];
                                    }
                                });
                            })))
                        ];
                    case 1:
                        _this1.compositions = _state.sent();
                        _this1.emit("webglcontextrestored");
                        (_this_ticker = _this1.ticker) == null ? void 0 : _this_ticker.resume();
                        if (isIOS() && _this1.canvas) {
                            _this1.canvas.style.display = "none";
                            douyin.window.setTimeout(function() {
                                _this1.canvas.style.display = "";
                            }, 0);
                        }
                        return [
                            2
                        ];
                }
            });
        });
        _this.handleResume = function() {
            _this.emit("update", {
                player: _assert_this_initialized(_this),
                playing: true
            });
        };
        _this.handleClick = function(e) {
            var x = e.x, y = e.y;
            _this.compositions.forEach(function(composition) {
                var regions = composition.hitTest(x, y);
                if (regions.length) {
                    for(var i = 0; i < regions.length; i++){
                        var behavior = regions[i].behavior || InteractBehavior.NOTIFY;
                        if (behavior === InteractBehavior.NOTIFY) {
                            _this.emit("click", _extends({}, regions[i], {
                                compositionId: composition.id,
                                compositionName: composition.name,
                                player: _assert_this_initialized(_this)
                            }));
                            composition.emit("click", _extends({}, regions[i], {
                                compositionId: composition.id,
                                compositionName: composition.name
                            }));
                        } else if (behavior === InteractBehavior.RESUME_PLAYER) {
                            void _this.resume();
                        }
                    }
                }
            });
        };
        var container = config.container, canvas = config.canvas, fps = config.fps, name = config.name, pixelRatio = config.pixelRatio, manualRender = config.manualRender, reportGPUTime = config.reportGPUTime, glType = config.renderFramework, notifyTouch = config.notifyTouch, _config_interactive = config.interactive, interactive = _config_interactive === void 0 ? false : _config_interactive, _config_renderOptions = config.renderOptions, renderOptions = _config_renderOptions === void 0 ? {} : _config_renderOptions, _config_env = config.env, env = _config_env === void 0 ? "" : _config_env;
        var preserveDrawingBuffer = renderOptions.willCaptureImage, premultipliedAlpha = renderOptions.premultipliedAlpha;
        if (initErrors.length) {
            throw new Error("Errors before player create: " + initErrors.map(function(message, index) {
                return "\n " + (index + 1) + ": " + message;
            }) + ".");
        }
        // 原 debug-disable 直接返回
        if (enableDebugType || glType === "debug-disable") {
            return _possible_constructor_return(_this);
        }
        // 注意：安卓设备和 iOS 13/iOS 16.5 在 WebGL2 下有渲染或卡顿问题，故默认使用 WebGL1
        var framework = isAndroid() || isDowngradeIOS() ? "webgl" : "webgl2";
        // 用户可以通过传入 renderFramework，手动强制使用 WebGL 1/2 来渲染
        if (glType) {
            framework = glType === "webgl" ? "webgl" : "webgl2";
        }
        _this.reportGPUTime = reportGPUTime;
        _this.pixelRatio = Number.isFinite(pixelRatio) ? pixelRatio : getPixelRatio();
        _this.offscreenMode = true;
        _this.env = env;
        _this.name = name || "" + seed++;
        if (canvas) {
            _this.canvas = canvas;
        } else {
            assertContainer(container);
            _this.canvas = douyin.document.createElement("canvas");
            container.appendChild(_this.canvas);
        }
        _this.container = _this.canvas.parentElement;
        _this.renderer = Renderer.create(_this.canvas, framework, {
            preserveDrawingBuffer: preserveDrawingBuffer,
            premultipliedAlpha: premultipliedAlpha
        });
        _this.renderer.env = env;
        _this.renderer.addLostHandler({
            lost: _this.lost
        });
        _this.renderer.addRestoreHandler({
            restore: _this.restore
        });
        _this.gpuCapability = _this.renderer.engine.gpuCapability;
        _this.builtinObjects.push(generateWhiteTexture(_this.renderer.engine));
        // 如果存在 WebGL 和 WebGL2 的 Player，需要给出警告
        playerMap.forEach(function(player) {
            if (player.gpuCapability.type !== _this.gpuCapability.type) {
                logger.warn("Create player with different WebGL version: old=" + player.gpuCapability.type + ", new=" + _this.gpuCapability.type + ".\nsee " + HELP_LINK["Create player with different WebGL version"] + ".");
            }
        });
        if (!manualRender) {
            _this.ticker = new Ticker(fps);
            _this.ticker.add(_this.tick.bind(_assert_this_initialized(_this)));
        }
        _this.event = new EventSystem(_this.canvas, !!notifyTouch);
        _this.event.bindListeners();
        _this.event.addEventListener(EVENT_TYPE_CLICK, _this.handleClick);
        _this.interactive = interactive;
        _this.resize();
        setSpriteMeshMaxItemCountByGPU(_this.gpuCapability.detail);
        playerMap.set(_this.canvas, _assert_this_initialized(_this));
        assertNoConcurrentPlayers();
        broadcastPlayerEvent(_assert_this_initialized(_this), true);
        return _this;
    }
    var _proto = Player.prototype;
    /**
   * 设置当前 Player 的播放速度
   * @param speed - 播放速度
   */ _proto.setSpeed = function setSpeed(speed) {
        if (!isNaN(speed)) {
            this.speed = speed;
        }
    };
    /**
   * 获取当前 Player 的播放速度
   * @returns
   */ _proto.getSpeed = function getSpeed() {
        return this.speed;
    };
    /**
   * 根据名称查找对应的合成（可能找不到，如果有同名的合成，默认返回第一个）
   * @example
   * ``` ts
   * const composition = player.getCompositionByName('新建合成1');
   * ```
   * @param name - 目标合成名称
   */ _proto.getCompositionByName = function getCompositionByName(name) {
        return this.compositions.find(function(comp) {
            return comp.name === name;
        });
    };
    /**
   * 获取当前播放的所有合成（请不要修改返回的数组内容）
   */ _proto.getCompositions = function getCompositions() {
        return this.compositions;
    };
    _proto.loadScene = function loadScene(scene, options) {
        var _this = this;
        return _async_to_generator(function() {
            var _this_ticker, composition, baseOrder;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        baseOrder = _this.baseCompositionIndex;
                        if (!isArray(scene)) return [
                            3,
                            2
                        ];
                        _this.baseCompositionIndex += scene.length;
                        return [
                            4,
                            Promise.all(scene.map(/*#__PURE__*/ _async_to_generator(function(scn, index) {
                                var res;
                                return __generator(this, function(_state) {
                                    switch(_state.label){
                                        case 0:
                                            return [
                                                4,
                                                _this.createComposition(scn, options)
                                            ];
                                        case 1:
                                            res = _state.sent();
                                            res.setIndex(baseOrder + index);
                                            return [
                                                2,
                                                res
                                            ];
                                    }
                                });
                            })))
                        ];
                    case 1:
                        composition = _state.sent();
                        return [
                            3,
                            4
                        ];
                    case 2:
                        _this.baseCompositionIndex += 1;
                        return [
                            4,
                            _this.createComposition(scene, options)
                        ];
                    case 3:
                        composition = _state.sent();
                        composition.setIndex(baseOrder);
                        _state.label = 4;
                    case 4:
                        (_this_ticker = _this.ticker) == null ? void 0 : _this_ticker.start();
                        return [
                            2,
                            composition
                        ];
                }
            });
        })();
    };
    _proto.createComposition = function createComposition(url, options) {
        if (options === void 0) options = {};
        var _this = this;
        return _async_to_generator(function() {
            var renderer, engine, last, opts, source, assetManager, scene, _iterator, _step, effectsObject, i, composition, _iterator1, _step1, guid, effectsObject1, firstFrameTime;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        renderer = _this.renderer;
                        engine = renderer.engine;
                        last = douyin.performance.now();
                        opts = _extends({
                            autoplay: true
                        }, options);
                        if (isSceneURL(url)) {
                            source = url.url;
                            if (isSceneWithOptions(url)) {
                                opts = _extends({}, opts, url.options);
                            }
                        } else {
                            source = url;
                        }
                        assetManager = new AssetManager(opts);
                        // TODO 多 json 之间目前不共用资源，如果后续需要多 json 共用，这边缓存机制需要额外处理
                        // 在 assetManager.loadScene 前清除，避免 loadScene 创建的 EffectsObject 对象丢失
                        engine.clearResources();
                        _this.assetManagers.push(assetManager);
                        return [
                            4,
                            assetManager.loadScene(source, _this.renderer, {
                                env: _this.env
                            })
                        ];
                    case 1:
                        scene = _state.sent();
                        // 加入 json 资产数据
                        engine.addPackageDatas(scene);
                        // 加入内置引擎对象
                        for(_iterator = _create_for_of_iterator_helper_loose(_this.builtinObjects); !(_step = _iterator()).done;){
                            effectsObject = _step.value;
                            engine.addInstance(effectsObject);
                        }
                        for(i = 0; i < scene.textureOptions.length; i++){
                            scene.textureOptions[i] = _instanceof1(scene.textureOptions[i], Texture) ? scene.textureOptions[i] : engine.assetLoader.loadGUID(scene.textureOptions[i].id);
                            scene.textureOptions[i].initialize();
                        }
                        if (!engine.database) return [
                            3,
                            3
                        ];
                        return [
                            4,
                            engine.createVFXItems(scene)
                        ];
                    case 2:
                        _state.sent();
                        _state.label = 3;
                    case 3:
                        // 加载期间 player 销毁
                        if (_this.disposed) {
                            throw new Error("Disposed player can not used to create Composition.");
                        }
                        composition = new Composition(_extends({}, opts, {
                            renderer: renderer,
                            width: renderer.getWidth(),
                            height: renderer.getHeight(),
                            event: _this.event,
                            handleItemMessage: function(message) {
                                _this.emit("message", message);
                            }
                        }), scene);
                        _this.compositions.push(composition);
                        // 中低端设备降帧到 30fps
                        if (_this.ticker) {
                            if (opts.renderLevel === RenderLevel.B) {
                                _this.ticker.setFPS(Math.min(_this.ticker.getFPS(), 30));
                            }
                        }
                        // TODO 目前编辑器会每帧调用 loadScene, 在这编译会导致闪帧，待编辑器渲染逻辑优化后移除。
                        if (_this.env !== PLAYER_OPTIONS_ENV_EDITOR) {
                            // TODO Material 单独存表, 加速查询
                            for(_iterator1 = _create_for_of_iterator_helper_loose(Object.keys(_this.renderer.engine.objectInstance)); !(_step1 = _iterator1()).done;){
                                guid = _step1.value;
                                effectsObject1 = _this.renderer.engine.objectInstance[guid];
                                if (_instanceof1(effectsObject1, Material)) {
                                    effectsObject1.createShaderVariant();
                                }
                            }
                        }
                        return [
                            4,
                            new Promise(function(resolve) {
                                var _this_renderer_getShaderLibrary;
                                (_this_renderer_getShaderLibrary = _this.renderer.getShaderLibrary()) == null ? void 0 : _this_renderer_getShaderLibrary.compileAllShaders(function() {
                                    resolve(null);
                                });
                            })
                        ];
                    case 4:
                        _state.sent();
                        if (opts.autoplay) {
                            _this.autoPlaying = true;
                            composition.play();
                        } else {
                            composition.pause();
                        }
                        firstFrameTime = douyin.performance.now() - last + composition.statistic.loadTime;
                        composition.statistic.firstFrameTime = firstFrameTime;
                        logger.info("First frame: [" + composition.name + "]" + firstFrameTime.toFixed(4) + "ms.");
                        return [
                            2,
                            composition
                        ];
                }
            });
        })();
    };
    /**
   * 播放通过 player 加载好的全部合成
   */ _proto.play = function play() {
        var _this_ticker;
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = true;
        this.compositions.map(function(composition) {
            composition.play();
        });
        (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.start();
    };
    /**
   * 跳转全部合成到指定时间后播放
   * @param time - 指定时间, 单位秒
   */ _proto.gotoAndPlay = function gotoAndPlay(time) {
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = true;
        this.compositions.map(function(composition) {
            composition.gotoAndPlay(time);
        });
        if (this.ticker) {
            this.ticker.start();
        } else {
            this.doTick(0, true);
        }
    };
    /**
   * 跳转全部合成到指定时间并停留
   * @param time - 指定时间, 单位秒
   */ _proto.gotoAndStop = function gotoAndStop(time) {
        var _this_ticker;
        if (this.offscreenMode) {
            this.resize();
            this.offscreenMode = false;
        }
        this.autoPlaying = false;
        this.compositions.map(function(composition) {
            composition.gotoAndStop(time);
        });
        if (!this.ticker || ((_this_ticker = this.ticker) == null ? void 0 : _this_ticker.getPaused())) {
            this.doTick(0, true);
        }
        this.emit("update", {
            player: this,
            playing: false
        });
    };
    /**
   * 顺序播放一组还未开始播放的合成
   * @param compositions - 要播放的合成数组
   */ _proto.playSequence = function playSequence(compositions) {
        var _loop = function(i) {
            compositions[i].on("end", function() {
                compositions[i + 1].play();
            });
        };
        var _this_ticker;
        for(var i = 0; i < compositions.length - 1; i++)_loop(i);
        compositions[0].play();
        (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.start();
    };
    /**
   * 暂停播放器
   * @param options
   * @param options.offloadTexture - 是否卸载贴图纹理，减少内存
   * @returns
   */ _proto.pause = function pause(options) {
        var _this_ticker;
        if (this.paused) {
            return;
        }
        (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.pause();
        this.emit("update", {
            player: this,
            playing: false
        });
        if (options && options.offloadTexture) {
            this.offloadTexture();
        }
    };
    /**
   * 恢复播放器
   * > 如果暂停时卸载了纹理贴图，此函数将自动请求网络重新加载纹理
   * @returns
   */ _proto.resume = function resume() {
        var _this = this;
        return _async_to_generator(function() {
            var _this_ticker;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (_this.resumePending) {
                            return [
                                2
                            ];
                        }
                        if (!_this.paused) return [
                            3,
                            2
                        ];
                        _this.resumePending = true;
                        return [
                            4,
                            Promise.all(_this.compositions.map(function(c) {
                                return c.reloadTexture();
                            }))
                        ];
                    case 1:
                        _state.sent();
                        _this.resumePending = false;
                        _this.handleResume();
                        _state.label = 2;
                    case 2:
                        (_this_ticker = _this.ticker) == null ? void 0 : _this_ticker.resume();
                        return [
                            2
                        ];
                }
            });
        })();
    };
    /**
   * player 在定时器每帧的回调
   * @param dt - 时间差，毫秒
   */ _proto.tick = function tick(dt) {
        this.doTick(dt, this.forceRenderNextFrame);
        this.forceRenderNextFrame = false;
    };
    _proto.doTick = function doTick(dt, forceRender) {
        var _this = this;
        var renderErrors = this.renderer.engine.renderErrors;
        renderErrors.values().next().value;
        if (renderErrors.size > 0) {
            var // 有渲染错误时暂停播放
            _this_ticker;
            this.emit("rendererror", renderErrors.values().next().value);
            (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.pause();
        }
        dt = Math.min(dt, 33) * this.speed;
        var comps = this.compositions;
        var skipRender = false;
        comps.sort(function(a, b) {
            return a.getIndex() - b.getIndex();
        });
        var currentCompositions = [];
        for(var i = 0; i < comps.length; i++){
            var composition = comps[i];
            if (composition.textureOffloaded) {
                skipRender = true;
                logger.error("Composition " + composition.name + " texture offloaded, skip render.");
                currentCompositions.push(composition);
                continue;
            }
            if (!composition.isDestroyed && composition.renderer) {
                composition.update(dt);
            }
            if (!composition.isDestroyed) {
                currentCompositions.push(composition);
            }
        }
        this.compositions = currentCompositions;
        this.baseCompositionIndex = this.compositions.length;
        if (skipRender) {
            var _this_ticker1;
            this.emit("rendererror", new Error("Play when texture offloaded."));
            return (_this_ticker1 = this.ticker) == null ? void 0 : _this_ticker1.pause();
        }
        if (!this.paused || forceRender) {
            var level = this.gpuCapability.level;
            var gl = this.renderer.context.gl;
            var time = level === 2 && this.reportGPUTime ? gpuTimer(gl) : undefined;
            time == null ? void 0 : time.begin();
            if (this.compositions.length || this.compositions.length < comps.length || forceRender) {
                this.renderer.setFramebuffer(null);
                this.renderer.clear({
                    stencilAction: exports.TextureLoadAction.clear,
                    clearStencil: 0,
                    depthAction: exports.TextureLoadAction.clear,
                    clearDepth: 1,
                    colorAction: exports.TextureLoadAction.clear,
                    clearColor: [
                        0,
                        0,
                        0,
                        0
                    ]
                });
                for(var i1 = 0; i1 < comps.length; i1++){
                    !comps[i1].renderFrame.isDestroyed && this.renderer.renderRenderFrame(comps[i1].renderFrame);
                }
            }
            time == null ? void 0 : time.end();
            time == null ? void 0 : time.getTime().then(function(t) {
                return _this.reportGPUTime == null ? void 0 : _this.reportGPUTime.call(_this, t != null ? t : 0);
            }).catch;
            if (this.autoPlaying) {
                this.emit("update", {
                    player: this,
                    playing: true
                });
            }
        }
    };
    /**
   * 调整画布的宽高比
   * @param aspect
   * @param scale
   */ _proto.resizeToAspect = function resizeToAspect(aspect, scale) {
        if (scale === void 0) scale = 1;
        if (aspect !== this.displayAspect) {
            this.displayAspect = aspect;
        }
        if (scale !== this.displayScale) {
            this.displayScale = scale;
        }
        this.resize();
    };
    /**
   * 将播放器重新和父容器大小对齐
   */ _proto.resize = function resize() {
        var parentElement = this.canvas.parentElement;
        var containerWidth;
        var containerHeight;
        var canvasWidth;
        var canvasHeight;
        if (parentElement) {
            var size = this.getTargetSize(parentElement);
            containerWidth = size[0];
            containerHeight = size[1];
            canvasWidth = size[2];
            canvasHeight = size[3];
        } else {
            containerWidth = canvasWidth = this.canvas.width;
            containerHeight = canvasHeight = this.canvas.height;
        }
        var aspect = containerWidth / containerHeight;
        if (containerWidth && containerHeight) {
            var _this_compositions;
            var documentWidth = douyin.document.documentElement.clientWidth;
            if (canvasWidth > documentWidth * 2) {
                logger.error("DPI overflowed, width " + canvasWidth + " is more than 2x document width " + documentWidth + ", see " + HELP_LINK["DPI overflowed"] + ".");
            }
            var maxSize = this.env ? this.gpuCapability.detail.maxTextureSize : 2048;
            if (canvasWidth > maxSize || canvasHeight > maxSize) {
                logger.error("Container size overflowed " + canvasWidth + "x" + canvasHeight + ", see " + HELP_LINK["Container size overflowed"] + ".");
                if (aspect > 1) {
                    canvasWidth = Math.round(maxSize);
                    canvasHeight = Math.round(maxSize / aspect);
                } else {
                    canvasHeight = Math.round(maxSize);
                    canvasWidth = Math.round(maxSize * aspect);
                }
            }
            // ios 14.1 -ios 14.3 resize canvas will cause memory leak
            this.renderer.resize(canvasWidth, canvasHeight);
            this.canvas.style.width = containerWidth + "px";
            this.canvas.style.height = containerHeight + "px";
            logger.info("Resize player " + this.name + " [" + canvasWidth + "," + canvasHeight + "," + containerWidth + "," + containerHeight + "].");
            (_this_compositions = this.compositions) == null ? void 0 : _this_compositions.forEach(function(comp) {
                comp.camera.aspect = aspect;
            });
        }
    };
    /**
   * 清空 canvas 的画面
   * @param immediate - 如果立即清理，当前画面将会消失，如果 player 还有合成在渲染，可能出现闪烁
   */ _proto.clearCanvas = function clearCanvas(immediate) {
        if (immediate) {
            this.renderer.clear({
                stencilAction: exports.TextureLoadAction.clear,
                clearStencil: 0,
                depthAction: exports.TextureLoadAction.clear,
                clearDepth: 1,
                colorAction: exports.TextureLoadAction.clear,
                clearColor: [
                    0,
                    0,
                    0,
                    0
                ]
            });
        } else {
            this.forceRenderNextFrame = true;
        }
    };
    /**
   * 销毁当前播放的所有 Composition
   */ _proto.destroyCurrentCompositions = function destroyCurrentCompositions() {
        this.compositions.forEach(function(comp) {
            return comp.dispose();
        });
        this.compositions.length = 0;
        this.baseCompositionIndex = 0;
    };
    /**
   * 销毁播放器
   * @param keepCanvas - 是否保留 canvas 画面，默认不保留，canvas 不能再被使用
   */ _proto.dispose = function dispose(keepCanvas) {
        var _this_ticker;
        logger.info("Call player destroyed: " + this.name + ".");
        if (this.disposed) {
            return;
        }
        playerMap.delete(this.canvas);
        this.pause();
        (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.stop();
        this.assetManagers.forEach(function(assetManager) {
            return assetManager.dispose();
        });
        this.compositions.forEach(function(comp) {
            return comp.dispose();
        });
        this.compositions.length = 0;
        this.renderer.context.removeLostHandler({
            lost: this.lost
        });
        this.renderer.context.removeRestoreHandler({
            restore: this.restore
        });
        this.event.dispose();
        this.renderer.dispose(!keepCanvas);
        this.destroyBuiltinObjects();
        broadcastPlayerEvent(this, false);
        if (_instanceof1(this.canvas, douyin.HTMLCanvasElement) && !keepCanvas && this.renderer.context) {
            // TODO: 数据模版下掉可以由文本模块单独管理
            canvasPool.dispose();
            // canvas will become a cry emoji in Android if still in dom
            if (this.canvas.parentNode) {
                this.canvas.parentNode.removeChild(this.canvas);
            }
            this.canvas.remove();
        }
        // 在报错函数中传入 player.name
        var errorMsg = getDestroyedErrorMessage(this.name);
        var throwErrorFunc = function() {
            return throwError(errorMsg);
        };
        var throwErrorPromiseFunc = function() {
            return throwErrorPromise(errorMsg);
        };
        this.tick = throwErrorFunc;
        this.resize = throwErrorFunc;
        this.loadScene = throwErrorPromiseFunc;
        this.play = throwErrorPromiseFunc;
        this.gotoAndPlay = throwErrorPromiseFunc;
        this.gotoAndStop = throwErrorPromiseFunc;
        this.playSequence = throwErrorFunc;
        this.destroyCurrentCompositions = throwErrorFunc;
        this.resume = throwErrorPromiseFunc;
        this.disposed = true;
    };
    _proto.offloadTexture = function offloadTexture() {
        this.compositions.forEach(function(comp) {
            return comp.offloadTexture();
        });
    };
    _proto.getTargetSize = function getTargetSize(parentEle) {
        assertContainer(parentEle);
        var displayAspect = this.displayAspect;
        var targetWidth;
        var targetHeight;
        if (displayAspect) {
            var parentAspect = parentEle.clientWidth / parentEle.clientHeight;
            if (parentAspect > displayAspect) {
                targetHeight = parentEle.clientHeight * this.displayScale;
                targetWidth = targetHeight * displayAspect;
            } else {
                targetWidth = parentEle.clientWidth * this.displayScale;
                targetHeight = targetWidth / displayAspect;
            }
        } else {
            targetWidth = parentEle.clientWidth;
            targetHeight = parentEle.clientHeight;
        }
        var ratio = this.pixelRatio;
        var containerWidth = targetWidth;
        var containerHeight = targetHeight;
        targetWidth = Math.round(targetWidth * ratio);
        targetHeight = Math.round(targetHeight * ratio);
        if (targetHeight < 1 || targetHeight < 1) {
            if (this.offscreenMode) {
                targetWidth = targetHeight = containerWidth = containerHeight = 1;
            } else {
                throw new Error("Invalid container size " + targetWidth + "x" + targetHeight + ", see " + HELP_LINK["Invalid container size"] + ".");
            }
        }
        return [
            containerWidth,
            containerHeight,
            targetWidth,
            targetHeight
        ];
    };
    _proto.destroyBuiltinObjects = function destroyBuiltinObjects() {
        for(var _iterator = _create_for_of_iterator_helper_loose(this.builtinObjects), _step; !(_step = _iterator()).done;){
            var effectsObject = _step.value;
            effectsObject.dispose();
        }
        this.builtinObjects.length = 0;
    };
    _create_class(Player, [
        {
            key: "hasPlayable",
            get: /**
   * 是否有合成在播放
   */ function get() {
                return this.compositions.length > 0;
            }
        },
        {
            key: "paused",
            get: /**
   * 播放器是否已暂停
   */ function get() {
                var _this_ticker;
                return (_this_ticker = this.ticker) == null ? void 0 : _this_ticker.getPaused();
            }
        },
        {
            key: "interactive",
            get: /**
   * 获取播放器是否可交互
   */ function get() {
                return this.event.enabled;
            },
            set: /**
   * 设置播放器是否可交互
   */ function set(enable) {
                this.event.enabled = enable;
            }
        }
    ]);
    return Player;
}(EventEmitter);
/**
 * 禁止/允许创建新的播放器，已创建的不受影响
 * @param disable - 是否禁止
 */ function disableAllPlayer(disable) {
    enableDebugType = !!disable;
}
/**
 * 判断指定的 canvas 是否有播放器正在使用
 * @param canvas - 指定的 canvas
 * @returns
 */ function isCanvasUsedByPlayer(canvas) {
    return playerMap.has(canvas);
}
/**
 * 获取 canvas 对应的播放器
 * @param canvas - 指定的 canvas
 * @returns
 */ function getPlayerByCanvas(canvas) {
    return playerMap.get(canvas);
}
/**
 * 获取使用中的播放器
 * @returns
 */ function getActivePlayers() {
    return Array.from(playerMap.values());
}
/**
 * 播放器在实例化、销毁（`dispose`）时分别触发插件的 `onPlayerCreated`、`onPlayerDestroy` 回调
 * @param player - 播放器
 * @param isCreate - 是否处于实例化时
 */ function broadcastPlayerEvent(player, isCreate) {
    Object.keys(pluginLoaderMap).forEach(function(key) {
        var ctrl = pluginLoaderMap[key];
        var func = isCreate ? ctrl.onPlayerCreated : ctrl.onPlayerDestroy;
        func == null ? void 0 : func(player);
    });
}
/**
 * 同时允许的播放器数量超过 1 时打印错误
 */ function assertNoConcurrentPlayers() {
    var runningPlayers = [];
    for(var _iterator = _create_for_of_iterator_helper_loose(playerMap.values()), _step; !(_step = _iterator()).done;){
        var player = _step.value;
        if (!player.paused) {
            runningPlayers.push(player);
        }
    }
    if (runningPlayers.length > 1) {
        logger.error("Current running player count: " + runningPlayers.length + ", see " + HELP_LINK["Current running player count"] + ".", runningPlayers);
    }
}
/**
 * 创建播放器传入的容器不是 `HTMLElement` 时抛出错误
 * @param container
 */ function assertContainer(container) {
    if (container === undefined || container === null) {
        throw new Error("Container is not an HTMLElement, see " + HELP_LINK["Container is not an HTMLElement"] + ".");
    }
}
function getDestroyedErrorMessage(name) {
    return "Never use destroyed player: " + name + " again, see " + HELP_LINK["Never use destroyed player again"] + ".";
}

Texture.create = function(engine, props) {
    return new GLTexture(engine, props);
};
Texture.createWithData = function(engine, data, options) {
    if (data === void 0) data = imageDataFromColor("#fff");
    if (options === void 0) options = {};
    var _options_type = options.type, type = _options_type === void 0 ? glContext.UNSIGNED_BYTE : _options_type, _options_format = options.format, format = _options_format === void 0 ? glContext.RGBA : _options_format, internalFormat = options.internalFormat, _options_wrapS = options.wrapS, wrapS = _options_wrapS === void 0 ? glContext.MIRRORED_REPEAT : _options_wrapS, _options_wrapT = options.wrapT, wrapT = _options_wrapT === void 0 ? glContext.MIRRORED_REPEAT : _options_wrapT, _options_minFilter = options.minFilter, minFilter = _options_minFilter === void 0 ? glContext.NEAREST : _options_minFilter, _options_magFilter = options.magFilter, magFilter = _options_magFilter === void 0 ? glContext.NEAREST : _options_magFilter, _options_flipY = options.flipY, flipY = _options_flipY === void 0 ? false : _options_flipY;
    var tex = new GLTexture(engine, {
        data: data,
        type: type,
        sourceType: exports.TextureSourceType.data,
        format: format,
        internalFormat: internalFormat || format,
        wrapS: wrapS,
        wrapT: wrapT,
        minFilter: minFilter,
        magFilter: magFilter,
        flipY: flipY
    });
    return tex;
};
Material.create = function(engine, props) {
    return new GLMaterial(engine, props);
};
Geometry.create = function(engine, props) {
    return new GLGeometry(engine, props);
};
Mesh.create = function(engine, props) {
    return new Mesh(engine, props);
};
Renderbuffer.create = function(props) {
    return new GLRenderbuffer(props);
};
Framebuffer.create = function(props, renderer) {
    return new GLFramebuffer(props, renderer);
};
Renderer.create = function(canvas, framework, renderOptions) {
    return new GLRenderer(canvas, framework, renderOptions);
};
Engine.create = function(gl) {
    return new GLEngine(gl);
};
var version = "2.0.3";
logger.info("Player version: " + version + ".");

exports.AbstractPlugin = AbstractPlugin;
exports.ActivationPlayable = ActivationPlayable;
exports.AnimationClipPlayable = AnimationClipPlayable;
exports.AssetLoader = AssetLoader;
exports.AssetManager = AssetManager;
exports.BYTES_TYPE_MAP = BYTES_TYPE_MAP;
exports.Behaviour = Behaviour;
exports.BezierCurve = BezierCurve;
exports.BezierCurvePath = BezierCurvePath;
exports.BezierCurveQuat = BezierCurveQuat;
exports.COPY_FRAGMENT_SHADER = COPY_FRAGMENT_SHADER;
exports.COPY_MESH_SHADER_ID = COPY_MESH_SHADER_ID;
exports.COPY_VERTEX_SHADER = COPY_VERTEX_SHADER;
exports.CalculateLoader = CalculateLoader;
exports.Camera = Camera;
exports.CameraVFXItemLoader = CameraVFXItemLoader;
exports.Component = Component;
exports.Composition = Composition;
exports.CompositionComponent = CompositionComponent;
exports.CompositionSourceManager = CompositionSourceManager;
exports.DEFAULT_FONTS = DEFAULT_FONTS;
exports.Database = Database;
exports.Downloader = Downloader;
exports.EFFECTS_COPY_MESH_NAME = EFFECTS_COPY_MESH_NAME;
exports.EVENT_TYPE_CLICK = EVENT_TYPE_CLICK;
exports.EVENT_TYPE_TOUCH_END = EVENT_TYPE_TOUCH_END;
exports.EVENT_TYPE_TOUCH_MOVE = EVENT_TYPE_TOUCH_MOVE;
exports.EVENT_TYPE_TOUCH_START = EVENT_TYPE_TOUCH_START;
exports.EffectsObject = EffectsObject;
exports.EffectsPackage = EffectsPackage;
exports.Engine = Engine;
exports.EventEmitter = EventEmitter;
exports.EventSystem = EventSystem;
exports.Float16ArrayWrapper = Float16ArrayWrapper;
exports.Framebuffer = Framebuffer;
exports.GLEngine = GLEngine;
exports.GLGeometry = GLGeometry;
exports.GLRenderer = GLRenderer;
exports.GPUCapability = GPUCapability;
exports.Geometry = Geometry;
exports.GlobalUniforms = GlobalUniforms;
exports.GradientValue = GradientValue;
exports.HELP_LINK = HELP_LINK$1;
exports.InteractLoader = InteractLoader;
exports.InteractMesh = InteractMesh;
exports.KTXTexture = KTXTexture;
exports.LineSegments = LineSegments;
exports.LinearValue = LinearValue;
exports.Material = Material;
exports.MaterialDataBlock = MaterialDataBlock;
exports.Mesh = Mesh;
exports.PLAYER_OPTIONS_ENV_EDITOR = PLAYER_OPTIONS_ENV_EDITOR;
exports.POST_PROCESS_SETTINGS = POST_PROCESS_SETTINGS;
exports.ParticleBehaviourPlayable = ParticleBehaviourPlayable;
exports.ParticleBehaviourPlayableAsset = ParticleBehaviourPlayableAsset;
exports.ParticleLoader = ParticleLoader;
exports.ParticleMesh = ParticleMesh;
exports.ParticleSystemRenderer = ParticleSystemRenderer;
exports.PassTextureCache = PassTextureCache;
exports.PathSegments = PathSegments;
exports.Player = Player;
exports.PluginSystem = PluginSystem;
exports.RENDER_PASS_NAME_PREFIX = RENDER_PASS_NAME_PREFIX;
exports.RENDER_PREFER_LOOKUP_TEXTURE = RENDER_PREFER_LOOKUP_TEXTURE;
exports.RUNTIME_ENV = RUNTIME_ENV;
exports.RandomSetValue = RandomSetValue;
exports.RandomValue = RandomValue;
exports.RandomVectorValue = RandomVectorValue;
exports.RenderFrame = RenderFrame;
exports.RenderPass = RenderPass;
exports.RenderPassPriorityNormal = RenderPassPriorityNormal;
exports.RenderPassPriorityPostprocess = RenderPassPriorityPostprocess;
exports.RenderPassPriorityPrepare = RenderPassPriorityPrepare;
exports.RenderTargetHandle = RenderTargetHandle;
exports.Renderbuffer = Renderbuffer;
exports.Renderer = Renderer;
exports.RendererComponent = RendererComponent;
exports.RuntimeClip = RuntimeClip;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_MAIN_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_0;
exports.SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0 = SEMANTIC_PRE_COLOR_ATTACHMENT_SIZE_0;
exports.SPRITE_VERTEX_STRIDE = SPRITE_VERTEX_STRIDE;
exports.SemanticMap = SemanticMap;
exports.SerializationHelper = SerializationHelper;
exports.ShaderFactory = ShaderFactory;
exports.ShaderVariant = ShaderVariant;
exports.SpriteColorPlayable = SpriteColorPlayable;
exports.SpriteLoader = SpriteLoader;
exports.StaticValue = StaticValue;
exports.TEMPLATE_USE_OFFSCREEN_CANVAS = TEMPLATE_USE_OFFSCREEN_CANVAS;
exports.TextComponentBase = TextComponentBase;
exports.TextLayout = TextLayout;
exports.TextLoader = TextLoader;
exports.TextStyle = TextStyle;
exports.Texture = Texture;
exports.TextureFactory = TextureFactory;
exports.Ticker = Ticker;
exports.TimelineClip = TimelineClip;
exports.TimelinePlayable = TimelinePlayable;
exports.TrackSortWrapper = TrackSortWrapper;
exports.Transform = Transform;
exports.TransformAnimationPlayable = TransformAnimationPlayable;
exports.ValueGetter = ValueGetter;
exports.adapter = index$3;
exports.addByOrder = addByOrder;
exports.addItem = addItem;
exports.addItemWithOrder = addItemWithOrder;
exports.applyMixins = applyMixins;
exports.assertExist = assertExist;
exports.asserts = asserts;
exports.base64ToFile = base64ToFile;
exports.blend = blend;
exports.calculateTranslation = calculateTranslation;
exports.canvasPool = canvasPool;
exports.colorGradingFrag = colorGradingFrag;
exports.colorStopsFromGradient = colorStopsFromGradient;
exports.colorToArr = colorToArr$1;
exports.combineImageTemplate = combineImageTemplate;
exports.createCopyShader = createCopyShader;
exports.createGLContext = createGLContext;
exports.createKeyFrameMeta = createKeyFrameMeta;
exports.createShape = createShape;
exports.createValueGetter = createValueGetter;
exports.decimalEqual = decimalEqual;
exports.defaultGlobalVolume = defaultGlobalVolume;
exports.defaultPlugins = defaultPlugins;
exports.deserializeMipmapTexture = deserializeMipmapTexture;
exports.disableAllPlayer = disableAllPlayer;
exports.earcut = earcut;
exports.effectsClass = effectsClass;
exports.effectsClassStore = effectsClassStore;
exports.enlargeBuffer = enlargeBuffer;
exports.ensureFixedNumber = ensureFixedNumber;
exports.ensureVec3 = ensureVec3;
exports.findPreviousRenderPass = findPreviousRenderPass;
exports.gaussianDownFrag = gaussianDown_frag;
exports.gaussianDownHFrag = gaussianDownHFrag;
exports.gaussianDownVFrag = gaussianDownVFrag;
exports.gaussianUpFrag = gaussianUpFrag;
exports.generateEmptyTypedArray = generateEmptyTypedArray;
exports.generateGUID = generateGUID;
exports.generateHalfFloatTexture = generateHalfFloatTexture;
exports.generateTransparentTexture = generateTransparentTexture;
exports.generateWhiteTexture = generateWhiteTexture;
exports.getActivePlayers = getActivePlayers;
exports.getBackgroundImage = getBackgroundImage;
exports.getColorFromGradientStops = getColorFromGradientStops;
exports.getConfig = getConfig;
exports.getDefaultTextureFactory = getDefaultTextureFactory;
exports.getGeometryByShape = getGeometryByShape;
exports.getGeometryTriangles = getGeometryTriangles;
exports.getImageItemRenderInfo = getImageItemRenderInfo;
exports.getKTXTextureOptions = getKTXTextureOptions;
exports.getKeyFrameMetaByRawValue = getKeyFrameMetaByRawValue;
exports.getMergedStore = getMergedStore;
exports.getParticleMeshShader = getParticleMeshShader;
exports.getPixelRatio = getPixelRatio;
exports.getPlayerByCanvas = getPlayerByCanvas;
exports.getPreMultiAlpha = getPreMultiAlpha;
exports.getStandardComposition = getStandardComposition;
exports.getStandardImage = getStandardImage;
exports.getStandardItem = getStandardItem;
exports.getStandardJSON = getStandardJSON;
exports.getTextureSize = getTextureSize;
exports.glContext = glContext;
exports.glType2VertexFormatType = glType2VertexFormatType;
exports.gpuTimer = gpuTimer;
exports.imageDataFromColor = imageDataFromColor;
exports.imageDataFromGradient = imageDataFromGradient;
exports.initErrors = initErrors;
exports.initGLContext = initGLContext;
exports.integrate = integrate;
exports.interpolateColor = interpolateColor;
exports.isAlipayMiniApp = isAlipayMiniApp;
exports.isAndroid = isAndroid;
exports.isArray = isArray;
exports.isCanvas = isCanvas;
exports.isCanvasUsedByPlayer = isCanvasUsedByPlayer;
exports.isFunction = isFunction;
exports.isIOS = isIOS;
exports.isIOSByUA = isIOSByUA;
exports.isMiniProgram = isMiniProgram;
exports.isObject = isObject;
exports.isSceneJSON = isSceneJSON;
exports.isSceneURL = isSceneURL;
exports.isSceneWithOptions = isSceneWithOptions;
exports.isSimulatorCellPhone = isSimulatorCellPhone;
exports.isString = isString;
exports.isUniformStruct = isUniformStruct;
exports.isUniformStructArray = isUniformStructArray;
exports.isValidFontFamily = isValidFontFamily;
exports.isWebGL2 = isWebGL2;
exports.isWechatMiniApp = isWechatMiniApp;
exports.itemFrag = itemFrag;
exports.itemFrameFrag = itemFrameFrag;
exports.itemVert = itemVert;
exports.loadAVIFOptional = loadAVIFOptional;
exports.loadBinary = loadBinary;
exports.loadBlob = loadBlob;
exports.loadImage = loadImage;
exports.loadMedia = loadMedia;
exports.loadVideo = loadVideo;
exports.loadWebPOptional = loadWebPOptional;
exports.logger = logger;
exports.math = index;
exports.modifyMaxKeyframeShader = modifyMaxKeyframeShader;
exports.nearestPowerOfTwo = nearestPowerOfTwo;
exports.noop = noop;
exports.normalizeColor = normalizeColor;
exports.numberToFix = numberToFix;
exports.parsePercent = parsePercent$1;
exports.particleFrag = particleFrag;
exports.particleOriginTranslateMap = particleOriginTranslateMap$1;
exports.particleUniformTypeMap = particleUniformTypeMap;
exports.particleVert = particleVert;
exports.pluginLoaderMap = pluginLoaderMap;
exports.randomInRange = randomInRange;
exports.registerPlugin = registerPlugin;
exports.removeItem = removeItem;
exports.rotateVec2 = rotateVec2;
exports.screenMeshVert = screenMeshVert;
exports.serialize = serialize;
exports.setBlendMode = setBlendMode;
exports.setConfig = setConfig;
exports.setDefaultTextureFactory = setDefaultTextureFactory;
exports.setMaskMode = setMaskMode;
exports.setMaxSpriteMeshItemCount = setMaxSpriteMeshItemCount;
exports.setRayFromCamera = setRayFromCamera;
exports.setSideMode = setSideMode;
exports.setSpriteMeshMaxItemCountByGPU = setSpriteMeshMaxItemCountByGPU;
exports.sortByOrder = sortByOrder;
exports.spec = index$1;
exports.spriteMeshShaderFromFilter = spriteMeshShaderFromFilter;
exports.spriteMeshShaderFromRenderInfo = spriteMeshShaderFromRenderInfo;
exports.spriteMeshShaderIdFromRenderInfo = spriteMeshShaderIdFromRenderInfo;
exports.thresholdFrag = thresholdFrag;
exports.throwDestroyedError = throwDestroyedError;
exports.trailVert = trailVert;
exports.translatePoint = translatePoint;
exports.trianglesFromRect = trianglesFromRect;
exports.unregisterPlugin = unregisterPlugin;
exports.valIfUndefined = valIfUndefined;
exports.value = value;
exports.valueDefine = valueDefine;
exports.vecFill = vecFill;
exports.vecMulCombine = vecMulCombine;
exports.version = version;
exports.vertexFormatType2GLType = vertexFormatType2GLType;
